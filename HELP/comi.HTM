<html>
<head>
<title>
COMi Users Guide
</title>
</head>
<body>
<h1>Introduction</h1>
<p>COMi is a multi-port asynchronous serial device driver for the
OS/2<a href='#fn_ibm'>* </a>operating system.  This version of COMi will
 work in any system running OS/2 2.0 and above.  There is a different
version for OS/2 1.x that is still available and supported by OS/tools. 
<p>By multi-port we mean that with COMi there is no limit (logically) to
 the number of COM devices that can be made available to OS/2 sessions
or applications.  There is a practical limit, of course, because there
is a limit to the number of COM devices that can be installed in any
single system.  COMi will allow you to install devices with names from
COM1 to COM99. 
<h1>Installation</h1>
<p>COMi comes with an easy to use installation program (INSTALL.EXE). 
This program can transfer all required files to the directories of your
choice, create a desktop folder and necessary program objects, and
initiate the configuration process. 
<p>If you have multiple COMi licenses you can reuse a COMi
initialization file for similar installations by copying that 
initiaization file to the distribution diskette.  When INSTALL finds a
COMi initialization file in the directory it is run from, it will
transfer that file to the installation destination directory.  The
transferred COMi initialization file will be presented for modification
during each subsequent installation process. 
<p>Multiple licenses for COMi can be installed from a network drive or
directory.  To do this you must first use INSTALL to transfer both COMi
and INSTALL to a network drive, then complete the configuration process
just as though you were installing it to a local drive. 
<p>Once installation and configuration are complete you can run INSTALL
on a workstation from the network directory to install COMi to that
workstation.  Any initialization file you created in the INSTALL
(network) directory will also be transferred to the workstation.  You
can then make any necessary changes to the initialization file by
selecting the <strong>Configuration | COMi... </strong>menu item, after
INSTALL has transferred the required files to the local drive. 
<h2>Installing Print Spooler Support</h2>
<p>To install and configure COMi Print Spooler support you must have
elected to transfer the spooler support files while installing COMi by
selecting the "Print Spooler Utilities" check box in the "Install
Options" dialog, configured COMi for your serial hardware, and you must
have re-booted your machine since that install session. 
<p>Once you have completed transferring the files, installing and 
configuring serial devices for COMi access, and re-booting your machine,
 you will need to do the following: 
<ol>
<li>Click mouse button two (usually the right button) on a local printer
 object. 
<p>If you do not have a printer object see "Printing in OS/2" book in
the Information folder for information on creating a printer object.
<li>Select the "Settings" menu item from the pop-up menu that appears. 
<li>Click on the "Output" tab from the settings notebook. 
<li>Click mouse button two on any port icon in the container window. 
<li>Select the "Install" menu item from the pop-up menu that apears.  A
new dialog will be presented. 
<li>In the "Directory" entry field of the new dialog, enter the
following (without the quotes): "\OS2\DLL", then press the &lt;ENTER&gt;
 key or select the "Refresh" button. 
<p>The Spooler software will read each spooler support library in that
directory, including the COMi spooler support library, and show an icon
in the container area of the dialog for each device these spooler 
support libraries support. 
<p>Only ports that have been installed with a COMi configuration program
 (COMscope or Install) will be available for installation as spooler
ports by the system spooler software. COMi must have been loaded at
system initialization before COMi print Spooler support can be
installed, or accessed. 
<li>Select one, or more, of the COMi Spooler ports and select the
"Install" button. 
<li>When the Spooler software is finished installing the ports you have
selected, it will show a message box indicating that the ports you
selected have been installed.  Click on the "OK" button. 
<li>When you are through installing print spooler ports, click on the
"Cancel" button. 
</ol>
<p>Once you have installed at least one COMi spooler port using this
procedure, you will be able to install and delete spooler ports from the
 COMi Configuration program (either Install or COMscope). 
<p>You can set the port parameters to match the requirements of a
printer by clicking mouse button two on an icon in the container area
and selecting the "Settings" menu item.  Help for setting printer port
initialization parameters will be available once you have entered the
setup dialog. 
<p><strong> Note : </strong>Configuration of COMi print spooler ports
for device and printer communications parameter initialization, will
always have to be completed from the printer object's settings notebook,
 as described here.  The system spooler software will not be aware of
any initialization parameters selected from the COMi configuration
program as they are intended as system startup defaults only. 
<h2>Configuration</h2>
<p>The COMi device driver can only be configured using COMscope or
Install.  These two programs create, or modify, an initialization file
for the device driver.  Each time your system is started, COMi reads
this initialization file to determine where to look for serial devices
and how to configure those devices. 
<p>Additional Information: 
<ul>
<li><a href='#CFG_ISA'>Industry Standard Architecture </a>
<li><a href='#CFG_MCA'>Micro Channel Architecture </a>
<li><a href='#CFG_CONFIG'>Starting Configuration Process </a>
</ul>
<h3><a name='CFG_ISA'>Industry Standard Architecture Machines</a></h3>
<p>The COMi device driver will not operate in <a href='#fn_ISA'>ISA
</a>systems until a valid initialization file is created.  There can be
no access to COM devices in ISA systems until the configuration process
has been completed and a valid initialization file has been created. 
<p>Related information:
<ul>
<li><a href='#TS_COMSYS_ISA'>Industry Standard Architecture
Considerations</a>
</ul>
<h3><a name='CFG_MCA'>Micro Channel Architecture Machines</a></h3>
<p>The COMi device driver does not need an initialization file to
initialize the eight pre-defined serial ports in a
PS/2<a href='#fn_ibm'>* </a>or other <a href='#fn_MCA'>MCA </a>system
that has ABIOS or equivalent. You will need to create an initialization
file for MCA machines only if you: 
<ol>
<li>Need to support more than eight serial devices. 
<li>Want to access devices that may be owned by other serial device
drivers that can be de-installed. 
<li>Need to support hardware that has base I/O addresses and/or
interrupt levels different than the MCA pre-defined serial device base
addresses and/or interrupt levels. 
<li>Your MCA system does not have an ABIOS or equivalent. 
</ol>
<p>Related information:
<ul>
<li><a href='#TS_COMSYS_MCA'>Micro Channel Architecture
Considerations</a>
</ul>
<h3><a name='CFG_CONFIG'>Starting Configuration Process</a></h3>
<p>During installation, the configuration process is started by INSTALL
(supplied with COMi).  After Installation is completed you will need to
re-boot your machine before you will be able to access serial devices
with COMi. 
<p>After installation you can configure COMi either from a program
object (icon) or from an OS/2<a href='#fn_ibm'>* </a>command prompt. 
<p><strong>Starting from a program object: </strong>
<p>If there is a program object for COMscope or Install you can double
click on the object to begin the configuration process. 
<p>If there is no program object for COMscope or Install, you can either
 start the program from the command line (in an OS/2 windowed session)
or create a program object using the following procedure: 
<ol>
<li>Open the <strong>Templates </strong>folder. 
<li>Drag a <strong>Program </strong>object off onto the desktop. 
<li>When the settings notebook appears select the <strong>Program
</strong>tab, if that page is not currently shown. 
<li>In the <strong>Path and File Name </strong>field, enter the absolute
 path and file name of the configuration program. 
<p>Example:  C:\COMM\COMscope.EXE 
<li>In the <strong>Working Directory </strong>field enter the absolute
path, to the configuration program. 
<p>Example:  C:\COMM 
<li>Select the <strong>General </strong>tab. 
<li>Enter the program name in the <strong>Title </strong>field. 
<p>Example:  COMi Configuration 
<li>Close the settings notebook by double clicking on the system menu
(small box in the upper left-hand corner). 
</ol>
<p><strong>Starting from an OS/2 command prompt: </strong>
<p>If the COMi device driver is loaded you will only need to enter the
program name and path on the command line. 
<p>Example:  [C:\]C:\comm\COMscope &lt;ENTER&gt; 
<p>If the COMi device driver is not loaded you will be prompted for a
path and file name after starting COMscope or Install.  The COMi
initialization file must be located in the same directory as the device
driver, and must have the same base name as the drvice driver file with
a ".INI" extension. 
<h1><a name='EXTENSIONS'>Extensions</a></h1>
<p>COMi has extensions that allow it to perform in some special
situations.  These extensions are: 
<ol>
<li>Modem interrupts can be disabled for any device.  Enabling this
extension will cause modem signals to be polled when handshaking
protocols are enabled that use modem signaling.  The device driver will
function normally, just not as efficiently. The purpose for this
extension is to support serial adapters that inadvertently left one or
more modem signal input pins floating, and will only be required if an
application is going to enable hardware handshaking when such an adapter
 is being used.
<li>The device driver can be configured to allow applications to have
control of the OUT1 output signal of any device.  The purpose of this
extension is to support adapters that use the OUT1 pin to control some
special function (e.g., baud rate clock selection, or RS-485 tri-state
enable).  Support is included for control of the LOOP function, but is
not very useful at the normal application level. 
<li>The baud rate divisor can be specified explicitly by an application.
  When this feature is enabled the application selected baud rate value
is written directly to, or read directly from, the baud rate registers
of the device.  This extension is to support adapters that allow users
to select nonstandard baud rate clocks.  When using this extension, an
application will need to calculate the proper baud rate divisor for
their particular adapter setup. 
<li>Normally each user defined serial device (UART) is tested to
determine if the defined device is a supported UART, if the defined
hardware interrupt level is available for use by the device driver, if
the device is physically connected to the defined hardware interrupt
level, and if the device has hardware buffering capabilities.  This
extension prevents all but the test for hardware interrupt availability
from being performed.  The purpose of this extension is to allow for
UARTs that are part of a motherboard chip set that may not be
initialized at the time the device driver is loaded (initialized), or
other UARTs that may not be completely compatible with the 8250
standard, but close enough to work with COMi. 
<p><strong> Note : </strong>When initialization testing is disabled,
COMi will not be able to automatically detect a 4x baud rate clock.
<li>Each device can be configured to enable the OUT1 signal at
initialization.  When this extension is enabled the OUT1 signal is
enabled at the very beginning of the initialization sequence and will
remain enabled for that entire OS/2<a href='#fn_ibm'>* </a> session,
unless <strong>Extended Modem Signals </strong>is enabled and an
extension aware application disables that signal. 
<li>COMi supports RTS/CTS handshanking in hardware when used with
Startech's ST16C650 UART.
<li>COMi will support the Texas Instruments 16C550B UART in the FIFO
mode.  This UART requires special processing when its receive FIFO is
enabled. 
<li>COMi will allow you to connect multiple devices to a single
interrupt in ISA machines.  Interrupt sharing in an ISA machine will NOT
 work safely, unless your hardware is specifically designed to do so. 
<li>The most important extension in COMi, we feel, is support for
COMscope.  COMscope and COMi allow for total control and monitoring of
serial devices.  COMscope can monitor all the device and device driver
states an application can access.  COMscope can also capture and display
 both the transmit and receive streams. 
</ol>
<h1>API Compatibility</h1>
<p>The COMi application interface (API) is exactly as described in the
"Physical Device Driver" technical reference for Category One, 
Asynchronous Serial Device Drivers.  COMi supports all features and
functions as described in that reference, except the Enhanced Mode
functions (functions 0x54 and 0x74). 
<p><strong>Differences from COM.SYS: </strong>
<p>There are some differences in how COMi is initialized compared to the
 COM.SYS device driver.  Here is a list of the differences: 
<ol>
<li>COM.SYS initializes at 1200 baud.  COMi defaults to 9600 baud. 
<li>COM.SYS initializes to a protocol of seven data bits, even parity,
and one stop bit.  COMi defaults to a protocol of eight data bits, no
parity, and one stop bit. 
<li>COM.SYS defaults with hardware buffer functionality set to
<a href='#CON_APO'>Automatic Protocol Override </a>with a receive 
trigger level of eight bytes.  COMi defaults to hardware buffers on,
with a receive trigger level of 1/2 FIFO depth and a transmit buffer
depth of sixteen bytes for 16550 UARTS and 24 bytes of 16650 UARTs. 
<li>COM.SYS has fixed receive and transmit buffers.  COMi's buffer sizes
 are user definable. 
<li>All COM.SYS defaults are fixed.  With COMi, all startup defaults,
including protocol, baud rate, buffers sizes, read and write time-out
processing and time-out values, FIFO functionality, and handshaking
protocols are user definable.  This feature allows COMi to use startup
defaults defined by the user. 
<li>COM.SYS does not support COMscope or COMspool, COMi does (this is
important!). 
</ol>
<p>There should be one other difference noted here, though it pertains
only to documentation.  The "Physical Device Driver" technical reference
 stated that the COM.SYS device driver starts up with CTS and DTR output
 handshaking, DSR input sensitivity, and RTS input handshaking, enabled.
  The COM.SYS device driver starts up with no handshaking enabled and
neither does COMi, unless the end-user makes it so. 
<h1>System and Adapter Support</h1>
<p>COMi can work with any adapter that uses any of the required serial
devices, in any combination and in any quantity your
OS/2<a href='#fn_ibm'>* </a>system can accommodate.  There are some
restrictions and caveats, though, and these are what this part of the
manual will explain. 
<p>COMi is designed to allow an OS/2 system to access multiple serial
devices at baud rates up to 460.8K BPS and above, using "dumb",
inexpensive, Universal Asynchronous Receiver Transmitters (UARTs).  The
device driver will support any UART of the 16550 family. This includes
the 8250, 8250A, 16450, 16450A, 16550A, 16550B, 16650, and some others,
including most built-in UARTs that are part of a motherboard chip set.
<p>Systems Supported: 
<ul>
<li><a href='#SUPPORT_MCA'>Micro Channel Architecture Machines </a>
<li><a href='#SUPPORT_ISA'>Industry Standard Architecture Machines </a>
</ul>
<p>ISA shared interrupt capable adapters supported: 
<ul>
<li><a href='#HLPC_ADAPTERS'>Serial Adapters Supported </a>
</ul>
<p>Devices Supported: 
<ul>
<li><a href='#SUPPORT_16650'>16650 UART</a>
<li><a href='#SUPPORT_16550'>16550 UART </a>
<li><a href='#SUPPORT_16450'>16450 UART </a>
<li><a href='#SUPPORT_8250'>8250 UART </a>
</ul>
<h2><a name='SUPPORT_16650'>16650 UART Support</a></h2>
<p>The ST16650 UART, by Startech, is an extension of the 16550 UART.  It
 has 32 byte FIFOs and is capable of selecting the on board baud rate
clock or dividing that clock by four.  With this UART your system will
be able to handle higher DTE baud rates; up to 460.8K BPS.
<p>COMi will automatically detect if a 16650 UART is installed and will
also automatically determine if the baud rate clock is a multiple of
four of the normal 1.843MHz baud clock.
<p>One version of the ST16C650 UART is completely pin compatable with
the 16550 UART.  You may purchase one or more of these UARTs and just
replace the UARTs currently installed on your serial adapter; assuming
the adapter has sockets for its UARTs.
<h2><a name='SUPPORT_16550'>16550 UART Support</a></h2>
<p>The 16550 UART is the most common serial device in
OS/2<a href='#fn_ibm'>* </a> systems.  These UARTs have both receive and
 transmit First In First Out (FIFO) buffers.  FIFOs allow a greater 
throughput with less interrupt overhead. 
<p>When the 16550 UART's FIFO modes are enabled the device will normally
 interrupt the CPU every 14 received characters or every 16 transmitted
characters.  This means that a device receiving data at 57600 baud will
get an interrupt about every 2.5 milliseconds.  For comparison, without
FIFOs, a device running at 57600 baud would get an interrupt about every
 170 microseconds. 
<p>The COMi device driver will automatically determine if any device it
is configured to support has hardware buffers, and will take full
advantage of those buffers when they are available 
<h2><a name='SUPPORT_16450'>16450 UART Support</a></h2>
<p>It is not recommended that you use any adapter that contains 16450
UARTs.  These UARTs have no hardware buffering capabilities and will
interrupt the CPU whenever a character is received or transmitted.  This
 means that if you are running a communications program at 9600 baud
there will be an interrupt about every one millisecond, possibly more if
 your application is receiving and streaming data (transmitting/
receiving large strings) in a full duplex mode. 
<h2><a name='SUPPORT_8250'>8250 UART Support</a></h2>
<p>As with the 16450 UART, the 8250 UART does not contain FIFOs, and it
is not recommended that you use serial adapters that use 8250 UARTs in
OS/2<a href='#fn_ibm'>* </a> systems.  COMi will work with these UARTs
but your system performance may be greatly diminished when using them at
 higher baud rates. 
<h2><a name='SUPPORT_MCA'>MCA Support</a></h2>
<p><a href='#fn_MCA'>MCA </a>machines are designed to allow adapters
and/or devices to share hardware interrupts.  This architecture makes it
 easy for COMi to support any number of serial devices in any
combinations of device base addresses and hardware interrupts, with the
following recommendations and restrictions: 
<ol>
<li>Try to evenly distribute the number of devices per hardware
interrupt, or use the least number of devices per hardware interrupt
level when using higher baud rates. 
<li>Try not to use more than eight serial devices per hardware interrupt
 level. 
<li>If you need more than eight serial ports you must use adapters that
support base addresses other than the eight pre-assigned MCA serial
device base addresses and hardware interrupt levels. 
</ol>
<h2><a name='SUPPORT_ISA'>ISA Support</a></h2>
<p><a href='#fn_ISA'>ISA </a>machines do not normally allow adapters, or
 devices, to share hardware interrupt levels.  Because of this
(deficiency) there are certain restrictions for configuring the device
driver for access to serial adapters and multiple serial devices.  These
 restrictions include: 
<ol>
<li>Shared interrupts are safely supported only when used with adapters
that support shared interrupts. 
<li>If you assign the same hardware interrupt level to two different
adapters, or devices, that do not support shared interrupts, you may
lose received characters. 
<li>If you assign the same hardware interrupt level to two different
adapters, or devices, that do not support shared interrupts, you will
probably lock-up your system, especially if you are not accessing the
port in a separate thread from your window procedure. 
<li>You may safely connect multiple, non-interrupt sharing, devices to a
 single interrupt without problems if the device is connected to the bus
 in a "wired-OR" circuit, and if you open and access only one of those
devices at a time. 
</ol>
<p>Related Information: 
<ul>
<li><a href='#HLPI_INST_ISA_PORTS'>Installing ISA Serial Devices </a>
<li><a href='#HLPC_ADAPTERS'>Serial Adapters Supported </a>
<li><a href='#HLPC_ADAPTER_TYPES'>Shared Interrupt Adapter Types </a>
</ul>
<h1><a name='HLPI_INST_ISA_PORTS'>Installing ISA Serial Devices</a></h1>
<p>If you are installing serial device support in an ISA machine and you
 intend to connect multiple devices to a single hardware interrupt level
 you need to be aware of the following: 
<ol>
<li>Your adapter must have special features to support interrupt
sharing. 
<li>The adapter's special features that allow interrupt sharing must be
enabled and configured correctly. 
<li>You must know the hardware address of your adapter's interrupt
status or ID register. 
<li>You must open the adapter set-up dialog by clicking on the
<strong>Adpter Set-up </strong>button from the <strong>Device Driver
Configuration </strong>dialog to specify the adapter type, hardware
interrupt level, and address of the interrupt status/ID register in
order to define more than one device to a hardware interrupt level. 
</ol>
<p><strong> Note : </strong>Sharing interrupts on an <a
href='#fn_MCA'>MCA </a>machine requires no special configuation.  Please
 note, though, that it is not recommended that you connect more than
eight devices to any one hardware interrupt level. 
<p>Related Information: 
<ul>
<li><a href='#HLPC_ADAPTERS'>Serial Adapters Supported </a>
<li><a href='#HLPC_ADAPTER_TYPES'>Shared Interrupt Adapter Types </a>
</ul>
<h2><a name='HLPC_ADAPTER_TYPES'>Shared Interrupt Adapter Types</a></h2>
<p>In order for COMi to support shared interrupts on an
<a href='#fn_ISA'>ISA </a>machine, an adapter of one of the types
described below must be used. 
<p><strong>Type One</strong>: 
<ol>
<li>All devices on an adapter can be connected to a single IRQ line. 
<li>The adapter has an interrupt ID register at adapter base I/O address
 +7. 
<li>Each bit in the interrupt ID register represents one, and only one,
serial device. 
<li>When there is no device with a pending interrupt, the ID register
will be read as a zero. 
</ol>
<p><strong>Type Two</strong>: 
<ol>
<li>Texas Instruments 16C550B UARTs are installed on the adapter. 
<li>All devices on an adapter can be connected to a single IRQ line. 
<li>The adapter has an interrupt ID register at adapter base I/O address
 +7. 
<li>Each bit in the interrupt ID register represents one, and only one,
serial device. 
<li>When there is no device with a pending interrupt, the ID register
will be read as a zero. 
</ol>
<p><strong>Type Three</strong>: 
<ol>
<li>All devices on an adapter can be connected to a single IRQ line. 
<li>The adapter has an interrupt ID register at a fixed or user defined
address. 
<li>Each bit in the interrupt ID register represents one, and only one,
serial device. 
<li>When there is no device with a pending interrupt, the ID register
will be read as a zero. 
</ol>
<p><strong>Type Four</strong>: 
<ol>
<li>The adapter has an interrupt ID register at a user definable
address. 
<li>The address of the interrupt ID register is as defined by the user
for odd interrupts (3, 5, 7, 9, 11, 13, 15) and is at the user defined
address +1 for even interrupts (2, 4, 6, 8, 10, 12, 14). 
<li>The value read from the interrupt ID register indicates the highest
priority device that has an interrupt pending. 
<li>When there is no device with a pending interrupt, the ID register
will be read as all ones (0xFF). 
</ol>
<p><strong>Type Five</strong>: 
<ol>
<li>All devices on an adapter can be connected to a single IRQ line. 
<li>The adapter has an interrupt ID register at a fixed address that is
based on which of four available PALs is installed on the adapter. 
<li>The value read from the interrupt ID register indicates the highest
priority device that has an interrupt pending. 
<li>When there is no device with a pending interrupt, the ID register
will be read as all ones (0xFF). 
</ol>
<p>Related Information: 
<ul>
<li><a href='#HLPC_ADAPTERS'>Serial Adapters Supported </a>
</ul>
<h2><a name='HLPC_ADAPTERS'>Serial Adapters Supported</a></h2>
<p>COMi has been tested with the following serial adapters. 
<pre>
ÚÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Type  ³Manufacturer      ³Model               ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³One   ³Sealevel Systems  ³COMM+4              ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³      ³                  ³TURBOCOMM+8         ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³      ³Globetek          ³S-1005              ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³      ³Quatech           ³ES-xxx              ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³      ³                  ³QS-xxx              ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Two   ³Comtrol           ³Hostess RJ45        ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³      ³                  ³Hostess RJ11        ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Three ³Connect Tech      ³DFLEX               ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Four  ³DigiBoard         ³PC/4                ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³      ³                  ³PC/8                ³
ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
³Five  ³DigiBoard         ³PC/16               ³
ÀÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
</pre>
<p>COMi will support shared interrupts with all of the adapters listed
above and any other adapter that uses one of the interrupt sharing
schemes described under <a href='#HLPC_ADAPTER_TYPES'>COMi Adapter
Types</a>. </strong>
<p>
<h1>Troubleshooting</h1>
<p>Believe it or not, the COMi installation and configuration process is
 not always as simple and straight forward as we would like it to be. 
<p>The following is help and explanation for the most common problems
encountered when attempting to install, configure, and access the COMi
device driver: 
<ul>
<li><a href='#TS_INT_LEVEL'>Hardware Interrupt Level Selection </a>
<li><a href='#TS_ADDR'>Base I/O Address Selection </a>
<li><a href='#TS_START'>Errors During System Start-up </a>
<li><a href='#TS_COMSYS'>Loading with COM.SYS </a>
<li><a href='#TS_RUNTIME'>Run-time Problems </a>
<li><a href='#TS_RUN_RW'>Read/Write Errors </a>
<li><a href='#TS_RUN_DEVCTL'>Device I/O control (DosDevIOCtl) Errors
</a>
<li><a href='#TS_RUN_LOCK_MOUSE'>Lock-up, Pointer Moves </a>
<li><a href='#TS_RUN_LOCK_NO_MOUSE'>Lock-up, Pointer Does Not Move </a>
</ul>
<h2><a name='TS_INT_LEVEL'>Hardware Interrupt Level Selection</a></h2>
<p>The COMi configuration program will not normally allow you to
configure more than one device per hardware interrupt level on
<a href='#fn_ISA'>ISA </a>machines unless you have selected an adapter
type from the <strong>Adpter Setup </strong>dialog, supplied an
interrupt status register address, and selected an interrupt level. 
<p><strong> Note : </strong>If you supply an interrupt status register
address and there is no such register with that function your, system
WILL lock-up. 
<p>You may configure more than one device to share an interrupt level by
 selecting the <strong>Extensions... </strong>button when configuring a
device, and selecting the "Share Interrupt Connection" check box. 
<p>In order to share interrupts using this "extension", your hardware
must have a "wired-OR" interrupt circuit that ties each device to the
system board's Interrupt Request (IRQ) circuit.  You can expect this to
be the case any time you are using a multi-device adapter that allows
you to connect more than one device to any one interrupt level. 
Adapters that contain only one serial device rarely use this type of
circuit. 
<p>In general it is not a good idea to configure devices on more than
one adapter to share interrupts.  The exception is when your are using
any adapter that specifically supports multi-adapter interrupt sharing. 
<p><a href='#fn_MCA'>MCA </a>machines are designed to allow interrupt
sharing.  You can select any hardware interrupt level, though we do not
recommend assigning more than eight devices to any one hardware 
interrupt level. 
<h2><a name='TS_ADDR'>Base I/O Address Selection</a></h2>
<p>The configuration programs will not allow you to select a base I/O
address for any device that is assigned to another COMi controlled
device, nor will it allow you to select a base address that is not at an
 eight byte boundary. 
<h2><a name='TS_START'>Errors During System Start-up</a></h2>
<p>During each load of the COMi device driver each defined device is 
normally tested to determine the following: 
<ol>
<li>If the device is a qualified UART. 
<li>If the configured hardware interrupt level is available. 
<li>If the device is connected to the configured hardware interrupt 
level. 
<li>If the configured interrupt status register (if any) is correct. 
<li>If the UART has FIFO capabilities (hardware buffers). 
</ol>
<p>Any device failing the first four tests will not be installed and
will not be available at run-time.  If you KNOW that the device is valid
 as defined, you can select <strong>Disable Startup UART Tests
</strong>in the Extensions dialog box for this device.  Enabling this
extension will cause all tests to be bypassed except the interrupt level
 availability test (number two). 
<p>This may be necessary if you have a UART that is built into the
motherboard chip set, or a device that is not quite compatible with the
8250/16450/16550/16650 UART. 
<h2><a name='TS_COMSYS'>Loading with COM.SYS</a></h2>
<p>COMi will work when COM.SYS and VCOM.SYS are loaded.  If you want to
use both COMi and COM.SYS you will need to insure that COM.SYS is loaded
 before COMi.  The configuration program will normally place COMi
"DEVICE=" statements at the end of the CONFIG.SYS file, so this should
not be a problem. 
<p>You will also have to refrain from naming COMi devices with the same
names COM.SYS will use.  Naming a COMi device COM1 through COM4 will
cause COM.SYS to drop access to any device it owns with those device
names.  If you know that you do not have serial hardware at a
traditional, or pre-defined, COMx location you can use that device name
without problems. 
<p>If you want to use COM.SYS and VCOM.SYS for some COM ports and COMi
for other's, you need only configure COMi to use the device name (COMx)
you want COM.SYS to drop. 
<p>Additional Considerations: 
<ol>
<li><a href='#TS_COMSYS_ISA'>ISA machines </a>
<li><a href='#TS_COMSYS_MCA'>MCA machines </a>
</ol>
<h3><a name='TS_COMSYS_ISA'>ISA Considerations</a></h3>
<p><a href='#fn_ISA'>ISA </a>machines have traditionally defined serial
devices for COM1 through COM4.  Below is a listing of traditional ISA
serial port specifications. 
<pre>
ÚÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿
³Device   ³Base     ³Interrupt³
³Name     ³Address  ³Level    ³
ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄ´
³COM1     ³0x3F8    ³4        ³
ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄ´
³COM2     ³0x2F8    ³3        ³
ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄ´
³COM3     ³0x3E8    ³4        ³
ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄ´
³COM4     ³0x2E8    ³3        ³
ÀÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÙ
</pre>
<p>The COM.SYS device driver will normally connect only to COM1 and
COM2.  However, you can request access to COM3 and COM4 by defining the
port number, base address, and interrupt level on the
"DEVICE=d:\path\COM.SYS" command line in the CONFIG.SYS file.  Using
this method will not allow you to share interrupts, but you could get
sequential access to devices defined with the same hardware interrupt
level. 
<p>If you want to have COM.SYS and VCOM.SYS control any of the above
listed devices you will not be able to use their respective COMx device
names when configuring COMi. 
<p>For information on how to configure COM.SYS for COM3 and COM4 access
enter "HELP COM.SYS" from any command prompt, or search in the "Command
Reference" for "COM.SYS". 
<h3><a name='TS_COMSYS_MCA'>MCA Considerations</a></h3>
<p>MCA machines have eight pre-defined serial port designations.  COM1
through COM4 can be controlled by COM.SYS.  Below is a listing of
pre-defined MCA serial port specifications. 
<pre>
ÚÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ¿
³Device   ³Base     ³Interrupt³
³Name     ³Address  ³Level    ³
ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄ´
³COM1     ³0x3F8    ³4        ³
ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄ´
³COM2     ³0x2F8    ³3        ³
ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄ´
³COM3     ³0x3220   ³3        ³
ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄ´
³COM4     ³0x3228   ³3        ³
ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄ´
³COM5     ³0x4220   ³3        ³
ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄ´
³COM6     ³0x4228   ³3        ³
ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄ´
³COM7     ³0x5220   ³3        ³
ÃÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄ´
³COM8     ³0x5228   ³3        ³
ÀÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÙ
</pre>
<p>COM.SYS will allow you to access up to four devices from this list
and will automatically use COM1 through COM4 for the first four serial
devices it detects from the above list.  The COMi device driver will
also automatically configure itself, but it will allow you to access all
 eight devices defined in the list above. 
<p>COMi will try to automatically configure itself for any unowned
device it detects in the list above.  If COM.SYS or any other ABIOS 
aware serial device driver is loaded, COMi will not install any COMx
port or device that is already owned by a previously loaded device
driver.  You will need to create an initialization file with a COMi
configuration program (COMscope or Install) if you want COMi to control
any device that a previously loaded device driver owns. 
<p>If you need access to more than eight serial devices and/or serial
devices that are not configured as defined in the above table, you will
also need to create an initialization file with a COMi configuration
program. 
<h2><a name='TS_RUNTIME'>Run-time Problems</a></h2>
<p>Improperly configuring COMi and/or the serial adapter can cause
various kinds of problems, none of which result in increased
productivity. 
<p>The following items are the most common problems: 
<ul>
<li><a href='#TS_RUN_RW'>Read/Write Errors </a>
<li><a href='#TS_RUN_DEVCTL'>Device I/O control (DosDevIOCtl) Errors
</a>
<li><a href='#TS_RUN_LOCK_MOUSE'>Lock-up, Pointer Moves </a>
<li><a href='#TS_RUN_LOCK_NO_MOUSE'>Lock-up, Pointer Does Not Move </a>
</ul>
<h3><a name='TS_RUN_RW'>Read/Write Errors</a></h3>
<p>When an application writes to, or reads from, a COMx device, the
device driver does not normally return to the calling thread until all
requested characters have been either received or transmitted.  If a
time-out occurs before all characters have been transmitted, or
received, the device driver will return to the calling thread with a
count of the actual characters written, or read. 
<p>An application should test the returned count to determine if it
should try to re-transmit, or read again, any remaining characters. 
<p>Write time-outs normally occur only when some output handshaking has
been enabled and some event has caused the device driver to stop
transmitting before it could transmit all of the requested characters. 
Read time-outs can occur anytime the "far-end" stops transmitting,
before all requested characters have been received. 
<h3><a name='TS_RUN_DEVCTL'>Device I/O control (DosDevIOCtl)
Errors</a></h3>
<p>See the "Physical Device Driver".  technical reference, Category One,
 Asynchronous Serial Device Drivers, for a complete description of the
device I/O control commands and their various input and output 
parameters.  COMi is designed to operate according to that application
interface. 
<p>Your distribution diskette contains a "C" source file that has sample
 code for most of the DosDevIOCtl functions defined in the Technical
Reference.  The file name is "IOCTL.C". 
<h3><a name='TS_RUN_LOCK_MOUSE'>Lock-up, Pointer Moves</a></h3>
<p>An application has probably tried to read the COM device from the
window procedure thread, the time-out is set for the default one minute
read time-out, and no characters are arriving at the UART. 
<p>The device driver does not return to the calling thread until no
characters have been received for the user configured read time-out
count.  It is recommended that an application access any COM device with
 a thread separate from the thread in which its window procedure is
running. 
<p>Of course there are other reasons for system lock-up, but this one
seems to be the most common when accessing COM devices. 
<h3><a name='TS_RUN_LOCK_NO_MOUSE'>Lock-up, Pointer Does Not
Move</a></h3>
<p>This problem, when related to COM devices, is almost always caused by
 improper configuration of the device driver and/or serial adapter
and/or device, and is the result of an endless loop within the interrupt
 service routine while interrupts have been disabled.  Make sure that
the COMi device driver is configured correctly for your adapter and that
 the serial adapter and/or device is configured as you intended. 
<h1>Communications Concepts</h1>
<p>This section is a "catch-all" for information we thought might be
useful. 
<p>Concepts: 
<ul>
<li><a href='#CON_HS'>Why Handshaking? </a>
<li><a href='#CON_APO'>Automatic Protocol Override </a>
</ul>
<h2><a name='CON_HS'>Why Handshaking?</a></h2>
<p>In any system it is important that all real-time activities, like
serial communications, be truly asynchronous.  Basically this means that
 no information should be lost because the operating system was busy
doing something else. 
<p>In operating systems like DOS, or DOS and Windows**, there is never
any guarantee the operating system will be able to get to a "real-time"
process in a timely manner.  Each process in these systems "owns" the
machine until it relinquishes control.  If a real-time process needs
service it has to wait until any currently running process has
completed. 
<p>In OS/2<a href='#fn_ibm'>* </a>this is not normally a problem.  Its
structure is such that hardware interrupts have the highest priority and
 are serviced almost immediately, and other processes are given a
time-slice in which to execute. 
<p>Problems can occur in two ways.  The first is when hardware 
interrupts come in faster than the operating system can respond.  For
asynchronous serial communications this problem is addressed mostly by
serial devices with hardware buffers (FIFOs). 
<p>The second problem is that an application may not be able to read and
 process incoming information as fast as the hardware and device driver
can receive and store information.  This problem is addressed by the
<strong>handshaking </strong>features of the serial device driver. 
<p>When handshaking is enabled the receiving system will signal the
transmitting system to stop transmitting when its receive buffer nears
full capacity.  The transmitting system should stop transmitting when it
 receives a signal to stop. 
<p>In OS/2, a serial device driver must be capable of handshaking
without intervention or control by the controlling higher level process.
  All a controlling process needs to do is command the device driver
into a handshaking mode and the device driver must do all of the
processing to be sure that the controlling process does not lose any
information.  This includes detecting when its own receive buffer is
nearly full so it can send a "stop transmitting" signal and then 
detecting when its receive buffer has been emptied enough so that it can
 send a "start transmitting" signal.  It also includes detecting when
the device it is transmitting to has sent a "stop transmitting" or
"start transmitting" signal and act accordingly. 
<h2><a name='CON_APO'>Why Automatic Protocol Override</a></h2>
<p>This feature can only be enabled when a device has hardware buffers
(FIFOs).  Normally you would want to enable hardware buffers to reduce
system overhead.  When handshaking is required between this hardware
(near-end) and some external hardware (far-end) it may be required that
a far-end's request to stop transmitting be acted upon immediately. 
<p>If hardware buffers are enabled it would be possible for that
hardware to transmit up to twenty bytes after the far-end sends a "stop
transmitting" signal.  This is because once the device driver has filled
 the hardware buffer, transmission will continue until the buffer is
empty.  This may cause a problem for some far-end equipment. 
<p>This problem can occur when any output handshaking is enabled.  This
includes CTS, DSR, and/or DCD output handshaking and transmit Xon/Xoff
handshaking.  The CTS, DSR, and DCD signals are "hardware" flow control
signals and transmit Xon/Xoff handshaking is "software" flow control
signaling. 
<p>There are two output handshaking scenarios to consider.  The first is
 the "hardware" signaling case.  When the far-end's receive buffer is
full (or nearly full) it may signal to the near-end by making one or
more of the "hardware" signals inactive.  When the near-end detects an
inactive signal it should stop transmitting.  If the transmit buffer is
enabled at the near-end it may transmit up to 16 bytes before it can act
 on that signal to stop. 
<p>The second case is "software" signaling.  When the far-end's receive
buffer is full (or nearly full) it may signal to the near-end by
transmitting an Xoff character.  When the near-end receives the Xoff
character it should stop transmitting.  If, at the near-end, the receive
 buffer is enabled, it will not detect the request to stop transmitting
until it has read the Xoff character from the receive buffer, and if the
 transmit buffer is enabled it may transmit up to sixteen bytes before
it stops transmitting. 
<p>The worst case could occur when "software" signaling is enabled. 
When hardware buffers are enabled it would be possible for an Xoff 
character to be received by the hardware and not read by the device
driver for up to four character-times after the byte was received.  The
worst case would be for the Xoff character to arrive at the near-end
hardware just as there are four characters left in the transmit buffer
to be transmitted.  The device would cause a transmit interrupt just as
the last or the four bytes is transmitted and the device driver would
refill the transmit buffer, then the device would cause a receive FIFO
time-out interrupt and the device driver would read, and detect, the
Xoff character, preventing further transmissions.  This case could allow
 up to twenty bytes to be transmitted after the far-end transmitted the
Xoff character. 
<p>All of these potential problems go away if the transmit buffer is
disabled when any output handshaking is enabled and the receive buffer
is disabled when transmit Xon/Xoff handshaking is enabled. 
<p>When <strong>Automatic Protocol Override </strong>(APO) is enabled
the device driver adjusts hardware buffer functionality according to
handshaking requirements.  When APO is enabled and an application
requests CTS, DSR, or DCD output handshaking the device driver will
disable the transmit buffer.  When APO is enabled and an application
requests transmit Xon/Xoff handshaking the device driver will disable
both the transmit and receive buffers. 
<p>There is one other adjustment <strong>Automatic Protocol Override
</strong>can cause the device driver to make to the hardware buffers of
a device.  When DSR input sensitivity is enabled, and APO is enabled,
the receive buffer will be disabled by the device driver. 
<p>DSR input sensitivity is designed to handle devices that may transmit
 garbage whenever DSR is in the inactive state.  In this case it would
be necessary to ignore any bytes received while DSR is inactive.  It may
 be possible for the far-end to transmit a character at the same time it
 activates DSR.  This could cause the near-end to miss a valid byte if
its receive buffer is enabled. 
<p>What does all this mean to you?  Probably nothing.  There are not
many "far-end" devices around these days that do not have some level of
buffering capability.  We recommend that you leave APO off, and FIFOs
enabled, unless, and until, you determine that you are communicating
with some archaic equipment that requires it. 
<h1><a name='fn_address'>FootNote 1</a></h1>
<p>Each device to be controlled by the COMi device driver owns a set of
eight contiguous I/O space addresses.  The I/O base address is the first
 address in that device's address space. See your adapter board
documentation to determine what I/O base address to use. 
<h1><a name='fn_int_level'>FootNote 2</a></h1>
<p> Each device to be controlled by the COMi device driver must be
connected to one, and only one, hardware interrupt level.  See your
adapter board documentation to determine what interrupt level to select.
 
<p>
<p><strong> Note : </strong>An exception to this rule is when you use a
serial adapter that supports shared interrupts in an <a
href='#fn_ISA'>ISA</a> machine.  If you are using such an adapter you
must take care not to use more than one interrupt level for each COMi
<a href='#fn_load'>load</a>. 
<p>You may use any combination of interrupt levels <a
href='#fn_MCA'>MCA</a> machines. 
<h1><a name='fn_OPEN_1'>FootNote 3</a></h1>
<p> A first level DosOpen is the first time a device is opened by any
application.  Any other DosOpen calls, without first calling DosClose,
are considered second level opens.  When all applications have closed a
device then the next DosOpen for that device will, again, be considered
a first level DosOpen.  The device driver returns some device operating
parameters back to device driver defaults whenever a first level DosOpen
 occurs. 
<p>Device driver operating parameters that are set back to device driver
 defaults are: 
<ul>
<li>Handshaking Parameters 
<li>Time-out Values 
<li>Time-out Processing 
<li>Stream Filters 
</ul>
<p><strong> Note : </strong>COMi start-up defaults are configurable by
the user.  The parameters in the above list are returned to defaults
defined explicitly by the user or implicitly by OS/tools.  If the user
has not defined a given parameter default during configuration that
parameter will be returned to the default defined by OS/tools. 
<h1><a name='fn_ISA'>FootNote 4</a></h1>
<p><strong>I</strong>ndustry <strong>S</strong>tandard
<strong>A</strong>rchitecture 
<p>Machines that are compatible with the IBM AT personal computer are of
 this type. 
<p>IBM and AT are registerd trademarks of International Business 
Machines, Incorporated. 
<h1><a name='fn_MCA'>FootNote 5</a></h1>
<p><strong>M</strong>icro <strong>C</strong>hannel <strong>A</strong>
rchitecture 
<p>Machines that are compatible with the IBM PS/2 are of this type. 
<p>IBM, Micro Channel, and PS/2 are registerd tradmarks of International
 Business Machines, Incorporated. 
<h1><a name='fn_active_dev'>FootNote 6</a></h1>
<p><strong> Note : </strong> The active device is the device selected
from the "Device | Select Device..." menu dialog box.  The name of the
currently active device is displayed in the title bar of the COMscope
main window, in the title bar of all COMscope monitor and control dialog
 boxes, and is shown as the title of any visible icon when a COMscope
instance has been minimized. 
<h1><a name='fn_dat_stream'>FootNote 7</a></h1>
<p><strong> Note : </strong> A COM device's main purpose in life is to
send/receive data to/from some external device.  All data written to a
device, and/or read from a device, is considered to be that device's I/O
 Data Stream.  Once a valid device has been selected COMscope can be
made to capture, and save, any data that is part of that I/O Data
Stream.  The bytes of an <strong>I/O Data Stream</strong> are stored in
the order in which they are transmitted and/or received. 
<h1><a name='fn_compress'>FootNote 8</a></h1>
<p><strong> Note : </strong> Ordinarily each byte received or
transmitted is displayed in order of transfer to/from the hardware, with
 each new byte is placed for viewing into the next character position on
 the screen.  When <strong>display compression</strong> is selected the
character position is not incremented when a received byte follows a
transmitted byte. 
<h1><a name='fn_load'>FootNote 9</a></h1>
<p><strong> Note : </strong> Each DEVICE=comdd.SYS statement in your
CONFIG.SYS file is considered a <strong>load</strong> of the COMi
Asynchronous Device Driver. 
<h1><a name='fn_check'>FootNote 10</a></h1>
<p>You can check (select) a button either by clicking mouse button one
while the pointer is on the item, or by using the TAB and/or cursor keys
 to move so the required item has the focus then pressing the space bar.
 
<h1><a name='fn_checkmark'>FootNote 11</a></h1>
<p>A symbol that shows that a menu choice is currently active. 
<h1><a name='fn_displayable'>FootNote 12</a></h1>
<p>In the lexical display format, only characters that are <strong>not
</strong>excluded by the user with display filters are displayed. 
<h1><a name='fn_synchronize'>FootNote 13</a></h1>
<p>When the lexical display format is in the "line" oriented mode the
transmit and receive streams can be synchronized.  This means that a
<a href='#fn_direction'>stream direction </a>being synchronized "to" is
displayed starting at the first character of that "line" and the
<strong>stream direction </strong>that is to be in synchronization is
displayed starting at the first character of the first "line" the begins
 immediately after the first character of the sync to <strong>stream
direction</strong>.
<h1><a name='fn_direction'>FootNote 14</a></h1>
<p>Stream direction is either into the device (receive), or out of the
device (transmit). 
<h1><a name='fn_int_scheme'>FootNote 15</a></h1>
<p>Different adapter manufacturers use different schemes to allow shared
 interrupts in ISA machines.  Currently the COMi device driver supports
the following schemes: 
<ul>
<li>Interrupt ID register is at the adapter base I/O address +7 (type
one) 
<p>Sealevel Systems COMM+8 and Turbo COMM+4, Connect Tech DFLEX, and
GlobeTeks four port adapter use this interrupt sharing scheme. 
<li>Interrupt ID register is at the adapter base I/O address +7 and the
Texas Instruments 16C550B UART is used (type one). 
<p>Comtrol Hostess serial adapters use this interrupt sharing scheme. 
<li>Interrupt ID register is aliased at each device's base I/O address
+7 (type three). 
<p>Quatechs' ES-XXX and QS-XXX adapters use this scheme. 
<li>Interrupt ID register address is at a user defined location for odd
interrupts ans is at the user defined address +1 for even interrupt
levels (type four). 
<p>DigiBoard's PC/4 and PC/8 use this interrupt sharing scheme. 
<li>Interrupt ID register address is at a user defined location (type
five). 
<p>DigiBoard's PC/16 uses this interrupting scheme. 
</ul>
<h1><a name='fn_ibm'>FootNote 16</a></h1>
<p>IBM, OS/2, PS/2, and Micro Channel are trademarks of International
Business Machines, Incorporated. 
<h1><a name='fn_microsoft'>FootNote 17</a></h1>
<p>Windows is a trademark of Microsoft, Incorporated. 
</body>
</html>