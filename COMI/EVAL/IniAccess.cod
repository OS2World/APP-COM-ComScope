;	Static Name Aliases
;
	TITLE   IniAccess.c
	.286p
	.287
INCLUDELIB	LLIBCE
_TEXT	SEGMENT  WORD PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT  WORD PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT  WORD PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT  WORD PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT  BYTE PUBLIC 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT  BYTE PUBLIC 'DEBTYP'
$$TYPES	ENDS
RMCode	SEGMENT  WORD PUBLIC 'CODE'
RMCode	ENDS
DGROUP	GROUP	CONST, _BSS, _DATA
	ASSUME DS: DGROUP
	ASSUME  SS: NOTHING
PUBLIC  _szBaseAddrError_u
PUBLIC  _szInterruptLevelError_u
PUBLIC  _szInterruptIDerror_u
PUBLIC  _szFinalError
PUBLIC  _szAllocBuffers_ululu
PUBLIC  _szAllocError
PUBLIC  _szMemoryError_u
PUBLIC  _szNoPortAvailable
PUBLIC  _szNoStackAvailable_uu
PUBLIC  _szLogoMessage_s
PUBLIC  _szSubLogo
PUBLIC  _szVerMod
PUBLIC  _szCopyright
PUBLIC  _szCreditHeader
PUBLIC  _stConfigInfo
PUBLIC  _szVersion
PUBLIC  _stConfigHeader
PUBLIC  _szVersionString_ss
PUBLIC  _stDCBheader
PUBLIC  _szPath_sss
PUBLIC  _szHighlightOn
PUBLIC  _bPrevErrorMsg
PUBLIC  _szHighlightOff
PUBLIC  _hCom
PUBLIC  _hFile
PUBLIC  _szBeepChar
PUBLIC  _szNoise
PUBLIC  _pDeviceParms
PUBLIC  _szCR_2x
PUBLIC  _pStart
PUBLIC  _szCR
PUBLIC  _pPrevious
PUBLIC  _wDeviceStrategy
PUBLIC  _szCRonly
PUBLIC  _szWaitKeyMessage
PUBLIC  _szDebugMessage
PUBLIC  _wCOMscopeStrategy
PUBLIC  _szCodeLocation_xxxxxxx
PUBLIC  _szClockRate_u
PUBLIC  _stDefaultDevHeader
PUBLIC  _szEvaluationMsg
PUBLIC  _szCOMmessage_u
PUBLIC  _bBreakInitialization
PUBLIC  _szVerboseMessage_uxu
PUBLIC  _szInputBuff_lu
PUBLIC  _awPorts
PUBLIC  _szOutputBuff_lu
PUBLIC  _szInputQueue_u
PUBLIC  _szOutputQueue_u
PUBLIC  _szUART_s
PUBLIC  _szUART_is
PUBLIC  _szAnd
PUBLIC  _szAnd4x
PUBLIC  _szAnd8x
PUBLIC  _szAnd12x
PUBLIC  _szAnd16x
PUBLIC  _szBlankPad
PUBLIC  _szPeriod
PUBLIC  _szExtended16550
PUBLIC  _szExtended16650
PUBLIC  _szExtended16654
PUBLIC  _szExtended16750
PUBLIC  _szExtended16950
PUBLIC  _szExtendedTI16550C
PUBLIC  _szABIOSaddrInvalid_u
PUBLIC  _szABIOSaddrTaken_u
PUBLIC  _szABIOSname_u
PUBLIC  _szABIOSowned_u
PUBLIC  _szRMowned_u
PUBLIC  _szSkippedPort_u
PUBLIC  _szBadInstall
PUBLIC  _iLIDcount
PUBLIC  _szHDWinterruptError_uu
PUBLIC  _szPCIerror_u
PUBLIC  _szHDWerror_xu
PUBLIC  _szInterruptError_uu
EXTRN	_GetAllSerialPCIAdapters:FAR
EXTRN	_sprintf:FAR
EXTRN	DOS16OPEN:FAR
EXTRN	_LoadPCIAdapter:FAR
EXTRN	_RMHELP_GetStatusPort:FAR
EXTRN	_RMHELP_HasPNPCaps:FAR
EXTRN	_MakeCOMscopeName:FAR
EXTRN	_RMHELP_GetPorts:FAR
EXTRN	_RMHELP_StatusPortInitComplete:FAR
EXTRN	_RMHELP_CreateDriver:FAR
EXTRN	DOS16CHGFILEPTR:FAR
EXTRN	_RMHELP_DestroyDriver:FAR
EXTRN	_StringLength:FAR
EXTRN	DOS16SLEEP:FAR
EXTRN	_AttachDD:FAR
EXTRN	DOS16CLOSE:FAR
EXTRN	_GetDeviceInterrupt:FAR
EXTRN	_GetDeviceBlockOffset:FAR
EXTRN	_atoi:FAR
EXTRN	_GetDeviceBlockLen:FAR
EXTRN	VIO16WRTTTY:FAR
EXTRN	DOS16READ:FAR
EXTRN	_GetKernalData:FAR
EXTRN	_GetDeviceAddress:FAR
EXTRN	_GetLIDentry:FAR
EXTRN	_FreeLIDentry:FAR
EXTRN	DOS16WRITE:FAR
EXTRN	_bABIOSpresent:WORD
EXTRN	_bIsTheFirst:WORD
EXTRN	_LIDtable:BYTE
EXTRN	_ulAvailableBufferSpace:DWORD
EXTRN	_ulRequiredBufferSpace:DWORD
EXTRN	_ulWriteBufferSpace:DWORD
EXTRN	_bUseDDdataSegment:WORD
EXTRN	__wPCIvendor:WORD
EXTRN	__wPCIdevice:WORD
EXTRN	__stDummyHeader:BYTE
EXTRN	__abyPath:BYTE
EXTRN	_wPCIadapterCount:WORD
EXTRN	_wDeviceCount:WORD
EXTRN	__wIntIDregister:WORD
EXTRN	_wDriverLoadCount:WORD
EXTRN	_wDelayCount:WORD
EXTRN	__wOEMjumpEntry:WORD
EXTRN	__wOEMjumpExit:WORD
EXTRN	_szMessage:BYTE
EXTRN	_astInstallParms:BYTE
EXTRN	__wMaxDeviceCount:WORD
EXTRN	_astMCAportTable:BYTE
EXTRN	__wEndOfData:WORD
EXTRN	__stDeviceParms:BYTE
EXTRN	__stAttachDD:BYTE
EXTRN	__wBusType:WORD
EXTRN	_bDisableRM:WORD
EXTRN	_bPnPcapable:WORD
EXTRN	__szName:BYTE
EXTRN	__byAdapterType:BYTE
EXTRN	__byOEMtype:BYTE
EXTRN	_byNextPCIslot:BYTE
EXTRN	_bSeparateIDreg:WORD
EXTRN	__pCOMscopeStrategy:WORD
EXTRN	__pDeviceStrategy:WORD
EXTRN	_chFailedReadIni:BYTE
EXTRN	_chFailedWriteIni:BYTE
EXTRN	_chFailedIniCorrupt_1:BYTE
EXTRN	_chFailedIniCorrupt_2:BYTE
EXTRN	_chFailedIniNotInit_1:BYTE
EXTRN	_chFailedIniNotInit_2:BYTE
EXTRN	_chFailedBadPath:BYTE
EXTRN	_chFailedBadVersion_1:BYTE
EXTRN	_chFailedBadVersion_2:BYTE
EXTRN	_chPCIMissing:BYTE
EXTRN	_chPCIBadIRQ:BYTE
EXTRN	_chTooManyPCIadapters:BYTE
EXTRN	_stPCIadapterTable:BYTE
EXTRN	_stPCIadapterHold:BYTE
EXTRN	_stConfigParms:BYTE
EXTRN	_bVerbose:WORD
EXTRN	_abyFileBuffer:BYTE
EXTRN	_bPrintLocation:WORD
EXTRN	_bWaitForCR:WORD
EXTRN	_wLoadNumber:WORD
EXTRN	_wLoadCount:WORD
EXTRN	_wLoadFlags:WORD
EXTRN	_abyCOMnumbers:BYTE
_DATA      SEGMENT
	ORG	$+4088
$SG2573	DB	'Load Number %u',  0dH,  0aH,  00H
$SG2751	DB	'COM%d    ',  00H
	ORG	$+3
$SG2774	DB	'COM%u    ',  00H
	ORG	$-4128
_szLogoMessage_s	DB	1bH, '[36mInstalling OS/tools'' COMi Asynchronous Communicat'
	DB	'ions device driver',  1bH, '[0m',  0dH,  0aH, '%s',  0dH,  0aH
	DB	00H
	ORG	$+1
_szSubLogo	DB	1bH, '[31;1m',  07H, 'Usage of his version of COMi is restri'
	DB	'cted and is for evaluation only.',  1bH, '[0m',  00H
	ORG	$+1
_szVerMod	DB	'E',  00H
_szCopyright	DB	0dH,  0aH, 'OS/tools'' COMi Asynchronous Communications devi'
	DB	'ce driver installed',  0dH,  0aH, 'Copyright (c) ',  1bH, '['
	DB	'36mOS/tools Incorporated',  1bH, '[0m 1989-2002 -- All right'
	DB	's reserved',  0dH,  0aH, 'e-mail: support@os-tools.com, URL:'
	DB	' http://www.os-tools.com',  0dH,  0aH,  00H
_szCreditHeader	DB	'Copyright (c) 1989-2002',  0dH,  0aH, 'OS/tools Incorporated'
	DB	0dH,  0aH, 'Gilroy, California',  0dH,  0aH, '(408)847-7487',  0dH
	DB	0aH, 'Written By Emmett S. Culley Jr.',  0dH,  0aH,  00H
	ORG	$+1
_szVersion	DB	'Version 4.0e',  00H
	ORG	$+1
_szVersionString_ss	DB	1bH, '[1m%s %s',  1bH, '[0m',  0dH,  0aH,  00H
_szPath_sss	DB	'%s %s %s ',  00H
_szHighlightOn	DB	1bH, '[1m',  00H
	ORG	$+1
_szHighlightOff	DB	1bH, '[0m',  00H
	ORG	$+1
_szBeepChar	DB	07H,  00H
_szNoise	DB	07H, 'h.',  00H
_szCR_2x	DB	0dH,  0aH,  0dH,  0aH,  00H
	ORG	$+1
_szCR	DB	0dH,  0aH,  00H
	ORG	$+1
_szCRonly	DB	0dH,  00H
_szWaitKeyMessage	DB	0dH,  0aH, 'Press Enter to continue.',  0dH,  0aH,  00H
	ORG	$+1
_szDebugMessage	DB	0dH,  0aH,  07H,  1bH, '[1mHit CTRL+C to cause debug trap.',  1bH
	DB	'[0m',  00H
	ORG	$+1
_szCodeLocation_xxxxxxx	DB	'C@ %04X:%04X I-%04X',  0dH,  0aH, 'D@ %04X:%04X I-%04X B-%04'
	DB	'X',  0dH,  0aH,  00H
_szClockRate_u	DB	1bH, '[1m',  07H, 'System clock rate expected to be %u milli'
	DB	'seconds for this OS/2 session',  1bH, '[0m',  0dH,  0aH,  00H
_szEvaluationMsg	DB	1bH, '[1mThis version is for ',  1bH, '[5mEVALUATION ONLY',  1bH
	DB	'[0m',  1bH, '[1m and has had some features disabled.',  0dH,  0aH
	DB	'See documentation for a description of the limitations of th'
	DB	'is version.  You',  0dH,  0aH, 'may copy and distribute this'
	DB	' version freely.  You may not modify this device',  0dH,  0aH
	DB	'driver in any way.',  0dH,  0aH,  0dH,  0aH, 'For an undimin'
	DB	'ished version of this device driver contact:',  0dH,  0aH,  0dH
	DB	0aH, 'OS/tools Incorporated',  0dH,  0aH, 'San Jose, Califor'
	DB	'nia',  0dH,  0aH, '(500)446-7257  FAX (408)847-7480',  1bH, '['
	DB	'0m',  0dH,  0aH,  00H
	ORG	$+1
_szCOMmessage_u	DB	'COM%u installed',  00H
_szVerboseMessage_uxu	DB	'COM%u installed at address 0x%X, hardware interrupt level = '
	DB	'%u',  0dH,  0aH,  00H
	ORG	$+1
_szInputBuff_lu	DB	'      input buffer length = %lu',  00H
_szOutputBuff_lu	DB	'      output buffer length = %lu',  00H
	ORG	$+1
_szInputQueue_u	DB	'      input packet queue = %u',  00H
_szOutputQueue_u	DB	'      output packet queue = %u',  00H
	ORG	$+1
_szUART_s	DB	'UART is %s',  00H
	ORG	$+1
_szUART_is	DB	'UART is ',  00H
	ORG	$+1
_szAnd	DB	' - ',  00H
_szAnd4x	DB	1bH, '[37;1m and 4x baud rate clock.',  1bH, '[0m',  00H
_szAnd8x	DB	1bH, '[37;1m and 8x baud rate clock.',  1bH, '[0m',  00H
_szAnd12x	DB	1bH, '[37;1m and 12x baud rate clock.',  1bH, '[0m',  00H
	ORG	$+1
_szAnd16x	DB	1bH, '[37;1m and 16x baud rate clock.',  1bH, '[0m',  00H
	ORG	$+1
_szBlankPad	DB	'      ',  00H
	ORG	$+1
_szPeriod	DB	'.',  1bH, '[0m',  00H
_szExtended16550	DB	'16550 with 16 byte FIFOs',  00H
	ORG	$+1
_szExtended16650	DB	1bH, '[33;1m16650 with 32 byte FIFOs',  00H
_szExtended16654	DB	1bH, '[35;1m16654 with 64 byte FIFOs',  00H
_szExtended16750	DB	1bH, '[31;1m16750 with 64 byte FIFOs',  00H
_szExtended16950	DB	1bH, '[32;1m16950 with 128 byte FIFOs',  00H
	ORG	$+1
_szExtendedTI16550C	DB	1bH, '[34;1mTI16550C with 16 byte FIFOs',  00H
	ORG	$+1
_szABIOSaddrInvalid_u	DB	1bH, '[1m',  07H, 'COM%u not installed because a valid devic'
	DB	'e was not detected at the specified base I/O address',  1bH, '['
	DB	'0m',  0dH,  0aH,  00H
	ORG	$+1
_szABIOSaddrTaken_u	DB	1bH, '[1m',  07H, 'COM%u not installed because a previously '
	DB	'loaded device driver owns the device',  0dH,  0aH, 'under a '
	DB	'different device name',  1bH, '[0m',  0dH,  0aH,  00H
_szABIOSname_u	DB	1bH, '[1m',  07H, 'COM%u not installed because name is taken'
	DB	' by a previously loaded device driver',  1bH, '[0m',  0dH,  0aH
	DB	00H
_szABIOSowned_u	DB	1bH, '[1m',  07H, 'COM%u not installed because device is own'
	DB	'ed by a previously loaded process',  1bH, '[0m',  0dH,  0aH,  00H
_szRMowned_u	DB	1bH, '[1m',  07H, 'COM%u not installed because IRQ or I/O ad'
	DB	'dress resource is not available.',  1bH, '[0m',  0dH,  0aH,  00H
	ORG	$+1
_szSkippedPort_u	DB	'COM%u not installed at users request',  1bH, '[0m',  0dH,  0aH
	DB	00H
	ORG	$+1
_szBadInstall	DB	1bH, '[1m',  07H, 'You must use either COMscope or Install t'
	DB	'o install the COMi device drvier.',  0dH,  0aH, 'See documen'
	DB	'tation for instructions on installation and configuration of'
	DB	' COMi.',  1bH, '[0m',  0dH,  0aH,  0dH,  0aH,  00H
	ORG	$+1
_szHDWinterruptError_uu	DB	1bH, '[1m',  07H, 'COM%u device is not connected to interrup'
	DB	't %u as expected and was not installed',  1bH, '[0m',  0dH,  0aH
	DB	00H
	ORG	$+1
_szPCIerror_u	DB	1bH, '[1m',  07H, 'No supported PCI device found, COM%u was '
	DB	'not installed.',  1bH, '[0m',  0dH,  0aH,  00H
	ORG	$+1
_szHDWerror_xu	DB	1bH, '[1m',  07H, 'No supported device was found at base add'
	DB	'ress 0x%X - COM%u was not installed.',  1bH, '[0m',  0dH,  0aH
	DB	00H
	ORG	$+1
_szInterruptError_uu	DB	1bH, '[1m',  07H, 'Interrupt %u is unavailable - COM%u was n'
	DB	'ot intalled.',  1bH, '[0m',  0dH,  0aH,  00H
	ORG	$+1
_szBaseAddrError_u	DB	1bH, '[1m',  07H, 'Invalid base I/O address was specified - '
	DB	'COM%u was not installed.',  1bH, '[0m',  0dH,  0aH,  00H
	ORG	$+1
_szInterruptLevelError_u	DB	1bH, '[1m',  07H, 'Invalid or no interrupt level was specifi'
	DB	'ed - COM%u was not installed.',  1bH, '[0m',  0dH,  0aH,  00H
_szInterruptIDerror_u	DB	1bH, '[1m',  07H, 'COM%u device does not support an Interrup'
	DB	't Status register as configured.',  1bH, '[0m',  0dH,  0aH,  00H
	ORG	$+1
_szFinalError	DB	1bH, '[1m',  07H, 'At least one installed device was not con'
	DB	'figured correctly.  See adapter',  0dH,  0aH, 'and/or COMi d'
	DB	'ocumentation for explanation.',  1bH, '[0m',  0dH,  0aH,  00H
_szAllocBuffers_ululu	DB	1bH, '[1m',  07H, 'Allocating %u selectors and %lu bytes RAM'
	DB	' for device driver buffers.',  0dH,  0aH, '%lu bytes were av'
	DB	'ailable in device driver data segment.',  1bH, '[0m',  0dH,  0aH
	DB	00H
	ORG	$+1
_szAllocError	DB	1bH, '[1m',  07H, 'Unable to allocate memory or selectors fo'
	DB	'r device driver buffers.  Your',  0dH,  0aH, 'system is unab'
	DB	'le to support the memory requested',  1bH, '[0m',  0dH,  0aH
	DB	00H
	ORG	$+1
_szMemoryError_u	DB	1bH, '[1m',  07H, 'Segment Overflow, decrease transmit buffe'
	DB	'r sizes  - COM%u was not installed',  1bH, '[0m',  0dH,  0aH
	DB	00H
	ORG	$+1
_szNoPortAvailable	DB	1bH, '[1m',  07H, 'There are no serial devices available for'
	DB	' COMi access.  Either there are no',  0dH,  0aH, 'standard s'
	DB	'erial devices installed, or all standard devices are already'
	DB	' owned',  0dH,  0aH, 'by one, or more, previously loaded dev'
	DB	'ice drivers (i.e., COM.SYS).',  1bH, '[0m',  0dH,  0aH,  00H
	ORG	$+1
_szNoStackAvailable_uu	DB	1bH, '[1mNo stack available for interrupt level %u - COM%u w'
	DB	'as not installed',  1bH, '[0m',  0dH,  0aH,  00H
_stConfigInfo	DD	00H
 	DB	40 DUP(0)

_stConfigHeader	DW	00H
 	DB	60 DUP(0)

_stDCBheader	DB	00H
 	DB	57 DUP(0)

_bPrevErrorMsg	DW	00H
_hCom	DW	00H
_hFile	DW	00H
_pDeviceParms	DD	00H
_pStart	DD	00H
_pPrevious	DD	00H
_wDeviceStrategy	DW	00H
_wCOMscopeStrategy	DW	00H
_stDefaultDevHeader	DD	00H
	DW	00H
 	DB	20 DUP(0)

_bBreakInitialization	DW	00H
_awPorts	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	ORG	$+28
_iLIDcount	DW	00H
_DATA      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
;|*** /************************************************************************
; Line 1
;|*** **
;|*** ** $Revision:  $
;|*** **
;|*** ** $Log:   $
;|*** **
;|*** ************************************************************************/
;|*** 
;|*** #define INCL_DOSDEVICES
;|*** #define INCL_VIO
;|*** #define INCL_DOS
;|*** #define INCL_DOSERRORS
;|*** #define INCL_NOPM
;|*** #define building_DD
;|*** 
;|*** #include <os2.h>
; Line 16
;|*** /*DDK*************************************************************************/
;|*** /*                                                                           */
;|*** /* COPYRIGHT (C) Microsoft Corporation, 1989                                 */
;|*** /* COPYRIGHT    Copyright (C) 1995 IBM Corporation                           */
;|*** /*                                                                           */
;|*** /*    The following IBM OS/2 WARP source code is provided to you solely for  */
;|*** /*    the purpose of assisting you in your development of OS/2 WARP device   */
;|*** /*    drivers. You may use this code in accordance with the IBM License      */
;|*** /*    Agreement provided in the IBM Device Driver Source Kit for OS/2. This  */
;|*** /*    Copyright statement may not be removed.                                */
;|*** /*                                                                           */
;|*** /*****************************************************************************/
;|*** /*static char *SCCSID = "@(#)os2.h	6.3 91/05/26";*/
;|*** /****************************** Module Header ******************************\
;|*** *
;|*** *
;|*** * Module Name: OS2.H
;|*** *
;|*** * This is the top level include file that includes all the files necessary
;|*** * for writing an OS/2 application.
;|*** *
;|*** \***************************************************************************/
;|*** 
;|*** #define OS2_INCLUDED
;|*** 
;|*** #if !(defined(INCL_32) || defined(INCL_16))
;|*** #ifdef M_I386
;|***     #define INCL_32
;|*** #else /* not M_I386 */
;|***     #define INCL_16
;|*** #endif /* M_I386 */
;|*** #endif /* INCL_32 || INCL_16 */
;|*** 
;|*** /* XLATOFF */
;|*** #if (defined(INCL_32) && defined(INCL_16))
;|*** #error message ("Illegal combination of API Flags - 32 && 16")
;|*** #endif /* INCL_32 && INCL_16 */
;|*** /* XLATON */
;|*** 
;|*** /* Common definitions */
;|*** 
;|*** #include <os2def.h>
; Line 42
;|*** /*DDK*************************************************************************/
;|*** /*                                                                           */
;|*** /* COPYRIGHT    Copyright (C) 1995 IBM Corporation                           */
;|*** /*                                                                           */
;|*** /*    The following IBM OS/2 WARP source code is provided to you solely for  */
;|*** /*    the purpose of assisting you in your development of OS/2 WARP device   */
;|*** /*    drivers. You may use this code in accordance with the IBM License      */
;|*** /*    Agreement provided in the IBM Device Driver Source Kit for OS/2. This  */
;|*** /*    Copyright statement may not be removed.                                */
;|*** /*                                                                           */
;|*** /*****************************************************************************/
;|*** /****************************** Module Header ******************************\
;|*** *
;|*** * Module Name: OS2DEF.H
;|*** *
;|*** * OS/2 Common Definitions file
;|*** *
;|*** *
;|*** * ===========================================================================
;|*** *
;|*** * Comments at the end of each typedef line give the name tags used in
;|*** * the assembler include version of this file.
;|*** *
;|*** * The assembler include version of this file excludes lines between NOINC
;|*** * and INC comments.
;|*** *
;|*** #ifndef __IBMC__
;|***    * The public version of this file (as shipped with the OS/2 Toolkit
;|***    * product) excludes all non 32-bit material marked in this file
;|***    * as well as any areas specifically marked with __IBMC__ conditional
;|***    * sections - including this paragraph. The H2IBMH rexx command file
;|***    * removes these sections.
;|*** #endif
;|*** \***************************************************************************/
;|*** 
;|*** #ifdef __IBMC__
;|***    #pragma checkout( suspend )
;|***       #ifndef __CHKHDR__
;|***          #pragma checkout( suspend )
;|***       #endif
;|***    #pragma checkout( resume )
;|*** #endif
;|*** 
;|*** #define OS2DEF_INCLUDED
;|*** 
;|*** #ifndef INCL_32         /* If neither INCL_32 or INCL_16 set already */
;|***    #ifndef INCL_16      /* find out from compiler if 32-bit or not.  */
;|***      #ifdef M_I386
;|***         #define INCL_32 /* Compiling for 32-bit */
;|***      #else
;|***         #define INCL_16 /* Compiling for 16-bit */
;|***      #endif
;|***   #endif
;|*** #endif
;|*** 
;|*** #ifdef INCL_32
;|***    #ifndef __IBMC__
;|***    /*****************************************************************/
;|***    /* This #ifdef brackets the rest of this entire file.  It is     */
;|***    /* used to include either the 32-bit or 16-bit base definitions. */
;|***    /* No definitions (other than 16/32-bit determination) must be   */
;|***    /* placed above this.                                            */
;|***    /*****************************************************************/
;|***    #endif
;|*** 
;|***    /* NOINC */
;|***    #ifdef INCL_16
;|***       #error message ("Using 32 bit definitions when compiling 16 bit code")
;|***    #endif /* INCL_16 */
;|***    #ifdef __IBMC__
;|***       #define FAR         /* this will be deleted shortly */
;|***       #define NEAR        /* this will be deleted shortly */
;|*** 
;|***       #define APIENTRY    _System
;|***       #define EXPENTRY    _System
;|*** 
;|***       #define APIENTRY16  _Far16 _Pascal
;|***       #define PASCAL16    _Far16 _Pascal
;|***       #define CDECL16     _Far16 _Cdecl
;|***    #else
;|***       #define FAR         /* nothing */
;|***       #define NEAR        /* nothing */
;|*** 
;|***       #define APIENTRY    _syscall
;|***       #define EXPENTRY    _syscall
;|*** 
;|***       #define PASCAL      /* nothing */
;|***    #endif
;|*** 
;|***    #define VOID        void
;|***    /* INC */
;|*** 
;|***    typedef unsigned long  APIRET;
;|***    typedef unsigned short APIRET16;
;|***    typedef unsigned long  APIRET32;
;|*** 
;|***    #ifndef FALSE
;|***       #define FALSE   0
;|***    #endif
;|*** 
;|***    #ifndef TRUE
;|***       #define TRUE    1
;|***    #endif
;|*** 
;|***    #ifndef NULL
;|***       #ifdef __IBMC__
;|***          #define NULL ((void *)0)
;|***       #else
;|***          #define NULL 0
;|***       #endif
;|***    #endif
;|*** 
;|***    #ifdef __IBMC__
;|***       typedef unsigned short   SHANDLE;
;|***    #else
;|***       /* TEMP      - David Kerr, this will change to short when the    */
;|***       /*             rest of the BSExxx.H files are changed to LHANDLE */
;|***       typedef unsigned long   SHANDLE;
;|***    #endif
;|***    typedef unsigned long    LHANDLE;
;|*** 
;|***    #define NULLHANDLE    ( (LHANDLE) 0)
;|***    #define NULLSHANDLE   ( (SHANDLE) 0)
;|*** 
;|***    /* NOINC */
;|***    #define CHAR    char            /* ch  */
;|***    #define SHORT   short           /* s   */
;|***    #define LONG    long            /* l   */
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #define INT  int             /* i   */
;|***    #endif /* !INCL_SAADEFS */
;|***    /* INC */
;|*** 
;|***    typedef unsigned char  UCHAR;   /* uch */
;|***    typedef unsigned short USHORT;  /* us  */
;|***    typedef unsigned long  ULONG;   /* ul  */
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       typedef unsigned int UINT;   /* ui  */
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    #ifdef __IBMC__
;|***       typedef UCHAR     * _Seg16 PUCHAR16;
;|***       typedef CHAR      * _Seg16 PCHAR16;
;|***    #endif
;|*** 
;|***    typedef unsigned char BYTE;     /* b   */
;|*** 
;|***    typedef unsigned char FAR  *PSZ;
;|***    typedef unsigned char NEAR *NPSZ;
;|*** 
;|***    typedef unsigned char FAR  *PCH;
;|***    typedef unsigned char NEAR *NPCH;
;|*** 
;|***    #ifdef __IBMC__
;|***       typedef int (* APIENTRY PFN)  ();
;|***       typedef int (* APIENTRY NPFN) ();
;|***    #else
;|***       typedef int   (PASCAL FAR  *PFN)();
;|***       typedef int   (PASCAL NEAR *NPFN)();
;|***    #endif
;|*** 
;|***    typedef BYTE   FAR  *PBYTE;
;|***    typedef BYTE   NEAR *NPBYTE;
;|*** 
;|***    typedef CHAR   FAR *PCHAR;
;|***    typedef SHORT  FAR *PSHORT;
;|***    typedef LONG   FAR *PLONG;
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       typedef INT    FAR *PINT;
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    typedef UCHAR  FAR *PUCHAR;
;|***    typedef USHORT FAR *PUSHORT;
;|***    typedef ULONG  FAR *PULONG;
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       typedef UINT FAR *PUINT;
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    typedef VOID   FAR *PVOID;
;|***    typedef PVOID  FAR *PPVOID;
;|*** 
;|***    typedef unsigned long BOOL;     /* f   */
;|***    typedef BOOL FAR *PBOOL;
;|*** 
;|***    typedef unsigned short  BOOL16;
;|***    #ifdef __IBMC__
;|***       typedef BOOL16     * _Seg16 PBOOL16;
;|***    #else
;|***       typedef BOOL16 FAR *PBOOL16;
;|***    #endif
;|*** 
;|***    /* NOINC */
;|***    #define BOOL32    BOOL
;|***    #define PBOOL32   PBOOL
;|***    /* INC */
;|*** 
;|***    /* NOINC */
;|***    /* Quad-word */
;|***    typedef struct _QWORD {        /* qword */
;|***       ULONG   ulLo;
;|***       ULONG   ulHi;
;|***    } QWORD;
;|***    typedef QWORD FAR *PQWORD;
;|***    /* INC */
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       typedef unsigned short SEL;     /* sel */
;|***       typedef SEL FAR *PSEL;
;|*** 
;|***       /*** Useful Helper Macros */
;|*** 
;|***       /* Create untyped far pointer from selector and offset */
;|***       #ifdef __IBMC__
;|***          #define MAKEP(sel,off) ((void * _Seg16)((((sel)&0xfff8)<<13)|(off)))
;|***       #else
;|***          #define MAKEP(sel, off)     ((PVOID)MAKEULONG(off, sel))
;|***       #endif
;|*** 
;|***       /* Extract selector or offset from far pointer */
;|***       #ifdef __IBMC__
;|***          #define SELECTOROF(ptr)     ((((ULONG)(ptr))>>13)|7)
;|***       #else
;|***          #define SELECTOROF(p)       (((PUSHORT)&(p))[1])
;|***       #endif
;|***       #define OFFSETOF(p)         (((PUSHORT)&(p))[0])
;|***    #endif  /* !INCL_SAADEFS */
;|*** 
;|***    /* Cast any variable to an instance of the specified type. */
;|***    #define MAKETYPE(v, type)   (*((type FAR *)&v))
;|*** 
;|***    /* Calculate the byte offset of a field in a structure of type type. */
;|***    #define FIELDOFFSET(type, field)    ((SHORT)&(((type *)0)->field))
;|*** 
;|***    /* Combine l & h to form a 32 bit quantity. */
;|***    #define MAKEULONG(l, h)  ((ULONG)(((USHORT)(l)) | ((ULONG)((USHORT)(h))) << 16))
;|***    #define MAKELONG(l, h)   ((LONG)MAKEULONG(l, h))
;|*** 
;|***    /* Combine l & h to form a 16 bit quantity. */
;|***    #define MAKEUSHORT(l, h) (((USHORT)(l)) | ((USHORT)(h)) << 8)
;|***    #define MAKESHORT(l, h)  ((SHORT)MAKEUSHORT(l, h))
;|*** 
;|***    /* Extract high and low order parts of 16 and 32 bit quantity */
;|***    #define LOBYTE(w)       LOUCHAR(w)
;|***    #define HIBYTE(w)       HIUCHAR(w)
;|***    #define LOUCHAR(w)      ((UCHAR)(w))
;|***    #define HIUCHAR(w)      ((UCHAR)(((USHORT)(w) >> 8) & 0xff))
;|***    #define LOUSHORT(l)     ((USHORT)((ULONG)l))
;|***    #define HIUSHORT(l)     ((USHORT)(((ULONG)(l) >> 16) & 0xffff))
;|*** 
;|***    /*** Common Error definitions ****/
;|*** 
;|***    typedef ULONG ERRORID;  /* errid */
;|***    typedef ERRORID FAR *PERRORID;
;|*** 
;|***    /* Combine severity and error code to produce ERRORID */
;|***    #define MAKEERRORID(sev, error) (ERRORID)(MAKEULONG((error), (sev)))
;|*** 
;|***    /* Extract error number from an errorid */
;|***    #define ERRORIDERROR(errid)            (LOUSHORT(errid))
;|*** 
;|***    /* Extract severity from an errorid */
;|***    #define ERRORIDSEV(errid)              (HIUSHORT(errid))
;|*** 
;|***    /* Severity codes */
;|***    #define SEVERITY_NOERROR                    0x0000
;|***    #define SEVERITY_WARNING                    0x0004
;|***    #define SEVERITY_ERROR                      0x0008
;|***    #define SEVERITY_SEVERE                     0x000C
;|***    #define SEVERITY_UNRECOVERABLE              0x0010
;|*** 
;|***    /* Base component error values */
;|*** 
;|***    #define WINERR_BASE     0x1000  /* Window Manager                  */
;|***    #define GPIERR_BASE     0x2000  /* Graphics Presentation Interface */
;|***    #define DEVERR_BASE     0x3000  /* Device Manager                  */
;|***    #define SPLERR_BASE     0x4000  /* Spooler                         */
;|*** 
;|***    /*** Common types used across components */
;|*** 
;|***    /*** Common DOS types */
;|*** 
;|***    typedef LHANDLE HMODULE;        /* hmod */
;|***    typedef LHANDLE PID;            /* pid  */
;|***    typedef LHANDLE TID;            /* tid  */
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       typedef USHORT  SGID;        /* sgid */
;|***    #endif  /* !INCL_SAADEFS */
;|*** 
;|***    typedef HMODULE FAR *PHMODULE;
;|***    typedef PID FAR *PPID;
;|***    typedef TID FAR *PTID;
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       typedef VOID FAR *HSEM;      /* hsem */
;|***       typedef HSEM FAR *PHSEM;
;|***    #endif  /* !INCL_SAADEFS */
;|*** 
;|***    /*** Common SUP types */
;|*** 
;|***    typedef LHANDLE   HAB;         /* hab  */
;|***    typedef HAB FAR *PHAB;
;|*** 
;|***    /*** Common GPI/DEV types */
;|*** 
;|***    typedef LHANDLE   HPS;         /* hps  */
;|***    typedef HPS FAR *PHPS;
;|*** 
;|***    typedef LHANDLE   HDC;         /* hdc  */
;|***    typedef HDC FAR *PHDC;
;|*** 
;|***    typedef LHANDLE   HRGN;        /* hrgn */
;|***    typedef HRGN FAR *PHRGN;
;|*** 
;|***    typedef LHANDLE   HBITMAP;     /* hbm  */
;|***    typedef HBITMAP FAR *PHBITMAP;
;|*** 
;|***    typedef LHANDLE   HMF;         /* hmf  */
;|***    typedef HMF FAR *PHMF;
;|*** 
;|***    typedef LHANDLE   HPAL;        /* hpal */
;|***    typedef HPAL FAR *PHPAL;
;|*** 
;|***    typedef LONG     COLOR;        /* clr  */
;|***    typedef COLOR FAR *PCOLOR;
;|*** 
;|***    typedef struct _POINTL  {      /* ptl  */
;|***       LONG  x;
;|***       LONG  y;
;|***    } POINTL;
;|***    typedef POINTL  FAR  *PPOINTL;
;|***    typedef POINTL  NEAR *NPPOINTL;
;|*** 
;|***    typedef struct _POINTS {       /* pts */
;|***       SHORT x;
;|***       SHORT y;
;|***    } POINTS;
;|***    typedef POINTS FAR *PPOINTS;
;|*** 
;|***    typedef struct _RECTL {        /* rcl */
;|***       LONG  xLeft;
;|***       LONG  yBottom;
;|***       LONG  xRight;
;|***       LONG  yTop;
;|***    } RECTL;
;|***    typedef RECTL FAR  *PRECTL;
;|***    typedef RECTL NEAR *NPRECTL;
;|*** 
;|***    typedef CHAR STR8[8];          /* str8 */
;|***    typedef STR8 FAR *PSTR8;
;|*** 
;|***    /*** common DEV/SPL types */
;|*** 
;|***    /* structure for Device Driver data */
;|*** 
;|***    typedef struct _DRIVDATA {     /* driv */
;|***       LONG    cb;
;|***       LONG    lVersion;
;|***       CHAR    szDeviceName[32];
;|***       CHAR    abGeneralData[1];
;|***    } DRIVDATA;
;|***    typedef DRIVDATA FAR *PDRIVDATA;
;|*** 
;|***    /* pointer data for DevOpenDC */
;|*** 
;|***    typedef PSZ FAR *PDEVOPENDATA;
;|*** 
;|***    /* array indices for array parameter for DevOpenDC, SplQmOpen or SplQpOpen */
;|*** 
;|***    #define ADDRESS          0
;|***    #ifndef INCL_SAADEFS
;|***       #define DRIVER_NAME      1
;|***       #define DRIVER_DATA      2
;|***       #define DATA_TYPE        3
;|***       #define COMMENT          4
;|***       #define PROC_NAME        5
;|***       #define PROC_PARAMS      6
;|***       #define SPL_PARAMS       7
;|***       #define NETWORK_PARAMS   8
;|*** 
;|***       /* structure definition as an alternative of the array parameter */
;|*** 
;|***       typedef struct _DEVOPENSTRUC {    /* dop */
;|***          PSZ        pszLogAddress;
;|***          PSZ        pszDriverName;
;|***          PDRIVDATA  pdriv;
;|***          PSZ        pszDataType;
;|***          PSZ        pszComment;
;|***          PSZ        pszQueueProcName;
;|***          PSZ        pszQueueProcParams;
;|***          PSZ        pszSpoolerParams;
;|***          PSZ        pszNetworkParams;
;|***       } DEVOPENSTRUC;
;|***       typedef DEVOPENSTRUC FAR *PDEVOPENSTRUC;
;|***    #endif  /* !INCL_SAADEFS */
;|*** 
;|***    /* common PMWP object and PMSTDDLG drag data */
;|*** 
;|***    typedef struct _PRINTDEST {   /* prntdst */
;|***       ULONG        cb;
;|***       LONG         lType;
;|***       PSZ          pszToken;
;|***       LONG         lCount;
;|***       PDEVOPENDATA pdopData;
;|***       ULONG        fl;
;|***       PSZ          pszPrinter;
;|***    } PRINTDEST;
;|***    typedef PRINTDEST FAR *PPRINTDEST;
;|*** 
;|***    #define PD_JOB_PROPERTY   0x0001      /* Flags for .fl field           */
;|*** 
;|***    /*** common AVIO/GPI types */
;|*** 
;|***    /* values of fsSelection field of FATTRS structure */
;|***    #define FATTR_SEL_ITALIC        0x0001
;|***    #define FATTR_SEL_UNDERSCORE    0x0002
;|***    #define FATTR_SEL_OUTLINE       0x0008
;|***    #define FATTR_SEL_STRIKEOUT     0x0010
;|***    #define FATTR_SEL_BOLD          0x0020
;|*** 
;|***    /* values of fsType field of FATTRS structure */
;|***    #define FATTR_TYPE_KERNING      0x0004
;|***    #define FATTR_TYPE_MBCS         0x0008
;|***    #define FATTR_TYPE_DBCS         0x0010
;|***    #define FATTR_TYPE_ANTIALIASED  0x0020
;|*** 
;|***    /* values of fsFontUse field of FATTRS structure */
;|***    #define FATTR_FONTUSE_NOMIX         0x0002
;|***    #define FATTR_FONTUSE_OUTLINE       0x0004
;|***    #define FATTR_FONTUSE_TRANSFORMABLE 0x0008
;|***    /* size for fields in the font structures */
;|*** 
;|***    #define FACESIZE 32
;|*** 
;|***    /* font struct for Vio/GpiCreateLogFont */
;|*** 
;|***    typedef struct _FATTRS {          /* fat */
;|***       USHORT  usRecordLength;
;|***       USHORT  fsSelection;
;|***       LONG    lMatch;
;|***       CHAR    szFacename[FACESIZE];
;|***       USHORT  idRegistry;
;|***       USHORT  usCodePage;
;|***       LONG    lMaxBaselineExt;
;|***       LONG    lAveCharWidth;
;|***       USHORT  fsType;
;|***       USHORT  fsFontUse;
;|***    } FATTRS;
;|***    typedef FATTRS FAR *PFATTRS;
;|*** 
;|***    /* values of fsType field of FONTMETRICS structure */
;|***    #define FM_TYPE_FIXED           0x0001
;|***    #define FM_TYPE_LICENSED        0x0002
;|***    #define FM_TYPE_KERNING         0x0004
;|***    #define FM_TYPE_DBCS            0x0010
;|***    #define FM_TYPE_MBCS            0x0018
;|***    #define FM_TYPE_64K             0x8000
;|***    #define FM_TYPE_ATOMS           0x4000
;|***    #define FM_TYPE_FAMTRUNC        0x2000
;|***    #define FM_TYPE_FACETRUNC       0x1000
;|*** 
;|***    /* values of fsDefn field of FONTMETRICS structure */
;|***    #define FM_DEFN_OUTLINE         0x0001
;|***    #define FM_DEFN_IFI             0x0002
;|***    #define FM_DEFN_WIN             0x0004
;|***    #define FM_DEFN_GENERIC         0x8000
;|*** 
;|***    /* values of fsSelection field of FONTMETRICS structure */
;|***    #define FM_SEL_ITALIC           0x0001
;|***    #define FM_SEL_UNDERSCORE       0x0002
;|***    #define FM_SEL_NEGATIVE         0x0004
;|***    #define FM_SEL_OUTLINE          0x0008          /* Hollow Outline Font */
;|***    #define FM_SEL_STRIKEOUT        0x0010
;|***    #define FM_SEL_BOLD             0x0020
;|***    #define FM_SEL_ISO9241_TESTED   0x0040
;|*** 
;|***    /* ISO 9241 is an international standard covering health and safety      */
;|***    /* in the work place for users of visual display terminals. Part 3 of    */
;|***    /* this standard covers clarity and legibility of text displayed on      */
;|***    /* computer screens, it places requirements on minimum sizes and         */
;|***    /* luminance contrast. The presence of FM_SEL_ISO9241_TESTED flag in the */
;|***    /* font metrics indicates that the font has been tested for compliance   */
;|***    /* to the standard. The FM_ISO_XXX flags indicate the results of the     */
;|***    /* test on the IBM 9515, 9517 and 9518 color displays at the supported   */
;|***    /* dimensions of 640x480 and 1024x768. To ensure compliance the          */
;|***    /* sXDeviceRes and sYDeviceRes must also match the target display        */
;|***    /* resolution.                                                           */
;|*** 
;|***    /* values of fbPassed/FailedISO field in the PANOSE structure */
;|***    #define FM_ISO_9518_640        0x01
;|***    #define FM_ISO_9515_640        0x02
;|***    #define FM_ISO_9515_1024       0x04
;|***    #define FM_ISO_9517_640        0x08
;|***    #define FM_ISO_9517_1024       0x10
;|*** 
;|***    /* values of fsCapabilities field of FONTMETRICS structure */
;|***    #define FM_CAP_NOMIX            0x0001
;|*** 
;|***    /* font metrics returned by GpiQueryFonts and others */
;|*** 
;|***    typedef struct _PANOSE { /* panose */
;|***       BYTE    bFamilyType;
;|***       BYTE    bSerifStyle;
;|***       BYTE    bWeight;
;|***       BYTE    bProportion;
;|***       BYTE    bContrast;
;|***       BYTE    bStrokeVariation;
;|***       BYTE    bArmStyle;
;|***       BYTE    bLetterform;
;|***       BYTE    bMidline;
;|***       BYTE    bXHeight;
;|***       BYTE    fbPassedISO;
;|***       BYTE    fbFailedISO;
;|***    } PANOSE;
;|*** 
;|***    typedef struct _FONTMETRICS {   /* fm */
;|***       CHAR    szFamilyname[FACESIZE];
;|***       CHAR    szFacename[FACESIZE];
;|***       USHORT  idRegistry;
;|***       USHORT  usCodePage;
;|***       LONG    lEmHeight;
;|***       LONG    lXHeight;
;|***       LONG    lMaxAscender;
;|***       LONG    lMaxDescender;
;|***       LONG    lLowerCaseAscent;
;|***       LONG    lLowerCaseDescent;
;|***       LONG    lInternalLeading;
;|***       LONG    lExternalLeading;
;|***       LONG    lAveCharWidth;
;|***       LONG    lMaxCharInc;
;|***       LONG    lEmInc;
;|***       LONG    lMaxBaselineExt;
;|***       SHORT   sCharSlope;
;|***       SHORT   sInlineDir;
;|***       SHORT   sCharRot;
;|***       USHORT  usWeightClass;
;|***       USHORT  usWidthClass;
;|***       SHORT   sXDeviceRes;
;|***       SHORT   sYDeviceRes;
;|***       SHORT   sFirstChar;
;|***       SHORT   sLastChar;
;|***       SHORT   sDefaultChar;
;|***       SHORT   sBreakChar;
;|***       SHORT   sNominalPointSize;
;|***       SHORT   sMinimumPointSize;
;|***       SHORT   sMaximumPointSize;
;|***       USHORT  fsType;
;|***       USHORT  fsDefn;
;|***       USHORT  fsSelection;
;|***       USHORT  fsCapabilities;
;|***       LONG    lSubscriptXSize;
;|***       LONG    lSubscriptYSize;
;|***       LONG    lSubscriptXOffset;
;|***       LONG    lSubscriptYOffset;
;|***       LONG    lSuperscriptXSize;
;|***       LONG    lSuperscriptYSize;
;|***       LONG    lSuperscriptXOffset;
;|***       LONG    lSuperscriptYOffset;
;|***       LONG    lUnderscoreSize;
;|***       LONG    lUnderscorePosition;
;|***       LONG    lStrikeoutSize;
;|***       LONG    lStrikeoutPosition;
;|***       SHORT   sKerningPairs;
;|***       SHORT   sFamilyClass;
;|***       LONG    lMatch;
;|***       LONG    FamilyNameAtom;
;|***       LONG    FaceNameAtom;
;|***       PANOSE  panose;
;|***    } FONTMETRICS;
;|***    typedef FONTMETRICS FAR *PFONTMETRICS;
;|*** 
;|***    /*** Common WIN types */
;|*** 
;|***    typedef LHANDLE HWND;      /* hwnd */
;|***    typedef HWND FAR *PHWND;
;|*** 
;|***    typedef LHANDLE HMQ;       /* hmq */
;|***    typedef LHANDLE FAR *PHMQ;
;|*** 
;|***    /* NOINC */
;|***    #define WRECT RECTL
;|***    #define PWRECT PRECTL
;|***    #define NPWRECT NPRECTL
;|*** 
;|***    #define WPOINT POINTL
;|***    #define PWPOINT PPOINTL
;|***    #define NPWPOINT NPPOINTL
;|***    /* INC */
;|*** 
;|***    typedef struct _ICONINFO {  /* icninf */
;|***       ULONG   cb;                  /* size of ICONINFO structure */
;|***       ULONG   fFormat;
;|***       PSZ     pszFileName;         /* use when fFormat = ICON_FILE */
;|***       HMODULE hmod;                /* use when fFormat = ICON_RESOURCE */
;|***       ULONG   resid;               /* use when fFormat = ICON_RESOURCE */
;|***       ULONG   cbIconData;          /* use when fFormat = ICON_DATA     */
;|***       PVOID   pIconData;           /* use when fFormat = ICON_DATA     */
;|***    } ICONINFO;
;|***    typedef ICONINFO FAR *PICONINFO;
;|*** 
;|***    #define ICON_FILE     1         /* flags for fFormat */
;|***    #define ICON_RESOURCE 2
;|***    #define ICON_DATA     3
;|***    #define ICON_CLEAR    4
;|*** 
;|*** #else /* not INCL_32 */
;|***    /* The previous #else/#endif corresponds to a #if near the top of this  */
;|***    /* file.  The next three lines include the 16-bit version of this file, */
;|***    /* hence these lines MUST be the last lines in this include file.       */
;|*** 
;|***    #ifdef INCL_16
;|***       #include <os2def16.h>
; Line 616
;|*** 
;|*** /* OS/2 Base Include File */
;|*** 
;|*** #ifndef INCL_NOBASEAPI
;|*** #include <bse.h>
; Line 47
;|*** /*DDK*************************************************************************/
;|*** /*                                                                           */
;|*** /* COPYRIGHT (C) Microsoft Corporation, 1989                                 */
;|*** /* COPYRIGHT    Copyright (C) 1995 IBM Corporation                           */
;|*** /*                                                                           */
;|*** /*    The following IBM OS/2 WARP source code is provided to you solely for  */
;|*** /*    the purpose of assisting you in your development of OS/2 WARP device   */
;|*** /*    drivers. You may use this code in accordance with the IBM License      */
;|*** /*    Agreement provided in the IBM Device Driver Source Kit for OS/2. This  */
;|*** /*    Copyright statement may not be removed.                                */
;|*** /*                                                                           */
;|*** /*****************************************************************************/
;|*** /*static char *SCCSID = "@(#)bse.h	6.2 91/02/12";*/
;|*** /*static char *SCCSID = "@(#)bse.h	6.2 91/02/12";*/
;|*** /****************************** Module Header ******************************\
;|*** *
;|*** * Module Name: BSE.H
;|*** *
;|*** * This file includes the definitions necessary for writing Base OS/2 applications.
;|*** *
;|*** *
;|*** *
;|*** *
;|*** * ===========================================================================
;|*** *
;|*** * The following symbols are used in this file for conditional sections.
;|*** *
;|*** *   INCL_BASE   -  ALL of OS/2 Base
;|*** *   INCL_DOS    -  OS/2 DOS Kernel
;|*** *   INCL_SUB    -  OS/2 VIO/KBD/MOU
;|*** *   INCL_DOSERRORS -  OS/2 Errors         - only included if symbol defined
;|*** *
;|*** \***************************************************************************/
;|*** 
;|*** #define INCL_BASEINCLUDED
;|*** 
;|*** /* if INCL_BASE defined then define all the symbols */
;|*** #ifdef INCL_BASE
;|***     #define INCL_DOS
;|***     #define INCL_SUB
;|***     #define INCL_DOSERRORS
;|*** #endif /* INCL_BASE */
;|*** 
;|*** #ifndef OS2_INCLUDED
;|*** #if !(defined(INCL_32) || defined(INCL_16))
;|*** #ifdef M_I386
;|***     #define INCL_32
;|*** #else /* not M_I386 */
;|***     #define INCL_16
;|*** #endif /* M_I386 */
;|*** #endif /* INCL_32 || INCL_16 */
;|*** #endif /* OS2_INCLUDED */
;|*** 
;|*** /* XLATOFF */
;|*** #ifdef INCL_32
;|*** #if defined(INCL_16)
;|*** #error message ("Illegal combination of API Flags - 32 && 16")
;|*** #endif /* || INCL_16 */
;|*** #endif /* INCL_32 */
;|*** /* XLATON */
;|*** 
;|*** #include <bsedos.h>       /* Base definitions */
; Line 62
;|*** /*DDK*************************************************************************/
;|*** /*                                                                           */
;|*** /* COPYRIGHT (C) Microsoft Corporation, 1989                                 */
;|*** /* COPYRIGHT    Copyright (C) 1995 IBM Corporation                           */
;|*** /*                                                                           */
;|*** /*    The following IBM OS/2 WARP source code is provided to you solely for  */
;|*** /*    the purpose of assisting you in your development of OS/2 WARP device   */
;|*** /*    drivers. You may use this code in accordance with the IBM License      */
;|*** /*    Agreement provided in the IBM Device Driver Source Kit for OS/2. This  */
;|*** /*    Copyright statement may not be removed.                                */
;|*** /*                                                                           */
;|*** /*****************************************************************************/
;|*** /*static char *SCCSID = "@(#)bsedos.h   6.29 92/03/10";*/
;|*** /***************************************************************************\
;|*** *
;|*** * Module Name: BSEDOS.H
;|*** *
;|*** * OS/2 Base Include File
;|*** *
;|*** *
;|*** *****************************************************************************
;|*** *
;|*** * Subcomponents marked with "+" are partially included by default
;|*** *
;|*** *   #define:                To include:
;|*** *
;|*** * + INCL_DOSPROCESS         Process and thread support
;|*** * + INCL_DOSFILEMGR         File Management
;|*** * + INCL_DOSMEMMGR          Memory Management
;|*** * + INCL_DOSSEMAPHORES      Semaphore support
;|*** * + INCL_DOSDATETIME        Date/Time and Timer support
;|*** *   INCL_DOSMODULEMGR       Module manager
;|*** * + INCL_DOSRESOURCES       Resource support
;|*** *   INCL_DOSNLS             National Language Support
;|*** *   INCL_DOSEXCEPTIONS      Exceptions
;|*** *   INCL_DOSMISC            Miscellaneous
;|*** *   INCL_DOSMONITORS        Monitors
;|*** *   INCL_DOSQUEUES          Queues
;|*** *   INCL_DOSSESMGR          Session Manager Support
;|*** *   INCL_DOSDEVICES         Device specific, ring 2 support
;|*** *   INCL_DOSNMPIPES         Named Pipes Support
;|*** *   INCL_DOSPROFILE         DosProfile API
;|*** *   INCL_DOSMVDM            MVDM support
;|*** *
;|*** \***************************************************************************/
;|*** 
;|*** #define INCL_DOSINCLUDED
;|*** 
;|*** #ifndef INCL_BASEINCLUDED
;|*** #if !(defined(INCL_32) || defined(INCL_16))
;|*** #ifdef M_I386
;|***     #define INCL_32
;|*** #else /* not M_I386 */
;|***     #define INCL_16
;|*** #endif /* M_I386 */
;|*** #endif /* INCL_32 || INCL_16 */
;|*** 
;|*** /* XLATOFF */
;|*** #if defined(INCL_16)
;|*** #pragma message ("32-bit Base API included when using 16-bit compiler")
;|*** #endif /* INCL_16 */
;|*** /* XLATON */
;|*** #endif /* INCL_BASEINCLUDED */
;|*** 
;|*** #ifdef INCL_32  /* This #ifdef brackets the rest of this entire */
;|***                         /* file.  It is used to include either the      */
;|***                         /* 32-bit or 16-bit base definitions.  No       */
;|***                         /* definitions (other than 16/32-bit            */
;|***                         /* determination) must be placed above this.    */
;|*** 
;|*** #ifdef INCL_DOS
;|*** 
;|*** #define INCL_DOSPROCESS
;|*** #define INCL_DOSFILEMGR
;|*** #define INCL_DOSMEMMGR
;|*** #define INCL_DOSSEMAPHORES
;|*** #define INCL_DOSDATETIME
;|*** #define INCL_DOSMODULEMGR
;|*** #define INCL_DOSRESOURCES
;|*** #define INCL_DOSNLS
;|*** #define INCL_DOSEXCEPTIONS
;|*** #define INCL_DOSMISC
;|*** #define INCL_DOSMONITORS
;|*** #define INCL_DOSQUEUES
;|*** #define INCL_DOSSESMGR
;|*** #define INCL_DOSDEVICES
;|*** #define INCL_DOSNMPIPES
;|*** #define INCL_DOSPROFILE
;|*** #define INCL_DOSMVDM
;|*** 
;|*** #endif /* INCL_DOS */
;|*** 
;|*** #ifdef INCL_ERRORS
;|*** #define INCL_DOSERRORS
;|*** #endif /* INCL_ERRORS */
;|*** 
;|*** #if (defined(INCL_DOSPROCESS) || !defined(INCL_NOCOMMON))
;|*** 
;|*** /*** General services */
;|*** 
;|*** APIRET  APIENTRY        DosBeep(ULONG freq, ULONG dur);
;|*** 
;|*** /*** Process and Thread support */
;|*** 
;|*** VOID    APIENTRY        DosExit(ULONG action, ULONG result);
;|*** 
;|*** /* DosExit codes */
;|*** 
;|*** #define EXIT_THREAD         0
;|*** #define EXIT_PROCESS        1
;|*** 
;|*** #endif /* common INCL_DOSPROCESS stuff */
;|*** 
;|*** #ifdef INCL_DOSPROCESS
;|*** 
;|*** /* XLATOFF */
;|*** #define DosCwait        DosWaitChild
;|*** #define DosSetPrty      DosSetPriority
;|*** /* XLATON */
;|*** 
;|*** #include <bsetib.h>
;|*** 
;|*** typedef VOID (*PFNTHREAD)(VOID);
;|*** 
;|*** APIRET  APIENTRY        DosCreateThread(PTID ptid, PFNTHREAD pfn, ULONG param, ULONG flag, ULONG cbStack);
;|*** 
;|*** APIRET  APIENTRY        DosResumeThread(TID tid);
;|*** 
;|*** APIRET  APIENTRY        DosSuspendThread(TID tid);
;|*** 
;|*** APIRET  APIENTRY        DosGetInfoBlocks(PTIB *pptib,PPIB *pppib);
;|*** 
;|*** APIRET  APIENTRY        DosKillThread(TID tid);
;|*** 
;|*** APIRET APIENTRY DosAllocThreadLocalMemory(ULONG cb, PULONG *p);
;|*** APIRET APIENTRY DosFreeThreadLocalMemory(ULONG *p);
;|*** 
;|*** /* Action code values */
;|*** 
;|*** #define DCWA_PROCESS        0
;|*** #define DCWA_PROCESSTREE    1
;|*** 
;|*** /* Wait option values */
;|*** 
;|*** #define DCWW_WAIT   0
;|*** #define DCWW_NOWAIT 1
;|*** 
;|*** /* Thread Flags for DosCreateThread options 59468 */
;|*** 
;|*** #define CREATE_READY        0
;|*** #define CREATE_SUSPENDED    1
;|*** #define STACK_SPARSE        0
;|*** #define STACK_COMMITTED     2
;|*** 
;|*** typedef struct _RESULTCODES {     /* resc */
;|***     ULONG codeTerminate;
;|***     ULONG codeResult;
;|*** } RESULTCODES;
;|*** typedef RESULTCODES     *PRESULTCODES;
;|*** 
;|*** APIRET  APIENTRY        DosWaitChild(ULONG action, ULONG option, PRESULTCODES pres, PPID ppid, PID pid);
;|*** 
;|*** APIRET  APIENTRY        DosWaitThread(PTID ptid, ULONG option);
;|*** 
;|*** APIRET  APIENTRY        DosSleep(ULONG msec);
;|*** 
;|*** APIRET  APIENTRY        DosDebug(PVOID pdbgbuf);
;|*** 
;|*** 
;|*** /* codeTerminate values (also passed to ExitList routines) */
;|*** 
;|*** #define TC_EXIT          0
;|*** #define TC_HARDERROR     1
;|*** #define TC_TRAP          2
;|*** #define TC_KILLPROCESS   3
;|*** #define TC_EXCEPTION     4
;|*** 
;|*** typedef VOID    (*PFNEXITLIST)(ULONG);
;|*** 
;|*** APIRET  APIENTRY        DosEnterCritSec(VOID);
;|*** 
;|*** APIRET  APIENTRY        DosExitCritSec(VOID);
;|*** 
;|*** APIRET  APIENTRY        DosExitList(ULONG ordercode, PFNEXITLIST pfn);
;|*** 
;|*** /* DosExitList functions */
;|*** 
;|*** #define EXLST_ADD       1
;|*** #define EXLST_REMOVE    2
;|*** #define EXLST_EXIT      3
;|*** 
;|*** APIRET  APIENTRY        DosExecPgm(PCHAR pObjname, LONG cbObjname, ULONG execFlag, PSZ pArg, PSZ pEnv, PRESULTCODES pRes, PSZ pName);
;|*** 
;|*** /* DosExecPgm functions */
;|*** 
;|*** #define EXEC_SYNC           0
;|*** #define EXEC_ASYNC          1
;|*** #define EXEC_ASYNCRESULT    2
;|*** #define EXEC_TRACE          3
;|*** #define EXEC_BACKGROUND     4
;|*** #define EXEC_LOAD           5
;|*** #define EXEC_ASYNCRESULTDB  6
;|*** 
;|*** 
;|*** APIRET  APIENTRY        DosSetPriority(ULONG scope, ULONG class, LONG delta, ULONG PorTid);
;|*** 
;|*** /* Priority scopes */
;|*** 
;|*** #define PRTYS_PROCESS       0
;|*** #define PRTYS_PROCESSTREE   1
;|*** #define PRTYS_THREAD        2
;|*** 
;|*** /* Priority classes */
;|*** 
;|*** #define PRTYC_NOCHANGE      0
;|*** #define PRTYC_IDLETIME      1
;|*** #define PRTYC_REGULAR       2
;|*** #define PRTYC_TIMECRITICAL  3
;|*** #define PRTYC_FOREGROUNDSERVER  4
;|*** 
;|*** /* Priority deltas */
;|*** 
;|*** #define PRTYD_MINIMUM      -31
;|*** #define PRTYD_MAXIMUM       31
;|*** 
;|*** APIRET  APIENTRY        DosKillProcess(ULONG action, PID pid);
;|*** 
;|*** #define DKP_PROCESSTREE     0
;|*** #define DKP_PROCESS         1
;|*** 
;|*** #endif /* INCL_DOSPROCESS */
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** 
;|*** /*
;|***  * CCHMAXPATH is the maximum fully qualified path name length including
;|***  * the drive letter, colon, backslashes and terminating NULL.
;|***  */
;|*** #define CCHMAXPATH      260
;|*** 
;|*** /*
;|***  * CCHMAXPATHCOMP is the maximum individual path component name length
;|***  * including a terminating NULL.
;|***  */
;|*** #define CCHMAXPATHCOMP  256
;|*** 
;|*** #endif  /* !INCL_SAADEFS */
;|*** 
;|*** #if (defined(INCL_DOSFILEMGR) || !defined(INCL_NOCOMMON))
;|*** 
;|*** /*** File manager */
;|*** 
;|*** /* DosSetFilePtr() file position codes */
;|*** 
;|*** #define FILE_BEGIN      0x0000  /* Move relative to beginning of file */
;|*** #define FILE_CURRENT    0x0001  /* Move relative to current fptr position */
;|*** #define FILE_END        0x0002  /* Move relative to end of file */
;|*** 
;|*** /* DosFindFirst/Next Directory handle types */
;|*** 
;|*** #define HDIR_SYSTEM     1       /* Use system handle (1) */
;|*** #define HDIR_CREATE     (-1)    /* Allocate a new, unused handle */
;|*** 
;|*** /* DosCopy control bits; may be or'ed together */
;|*** #define DCPY_EXISTING   0x00001         /* Copy even if target exists */
;|*** #define DCPY_APPEND     0x00002         /* Append to existing file, do not replace */
;|*** #define DCPY_FAILEAS    0x00004         /* Fail if EAs not supported on target*/
;|*** 
;|*** /* DosOpen/DosQFHandState/DosQueryFileInfo et al file attributes; also */
;|*** /* known as Dos File Mode bits... */
;|*** #define FILE_NORMAL     0x0000
;|*** #define FILE_READONLY   0x0001
;|*** #define FILE_HIDDEN     0x0002
;|*** #define FILE_SYSTEM     0x0004
;|*** #define FILE_DIRECTORY  0x0010
;|*** #define FILE_ARCHIVED   0x0020
;|*** 
;|*** 
;|*** #define MUST_HAVE_READONLY      ( (FILE_READONLY  << 8) | FILE_READONLY  )
;|*** #define MUST_HAVE_HIDDEN        ( (FILE_HIDDEN    << 8) | FILE_HIDDEN    )
;|*** #define MUST_HAVE_SYSTEM        ( (FILE_SYSTEM    << 8) | FILE_SYSTEM    )
;|*** #define MUST_HAVE_DIRECTORY     ( (FILE_DIRECTORY << 8) | FILE_DIRECTORY )
;|*** #define MUST_HAVE_ARCHIVED      ( (FILE_ARCHIVED  << 8) | FILE_ARCHIVED  )
;|*** 
;|*** /* DosOpen() actions */
;|*** 
;|*** #define FILE_EXISTED    0x0001
;|*** #define FILE_CREATED    0x0002
;|*** #define FILE_TRUNCATED  0x0003
;|*** 
;|*** /* DosOpen() open flags */
;|*** #define FILE_OPEN                  0x0001
;|*** #define FILE_TRUNCATE              0x0002
;|*** #define FILE_CREATE                0x0010
;|*** 
;|*** /*     this nibble applies if file already exists                xxxx */
;|*** 
;|*** #define OPEN_ACTION_FAIL_IF_EXISTS     0x0000  /* ---- ---- ---- 0000 */
;|*** #define OPEN_ACTION_OPEN_IF_EXISTS     0x0001  /* ---- ---- ---- 0001 */
;|*** #define OPEN_ACTION_REPLACE_IF_EXISTS  0x0002  /* ---- ---- ---- 0010 */
;|*** 
;|*** /*     this nibble applies if file does not exist           xxxx      */
;|*** 
;|*** #define OPEN_ACTION_FAIL_IF_NEW        0x0000  /* ---- ---- 0000 ---- */
;|*** #define OPEN_ACTION_CREATE_IF_NEW      0x0010  /* ---- ---- 0001 ---- */
;|*** 
;|*** /* DosOpen/DosSetFHandState flags */
;|*** 
;|*** #define OPEN_ACCESS_READONLY        0x0000  /* ---- ---- ---- -000 */
;|*** #define OPEN_ACCESS_WRITEONLY       0x0001  /* ---- ---- ---- -001 */
;|*** #define OPEN_ACCESS_READWRITE       0x0002  /* ---- ---- ---- -010 */
;|*** #define OPEN_SHARE_DENYREADWRITE    0x0010  /* ---- ---- -001 ---- */
;|*** #define OPEN_SHARE_DENYWRITE        0x0020  /* ---- ---- -010 ---- */
;|*** #define OPEN_SHARE_DENYREAD         0x0030  /* ---- ---- -011 ---- */
;|*** #define OPEN_SHARE_DENYNONE         0x0040  /* ---- ---- -100 ---- */
;|*** #define OPEN_FLAGS_NOINHERIT        0x0080  /* ---- ---- 1--- ---- */
;|*** #define OPEN_FLAGS_NO_LOCALITY      0x0000  /* ---- -000 ---- ---- */
;|*** #define OPEN_FLAGS_SEQUENTIAL       0x0100  /* ---- -001 ---- ---- */
;|*** #define OPEN_FLAGS_RANDOM           0x0200  /* ---- -010 ---- ---- */
;|*** #define OPEN_FLAGS_RANDOMSEQUENTIAL 0x0300  /* ---- -011 ---- ---- */
;|*** #define OPEN_FLAGS_NO_CACHE         0x1000  /* ---1 ---- ---- ---- */
;|*** #define OPEN_FLAGS_FAIL_ON_ERROR    0x2000  /* --1- ---- ---- ---- */
;|*** #define OPEN_FLAGS_WRITE_THROUGH    0x4000  /* -1-- ---- ---- ---- */
;|*** #define OPEN_FLAGS_DASD             0x8000  /* 1--- ---- ---- ---- */
;|*** #define OPEN_FLAGS_NONSPOOLED       0x00040000
;|*** #define OPEN_FLAGS_PROTECTED_HANDLE 0x40000000
;|*** 
;|*** 
;|*** /* DosSearchPath() constants */
;|*** 
;|*** #define SEARCH_PATH            0x0000
;|*** #define SEARCH_CUR_DIRECTORY   0x0001
;|*** #define SEARCH_ENVIRONMENT     0x0002
;|*** #define SEARCH_IGNORENETERRS   0x0004
;|*** 
;|*** 
;|*** /************************************************************
;|*** EA Info Levels & Find First/Next
;|*** =========================================
;|*** API's: DosFindFirst, DosQueryFileInfo, DosQueryPathInfo, DosSetFileInfo,
;|***        DosSetPathInfo
;|*** ************************************************************/
;|*** 
;|*** /* File info levels&gml All listed API's */
;|*** #define FIL_STANDARD            1       /* Info level 1, standard file info */
;|*** #define FIL_QUERYEASIZE         2       /* Level 2, return Full EA size */
;|*** #define FIL_QUERYEASFROMLIST    3       /* Level 3, return requested EA's */
;|*** 
;|*** /* File info levels: Dos...PathInfo only */
;|*** #define FIL_QUERYFULLNAME       5       /* Level 5, return fully qualified
;|***                                            name of file */
;|*** /* DosFsAttach() */
;|*** /* Attact or detach */
;|*** #define FS_ATTACH       0       /* Attach file server */
;|*** #define FS_DETACH       1       /* Detach file server */
;|*** #define FS_SPOOLATTACH  2       /* Register a spooler device */
;|*** #define FS_SPOOLDETACH  3       /* De-register a spooler device */
;|*** 
;|*** 
;|*** /* DosFsCtl() */
;|*** /* Routing type */
;|*** #define FSCTL_HANDLE    1       /* File Handle directs req routing */
;|*** #define FSCTL_PATHNAME  2       /* Path Name directs req routing */
;|*** #define FSCTL_FSDNAME   3       /* FSD Name directs req routing */
;|*** 
;|*** /* defined FSCTL functions */
;|*** #define FSCTL_ERROR_INFO        1       /* return error info from FSD */
;|*** #define FSCTL_MAX_EASIZE        2       /* Max ea size for the FSD */
;|*** 
;|*** typedef struct  _EASIZEBUF {    /* struct for FSCTL fn 2 - max ea size */
;|***         USHORT  cbMaxEASize;    /* max. size of one EA */
;|***         ULONG   cbMaxEAListSize;        /* max size of the full EA List */
;|*** } EASIZEBUF;
;|*** typedef EASIZEBUF FAR * PEASIZEBUF;
;|*** 
;|*** 
;|*** /* DosQueryFSAttach() */
;|*** /* Information level types (defines method of query) */
;|*** #define FSAIL_QUERYNAME 1       /* Return data for a Drive or Device */
;|*** #define FSAIL_DEVNUMBER 2       /* Return data for Ordinal Device # */
;|*** #define FSAIL_DRVNUMBER 3       /* Return data for Ordinal Drive # */
;|*** 
;|*** /* Item types (from data structure item "iType") */
;|*** #define FSAT_CHARDEV    1       /* Resident character device */
;|*** #define FSAT_PSEUDODEV  2       /* Pseudo-character device */
;|*** #define FSAT_LOCALDRV   3       /* Local drive */
;|*** #define FSAT_REMOTEDRV  4       /* Remote drive attached to FSD */
;|*** 
;|*** 
;|*** typedef struct  _FSQBUFFER {    /* fsqbuf Data structure for QFSAttach*/
;|***     USHORT      iType;          /* Item type */
;|***     USHORT      cbName;         /* Length of item name, sans NULL */
;|***     UCHAR       szName[1];      /* ASCIIZ item name */
;|***     USHORT      cbFSDName;      /* Length of FSD name, sans NULL */
;|***     UCHAR       szFSDName[1];   /* ASCIIZ FSD name */
;|***     USHORT      cbFSAData;      /* Length of FSD Attach data returned */
;|***     UCHAR       rgFSAData[1];   /* FSD Attach data from FSD */
;|*** } FSQBUFFER;
;|*** typedef FSQBUFFER FAR *PFSQBUFFER;
;|*** 
;|*** 
;|*** typedef struct _FSQBUFFER2 {    /* fsqbuf Data structure for QFSAttach*/
;|***     USHORT  iType;
;|***     USHORT  cbName;
;|***     USHORT  cbFSDName;
;|***     USHORT  cbFSAData;
;|***     UCHAR   szName[1];
;|***     UCHAR   szFSDName[1];
;|***     UCHAR   rgFSAData[1];
;|*** } FSQBUFFER2;
;|*** 
;|*** typedef FSQBUFFER2 FAR * PFSQBUFFER2;
;|*** 
;|*** typedef struct _SPOOLATTACH {   /* Data structure for spooler operations */
;|***     USHORT      hNmPipe;        /* Named pipe handle                     */
;|***     ULONG       ulKey;          /* Attached key                          */
;|*** } SPOOLATTACH;
;|*** typedef SPOOLATTACH FAR *PSPOOLATTACH;
;|*** 
;|*** /***********
;|*** File System Drive Information&gml DosQueryFSInfo DosSetFSInfo
;|*** ***********/
;|*** 
;|*** /* FS Drive Info Levels */
;|*** #define FSIL_ALLOC      1       /* Drive allocation info (Query only) */
;|*** #define FSIL_VOLSER     2       /* Drive Volum/Serial info */
;|*** 
;|*** /* DosQueryFHType() */
;|*** /* Handle classes (low 8 bits of Handle Type) */
;|*** #define FHT_DISKFILE    0x0000          /* Disk file handle */
;|*** #define FHT_CHRDEV      0x0001          /* Character device handle */
;|*** #define FHT_PIPE        0x0002          /* Pipe handle */
;|*** 
;|*** /* Handle bits (high 8 bits of Handle Type) */
;|*** #define FHB_DSKREMOTE           0x8000  /* Remote disk */
;|*** #define FHB_CHRDEVREMOTE        0x8000  /* Remote character device */
;|*** #define FHB_PIPEREMOTE          0x8000  /* Remote pipe */
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** 
;|*** /* File time and date types */
;|*** 
;|*** typedef struct _FTIME {         /* ftime */
;|***     USHORT twosecs : 5;
;|***     USHORT minutes : 6;
;|***     USHORT hours   : 5;
;|*** } FTIME;
;|*** typedef FTIME   *PFTIME;
;|*** 
;|*** typedef struct _FDATE {         /* fdate */
;|***     USHORT day     : 5;
;|***     USHORT month   : 4;
;|***     USHORT year    : 7;
;|*** } FDATE;
;|*** typedef FDATE   *PFDATE;
;|*** 
;|*** #endif /* INCL_SAADEFS */
;|*** 
;|*** typedef struct _VOLUMELABEL {    /* vol */
;|***     BYTE cch;
;|***     CHAR szVolLabel[12];
;|*** } VOLUMELABEL;
;|*** typedef VOLUMELABEL FAR *PVOLUMELABEL;
;|*** 
;|*** typedef struct _FSINFO {    /* fsinf */
;|***     ULONG ulVSN;
;|***     VOLUMELABEL vol;
;|*** } FSINFO;
;|*** typedef FSINFO FAR *PFSINFO;
;|*** 
;|*** /* HANDTYPE values */
;|*** 
;|*** #define HANDTYPE_FILE     0x0000
;|*** #define HANDTYPE_DEVICE   0x0001
;|*** #define HANDTYPE_PIPE     0x0002
;|*** #define HANDTYPE_PROTECTED 0x4000
;|*** #define HANDTYPE_NETWORK  0x8000
;|*** 
;|*** typedef struct _FILELOCK {    /* flock */
;|***     LONG lOffset;
;|***     LONG lRange;
;|*** } FILELOCK;
;|*** typedef FILELOCK FAR *PFILELOCK;
;|*** 
;|*** typedef SHANDLE HFILE;     /* hf */
;|*** typedef HFILE   *PHFILE;
;|*** 
;|*** typedef  ULONG    HEV;             /* hev */
;|*** typedef  HEV      *PHEV;
;|*** typedef  ULONG  FHLOCK;
;|*** typedef  PULONG  PFHLOCK;
;|*** 
;|*** APIRET  APIENTRY        DosSetFileLocks(HFILE hFile, PFILELOCK pflUnlock, PFILELOCK pflLock, ULONG timeout, ULONG flags);
;|*** APIRET  APIENTRY        DosProtectSetFileLocks(HFILE hFile,
;|***                                                PFILELOCK pflUnlock,
;|***                                                PFILELOCK pflLock,
;|***                                                ULONG timeout, ULONG flags,
;|***                                                FHLOCK fhFileHandleLockID);
;|*** 
;|*** APIRET  APIENTRY        DosCancelLockRequest(HFILE hFile, PFILELOCK pflLock);
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** 
;|*** typedef struct _FILEFINDBUF {   /* findbuf */
;|***     FDATE  fdateCreation;
;|***     FTIME  ftimeCreation;
;|***     FDATE  fdateLastAccess;
;|***     FTIME  ftimeLastAccess;
;|***     FDATE  fdateLastWrite;
;|***     FTIME  ftimeLastWrite;
;|***     ULONG  cbFile;
;|***     ULONG  cbFileAlloc;
;|***     USHORT attrFile;
;|***     UCHAR  cchName;
;|***     CHAR   achName[CCHMAXPATHCOMP];
;|*** } FILEFINDBUF;
;|*** typedef FILEFINDBUF     *PFILEFINDBUF;
;|*** 
;|*** /* XLATOFF */
;|*** #pragma pack(2)
;|*** /* XLATON */
;|*** 
;|*** typedef struct _FILEFINDBUF2 {  /* findbuf2 */
;|***     FDATE  fdateCreation;
;|***     FTIME  ftimeCreation;
;|***     FDATE  fdateLastAccess;
;|***     FTIME  ftimeLastAccess;
;|***     FDATE  fdateLastWrite;
;|***     FTIME  ftimeLastWrite;
;|***     ULONG  cbFile;
;|***     ULONG  cbFileAlloc;
;|***     USHORT attrFile;
;|***     ULONG  cbList;
;|***     UCHAR  cchName;
;|***     CHAR   achName[CCHMAXPATHCOMP];
;|*** } FILEFINDBUF2;
;|*** typedef FILEFINDBUF2    *PFILEFINDBUF2;
;|*** 
;|*** /* XLATOFF */
;|*** #pragma pack()
;|*** /* XLATON */
;|*** 
;|*** typedef struct _FILEFINDBUF3 {   /* findbuf3 */
;|***     ULONG   oNextEntryOffset;                   /* new field */
;|***     FDATE   fdateCreation;
;|***     FTIME   ftimeCreation;
;|***     FDATE   fdateLastAccess;
;|***     FTIME   ftimeLastAccess;
;|***     FDATE   fdateLastWrite;
;|***     FTIME   ftimeLastWrite;
;|***     ULONG   cbFile;
;|***     ULONG   cbFileAlloc;
;|***     ULONG   attrFile;                           /* widened field */
;|***     UCHAR   cchName;
;|***     CHAR    achName[CCHMAXPATHCOMP];
;|*** } FILEFINDBUF3;
;|*** typedef FILEFINDBUF3    *PFILEFINDBUF3;
;|*** 
;|*** typedef struct _FILEFINDBUF4 {   /* findbuf4 */
;|***     ULONG   oNextEntryOffset;                   /* new field */
;|***     FDATE   fdateCreation;
;|***     FTIME   ftimeCreation;
;|***     FDATE   fdateLastAccess;
;|***     FTIME   ftimeLastAccess;
;|***     FDATE   fdateLastWrite;
;|***     FTIME   ftimeLastWrite;
;|***     ULONG   cbFile;
;|***     ULONG   cbFileAlloc;
;|***     ULONG   attrFile;                           /* widened field */
;|***     ULONG   cbList;
;|***     UCHAR   cchName;
;|***     CHAR    achName[CCHMAXPATHCOMP];
;|*** } FILEFINDBUF4;
;|*** typedef FILEFINDBUF4    *PFILEFINDBUF4;
;|*** 
;|*** /* extended attribute structures */
;|*** 
;|*** typedef struct _GEA {       /* gea */
;|***     BYTE cbName;            /* name length not including NULL */
;|***     CHAR szName[1];         /* attribute name */
;|*** } GEA;
;|*** typedef GEA     *PGEA;
;|*** 
;|*** typedef struct _GEALIST {   /* geal */
;|***     ULONG cbList;           /* total bytes of structure including full list */
;|***     GEA list[1];            /* variable length GEA structures */
;|*** } GEALIST;
;|*** typedef GEALIST* PGEALIST;
;|*** 
;|*** typedef struct _FEA {       /* fea */
;|***     BYTE fEA;               /* flags                              */
;|***     BYTE cbName;            /* name length not including NULL */
;|***     USHORT cbValue;         /* value length */
;|*** } FEA;
;|*** typedef FEA     *PFEA;
;|*** 
;|*** /* flags for _FEA.fEA */
;|*** 
;|*** #define FEA_NEEDEA 0x80     /* need EA bit */
;|*** 
;|*** typedef struct _FEALIST {   /* feal */
;|***     ULONG cbList;           /* total bytes of structure including full list */
;|***     FEA list[1];            /* variable length FEA structures */
;|*** } FEALIST;
;|*** typedef FEALIST* PFEALIST;
;|*** 
;|*** typedef struct _EAOP {      /* eaop */
;|***     PGEALIST fpGEAList;     /* general EA list */
;|***     PFEALIST fpFEAList;     /* full EA list */
;|***     ULONG oError;
;|*** } EAOP;
;|*** typedef EAOP* PEAOP;
;|*** 
;|*** 
;|*** /* XLATOFF */
;|*** #pragma pack(1)
;|*** /* XLATON */
;|*** 
;|*** typedef struct _FEA2 {      /* fea2 */
;|***     ULONG   oNextEntryOffset;                   /* new field */
;|***     BYTE    fEA;
;|***     BYTE    cbName;
;|***     USHORT  cbValue;
;|***     CHAR    szName[1];                          /* new field */
;|*** } FEA2;
;|*** 
;|*** typedef FEA2 *PFEA2;
;|*** 
;|*** /* flags for _FEA.fEA */
;|*** 
;|*** #define FEA_NEEDEA 0x80     /* need EA bit */
;|*** 
;|*** typedef struct _FEA2LIST {    /* fea2l */
;|***     ULONG   cbList;
;|***     FEA2    list[1];
;|*** } FEA2LIST;
;|*** 
;|*** typedef FEA2LIST *PFEA2LIST;
;|*** 
;|*** typedef struct _GEA2 {        /* gea2 */
;|***     ULONG   oNextEntryOffset;                   /* new field */
;|***     BYTE    cbName;
;|***     CHAR    szName[1];                          /* new field */
;|*** } GEA2;
;|*** 
;|*** typedef GEA2 *PGEA2;
;|*** 
;|*** typedef struct _GEA2LIST {    /* gea2l */
;|***     ULONG   cbList;
;|***     GEA2    list[1];
;|*** } GEA2LIST;
;|*** 
;|*** typedef GEA2LIST *PGEA2LIST;
;|*** 
;|*** typedef struct _EAOP2 {      /* eaop2 */
;|***     PGEA2LIST   fpGEA2List;                     /* GEA set */
;|***     PFEA2LIST   fpFEA2List;                     /* FEA set */
;|***     ULONG       oError;                         /* offset of FEA error */
;|*** } EAOP2;
;|*** 
;|*** typedef EAOP2 *PEAOP2;
;|*** 
;|*** /* XLATOFF */
;|*** #pragma pack()
;|*** /* XLATON */
;|*** 
;|*** /*
;|***  * Equates for the types of EAs that follow the convention that we have
;|***  * established.
;|***  *
;|***  * Values 0xFFFE thru 0x8000 are reserved.
;|***  * Values 0x0000 thru 0x7fff are user definable.
;|***  * Value  0xFFFC is not used
;|***  */
;|*** 
;|*** #define EAT_BINARY      0xFFFE          /* length preceeded binary */
;|*** #define EAT_ASCII       0xFFFD          /* length preceeded ASCII */
;|*** #define EAT_BITMAP      0xFFFB          /* length preceeded bitmap */
;|*** #define EAT_METAFILE    0xFFFA          /* length preceeded metafile */
;|*** #define EAT_ICON        0xFFF9          /* length preceeded icon */
;|*** #define EAT_EA          0xFFEE          /* length preceeded ASCII */
;|***                                         /* name of associated data (#include) */
;|*** #define EAT_MVMT        0xFFDF          /* multi-valued, multi-typed field */
;|*** #define EAT_MVST        0xFFDE          /* multi-valued, single-typed field */
;|*** #define EAT_ASN1        0xFFDD          /* ASN.1 field */
;|*** 
;|*** /* XLATOFF */
;|*** #pragma pack(1)
;|*** /* XLATON */
;|*** 
;|*** typedef struct _CNPATH {      /* CHANGENOTIFYPATH */
;|***     ULONG   oNextEntryOffset;
;|***     ULONG   wFlags;
;|***     USHORT  cbName;
;|***     CHAR    szName[1];
;|*** } CNPATH;
;|*** 
;|*** typedef CNPATH *PCNPATH;
;|*** 
;|*** typedef struct _CNINFO {      /* CHANGENOTIFYINFO */
;|***     ULONG   oNextEntryOffset;
;|***     CHAR    bAction;
;|***     USHORT  cbName;
;|***     CHAR    szName[1];
;|*** } CNINFO;
;|*** 
;|*** typedef CNINFO *PCNINFO;
;|*** 
;|*** /* XLATOFF */
;|*** #pragma pack()
;|*** /* XLATON */
;|*** 
;|*** /*
;|***  *  Equates for ChangeNotifyInfo baction field
;|***  *
;|***  */
;|*** 
;|*** #define             RCNF_FILE_ADDED        0x0001
;|*** #define             RCNF_FILE_DELETED      0x0002
;|*** #define             RCNF_DIR_ADDED         0x0003
;|*** #define             RCNF_DIR_DELETED       0x0004
;|*** #define             RCNF_MOVED_IN          0x0005
;|*** #define             RCNF_MOVED_OUT         0x0006
;|*** #define             RCNF_CHANGED           0x0007
;|*** #define             RCNF_OLDNAME           0x0008
;|*** #define             RCNF_NEWNAME           0x0009
;|*** #define             RCNF_DEVICE_ATTACHED   0x000A
;|*** #define             RCNF_DEVICE_DETACHED   0x000B
;|*** 
;|*** #endif  /* !INCL_SAADEFS */
;|*** 
;|*** APIRET  APIENTRY        DosOpen(PSZ pszFileName, PHFILE phf, PULONG pulAction, ULONG cbFile, ULONG ulAttribute, ULONG fsOpenFlags, ULONG fsOpenMode, PEAOP2 peaop2 );
;|*** APIRET  APIENTRY        DosProtectOpen(PSZ pszFileName, PHFILE phf,
;|***                                        PULONG pulAction, ULONG cbFile,
;|***                                        ULONG ulAttribute, ULONG fsOpenFlags,
;|***                                        ULONG fsOpenMode, PEAOP2 peaop2,
;|***                                        PFHLOCK pfhFileHandleLockID);
;|*** 
;|*** APIRET  APIENTRY        DosClose(HFILE hFile);
;|*** APIRET  APIENTRY        DosProtectClose(HFILE hFile, FHLOCK fhFileHandleLockID);
;|*** 
;|*** APIRET  APIENTRY        DosRead(HFILE hFile, PVOID pBuffer, ULONG cbRead, PULONG pcbActual);
;|*** APIRET  APIENTRY        DosProtectRead(HFILE hFile, PVOID pBuffer,
;|***                                        ULONG cbRead, PULONG pcbActual,
;|***                                        FHLOCK fhFileHandleLockID);
;|*** 
;|*** APIRET  APIENTRY        DosWrite(HFILE hFile, PVOID pBuffer, ULONG cbWrite, PULONG pcbActual);
;|*** APIRET  APIENTRY        DosProtectWrite(HFILE hFile, PVOID pBuffer,
;|***                                         ULONG cbWrite, PULONG pcbActual,
;|***                                         FHLOCK fhFileHandleLockID);
;|*** 
;|*** /* File time and date types */
;|*** 
;|*** typedef struct _FILESTATUS {    /* fsts */
;|***     FDATE  fdateCreation;
;|***     FTIME  ftimeCreation;
;|***     FDATE  fdateLastAccess;
;|***     FTIME  ftimeLastAccess;
;|***     FDATE  fdateLastWrite;
;|***     FTIME  ftimeLastWrite;
;|***     ULONG  cbFile;
;|***     ULONG  cbFileAlloc;
;|***     USHORT attrFile;
;|*** } FILESTATUS;
;|*** typedef FILESTATUS      *PFILESTATUS;
;|*** 
;|*** typedef struct _FILESTATUS2 {   /* fsts2 */
;|***     FDATE  fdateCreation;
;|***     FTIME  ftimeCreation;
;|***     FDATE  fdateLastAccess;
;|***     FTIME  ftimeLastAccess;
;|***     FDATE  fdateLastWrite;
;|***     FTIME  ftimeLastWrite;
;|***     ULONG  cbFile;
;|***     ULONG  cbFileAlloc;
;|***     USHORT attrFile;
;|***     ULONG  cbList;
;|*** } FILESTATUS2;
;|*** typedef FILESTATUS2     *PFILESTATUS2;
;|*** 
;|*** 
;|*** typedef struct _FILESTATUS3 {   /* fsts3 */
;|***     FDATE  fdateCreation;
;|***     FTIME  ftimeCreation;
;|***     FDATE  fdateLastAccess;
;|***     FTIME  ftimeLastAccess;
;|***     FDATE  fdateLastWrite;
;|***     FTIME  ftimeLastWrite;
;|***     ULONG  cbFile;
;|***     ULONG  cbFileAlloc;
;|***     ULONG  attrFile;
;|*** } FILESTATUS3;
;|*** typedef FILESTATUS3     *PFILESTATUS3;
;|*** 
;|*** typedef struct _FILESTATUS4 {    /* fsts4 */
;|***     FDATE  fdateCreation;
;|***     FTIME  ftimeCreation;
;|***     FDATE  fdateLastAccess;
;|***     FTIME  ftimeLastAccess;
;|***     FDATE  fdateLastWrite;
;|***     FTIME  ftimeLastWrite;
;|***     ULONG  cbFile;
;|***     ULONG  cbFileAlloc;
;|***     ULONG  attrFile;
;|***     ULONG  cbList;
;|*** } FILESTATUS4;
;|*** typedef FILESTATUS4     *PFILESTATUS4;
;|*** 
;|*** 
;|*** typedef struct _FSALLOCATE {    /* fsalloc */
;|***     ULONG  idFileSystem;
;|***     ULONG  cSectorUnit;
;|***     ULONG  cUnit;
;|***     ULONG  cUnitAvail;
;|***     USHORT cbSector;
;|*** } FSALLOCATE;
;|*** typedef FSALLOCATE      *PFSALLOCATE;
;|*** 
;|*** typedef SHANDLE HDIR;        /* hdir */
;|*** typedef HDIR    *PHDIR;
;|*** 
;|*** /* XLATOFF */
;|*** #define DosOpen2        DosOpen
;|*** #define DosFindFirst2   DosFindFirst
;|*** #define DosQFHandState  DosQueryFHState
;|*** #define DosProtectQFHandState  DosProtectQueryFHState
;|*** #define DosSetFHandState        DosSetFHState
;|*** #define DosProtectSetFHandState        DosProtectSetFHState
;|*** #define DosQHandType    DosQueryHType
;|*** #define DosQFSAttach    DosQueryFSAttach
;|*** #define DosNewSize      DosSetFileSize
;|*** #define DosProtectNewSize      DosProtectSetFileSize
;|*** #define DosBufReset     DosResetBuffer
;|*** #define DosChgFilePtr   DosSetFilePtr
;|*** #define DosProtectChgFilePtr   DosProtectSetFilePtr
;|*** #define DosMkDir        DosCreateDir
;|*** #define DosMkDir2       DosCreateDir
;|*** #define DosRmDir        DosDeleteDir
;|*** #define DosSelectDisk   DosSetDefaultDisk
;|*** #define DosQCurDisk     DosQueryCurrentDisk
;|*** #define DosChDir        DosSetCurrentDir
;|*** #define DosQCurDir      DosQueryCurrentDir
;|*** #define DosQFSInfo      DosQueryFSInfo
;|*** #define DosQVerify      DosQueryVerify
;|*** #define DosQFileInfo    DosQueryFileInfo
;|*** #define DosProtectQFileInfo    DosProtectQueryFileInfo
;|*** #define DosQPathInfo    DosQueryPathInfo
;|*** /* XLATON */
;|*** 
;|*** APIRET  APIENTRY DosOpenChangeNotify(PCNPATH PathBuf, ULONG LogSize, PHDIR hdir,
;|***                                      ULONG ulReserved);
;|*** APIRET  APIENTRY DosResetChangeNotify(PCNINFO LogBuf, ULONG BufferSize,
;|***                                       PULONG LogCount, HDIR hdir);
;|*** APIRET  APIENTRY DosCloseChangeNotify(HDIR hdir);
;|*** 
;|*** APIRET  APIENTRY        DosDelete(PSZ pszFile);
;|*** 
;|*** APIRET  APIENTRY        DosForceDelete(PSZ pszFile);
;|*** 
;|*** APIRET  APIENTRY        DosDupHandle(HFILE hFile, PHFILE pHfile);
;|*** 
;|*** APIRET  APIENTRY        DosQueryFHState(HFILE hFile, PULONG pMode);
;|*** APIRET  APIENTRY        DosProtectQueryFHState(HFILE hFile, PULONG pMode,
;|***                                                FHLOCK fhFileHandleLockID);
;|*** 
;|*** APIRET  APIENTRY        DosSetFHState(HFILE hFile, ULONG mode);
;|*** APIRET  APIENTRY        DosProtectSetFHState(HFILE hFile, ULONG mode,
;|***                                              FHLOCK fhFileHandleLockID);
;|*** 
;|*** APIRET  APIENTRY        DosQueryHType(HFILE hFile, PULONG pType, PULONG pAttr);
;|*** 
;|*** APIRET  APIENTRY        DosFindFirst(PSZ pszFileSpec, PHDIR phdir, ULONG flAttribute, PVOID pfindbuf, ULONG cbBuf, PULONG pcFileNames, ULONG ulInfoLevel );
;|*** 
;|*** APIRET  APIENTRY        DosFindNext(HDIR hdir, PVOID pfindbuf, ULONG cbfindbuf, PULONG pcFilenames );
;|*** 
;|*** APIRET  APIENTRY        DosFindClose(HDIR hDir);
;|*** 
;|*** APIRET  APIENTRY        DosFSAttach(PSZ pszDevice, PSZ pszFilesystem, PVOID pData, ULONG cbData, ULONG flag);
;|*** 
;|*** APIRET  APIENTRY        DosQueryFSAttach(PSZ pszDeviceName, ULONG ulOrdinal, ULONG ulFSAInfoLevel, PFSQBUFFER2 pfsqb, PULONG pcbBuffLength );
;|*** 
;|*** APIRET  APIENTRY        DosFSCtl(PVOID pData, ULONG cbData, PULONG pcbData, PVOID pParms, ULONG cbParms, PULONG pcbParms, ULONG function, PSZ pszRoute, HFILE hFile, ULONG method);
;|*** 
;|*** APIRET  APIENTRY        DosSetFileSize(HFILE hFile, ULONG cbSize);
;|*** APIRET  APIENTRY        DosProtectSetFileSize(HFILE hFile, ULONG cbSize,
;|***                                               FHLOCK fhFileHandleLockID);
;|*** 
;|*** APIRET  APIENTRY        DosResetBuffer(HFILE hFile);
;|*** 
;|*** APIRET  APIENTRY        DosSetFilePtr(HFILE hFile, LONG ib, ULONG method, PULONG ibActual);
;|*** APIRET  APIENTRY        DosProtectSetFilePtr(HFILE hFile, LONG ib,
;|***                                              ULONG method, PULONG ibActual,
;|***                                              FHLOCK fhFileHandleLockID);
;|*** 
;|*** APIRET  APIENTRY        DosMove(PSZ pszOld, PSZ pszNew);
;|*** 
;|*** APIRET  APIENTRY        DosCopy(PSZ pszOld, PSZ pszNew, ULONG option);
;|*** 
;|*** APIRET  APIENTRY        DosEditName(ULONG metalevel, PSZ pszSource, PSZ pszEdit, PBYTE pszTarget, ULONG cbTarget);
;|*** 
;|*** APIRET  APIENTRY        DosCreateDir(PSZ pszDirName, PEAOP2 peaop2 );
;|*** 
;|*** APIRET  APIENTRY        DosDeleteDir(PSZ pszDir);
;|*** 
;|*** APIRET  APIENTRY        DosSetDefaultDisk(ULONG disknum);
;|*** 
;|*** APIRET  APIENTRY        DosQueryCurrentDisk(PULONG pdisknum, PULONG plogical);
;|*** 
;|*** APIRET  APIENTRY        DosSetCurrentDir(PSZ pszDir);
;|*** 
;|*** APIRET  APIENTRY        DosQueryCurrentDir(ULONG disknum, PBYTE pBuf, PULONG pcbBuf);
;|*** 
;|*** APIRET  APIENTRY        DosQueryFSInfo(ULONG disknum, ULONG infolevel, PVOID pBuf, ULONG cbBuf);
;|*** 
;|*** APIRET  APIENTRY        DosSetFSInfo(ULONG disknum, ULONG infolevel, PVOID pBuf, ULONG cbBuf);
;|*** 
;|*** APIRET  APIENTRY        DosQueryVerify(PBOOL32 pBool);
;|*** 
;|*** APIRET  APIENTRY        DosSetVerify(BOOL32);
;|*** 
;|*** APIRET  APIENTRY        DosSetMaxFH(ULONG cFH);
;|*** 
;|*** APIRET  APIENTRY        DosSetRelMaxFH(PLONG pcbReqCount, PULONG pcbCurMaxFH);
;|*** 
;|*** APIRET  APIENTRY        DosQueryFileInfo(HFILE hf, ULONG ulInfoLevel, PVOID pInfo,  ULONG cbInfoBuf );
;|*** APIRET  APIENTRY        DosProtectQueryFileInfo(HFILE hf, ULONG ulInfoLevel,
;|***                                                 PVOID pInfo, ULONG cbInfoBuf,
;|***                                                 FHLOCK fhFileHandleLockID);
;|*** 
;|*** APIRET  APIENTRY        DosSetFileInfo(HFILE hf, ULONG ulInfoLevel, PVOID pInfoBuf, ULONG cbInfoBuf );
;|*** APIRET  APIENTRY        DosProtectSetFileInfo(HFILE hf, ULONG ulInfoLevel,
;|***                                               PVOID pInfoBuf, ULONG cbInfoBuf,
;|***                                               FHLOCK fhFileHandleLockID);
;|*** 
;|*** APIRET  APIENTRY        DosQueryPathInfo(PSZ pszPathName, ULONG ulInfoLevel, PVOID pInfoBuf, ULONG cbInfoBuf );
;|*** 
;|*** APIRET  APIENTRY        DosSetPathInfo(PSZ pszPathName, ULONG ulInfoLevel, PVOID pInfoBuf, ULONG cbInfoBuf, ULONG flOptions );
;|*** 
;|*** /* defines for DosSetPathInfo -pathinfo flag */
;|*** #define DSPI_WRTTHRU    0x10    /* write through */
;|*** 
;|*** APIRET  APIENTRY        DosShutdown(ULONG ulReserved);
;|*** 
;|*** APIRET  APIENTRY        DosEnumAttribute(ULONG ulRefType, PVOID pvFile, ULONG ulEntry, PVOID pvBuf, ULONG cbBuf, PULONG pulCount, ULONG ulInfoLevel );
;|*** 
;|*** APIRET  APIENTRY        DosProtectEnumAttribute(ULONG ulRefType, PVOID pvFile, ULONG ulEntry, PVOID pvBuf, ULONG cbBuf, PULONG pulCount, ULONG ulInfoLevel, FHLOCK fhFileHandleLockID );
;|*** 
;|*** /* XLATOFF */
;|*** #pragma pack(1)
;|*** /* XLATON */
;|*** 
;|*** typedef struct _DENA1 { /* _dena1 level 1 info returned from DosEnumAttribute */
;|***     UCHAR       reserved;       /* 0 */
;|***     UCHAR       cbName;         /* length of name exculding NULL */
;|***     USHORT      cbValue;        /* length of value */
;|***     UCHAR       szName[1];      /* variable length asciiz name */
;|*** } DENA1;
;|*** typedef DENA1 FAR *PDENA1;
;|*** 
;|*** /* XLATOFF */
;|*** #pragma pack()
;|*** /* XLATON */
;|*** 
;|*** typedef FEA2 DENA2;
;|*** typedef PFEA2 PDENA2;
;|*** 
;|*** /* Infolevels for DosEnumAttribute  */
;|*** #define ENUMEA_LEVEL_NO_VALUE   1L      /* FEA without value */
;|*** /* Reference types for DosEnumAttribute */
;|*** #define ENUMEA_REFTYPE_FHANDLE  0       /* file handle */
;|*** #define ENUMEA_REFTYPE_PATH     1       /* path name */
;|*** #define ENUMEA_REFTYPE_MAX      ENUMEA_REFTYPE_PATH
;|*** 
;|*** #endif /* common INCL_DOSFILEMGR */
;|*** 
;|*** #if (defined(INCL_DOSMEMMGR) || !defined(INCL_NOCOMMON))
;|*** /*** Memory management */
;|*** 
;|*** APIRET  APIENTRY        DosAllocMem(PPVOID ppb, ULONG cb, ULONG flag);
;|*** 
;|*** APIRET  APIENTRY        DosFreeMem(PVOID pb);
;|*** 
;|*** APIRET  APIENTRY        DosSetMem(PVOID pb, ULONG cb, ULONG flag);
;|*** 
;|*** APIRET  APIENTRY        DosGiveSharedMem(PVOID pb, PID pid, ULONG flag);
;|*** 
;|*** APIRET  APIENTRY        DosGetSharedMem(PVOID pb, ULONG flag);
;|*** 
;|*** APIRET  APIENTRY        DosGetNamedSharedMem(PPVOID ppb, PSZ pszName, ULONG flag);
;|*** 
;|*** APIRET  APIENTRY        DosAllocSharedMem(PPVOID ppb, PSZ pszName, ULONG cb, ULONG flag);
;|*** 
;|*** APIRET  APIENTRY        DosQueryMem(PVOID pb, PULONG pcb, PULONG pFlag);
;|*** 
;|*** #define DosSubAlloc     DosSubAllocMem
;|*** #define DOSSUBALLOC     DosSubAllocMem
;|*** APIRET  APIENTRY        DosSubAllocMem(PVOID pbBase, PPVOID ppb, ULONG cb);
;|*** 
;|*** #define DosSubFree      DosSubFreeMem
;|*** #define DOSSUBFREE      DosSubFreeMem
;|*** APIRET  APIENTRY        DosSubFreeMem(PVOID pbBase, PVOID pb, ULONG cb);
;|*** 
;|*** #define DosSubSet       DosSubSetMem
;|*** #define DOSSUBSET       DosSubSetMem
;|*** APIRET  APIENTRY        DosSubSetMem(PVOID pbBase, ULONG flag, ULONG cb);
;|*** 
;|*** #define DosSubUnset     DosSubUnsetMem
;|*** #define DOSSUBUNSET     DosSubUnsetMem
;|*** APIRET  APIENTRY        DosSubUnsetMem(PVOID pbBase);
;|*** 
;|*** #include <bsememf.h>    /* get flags for API                            */
;|*** 
;|*** #endif /* INCL_DOSMEMMGR */
;|*** 
;|*** #if (defined(INCL_DOSSEMAPHORES) || !defined(INCL_NOCOMMON))
;|*** 
;|*** /*
;|***  *     32-bit Semaphore Support
;|***  */
;|*** 
;|*** /* Semaphore Attributes */
;|*** 
;|*** #define DC_SEM_SHARED   0x01      /* DosCreateMutex, DosCreateEvent, and     */
;|***                                   /*   DosCreateMuxWait use it to indicate   */
;|***                                   /*   whether the semaphore is shared or    */
;|***                                   /*   private when the PSZ is null          */
;|*** #define DCMW_WAIT_ANY   0x02      /* DosCreateMuxWait option for wait on any */
;|***                                   /*   event/mutex to occur                  */
;|*** #define DCMW_WAIT_ALL   0x04      /* DosCreateMuxWait option for wait on all */
;|***                                   /*   events/mutexs to occur                */
;|*** 
;|*** /* PMxxxxxx */
;|*** #define DC_SEM_PM       0x40      /* PM Shared Event Semaphore.              */
;|*** 
;|*** #define PM_EVENT_POSTED 3000      /* PM Shared Event Posted                  */
;|*** 
;|*** #define SEM_INDEFINITE_WAIT      0xFFFFFFFF
;|*** #define SEM_IMMEDIATE_RETURN     0L
;|*** 
;|*** typedef struct _PSEMRECORD {    /* psr */
;|***     HSEM        hsemCur;
;|***     ULONG       ulUser;
;|*** } SEMRECORD;
;|*** typedef SEMRECORD       *PSEMRECORD;
;|*** 
;|*** #endif /* common INCL_DOSSEMAPHORES */
;|*** 
;|*** #ifdef INCL_DOSSEMAPHORES
;|*** 
;|*** typedef  ULONG    HEV;             /* hev */
;|*** typedef  HEV      *PHEV;
;|*** typedef  ULONG    HMTX;            /* hmtx */
;|*** typedef  HMTX     *PHMTX;
;|*** typedef  ULONG    HMUX;            /* hmux */
;|*** typedef  HMUX     *PHMUX;
;|*** 
;|*** APIRET  APIENTRY        DosCreateEventSem (PSZ pszName, PHEV phev, ULONG flAttr, BOOL32 fState);
;|*** APIRET  APIENTRY        DosOpenEventSem (PSZ pszName, PHEV phev);
;|*** APIRET  APIENTRY        DosCloseEventSem (HEV hev);
;|*** APIRET  APIENTRY        DosResetEventSem (HEV hev, PULONG pulPostCt);
;|*** APIRET  APIENTRY        DosPostEventSem (HEV hev);
;|*** APIRET  APIENTRY        DosWaitEventSem (HEV hev, ULONG ulTimeout);
;|*** APIRET  APIENTRY        DosQueryEventSem (HEV hev, PULONG pulPostCt);
;|*** 
;|*** APIRET  APIENTRY        DosCreateMutexSem (PSZ pszName, PHMTX phmtx, ULONG flAttr, BOOL32 fState);
;|*** APIRET  APIENTRY        DosOpenMutexSem (PSZ pszName, PHMTX phmtx);
;|*** APIRET  APIENTRY        DosCloseMutexSem (HMTX hmtx);
;|*** APIRET  APIENTRY        DosRequestMutexSem (HMTX hmtx, ULONG ulTimeout);
;|*** APIRET  APIENTRY        DosReleaseMutexSem (HMTX hmtx);
;|*** APIRET  APIENTRY        DosQueryMutexSem (HMTX hmtx, PPID ppid, PTID ptid, PULONG pulCount);
;|*** 
;|*** APIRET  APIENTRY        DosCreateMuxWaitSem (PSZ pszName, PHMUX phmux, ULONG cSemRec, PSEMRECORD pSemRec, ULONG flAttr);
;|*** APIRET  APIENTRY        DosOpenMuxWaitSem (PSZ pszName, PHMUX phmux);
;|*** APIRET  APIENTRY        DosCloseMuxWaitSem (HMUX hmux);
;|*** APIRET  APIENTRY        DosWaitMuxWaitSem (HMUX hmux, ULONG ulTimeout, PULONG pulUser);
;|*** APIRET  APIENTRY        DosAddMuxWaitSem (HMUX hmux, PSEMRECORD pSemRec);
;|*** APIRET  APIENTRY        DosDeleteMuxWaitSem (HMUX hmux, HSEM hSem);
;|*** APIRET  APIENTRY        DosQueryMuxWaitSem (HMUX hmux, PULONG pcSemRec, PSEMRECORD pSemRec, PULONG pflAttr);
;|*** 
;|*** APIRET  APIENTRY        DosPMPostEventSem (HEV hev);
;|*** APIRET  APIENTRY        DosPMWaitEventSem (HEV pmhev, HEV hev, ULONG ulTimeout);
;|*** APIRET  APIENTRY        DosPMRequestMutexSem (HEV hev, HMTX hmtx, ULONG ulTimeout);
;|*** APIRET  APIENTRY        DosPMWaitMuxWaitSem (HEV hev, HMUX hmux, ULONG ulTimeout, PULONG pulUser);
;|*** 
;|*** #endif /* INCL_DOSSEMAPHORES */
;|*** 
;|*** #if (defined(INCL_DOSDATETIME) || !defined(INCL_NOCOMMON))
;|*** 
;|*** /*** Time support */
;|*** 
;|*** typedef struct _DATETIME {    /* date */
;|***     UCHAR   hours;
;|***     UCHAR   minutes;
;|***     UCHAR   seconds;
;|***     UCHAR   hundredths;
;|***     UCHAR   day;
;|***     UCHAR   month;
;|***     USHORT  year;
;|***     SHORT   timezone;
;|***     UCHAR   weekday;
;|*** } DATETIME;
;|*** typedef DATETIME        *PDATETIME;
;|*** 
;|*** APIRET  APIENTRY        DosGetDateTime(PDATETIME pdt);
;|*** 
;|*** APIRET  APIENTRY        DosSetDateTime(PDATETIME pdt);
;|*** 
;|*** #endif /* common INCL_DOSDATETIME */
;|*** 
;|*** #ifdef INCL_DOSDATETIME
;|*** 
;|*** /* XLATOFF */
;|*** #define DosTimerAsync   DosAsyncTimer
;|*** #define DosTimerStart   DosStartTimer
;|*** #define DosTimerStop    DosStopTimer
;|*** /* XLATON */
;|*** 
;|*** typedef SHANDLE HTIMER;
;|*** typedef HTIMER  *PHTIMER;
;|*** 
;|*** APIRET  APIENTRY        DosAsyncTimer(ULONG msec, HSEM hsem, PHTIMER phtimer);
;|*** 
;|*** APIRET  APIENTRY        DosStartTimer(ULONG msec, HSEM hsem, PHTIMER phtimer);
;|*** 
;|*** APIRET  APIENTRY        DosStopTimer(HTIMER htimer);
;|*** 
;|*** #endif /* INCL_DOSDATETIME */
;|*** 
;|*** 
;|*** /*** Module manager */
;|*** 
;|*** #ifdef INCL_DOSMODULEMGR
;|*** 
;|*** /* XLATOFF */
;|*** #define DosGetProcAddr          DosQueryProcAddr
;|*** #define DosGetModHandle         DosQueryModuleHandle
;|*** #define DosGetModName           DosQueryModuleName
;|*** /* XLATON */
;|*** 
;|*** APIRET  APIENTRY  DosLoadModule(PSZ pszName, ULONG cbName, PSZ pszModname, PHMODULE phmod);
;|*** 
;|*** APIRET  APIENTRY  DosFreeModule(HMODULE hmod);
;|*** 
;|*** APIRET  APIENTRY  DosQueryProcAddr(HMODULE hmod, ULONG ordinal, PSZ pszName,PFN* ppfn);
;|*** 
;|*** APIRET  APIENTRY  DosQueryModuleHandle(PSZ pszModname, PHMODULE phmod);
;|*** 
;|*** APIRET  APIENTRY  DosQueryModuleName(HMODULE hmod, ULONG cbName, PCHAR pch);
;|*** 
;|*** #define PT_16BIT  0
;|*** #define PT_32BIT  1
;|*** 
;|*** APIRET  APIENTRY  DosQueryProcType(HMODULE hmod, ULONG ordinal, PSZ pszName, PULONG pulproctype);
;|*** 
;|*** APIRET  APIENTRY  DosQueryModFromEIP(HMODULE *phMod, ULONG *pObjNum, ULONG BuffLen, PCHAR pBuff, ULONG *pOffset, ULONG Address);
;|*** 
;|*** #define HW_CFG_MCA              0x00000001
;|*** #define HW_CFG_EISA             0x00000002
;|*** #define HW_CFG_ABIOS_SUPPORTED  0x00000004
;|*** #define HW_CFG_ABIOS_PRESENT    0x00000008
;|*** 
;|*** APIRET  APIENTRY DosQueryABIOSSupport(ULONG reserved);
;|*** 
;|*** #endif /* INCL_DOSMODULEMGR */
;|*** 
;|*** #if (defined(INCL_DOSRESOURCES) || !defined(INCL_NOCOMMON))
;|*** 
;|*** /*** Resource support */
;|*** 
;|*** /* Predefined resource types */
;|*** 
;|*** #define RT_POINTER      1   /* mouse pointer shape */
;|*** #define RT_BITMAP       2   /* bitmap */
;|*** #define RT_MENU         3   /* menu template */
;|*** #define RT_DIALOG       4   /* dialog template */
;|*** #define RT_STRING       5   /* string tables */
;|*** #define RT_FONTDIR      6   /* font directory */
;|*** #define RT_FONT         7   /* font */
;|*** #define RT_ACCELTABLE   8   /* accelerator tables */
;|*** #define RT_RCDATA       9   /* binary data */
;|*** #define RT_MESSAGE      10  /* error msg     tables */
;|*** #define RT_DLGINCLUDE   11  /* dialog include file name */
;|*** #define RT_VKEYTBL      12  /* key to vkey tables */
;|*** #define RT_KEYTBL       13  /* key to UGL tables */
;|*** #define RT_CHARTBL      14  /* glyph to character tables */
;|*** #define RT_DISPLAYINFO  15  /* screen display information */
;|*** 
;|*** #define RT_FKASHORT     16  /* function key area short form */
;|*** #define RT_FKALONG      17  /* function key area long form */
;|*** 
;|*** #define RT_HELPTABLE    18  /* Help table for Cary Help manager */
;|*** #define RT_HELPSUBTABLE 19  /* Help subtable for Cary Help manager */
;|*** 
;|*** #define RT_FDDIR        20  /* DBCS uniq/font driver directory */
;|*** #define RT_FD           21  /* DBCS uniq/font driver */
;|*** 
;|*** #define RT_MAX          22  /* 1st unused Resource Type */
;|*** 
;|*** 
;|*** #define RF_ORDINALID    0x80000000L     /* ordinal id flag in resource table */
;|*** 
;|*** #endif /* common INCL_DOSRESOURCES */
;|*** 
;|*** #ifdef INCL_DOSRESOURCES
;|*** 
;|*** /* XLATOFF */
;|*** #define DosGetResource2 DosGetResource
;|*** /* XLATON */
;|*** 
;|*** APIRET  APIENTRY        DosGetResource(HMODULE hmod, ULONG idType, ULONG idName, PPVOID ppb);
;|*** 
;|*** APIRET  APIENTRY        DosFreeResource(PVOID pb);
;|*** 
;|*** APIRET  APIENTRY        DosQueryResourceSize(HMODULE hmod, ULONG idt, ULONG idn, PULONG pulsize);
;|*** 
;|*** #endif /* INCL_DOSRESOURCES */
;|*** 
;|*** 
;|*** /*** NLS Support */
;|*** 
;|*** #ifdef INCL_DOSNLS
;|*** 
;|*** typedef struct _COUNTRYCODE { /* ctryc */
;|***     ULONG       country;
;|***     ULONG       codepage;
;|*** } COUNTRYCODE;
;|*** typedef COUNTRYCODE     *PCOUNTRYCODE;
;|*** 
;|*** typedef struct _COUNTRYINFO { /* ctryi */
;|***     ULONG       country;
;|***     ULONG       codepage;
;|***     ULONG       fsDateFmt;
;|***     CHAR        szCurrency[5];
;|***     CHAR        szThousandsSeparator[2];
;|***     CHAR        szDecimal[2];
;|***     CHAR        szDateSeparator[2];
;|***     CHAR        szTimeSeparator[2];
;|***     UCHAR       fsCurrencyFmt;
;|***     UCHAR       cDecimalPlace;
;|***     UCHAR       fsTimeFmt;
;|***     USHORT      abReserved1[2];
;|***     CHAR        szDataSeparator[2];
;|***     USHORT      abReserved2[5];
;|*** } COUNTRYINFO;
;|*** typedef COUNTRYINFO     *PCOUNTRYINFO;
;|*** 
;|*** /* XLATOFF */
;|*** #define DosGetCtryInfo  DosQueryCtryInfo
;|*** #define DosGetDBCSEv    DosQueryDBCSEnv
;|*** #define DosCaseMap      DosMapCase
;|*** #define DosGetCollate   DosQueryCollate
;|*** #define DosGetCp        DosQueryCp
;|*** #define DosSetProcCp    DosSetProcessCp
;|*** /* XLATON */
;|*** 
;|*** APIRET  APIENTRY        DosQueryCtryInfo(ULONG cb, PCOUNTRYCODE pcc, PCOUNTRYINFO pci, PULONG pcbActual);
;|*** 
;|*** APIRET  APIENTRY        DosQueryDBCSEnv(ULONG cb, PCOUNTRYCODE pcc, PCHAR pBuf);
;|*** 
;|*** APIRET  APIENTRY        DosMapCase(ULONG cb, PCOUNTRYCODE pcc, PCHAR pch);
;|*** 
;|*** APIRET  APIENTRY        DosQueryCollate(ULONG cb, PCOUNTRYCODE pcc, PCHAR pch, PULONG pcch);
;|*** 
;|*** APIRET  APIENTRY        DosQueryCp(ULONG cb, PULONG arCP, PULONG pcCP);
;|*** 
;|*** APIRET  APIENTRY        DosSetProcessCp(ULONG cp);
;|*** 
;|*** #endif /* INCL_DOSNLS */
;|*** 
;|*** 
;|*** /*** Signal support */
;|*** 
;|*** #ifdef INCL_DOSEXCEPTIONS
;|*** 
;|*** /* DosSetSigExceptionFocus codes */
;|*** 
;|*** #define SIG_UNSETFOCUS 0
;|*** #define SIG_SETFOCUS 1
;|*** 
;|*** #include <bsexcpt.h>
;|*** 
;|*** APIRET  APIENTRY        DosSetExceptionHandler(PEXCEPTIONREGISTRATIONRECORD pERegRec);
;|*** 
;|*** APIRET  APIENTRY        DosUnsetExceptionHandler(PEXCEPTIONREGISTRATIONRECORD pERegRec);
;|*** 
;|*** APIRET  APIENTRY        DosRaiseException(PEXCEPTIONREPORTRECORD pexcept);
;|*** 
;|*** APIRET  APIENTRY        DosSendSignalException(PID pid, ULONG exception);
;|*** 
;|*** APIRET  APIENTRY        DosUnwindException(PEXCEPTIONREGISTRATIONRECORD phandler, PVOID pTargetIP, PEXCEPTIONREPORTRECORD pERepRec);
;|*** 
;|*** APIRET  APIENTRY        DosSetSignalExceptionFocus(BOOL32 flag, PULONG pulTimes);
;|*** 
;|*** APIRET  APIENTRY        DosEnterMustComplete(PULONG pulNesting);
;|*** 
;|*** APIRET  APIENTRY        DosExitMustComplete(PULONG pulNesting);
;|*** 
;|*** APIRET  APIENTRY        DosAcknowledgeSignalException(ULONG ulSignalNum);
;|*** 
;|*** #endif /* INCL_DOSEXCEPTIONS */
;|*** 
;|*** 
;|*** /*** Pipe and queue support */
;|*** 
;|*** #ifdef INCL_DOSQUEUES
;|*** #if (defined(INCL_DOSFILEMGR) || !defined(INCL_NOCOMMON))
;|*** 
;|*** typedef SHANDLE HQUEUE;  /* hq */
;|*** typedef HQUEUE  *PHQUEUE;
;|*** typedef struct _REQUESTDATA {   /* reqqdata */
;|***     PID         pid;
;|***     ULONG       ulData;
;|*** } REQUESTDATA;
;|*** typedef REQUESTDATA     *PREQUESTDATA;
;|*** 
;|*** #define QUE_FIFO              0L
;|*** #define QUE_LIFO              1L
;|*** #define QUE_PRIORITY          2L
;|*** #define QUE_NOCONVERT_ADDRESS 0L
;|*** #define QUE_CONVERT_ADDRESS   4L
;|*** 
;|*** /* XLATOFF */
;|*** #define DosMakePipe     DosCreatePipe
;|*** /* XLATON */
;|*** 
;|*** APIRET  APIENTRY        DosCreatePipe(PHFILE phfRead, PHFILE phfWrite, ULONG cb);
;|*** 
;|*** APIRET  APIENTRY        DosCloseQueue(HQUEUE hq);
;|*** 
;|*** APIRET  APIENTRY        DosCreateQueue(PHQUEUE phq, ULONG priority, PSZ pszName);
;|*** 
;|*** APIRET  APIENTRY        DosOpenQueue(PPID ppid, PHQUEUE phq, PSZ pszName);
;|*** 
;|*** APIRET  APIENTRY        DosPeekQueue(HQUEUE hq, PREQUESTDATA pRequest, PULONG pcbData, PPVOID ppbuf, PULONG element, BOOL32 nowait, PBYTE ppriority, HEV hsem);
;|*** 
;|*** APIRET  APIENTRY        DosPurgeQueue(HQUEUE hq);
;|*** 
;|*** APIRET  APIENTRY        DosQueryQueue(HQUEUE hq, PULONG pcbEntries);
;|*** 
;|*** APIRET  APIENTRY        DosReadQueue(HQUEUE hq, PREQUESTDATA pRequest, PULONG pcbData, PPVOID ppbuf, ULONG element, BOOL32 wait, PBYTE ppriority, HEV hsem);
;|*** 
;|*** APIRET  APIENTRY        DosWriteQueue(HQUEUE hq, ULONG request, ULONG cbData, PVOID pbData, ULONG priority);
;|*** 
;|*** #else /* INCL_DOSFILEMGR || !INCL_NOCOMMON */
;|*** #error PHFILE not defined - define INCL_DOSFILEMGR or undefine INCL_NOCOMMON
;|*** #endif /* INCL_DOSFILEMGR || !INCL_NOCOMMON */
;|*** #endif /* INCL_DOSQUEUES */
;|*** 
;|*** #ifdef INCL_DOSMISC
;|*** 
;|*** /* definitions for DosSearchPath control word */
;|*** #define DSP_IMPLIEDCUR          1 /* current dir will be searched first */
;|*** #define DSP_PATHREF             2 /* from env.variable */
;|*** #define DSP_IGNORENETERR        4 /* ignore net errs & continue search */
;|*** 
;|*** /* indices for DosQuerySysInfo */
;|*** #define QSV_MAX_PATH_LENGTH     1
;|*** #define Q_MAX_PATH_LENGTH       QSV_MAX_PATH_LENGTH
;|*** #define QSV_MAX_TEXT_SESSIONS   2
;|*** #define QSV_MAX_PM_SESSIONS     3
;|*** #define QSV_MAX_VDM_SESSIONS    4
;|*** #define QSV_BOOT_DRIVE          5       /* 1=A, 2=B, etc. */
;|*** #define QSV_DYN_PRI_VARIATION   6       /* 0=Absolute, 1=Dynamic */
;|*** #define QSV_MAX_WAIT            7       /* seconds */
;|*** #define QSV_MIN_SLICE           8       /* milli seconds */
;|*** #define QSV_MAX_SLICE           9       /* milli seconds */
;|*** #define QSV_PAGE_SIZE           10
;|*** #define QSV_VERSION_MAJOR       11
;|*** #define QSV_VERSION_MINOR       12
;|*** #define QSV_VERSION_REVISION    13      /* Revision letter */
;|*** #define QSV_MS_COUNT            14      /* Free running millisecond counter */
;|*** #define QSV_TIME_LOW            15      /* Low dword of time in seconds */
;|*** #define QSV_TIME_HIGH           16      /* High dword of time in seconds */
;|*** #define QSV_TOTPHYSMEM          17      /* Physical memory on system */
;|*** #define QSV_TOTRESMEM           18      /* Resident memory on system */
;|*** #define QSV_TOTAVAILMEM         19      /* Available memory for all processes */
;|*** #define QSV_MAXPRMEM            20      /* Avail private mem for calling proc */
;|*** #define QSV_MAXSHMEM            21      /* Avail shared mem for calling proc */
;|*** #define QSV_TIMER_INTERVAL      22      /* Timer interval in tenths of ms */
;|*** #define QSV_MAX_COMP_LENGTH     23      /* max len of one component in a name */
;|*** #define QSV_FGND_SG_ID          24      /* Foreground Screen Group ID 26215   */
;|*** #define QSV_FGND_PID            25      /* Foreground Process ID      26215   */
;|*** #define QSV_MAX                 QSV_MAX_COMP_LENGTH
;|*** 
;|*** /* definitions for DosError - combine with | */
;|*** #define FERR_DISABLEHARDERR     0x00000000L     /* disable hard error popups */
;|*** #define FERR_ENABLEHARDERR      0x00000001L     /* enable hard error popups */
;|*** #define FERR_ENABLEEXCEPTION    0x00000000L     /* enable exception popups */
;|*** #define FERR_DISABLEEXCEPTION   0x00000002L     /* disable exception popups */
;|*** 
;|*** /* definitions for DosDumpProcess */
;|*** #define DDP_DISABLEPROCDUMP     0x00000000L     /* disable process dumps */
;|*** #define DDP_ENABLEPROCDUMP      0x00000001L     /* enable process dumps */
;|*** #define DDP_PERFORMPROCDUMP     0x00000002L     /* perform process dump */
;|*** 
;|*** /* definitions for DosSuppressPopUps */
;|*** #define SPU_DISABLESUPPRESSION  0x00000000L     /* disable popup suppression */
;|*** #define SPU_ENABLESUPPRESSION   0x00000001L     /* enable popup suppression */
;|*** 
;|*** /* definitions for DosQueryRASInfo Index */
;|*** #define SIS_MMIOADDR            0
;|*** #define SIS_MEC_TABLE           1
;|*** #define SIS_SYS_LOG             2
;|*** 
;|*** /* definitions for DosQueryExtLIBPATH and DosSetExtLIBPATH flags parameter */
;|*** #define BEGIN_LIBPATH   1
;|*** #define END_LIBPATH     2
;|*** 
;|*** /* XLATOFF */
;|*** #define DosInsMessage   DosInsertMessage
;|*** #define DosQSysInfo     DosQuerySysInfo
;|*** /* XLATON */
;|*** 
;|*** APIRET  APIENTRY        DosError(ULONG error);
;|*** 
;|*** APIRET  APIENTRY        DosGetMessage(PCHAR* pTable, ULONG cTable, PCHAR pBuf, ULONG cbBuf, ULONG msgnumber, PSZ pszFile, PULONG pcbMsg);
;|*** 
;|*** APIRET  APIENTRY        DosErrClass(ULONG code, PULONG pClass, PULONG pAction, PULONG pLocus);
;|*** 
;|*** APIRET  APIENTRY        DosInsertMessage(PCHAR* pTable, ULONG cTable, PSZ pszMsg, ULONG cbMsg, PCHAR pBuf, ULONG cbBuf, PULONG pcbMsg);
;|*** 
;|*** APIRET  APIENTRY        DosPutMessage(HFILE hfile, ULONG cbMsg, PCHAR pBuf);
;|*** 
;|*** APIRET  APIENTRY        DosQuerySysInfo(ULONG iStart, ULONG iLast, PVOID pBuf, ULONG cbBuf);
;|*** 
;|*** APIRET  APIENTRY        DosScanEnv(PSZ pszName, PSZ *ppszValue);
;|*** 
;|*** APIRET  APIENTRY        DosSearchPath(ULONG flag, PSZ pszPathOrName, PSZ pszFilename, PBYTE pBuf, ULONG cbBuf);
;|*** 
;|*** APIRET  APIENTRY        DosQueryMessageCP(PCHAR pb, ULONG cb, PSZ pszFilename, PULONG cbBuf);
;|*** 
;|*** APIRET  APIENTRY        DosQueryRASInfo(ULONG Index, PPVOID Addr);
;|*** 
;|*** APIRET  APIENTRY        DosForceSystemDump(ULONG reserved);
;|*** 
;|*** APIRET  APIENTRY        DosDumpProcess(ULONG Flag, ULONG Drive, PID Pid);
;|*** 
;|*** APIRET  APIENTRY        DosSuppressPopUps(ULONG Flag, ULONG Drive);
;|*** 
;|*** APIRET  APIENTRY        DosSetExtLIBPATH( PSZ pszExtLIBPATH, ULONG flags);
;|*** 
;|*** APIRET  APIENTRY        DosQueryExtLIBPATH( PSZ pszExtLIBPATH, ULONG flags);
;|*** 
;|*** APIRET  APIENTRY        DosVerifyPidTid(PID Pid, TID Tid);   /* 88344 */
;|*** 
;|*** #endif /* INCL_DOSMISC */
;|*** 
;|*** 
;|*** /*** Session manager support */
;|*** 
;|*** #ifdef INCL_DOSSESMGR
;|*** 
;|*** typedef struct _STARTDATA {   /* stdata */
;|***     USHORT  Length;
;|***     USHORT  Related;
;|***     USHORT  FgBg;
;|***     USHORT  TraceOpt;
;|***     PSZ     PgmTitle;
;|***     PSZ     PgmName;
;|***     PBYTE   PgmInputs;
;|***     PBYTE   TermQ;
;|***     PBYTE   Environment;
;|***     USHORT  InheritOpt;
;|***     USHORT  SessionType;
;|***     PSZ     IconFile;
;|***     ULONG   PgmHandle;
;|***     USHORT  PgmControl;
;|***     USHORT  InitXPos;
;|***     USHORT  InitYPos;
;|***     USHORT  InitXSize;
;|***     USHORT  InitYSize;
;|***     USHORT  Reserved;
;|***     PSZ     ObjectBuffer;
;|***     ULONG   ObjectBuffLen;
;|*** } STARTDATA;
;|*** typedef STARTDATA       *PSTARTDATA;
;|*** 
;|*** #define SSF_RELATED_INDEPENDENT 0
;|*** #define SSF_RELATED_CHILD       1
;|*** 
;|*** #define SSF_FGBG_FORE           0
;|*** #define SSF_FGBG_BACK           1
;|*** 
;|*** #define SSF_TRACEOPT_NONE       0
;|*** #define SSF_TRACEOPT_TRACE      1
;|*** #define SSF_TRACEOPT_TRACEALL   2
;|*** 
;|*** #define SSF_INHERTOPT_SHELL     0
;|*** #define SSF_INHERTOPT_PARENT    1
;|*** 
;|*** /* note that these types are identical to those in pmshl.h for PROG_* */
;|*** #define SSF_TYPE_DEFAULT        0
;|*** #define SSF_TYPE_FULLSCREEN     1
;|*** #define SSF_TYPE_WINDOWABLEVIO  2
;|*** #define SSF_TYPE_PM             3
;|*** #define SSF_TYPE_VDM            4
;|*** #define SSF_TYPE_GROUP          5
;|*** #define SSF_TYPE_DLL            6
;|*** #define SSF_TYPE_WINDOWEDVDM    7
;|*** #define SSF_TYPE_PDD            8
;|*** #define SSF_TYPE_VDD            9
;|*** 
;|*** /* note that these flags are identical to those in pmshl.h for SHE_* */
;|*** #define SSF_CONTROL_VISIBLE     0x0000
;|*** #define SSF_CONTROL_INVISIBLE   0x0001
;|*** #define SSF_CONTROL_MAXIMIZE    0x0002
;|*** #define SSF_CONTROL_MINIMIZE    0x0004
;|*** #define SSF_CONTROL_NOAUTOCLOSE 0x0008
;|*** #define SSF_CONTROL_SETPOS      0x8000
;|*** 
;|*** typedef struct _STATUSDATA { /* stsdata */
;|***     USHORT Length;
;|***     USHORT SelectInd;
;|***     USHORT BondInd;
;|*** } STATUSDATA;
;|*** typedef STATUSDATA      *PSTATUSDATA;
;|*** 
;|*** /* SelectInd and BondInd paramater values for DosSetSession */
;|*** #define SET_SESSION_UNCHANGED      0
;|*** #define SET_SESSION_SELECTABLE     1
;|*** #define SET_SESSION_NON_SELECTABLE 2
;|*** #define SET_SESSION_BOND           1
;|*** #define SET_SESSION_NO_BOND        2
;|*** 
;|*** /* TargetOption (scope) parameter values for DosStopSession */
;|*** #define STOP_SESSION_SPECIFIED     0
;|*** #define STOP_SESSION_ALL           1
;|*** 
;|*** /* XLATOFF */
;|*** #define DosQAppType     DosQueryAppType
;|*** /* XLATON */
;|*** 
;|*** APIRET  APIENTRY        DosStartSession(PSTARTDATA psd, PULONG pidSession, PPID ppid);
;|*** 
;|*** APIRET  APIENTRY        DosSetSession(ULONG idSession, PSTATUSDATA psd);
;|*** 
;|*** APIRET  APIENTRY        DosSelectSession(ULONG idSession);
;|*** 
;|*** APIRET  APIENTRY        DosStopSession(ULONG scope, ULONG idSession);
;|*** 
;|*** APIRET  APIENTRY        DosQueryAppType(PSZ pszName, PULONG pFlags);
;|*** 
;|*** #endif /* INCL_DOSSESMGR */
;|*** 
;|*** #if (defined(INCL_DOSSESMGR) || defined(INCL_DOSFILEMGR))
;|*** 
;|*** /* AppType returned in by DosQueryAppType in pFlags as follows          */
;|*** #define FAPPTYP_NOTSPEC         0x00000000
;|*** #define FAPPTYP_NOTWINDOWCOMPAT 0x00000001
;|*** #define FAPPTYP_WINDOWCOMPAT    0x00000002
;|*** #define FAPPTYP_WINDOWAPI       0x00000003
;|*** #define FAPPTYP_BOUND           0x00000008
;|*** #define FAPPTYP_DLL             0x00000010
;|*** #define FAPPTYP_DOS             0x00000020
;|*** #define FAPPTYP_PHYSDRV         0x00000040 /* physical device driver       */
;|*** #define FAPPTYP_VIRTDRV         0x00000080 /* virtual device driver        */
;|*** #define FAPPTYP_PROTDLL         0x00000100 /* 'protected memory' dll       */
;|*** #define FAPPTYP_WINDOWSREAL     0x00000200 /*         real mode app        */
;|*** #define FAPPTYP_WINDOWSPROT     0x00000400 /*         protect mode app     */
;|*** #define FAPPTYP_WINDOWSPROT31   0x00001000 /*         3.1 protect mode app */
;|*** #define FAPPTYP_32BIT           0x00004000
;|*** #define FAPPTYP_EXETYPE         FAPPTYP_WINDOWAPI
;|*** 
;|*** #define FAPPTYP_RESERVED        ~(FAPPTYP_WINDOWAPI | FAPPTYP_BOUND | FAPPTYP_DLL | FAPPTYP_DOS | FAPPTYP_PHYSDRV | FAPPTYP_VIRTDRV | FAPPTYP_PROTDLL | FAPPTYP_32BIT)
;|*** 
;|*** #ifdef INCL_DOSFILEMGR
;|*** 
;|*** #define EAT_APPTYP_PMAPI        0x00            /* Uses PM API */
;|*** #define EAT_APPTYP_DOS          0x01            /* DOS APP */
;|*** #define EAT_APPTYP_PMW          0x02            /* Window compatible */
;|*** #define EAT_APPTYP_NOPMW        0x03            /* Not Window compatible */
;|*** #define EAT_APPTYP_EXETYPE      0x03            /* EXE type mask */
;|*** #define EAT_APPTYP_RESERVED     ~(EAT_APPTYP_EXETYPE)
;|*** 
;|*** #endif /* INCL_DOSFILEMGR */
;|*** 
;|*** #endif /* INCL_DOSSESMGR || INCL_DOSFILEMGR */
;|*** 
;|*** 
;|*** /*** Device support */
;|*** 
;|*** #ifdef INCL_DOSDEVICES
;|*** 
;|*** /* XLATOFF */
;|*** #define DosDevIOCtl2    DosDevIOCtl
;|*** /* XLATON */
;|*** 
;|*** APIRET  APIENTRY        DosDevConfig(PVOID pdevinfo, ULONG item);
;|*** #define DEVINFO_PRINTER         0       /* Number of printers attached */
;|*** #define DEVINFO_RS232           1       /* Number of RS232 ports */
;|*** #define DEVINFO_FLOPPY          2       /* Number of diskette drives */
;|*** #define DEVINFO_COPROCESSOR     3       /* Presence of math coprocessor */
;|*** #define DEVINFO_SUBMODEL        4       /* PC Submodel Type */
;|*** #define DEVINFO_MODEL           5       /* PC Model Type */
;|*** #define DEVINFO_ADAPTER         6       /* Primary display adapter type */
;|*** 
;|*** APIRET  APIENTRY        DosDevIOCtl(HFILE hDevice, ULONG category, ULONG function, PVOID pParams, ULONG cbParmLenMax, PULONG pcbParmLen, PVOID pData, ULONG cbDataLenMax, PULONG pcbDataLen);
;|*** 
;|*** 
;|*** APIRET  APIENTRY        DosPhysicalDisk(ULONG function, PVOID pBuf, ULONG cbBuf, PVOID pParams, ULONG cbParams);
;|*** #define INFO_COUNT_PARTITIONABLE_DISKS  1       /* # of partitionable disks */
;|*** #define INFO_GETIOCTLHANDLE             2       /* Obtain handle            */
;|*** #define INFO_FREEIOCTLHANDLE            3       /* Release handle           */
;|*** 
;|*** #endif /* INCL_DOSDEVICES */
;|*** 
;|*** 
;|*** /*** DosNamedPipes API Support */
;|*** 
;|*** #ifdef INCL_DOSNMPIPES
;|*** 
;|*** /*** Data structures used with named pipes ***/
;|*** 
;|*** typedef SHANDLE HPIPE;     /* hp */
;|*** typedef HPIPE   *PHPIPE;
;|*** 
;|*** typedef struct _AVAILDATA {             /* AVAILDATA */
;|***     USHORT      cbpipe;                 /* bytes left in the pipe */
;|***     USHORT      cbmessage;              /* bytes left in the current message */
;|*** } AVAILDATA;
;|*** typedef AVAILDATA FAR *PAVAILDATA;
;|*** 
;|*** typedef struct _PIPEINFO {              /* nmpinf */
;|***     USHORT cbOut;                       /* length of outgoing I/O buffer */
;|***     USHORT cbIn;                        /* length of incoming I/O buffer */
;|***     BYTE   cbMaxInst;                   /* maximum number of instances   */
;|***     BYTE   cbCurInst;                   /* current number of instances   */
;|***     BYTE   cbName;                      /* length of pipe name           */
;|***     CHAR   szName[1];                   /* start of name                 */
;|*** } PIPEINFO;
;|*** typedef PIPEINFO FAR *PPIPEINFO;
;|*** 
;|*** typedef struct _PIPESEMSTATE {  /* nmpsmst */
;|***     BYTE   fStatus;             /* type of record, 0 = EOI, 1 = read ok, */
;|***                                 /* 2 = write ok, 3 = pipe closed         */
;|***     BYTE   fFlag;               /* additional info, 01 = waiting thread  */
;|***     USHORT usKey;               /* user's key value                      */
;|***     USHORT usAvail;             /* available data/space if status = 1/2  */
;|*** } PIPESEMSTATE;
;|*** typedef PIPESEMSTATE FAR *PPIPESEMSTATE;
;|*** 
;|*** #define NP_INDEFINITE_WAIT      -1
;|*** #define NP_DEFAULT_WAIT         0L
;|*** 
;|*** /* DosPeekNmPipe() pipe states */
;|*** 
;|*** #define NP_STATE_DISCONNECTED   0x0001
;|*** #define NP_STATE_LISTENING      0x0002
;|*** #define NP_STATE_CONNECTED      0x0003
;|*** #define NP_STATE_CLOSING        0x0004
;|*** 
;|*** /* DosCreateNPipe open modes */
;|*** 
;|*** #define NP_ACCESS_INBOUND       0x0000
;|*** #define NP_ACCESS_OUTBOUND      0x0001
;|*** #define NP_ACCESS_DUPLEX        0x0002
;|*** #define NP_INHERIT              0x0000
;|*** #define NP_NOINHERIT            0x0080
;|*** #define NP_WRITEBEHIND          0x0000
;|*** #define NP_NOWRITEBEHIND        0x4000
;|*** 
;|*** /* DosCreateNPipe and DosQueryNPHState state */
;|*** 
;|*** #define NP_READMODE_BYTE        0x0000
;|*** #define NP_READMODE_MESSAGE     0x0100
;|*** #define NP_TYPE_BYTE            0x0000
;|*** #define NP_TYPE_MESSAGE         0x0400
;|*** #define NP_END_CLIENT           0x0000
;|*** #define NP_END_SERVER           0x4000
;|*** #define NP_WAIT                 0x0000
;|*** #define NP_NOWAIT               0x8000
;|*** #define NP_UNLIMITED_INSTANCES  0x00FF
;|*** 
;|*** /* XLATOFF */
;|*** #define DosCallNmPipe   DosCallNPipe
;|*** #define DosConnectNmPipe        DosConnectNPipe
;|*** #define DosDisConnectNmPipe     DosDisConnectNPipe
;|*** #define DosMakeNmPipe   DosCreateNPipe
;|*** #define DosPeekNmPipe   DosPeekNPipe
;|*** #define DosQNmPHandState        DosQueryNPHState
;|*** #define DosQNmPipeInfo  DosQueryNPipeInfo
;|*** #define DosQNmPipeSemState      DosQueryNPipeSemState
;|*** #define DosRawReadNmPipe        DosRawReadNPipe
;|*** #define DosRawWriteNmPipe       DosRawWriteNPipe
;|*** #define DosSetNmPHandState      DosSetNPHState
;|*** #define DosSetNmPipeSem DosSetNPipeSem
;|*** #define DosTransactNmPipe       DosTransactNPipe
;|*** #define DosWaitNmPipe   DosWaitNPipe
;|*** /* XLATON */
;|*** 
;|*** APIRET  APIENTRY        DosCallNPipe(PSZ pszName, PVOID pInbuf, ULONG cbIn, PVOID pOutbuf, ULONG cbOut, PULONG pcbActual, ULONG msec);
;|*** 
;|*** APIRET  APIENTRY        DosConnectNPipe(HPIPE hpipe);
;|*** 
;|*** APIRET  APIENTRY        DosDisConnectNPipe(HPIPE hpipe);
;|*** 
;|*** APIRET  APIENTRY        DosCreateNPipe(PSZ pszName, PHPIPE pHpipe, ULONG openmode, ULONG pipemode, ULONG cbInbuf, ULONG cbOutbuf, ULONG msec);
;|*** 
;|*** APIRET  APIENTRY        DosPeekNPipe(HPIPE hpipe, PVOID pBuf, ULONG cbBuf, PULONG pcbActual, PAVAILDATA pAvail, PULONG pState);
;|*** 
;|*** APIRET  APIENTRY        DosQueryNPHState(HPIPE hpipe, PULONG pState);
;|*** 
;|*** APIRET  APIENTRY        DosQueryNPipeInfo(HPIPE hpipe, ULONG infolevel, PVOID pBuf, ULONG cbBuf);
;|*** 
;|*** APIRET  APIENTRY        DosQueryNPipeSemState(HSEM hsem, PPIPESEMSTATE pnpss, ULONG cbBuf);
;|*** 
;|*** APIRET  APIENTRY        DosSetNPHState(HPIPE hpipe, ULONG state);
;|*** 
;|*** APIRET  APIENTRY        DosSetNPipeSem(HPIPE hpipe, HSEM hsem, ULONG key);
;|*** 
;|*** APIRET  APIENTRY        DosTransactNPipe(HPIPE hpipe, PVOID pOutbuf, ULONG cbOut, PVOID pInbuf, ULONG cbIn, PULONG pcbRead);
;|*** 
;|*** APIRET  APIENTRY        DosWaitNPipe(PSZ pszName, ULONG msec);
;|*** 
;|*** /* values in fStatus */
;|*** #define NPSS_EOI                   0     /* End Of Information    */
;|*** #define NPSS_RDATA                 1     /* read data available   */
;|*** #define NPSS_WSPACE                2     /* write space available */
;|*** #define NPSS_CLOSE                 3     /* pipe in CLOSING state */
;|*** 
;|*** /* values in npss_flag */
;|*** #define NPSS_WAIT                  0x01  /* waiting thread on end of pipe */
;|*** 
;|*** /* defined bits in pipe mode */
;|*** #define NP_NBLK                    0x8000 /* non-blocking read/write */
;|*** #define NP_SERVER                  0x4000 /* set if server end       */
;|*** #define NP_WMESG                   0x0400 /* write messages          */
;|*** #define NP_RMESG                   0x0100 /* read as messages        */
;|*** #define NP_ICOUNT                  0x00FF /* instance count field    */
;|*** 
;|*** 
;|*** /*      Named pipes may be in one of several states depending on the actions
;|***  *      that have been taken on it by the server end and client end.  The
;|***  *      following state/action table summarizes the valid state transitions:
;|***  *
;|***  *      Current state           Action                  Next state
;|***  *
;|***  *       <none>             server DosMakeNmPipe        DISCONNECTED
;|***  *       DISCONNECTED       server connect              LISTENING
;|***  *       LISTENING          client open                 CONNECTED
;|***  *       CONNECTED          server disconn              DISCONNECTED
;|***  *       CONNECTED          client close                CLOSING
;|***  *       CLOSING            server disconn              DISCONNECTED
;|***  *       CONNECTED          server close                CLOSING
;|***  *       <any other>        server close                <pipe deallocated>
;|***  *
;|***  *      If a server disconnects his end of the pipe, the client end will enter a
;|***  *      special state in which any future operations (except close) on the file
;|***  *      descriptor associated with the pipe will return an error.
;|***  */
;|*** 
;|*** /*
;|***  *      Values for named pipe state
;|***  */
;|*** 
;|*** #define NP_DISCONNECTED            1    /* after pipe creation or Disconnect */
;|*** #define NP_LISTENING               2    /* after DosNmPipeConnect            */
;|*** #define NP_CONNECTED               3    /* after Client open                 */
;|*** #define NP_CLOSING                 4    /* after Client or Server close      */
;|*** 
;|*** 
;|*** #endif /* INCL_DOSNMPIPES */
;|*** 
;|*** 
;|*** /*** DosProfile API support */
;|*** 
;|*** #ifdef INCL_DOSPROFILE
;|*** 
;|*** /*** Perfview API support */
;|*** 
;|*** APIRET  APIENTRY        DosTmrQueryFreq(PULONG pulTmrFreq);
;|*** APIRET  APIENTRY        DosTmrQueryTime(PQWORD pqwTmrTime);
;|*** APIRET  APIENTRY        DosRegisterPerfCtrs(PBYTE pbDataBlk, PBYTE pbTextBlk, ULONG flFlags);
;|*** 
;|*** /* DosProfile ordinal number */
;|*** 
;|*** #define PROF_ORDINAL     133
;|*** 
;|*** /* DosProfile usType */
;|*** 
;|*** #define PROF_SYSTEM      0
;|*** #define PROF_USER        1
;|*** #define PROF_USEDD       2
;|*** #define PROF_KERNEL      4
;|*** #define PROF_VERBOSE     8
;|*** #define PROF_ENABLE     16
;|*** 
;|*** /* DosProfile usFunc */
;|*** 
;|*** #define PROF_ALLOC       0
;|*** #define PROF_CLEAR       1
;|*** #define PROF_ON          2
;|*** #define PROF_OFF         3
;|*** #define PROF_DUMP        4
;|*** #define PROF_FREE        5
;|*** 
;|*** /* DosProfile tic count granularity (DWORD) */
;|*** 
;|*** #define PROF_SHIFT       2
;|*** 
;|*** /* DosProfile module name string length */
;|*** 
;|*** #define PROF_MOD_NAME_SIZE   10
;|*** 
;|*** /* DosProfile error code for end of data */
;|*** 
;|*** #define PROF_END_OF_DATA     13
;|*** 
;|*** #endif /* INCL_DOSPROFILE */
;|*** 
;|*** 
;|*** /*** Virtual DOS Machine API support */
;|*** 
;|*** #ifdef INCL_DOSMVDM
;|*** 
;|*** typedef LHANDLE   HVDD;     /* hvdd */
;|*** typedef HVDD FAR *PHVDD;    /* phvdd */
;|*** 
;|*** APIRET  APIENTRY DosOpenVDD(PSZ pszVDD, PHVDD phvdd);
;|*** 
;|*** APIRET  APIENTRY DosRequestVDD(HVDD hvdd, SGID sgid, ULONG cmd,
;|***                                ULONG cbInput, PVOID pInput,
;|***                                ULONG cbOutput, PVOID pOutput);
;|*** 
;|*** APIRET  APIENTRY DosCloseVDD(HVDD hvdd);
;|*** 
;|*** APIRET  APIENTRY DosQueryDOSProperty(SGID sgid, PSZ pszName,
;|***                                      ULONG cb, PSZ pch);
;|*** 
;|*** APIRET  APIENTRY DosSetDOSProperty(SGID sgid, PSZ pszName,
;|***                                    ULONG cb, PSZ pch);
;|*** #endif /* INCL_DOSMVDM */
;|*** 
;|*** 
;|*** /* The following #else/#endif corresponds to a #if near the top of this */
;|*** /* file.  The next three lines include the 16-bit version of this file, */
;|*** /* hence these lines MUST be the last lines in this include file.       */
;|*** #else /* not INCL_32 */
;|*** 
;|*** #ifdef INCL_16
;|*** #include <bsedos16.h>
; Line 1841
;|*** 
;|*** #ifdef INCL_DOSDEVIOCTL
;|*** #include <bsedev.h>       /* Structures and constants for DosDevIOCtl */
;|*** #endif /* INCL_DOSDEVIOCTL */
;|*** 
;|*** #ifndef INCL_32
;|*** #include <bsesub.h>       /* VIO/KBD/MOU definitions */
; Line 69
;|*** #endif /* INCL_32 */
;|*** #include <bseerr.h>       /* Base error code definitions */
; Line 71
;|*** #endif /* INCL_NOBASEAPI */
;|*** 
;|*** /* OS/2 Presentation Manager Include File */
;|*** 
;|*** #ifndef INCL_NOPMAPI
;|*** #include <pm.h>
; Line 53
;|*** /*DDK*************************************************************************/
;|*** /*                                                                           */
;|*** /* COPYRIGHT    Copyright (C) 1995 IBM Corporation                           */
;|*** /*                                                                           */
;|*** /*    The following IBM OS/2 WARP source code is provided to you solely for  */
;|*** /*    the purpose of assisting you in your development of OS/2 WARP device   */
;|*** /*    drivers. You may use this code in accordance with the IBM License      */
;|*** /*    Agreement provided in the IBM Device Driver Source Kit for OS/2. This  */
;|*** /*    Copyright statement may not be removed.                                */
;|*** /*                                                                           */
;|*** /*****************************************************************************/
;|*** /****************************** Module Header ******************************\
;|*** *
;|*** * Module Name: PM.H
;|*** *
;|*** * OS/2 Presentation Manager top level include file.
;|*** *
;|*** *
;|*** * ===========================================================================
;|*** *
;|*** * The following symbols are used in this file for conditional sections.
;|*** *
;|*** *   #define:                To include:
;|*** *
;|*** *   INCL_PM                  ALL of OS/2 Presentation Manager
;|*** *   INCL_AVIO                OS/2 Advanced VIO (16-Bit only)
;|*** *   INCL_BITMAPFILEFORMAT    OS/2 Bitmap File Format
;|*** *   INCL_DEV                 OS/2 Device Support
;|*** *   INCL_ERRORS              OS/2 Errors
;|*** *   INCL_FONTFILEFORMAT      OS/2 Font File Format
;|*** *   INCL_GPI                 OS/2 GPI
;|*** *   INCL_ORDERS              OS/2 Graphical Order Formats
;|*** *   INCL_PIC                 OS/2 Picture utilities
;|*** *   INCL_SPL                 OS/2 Spooler
;|*** *   INCL_WINSTDDLGS          CUA controls and dialogs
;|*** *   INCL_WIN                 OS/2 Window Manager
;|*** *   INCL_WINWORKPLACE        OS/2 Workplace Shell
;|*** *
;|*** * ===========================================================================
;|*** *
;|*** * Comments at the end of each typedef line give the name tags used in
;|*** * the assembler include version of this file.
;|*** *
;|*** * The assembler include version of this file excludes lines between NOINC
;|*** * and INC comments.
;|*** *
;|*** #ifndef __IBMC__
;|***    * The public version of this file (as shipped with the OS/2 Toolkit
;|***    * product) excludes all non 32-bit material marked in this file
;|***    * as well as any areas specifically marked with __IBMC__ conditional
;|***    * sections - including this paragraph. The H2IBMH rexx command file
;|***    * removes these sections.
;|*** #endif
;|*** \***************************************************************************/
;|*** 
;|*** /* NOINC */
;|*** #ifdef __IBMC__
;|***    #pragma checkout( suspend )
;|***       #ifndef __CHKHDR__
;|***          #pragma checkout( suspend )
;|***       #endif
;|***    #pragma checkout( resume )
;|*** #endif
;|*** /* INC */
;|*** 
;|*** #define PM_INCLUDED
;|*** 
;|*** #ifndef INCL_32         /* If neither INCL_32 or INCL_16 set already */
;|***    #ifndef INCL_16      /* find out from compiler if 32-bit or not.  */
;|***      #ifdef M_I386
;|***         #define INCL_32 /* Compiling for 32-bit */
;|***      #else
;|***         #define INCL_16 /* Compiling for 16-bit */
;|***      #endif
;|***   #endif
;|*** #endif
;|*** 
;|*** /*** if INCL_PM defined then define all the symbols ************************/
;|*** #ifdef INCL_PM
;|***    #define INCL_AVIO
;|***    #define INCL_BITMAPFILEFORMAT
;|***    #define INCL_DEV
;|***    #define INCL_ERRORS
;|***    #define INCL_FONTFILEFORMAT
;|***    #define INCL_GPI
;|***    #define INCL_ORDERS
;|***    #define INCL_PIC
;|***    #define INCL_SPL
;|***    #define INCL_WIN
;|***    #define INCL_WINSTDDLGS
;|***    #define INCL_WINWORKPLACE
;|*** #endif /* INCL_PM */
;|*** 
;|*** 
;|*** #include <pmwin.h>        /* OS/2 Window Manager definitions    */
; Line 95
;|*** /*DDK*************************************************************************/
;|*** /*                                                                           */
;|*** /* COPYRIGHT    Copyright (C) 1995 IBM Corporation                           */
;|*** /*                                                                           */
;|*** /*    The following IBM OS/2 WARP source code is provided to you solely for  */
;|*** /*    the purpose of assisting you in your development of OS/2 WARP device   */
;|*** /*    drivers. You may use this code in accordance with the IBM License      */
;|*** /*    Agreement provided in the IBM Device Driver Source Kit for OS/2. This  */
;|*** /*    Copyright statement may not be removed.                                */
;|*** /*                                                                           */
;|*** /*****************************************************************************/
;|*** /****************************** Module Header ******************************\
;|*** *
;|*** * Module Name: PMWIN.H
;|*** *
;|*** * OS/2 Presentation Manager Window Manager include file.
;|*** *
;|*** *
;|*** * ===========================================================================
;|*** *
;|*** * The folowing symbols are used in this file for conditional sections.
;|*** *
;|*** * If INCL_WIN is defined, all subcomponents are included.
;|*** *
;|*** * Subcomponents marked with "+" are partially included by default:
;|*** *
;|*** *   #define:                To include:
;|*** *
;|*** * + INCL_WINWINDOWMGR       General window management
;|*** * + INCL_WINMESSAGEMGR      Message management
;|*** * + INCL_WININPUT           Mouse and keyboard input
;|*** * + INCL_WINDIALOGS         Dialog boxes
;|*** * + INCL_WINSTATICS         Static controls
;|*** * + INCL_WINBUTTONS         Button controls
;|*** * + INCL_WINENTRYFIELDS     Entry Fields
;|*** *   INCL_WINMLE             Multiple Line Entry Fields
;|*** * + INCL_WINLISTBOXES       List box controls
;|*** * + INCL_WINMENUS           Menu controls
;|*** * + INCL_WINSCROLLBARS      Scroll bar controls
;|*** * + INCL_WINFRAMEMGR        Frame manager
;|*** *   INCL_WINFRAMECTLS       Frame controls (title bars & size border)
;|*** *   INCL_WINRECTANGLES      Rectangle routines
;|*** *   INCL_WINSYS             System values (and colors)
;|*** *   INCL_WINTIMER           Timer routines
;|*** * + INCL_WINACCELERATORS    Keyboard accelerators
;|*** *   INCL_WINTRACKRECT       WinTrackRect() function
;|*** *   INCL_WINCLIPBOARD       Clipboard manager
;|*** * + INCL_WINCURSORS         Text cursors
;|*** * + INCL_WINPOINTERS        Mouse pointers
;|*** *   INCL_WINHOOKS           Hook manager
;|*** * + INCL_WINSWITCHLIST      Shell Switch List API
;|*** *   INCL_WINPROGRAMLIST     Shell Program List API
;|*** *   INCL_WINSHELLDATA       Shell Data (?)
;|*** *   INCL_WINCOUNTRY         Country support
;|*** *   INCL_WINHEAP            Heap Manager
;|*** *   INCL_WINATOM            Atom Manager
;|*** #ifndef INCL_32
;|***    *INCL_WINCATCHTHROW      WinCatch/WinThrow support
;|*** #endif
;|*** *   INCL_WINERRORS          Error code definitions
;|*** *   INCL_NLS                DBCS window manager definition
;|*** * + INCL_WINHELP            Help Manager definitions
;|*** *   INCL_WINSEI             Set Error Info API
;|*** *   INCL_WINLOAD            Load/Delete Library/Procedure
;|*** *   INCL_WINTYPES           Definitions for Datatypes
;|*** *   INCL_WINTHUNKAPI        Thunk Procedure API
;|*** *   INCL_WINDESKTOP         Desktop API
;|*** *
;|*** * ===========================================================================
;|*** *
;|*** * Comments at the end of each typedef line give the name tags used in
;|*** * the assembler include version of this file.
;|*** *
;|*** * The assembler include version of this file excludes lines between NOINC
;|*** * and INC comments.
;|*** *
;|*** #ifndef __IBMC__
;|***    * The public version of this file (as shipped with the OS/2 Toolkit
;|***    * product) excludes all non 32-bit material marked in this file
;|***    * as well as any areas specifically marked with __IBMC__ conditional
;|***    * sections - including this paragraph. The H2IBMH rexx command file
;|***    * removes these sections.
;|*** #endif
;|*** \***************************************************************************/
;|*** 
;|*** /* NOINC */
;|*** #ifdef __IBMC__
;|***    #pragma checkout( suspend )
;|***       #ifndef __CHKHDR__
;|***          #pragma checkout( suspend )
;|***       #endif
;|***    #pragma checkout( resume )
;|*** #endif
;|*** /* INC */
;|*** 
;|*** #define WIN_INCLUDED
;|*** 
;|*** 
;|*** #ifndef INCL_32         /* If neither INCL_32 or INCL_16 set already */
;|***    #ifndef INCL_16      /* find out from compiler if 32-bit or not.  */
;|***      #ifdef M_I386
;|***         #define INCL_32 /* Compiling for 32-bit */
;|***      #else
;|***         #define INCL_16 /* Compiling for 16-bit */
;|***      #endif
;|***   #endif
;|*** #endif
;|*** 
;|*** #ifdef INCL_16
;|***    /* NOINC */
;|***    #include <pmwin16.h>
; Line 111
;|***    /* INC */
;|*** #endif /* INCL_16 */
;|*** 
;|*** /*** include everything if requested ***************************************/
;|*** #ifdef INCL_WIN
;|***    #define INCL_WINWINDOWMGR
;|***    #define INCL_WINMESSAGEMGR
;|***    #define INCL_WININPUT
;|***    #define INCL_WINDIALOGS
;|***    #define INCL_WINSTATICS
;|***    #define INCL_WINBUTTONS
;|***    #define INCL_WINENTRYFIELDS
;|***    #define INCL_WINMLE
;|***    #define INCL_WINLISTBOXES
;|***    #define INCL_WINMENUS
;|***    #define INCL_WINSCROLLBARS
;|***    #define INCL_WINFRAMEMGR
;|***    #define INCL_WINFRAMECTLS
;|***    #define INCL_WINRECTANGLES
;|***    #define INCL_WINSYS
;|***    #define INCL_WINTIMER
;|***    #define INCL_WINACCELERATORS
;|***    #define INCL_WINTRACKRECT
;|***    #define INCL_WINCLIPBOARD
;|***    #define INCL_WINCURSORS
;|***    #define INCL_WINPOINTERS
;|***    #define INCL_WINHOOKS
;|***    #define INCL_WINSWITCHLIST
;|***    #define INCL_WINPROGRAMLIST
;|***    #define INCL_WINSHELLDATA
;|***    #define INCL_WINCOUNTRY
;|***    #define INCL_WINHEAP
;|***    #define INCL_WINATOM
;|***    #ifndef INCL_32
;|***      #define INCL_WINCATCHTHROW
;|***    #endif
;|***    #define INCL_WINERRORS
;|***    #define INCL_WINDDE
;|***    #define INCL_WINHELP
;|***    #define INCL_WINSEI
;|***    #define INCL_WINLOAD
;|***    #define INCL_WINTYPES
;|***    #define INCL_WINDESKTOP
;|***    #define INCL_WINPALETTE
;|***    #define INCL_WINTHUNKAPI
;|***    #define INCL_WINSTDDLGS
;|*** #else /* INCL_WIN */
;|***    /*** include resource compiler required sections ************************/
;|***    #ifdef RC_INVOKED
;|***       #define INCL_WININPUT
;|***       #define INCL_WINDIALOGS
;|***       #define INCL_WINSTATICS
;|***       #define INCL_WINBUTTONS
;|***       #define INCL_WINENTRYFIELDS
;|***       #define INCL_WINLISTBOXES
;|***       #define INCL_WINMENUS
;|***       #define INCL_WINSCROLLBARS
;|***       #define INCL_WINFRAMEMGR
;|***       #define INCL_WINFRAMECTLS
;|***       #define INCL_WINACCELERATORS
;|***       #define INCL_WINPOINTERS
;|***       #define INCL_WINMESSAGEMGR
;|***       #define INCL_WINMLE
;|***       #define INCL_WINHELP
;|***       #define INCL_WINSTDDLGS
;|***       #define INCL_WINSYS
;|***    #endif /* RC_INVOKED */
;|*** #endif /* INCL_WIN */
;|*** 
;|*** /*** ensure standard entry field defintions if MLE is defined **************/
;|*** #ifdef INCL_WINMLE
;|***    #ifndef INCL_WINENTRYFIELDS
;|***       #define INCL_WINENTRYFIELDS
;|***    #endif /* INCL_WINENTRYFIELDS */
;|*** #endif /* INCL_WINMLE */
;|*** 
;|*** /*** INCL_WINCOMMON compatability ******************************************/
;|*** #ifdef INCL_WINCOMMON
;|***    #define INCL_WINWINDOWMGR
;|*** #endif /* INCL_WINCOMMON */
;|*** 
;|*** /*** include PMWIN errors if all errors requested **************************/
;|*** #ifdef INCL_ERRORS
;|***    #define INCL_WINERRORS
;|*** #endif  /* INCL_ERRORS */
;|*** 
;|*** /***************************************************************************/
;|*** /***        General Window Management types, constants and macros        ***/
;|*** /***************************************************************************/
;|*** 
;|*** typedef VOID FAR    *MPARAM;    /* mp    */
;|*** typedef MPARAM FAR  *PMPARAM;   /* pmp   */
;|*** typedef VOID FAR    *MRESULT;   /* mres  */
;|*** typedef MRESULT FAR *PMRESULT;  /* pmres */
;|*** 
;|*** /*** Macros to make an MPARAM from standard types. *************************/
;|*** 
;|*** #define MPVOID                     ((MPARAM)0L)
;|*** #ifdef INCL_32
;|***    #define MPFROMP(p)                 ((MPARAM)((ULONG)(p)))
;|*** #else
;|***    #define MPFROMP(p)                 ((MPARAM)(VOID FAR *)(p))
;|*** #endif
;|*** #define MPFROMHWND(hwnd)           ((MPARAM)(HWND)(hwnd))
;|*** #define MPFROMCHAR(ch)             ((MPARAM)(USHORT)(ch))
;|*** #define MPFROMSHORT(s)             ((MPARAM)(USHORT)(s))
;|*** #define MPFROM2SHORT(s1, s2)       ((MPARAM)MAKELONG(s1, s2))
;|*** #define MPFROMSH2CH(s, uch1, uch2) ((MPARAM)MAKELONG(s, MAKESHORT(uch1, uch2)))
;|*** #define MPFROMLONG(l)              ((MPARAM)(ULONG)(l))
;|*** 
;|*** /*** Macros to extract standard types from an MPARAM ***********************/
;|*** 
;|*** #define PVOIDFROMMP(mp)            ((VOID FAR *)(mp))
;|*** #define HWNDFROMMP(mp)             ((HWND)(mp))
;|*** #define CHAR1FROMMP(mp)            ((UCHAR)((ULONG)mp))
;|*** #define CHAR2FROMMP(mp)            ((UCHAR)((ULONG)mp >> 8))
;|*** #define CHAR3FROMMP(mp)            ((UCHAR)((ULONG)mp >> 16))
;|*** #define CHAR4FROMMP(mp)            ((UCHAR)((ULONG)mp >> 24))
;|*** #define SHORT1FROMMP(mp)           ((USHORT)(ULONG)(mp))
;|*** #define SHORT2FROMMP(mp)           ((USHORT)((ULONG)mp >> 16))
;|*** #define LONGFROMMP(mp)             ((ULONG)(mp))
;|*** 
;|*** /*** Macros to make an MRESULT from standard types. ************************/
;|*** 
;|*** #define MRFROMP(p)                 ((MRESULT)(VOID FAR *)(p))
;|*** #define MRFROMSHORT(s)             ((MRESULT)(USHORT)(s))
;|*** #define MRFROM2SHORT(s1, s2)       ((MRESULT)MAKELONG(s1, s2))
;|*** #define MRFROMLONG(l)              ((MRESULT)(ULONG)(l))
;|*** 
;|*** /*** Macros to extract standard types from an MRESULT **********************/
;|*** 
;|*** #define PVOIDFROMMR(mr)            ((VOID FAR *)(mr))
;|*** #define SHORT1FROMMR(mr)           ((USHORT)((ULONG)mr))
;|*** #define SHORT2FROMMR(mr)           ((USHORT)((ULONG)mr >> 16))
;|*** #define LONGFROMMR(mr)             ((ULONG)(mr))
;|*** 
;|*** 
;|*** /****************************************************************************
;|*** * This is the standard function definition for window procedures.
;|*** * Typically they are names like "XxxxxxxxWndProc", where the prefix
;|*** * "Xxxxxxxxx" is replaced by some name descriptive of the window procedure
;|*** * being declared.  Window procedures must be EXPORTED in the definitions
;|*** * file used by the linker.
;|*** *
;|*** * MRESULT EXPENTRY MyclassWndProc(HWND hwnd,   * window handle        *
;|*** *                                 ULONG msg,   * message number       *
;|*** *                                 MPARAM mp1,  * 1st (packed) parms   *
;|*** *                                 MPARAM mp2); * 2nd (packed) parms   *
;|*** *
;|*** ****************************************************************************/
;|*** 
;|*** /*** Pointer to a window procedure function ********************************/
;|*** #ifdef INCL_32
;|***    typedef MRESULT (EXPENTRY FNWP)(HWND, ULONG, MPARAM, MPARAM);
;|***    typedef FNWP FAR *PFNWP;
;|*** #else
;|***    typedef MRESULT (PASCAL FAR *PFNWP)(HWND, USHORT, MPARAM, MPARAM);
;|*** #endif
;|*** 
;|*** /*** Predefined window handles *********************************************/
;|*** #ifndef INCL_SAADEFS
;|***    #define HWND_DESKTOP               (HWND)1
;|***    #define HWND_OBJECT                (HWND)2
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** #define HWND_TOP                      (HWND)3
;|*** #define HWND_BOTTOM                   (HWND)4
;|*** 
;|*** #ifndef INCL_SAADEFS
;|***    #define HWND_THREADCAPTURE         (HWND)5
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** 
;|*** /*** Standard Window Classes ***********************************************/
;|*** 
;|*** #define WC_FRAME             ((PSZ)0xffff0001L)
;|*** #define WC_COMBOBOX          ((PSZ)0xffff0002L)
;|*** #define WC_BUTTON            ((PSZ)0xffff0003L)
;|*** #define WC_MENU              ((PSZ)0xffff0004L)
;|*** #define WC_STATIC            ((PSZ)0xffff0005L)
;|*** #define WC_ENTRYFIELD        ((PSZ)0xffff0006L)
;|*** #define WC_LISTBOX           ((PSZ)0xffff0007L)
;|*** #define WC_SCROLLBAR         ((PSZ)0xffff0008L)
;|*** #define WC_TITLEBAR          ((PSZ)0xffff0009L)
;|*** #define WC_MLE               ((PSZ)0xffff000AL)
;|*** /* 000B to 000F reserved */
;|*** #define WC_APPSTAT           ((PSZ)0xffff0010L)
;|*** #define WC_KBDSTAT           ((PSZ)0xffff0011L)
;|*** #define WC_PECIC             ((PSZ)0xffff0012L)
;|*** #define WC_DBE_KKPOPUP       ((PSZ)0xffff0013L)
;|*** /* 0014 to 001F reserved */
;|*** #define WC_SPINBUTTON        ((PSZ)0xffff0020L)
;|*** /* 0021 to 0024 reserved */
;|*** #define WC_CONTAINER         ((PSZ)0xffff0025L)
;|*** #define WC_SLIDER            ((PSZ)0xffff0026L)
;|*** #define WC_VALUESET          ((PSZ)0xffff0027L)
;|*** #define WC_NOTEBOOK          ((PSZ)0xffff0028L)
;|*** /* 0029 to 002C used by PEN */
;|*** #define WC_PENFIRST          ((PSZ)0xffff0029L)
;|*** #define WC_PENLAST           ((PSZ)0xffff002CL)
;|*** /* 002D to 0030 reserved */
;|*** /* 0030 to 003F reserved */
;|*** #define WC_MMPMFIRST         ((PSZ)0xffff0040L)
;|*** #define WC_CIRCULARSLIDER    ((PSZ)0xffff0041L)
;|*** #define WC_MMPMLAST          ((PSZ)0xffff004fL)
;|*** 
;|*** /*** Standard Window Styles ************************************************/
;|*** 
;|*** #define WS_VISIBLE                 0x80000000L
;|*** #define WS_DISABLED                0x40000000L
;|*** #define WS_CLIPCHILDREN            0x20000000L
;|*** #define WS_CLIPSIBLINGS            0x10000000L
;|*** #define WS_PARENTCLIP              0x08000000L
;|*** #define WS_SAVEBITS                0x04000000L
;|*** #define WS_SYNCPAINT               0x02000000L
;|*** #define WS_MINIMIZED               0x01000000L
;|*** #define WS_MAXIMIZED               0x00800000L
;|*** #define WS_ANIMATE                 0x00400000L
;|*** 
;|*** /*** Dialog manager styles *************************************************/
;|*** 
;|*** #define WS_GROUP                   0x00010000L
;|*** #define WS_TABSTOP                 0x00020000L
;|*** #define WS_MULTISELECT             0x00040000L
;|*** 
;|*** /*** Class styles *********************************************************/
;|*** 
;|*** #define CS_MOVENOTIFY              0x00000001L
;|*** #define CS_SIZEREDRAW              0x00000004L
;|*** #define CS_HITTEST                 0x00000008L
;|*** #define CS_PUBLIC                  0x00000010L
;|*** #define CS_FRAME                   0x00000020L
;|*** #define CS_CLIPCHILDREN            0x20000000L
;|*** #define CS_CLIPSIBLINGS            0x10000000L
;|*** #define CS_PARENTCLIP              0x08000000L
;|*** #define CS_SAVEBITS                0x04000000L
;|*** #define CS_SYNCPAINT               0x02000000L
;|*** 
;|*** /***************************************************************************/
;|*** /*** Window Manager Subsection part 1 **************************************/
;|*** /***************************************************************************/
;|*** 
;|*** #if (defined(INCL_WINWINDOWMGR) || !defined(INCL_NOCOMMON))
;|*** 
;|***    #ifdef INCL_32
;|***       BOOL    APIENTRY WinRegisterClass(HAB hab,
;|***                                         PSZ pszClassName,
;|***                                         PFNWP pfnWndProc,
;|***                                         ULONG flStyle,
;|***                                         ULONG cbWindowData);
;|***    #else
;|***       BOOL    APIENTRY WinRegisterClass(HAB hab,
;|***                                         PSZ pszClassName,
;|***                                         PFNWP pfnWndProc,
;|***                                         ULONG flStyle,
;|***                                         USHORT cbWindowData);
;|***    #endif  /* INCL_32 */
;|*** 
;|***    #ifdef INCL_32
;|***       MRESULT APIENTRY WinDefWindowProc(HWND hwnd,
;|***                                         ULONG msg,
;|***                                         MPARAM mp1,
;|***                                         MPARAM mp2);
;|***    #else
;|***       MRESULT APIENTRY WinDefWindowProc(HWND hwnd,
;|***                                         USHORT msg,
;|***                                         MPARAM mp1,
;|***                                         MPARAM mp2);
;|***    #endif  /* INCL_32 */
;|*** 
;|***    BOOL    APIENTRY WinDestroyWindow(HWND hwnd);
;|*** 
;|***    BOOL    APIENTRY WinShowWindow(HWND hwnd,
;|***                                   BOOL fShow);
;|*** 
;|***    BOOL    APIENTRY WinQueryWindowRect(HWND hwnd,
;|***                                        PRECTL prclDest);
;|*** 
;|***    HPS     APIENTRY WinGetPS(HWND hwnd);
;|*** 
;|***    BOOL    APIENTRY WinReleasePS(HPS hps);
;|*** 
;|***    BOOL    APIENTRY WinEndPaint(HPS hps);
;|*** 
;|***    #ifndef INCL_SAADEFS
;|*** 
;|***       #ifdef INCL_32
;|***          HPS   APIENTRY WinGetClipPS(HWND hwnd,
;|***                                      HWND hwndClip,
;|***                                      ULONG fl);
;|***       #else
;|***          HPS   APIENTRY WinGetClipPS(HWND hwnd,
;|***                                      HWND hwndClip,
;|***                                      USHORT fs);
;|***       #endif  /* INCL_32 */
;|*** 
;|***       BOOL  APIENTRY WinIsWindowShowing(HWND hwnd);
;|*** 
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    HPS   APIENTRY WinBeginPaint(HWND hwnd,
;|***                                 HPS hps,
;|***                                 PRECTL prclPaint);
;|***    HDC   APIENTRY WinOpenWindowDC(HWND hwnd);
;|*** 
;|***    #ifdef INCL_32
;|***       LONG APIENTRY WinScrollWindow(HWND hwnd,
;|***                                     LONG dx,
;|***                                     LONG dy,
;|***                                     PRECTL prclScroll,
;|***                                     PRECTL prclClip,
;|***                                     HRGN hrgnUpdate,
;|***                                     PRECTL prclUpdate,
;|***                                     ULONG rgfsw);
;|***    #else
;|***       SHORT APIENTRY WinScrollWindow(HWND hwnd,
;|***                                      SHORT dx,
;|***                                      SHORT dy,
;|***                                      PRECTL prclScroll,
;|***                                      PRECTL prclClip,
;|***                                      HRGN hrgnUpdate,
;|***                                      PRECTL prclUpdate,
;|***                                      USHORT rgfsw);
;|***    #endif  /* INCL_32 */
;|*** 
;|***    /*** WinGetClipPS() flags ***********************************************/
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #define PSF_LOCKWINDOWUPDATE       0x0001
;|***       #define PSF_CLIPUPWARDS            0x0002
;|***       #define PSF_CLIPDOWNWARDS          0x0004
;|***       #define PSF_CLIPSIBLINGS           0x0008
;|***       #define PSF_CLIPCHILDREN           0x0010
;|***       #define PSF_PARENTCLIP             0x0020
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    /*** WinScrollWindow() flags ********************************************/
;|*** 
;|***    #define SW_SCROLLCHILDREN          0x0001
;|***    #define SW_INVALIDATERGN           0x0002
;|*** 
;|***    BOOL  APIENTRY WinFillRect(HPS hps,
;|***                               PRECTL prcl,
;|***                               LONG lColor);
;|*** 
;|***    /*** WinInitialize/WinTerminate Interface declarations ******************/
;|*** 
;|***    typedef struct _QVERSDATA {  /* qver */
;|***       USHORT   environment;
;|***       USHORT   version;
;|***    } QVERSDATA;
;|***    typedef QVERSDATA FAR *PQVERSDATA;
;|*** 
;|***    #define QV_OS2                     0x0000
;|***    #define QV_CMS                     0x0001
;|***    #define QV_TSO                     0x0002
;|***    #define QV_TSOBATCH                0x0003
;|***    #define QV_OS400                   0x0004
;|*** 
;|*** 
;|***    ULONG  APIENTRY WinQueryVersion(HAB hab);
;|*** 
;|***    #ifdef INCL_32
;|***       HAB    APIENTRY WinInitialize(ULONG flOptions);
;|***    #else
;|***       HAB    APIENTRY WinInitialize(USHORT fsOptions);
;|***    #endif  /* INCL_32 */
;|*** 
;|***    BOOL   APIENTRY WinTerminate(HAB hab);
;|*** 
;|***    HAB    APIENTRY WinQueryAnchorBlock(HWND hwnd);
;|*** 
;|*** #endif /* INCL_WINWINDOWMGR | !INCL_NOCOMMON */
;|*** 
;|*** /***************************************************************************/
;|*** /***  End of Window Manager COMMON section *********************************/
;|*** /***************************************************************************/
;|*** 
;|*** 
;|*** #ifdef INCL_32
;|***    HWND    APIENTRY WinCreateWindow(HWND hwndParent,
;|***                                     PSZ pszClass,
;|***                                     PSZ pszName,
;|***                                     ULONG flStyle,
;|***                                     LONG x,
;|***                                     LONG y,
;|***                                     LONG cx,
;|***                                     LONG cy,
;|***                                     HWND hwndOwner,
;|***                                     HWND hwndInsertBehind,
;|***                                     ULONG id,
;|***                                     PVOID pCtlData,
;|***                                     PVOID pPresParams);
;|*** #else
;|***    HWND    APIENTRY WinCreateWindow(HWND hwndParent,
;|***                                     PSZ pszClass,
;|***                                     PSZ pszName,
;|***                                     ULONG flStyle,
;|***                                     SHORT x,
;|***                                     SHORT y,
;|***                                     SHORT cx,
;|***                                     SHORT cy,
;|***                                     HWND hwndOwner,
;|***                                     HWND hwndInsertBehind,
;|***                                     USHORT id,
;|***                                     PVOID pCtlData,
;|***                                     PVOID pPresParams);
;|*** #endif  /* INCL_32 */
;|*** 
;|*** BOOL    APIENTRY WinEnableWindow(HWND hwnd,
;|***                                  BOOL fEnable);
;|*** 
;|*** BOOL    APIENTRY WinIsWindowEnabled(HWND hwnd);
;|*** 
;|*** BOOL    APIENTRY WinEnableWindowUpdate(HWND hwnd,
;|***                                        BOOL fEnable);
;|*** 
;|*** BOOL    APIENTRY WinIsWindowVisible(HWND hwnd);
;|*** 
;|*** #ifdef INCL_32
;|***    LONG    APIENTRY WinQueryWindowText(HWND hwnd,
;|***                                        LONG cchBufferMax,
;|***                                        PCH pchBuffer);
;|*** #else
;|***    SHORT   APIENTRY WinQueryWindowText(HWND hwnd,
;|***                                        SHORT cchBufferMax,
;|***                                        PCH pchBuffer);
;|*** #endif  /* INCL_32 */
;|*** 
;|*** BOOL    APIENTRY WinSetWindowText(HWND hwnd,
;|***                                   PSZ pszText);
;|*** 
;|*** #ifdef INCL_32
;|***    LONG    APIENTRY WinQueryWindowTextLength(HWND hwnd);
;|*** #else
;|***    SHORT   APIENTRY WinQueryWindowTextLength(HWND hwnd);
;|*** #endif  /* INCL_32 */
;|*** 
;|*** #ifdef INCL_32
;|***    HWND    APIENTRY WinWindowFromID(HWND hwndParent,
;|***                                     ULONG id);
;|*** #else
;|***    HWND    APIENTRY WinWindowFromID(HWND hwndParent,
;|***                                     USHORT id);
;|*** #endif  /* INCL_32 */
;|*** 
;|*** BOOL    APIENTRY WinIsWindow(HAB hab,
;|***                              HWND hwnd);
;|*** 
;|*** #ifdef INCL_32
;|***    HWND    APIENTRY WinQueryWindow(HWND hwnd,
;|***                                    LONG cmd);
;|*** #else
;|***    HWND    APIENTRY WinQueryWindow(HWND hwnd,
;|***                                    SHORT cmd,
;|***                                    BOOL fLock);
;|*** #endif  /* INCL_32 */
;|*** 
;|*** #ifdef INCL_32
;|***    LONG    APIENTRY WinMultWindowFromIDs(HWND hwndParent,
;|***                                          PHWND prghwnd,
;|***                                          ULONG idFirst,
;|***                                          ULONG idLast);
;|*** #else
;|***    SHORT   APIENTRY WinMultWindowFromIDs(HWND hwndParent,
;|***                                          PHWND prghwnd,
;|***                                          USHORT idFirst,
;|***                                          USHORT idLast);
;|*** #endif  /* INCL_32 */
;|*** 
;|*** /*** WinQueryWindow() codes ************************************************/
;|*** 
;|*** #define QW_NEXT         0
;|*** #define QW_PREV         1
;|*** #define QW_TOP          2
;|*** #define QW_BOTTOM       3
;|*** #define QW_OWNER        4
;|*** #define QW_PARENT       5
;|*** #define QW_NEXTTOP      6
;|*** #define QW_PREVTOP      7
;|*** #define QW_FRAMEOWNER   8
;|*** 
;|*** BOOL   APIENTRY WinSetParent(HWND hwnd,
;|***                              HWND hwndNewParent,
;|***                              BOOL fRedraw);
;|*** 
;|*** BOOL   APIENTRY WinIsChild(HWND hwnd,
;|***                            HWND hwndParent);
;|*** BOOL   APIENTRY WinSetOwner(HWND hwnd,
;|***                             HWND hwndNewOwner);
;|*** #ifndef INCL_SAADEFS
;|***    BOOL   APIENTRY WinQueryWindowProcess(HWND hwnd,
;|***                                          PPID ppid,
;|***                                          PTID ptid);
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** HWND   APIENTRY WinQueryObjectWindow(HWND hwndDesktop);
;|*** HWND   APIENTRY WinQueryDesktopWindow(HAB hab,
;|***                                       HDC hdc);
;|*** 
;|*** /*** Window positioning functions */
;|*** 
;|*** /* WinSetMultWindowPos() structure */
;|*** 
;|*** #ifdef INCL_32
;|***    typedef struct _SWP {  /* swp */
;|***       ULONG   fl;
;|***       LONG    cy;
;|***       LONG    cx;
;|***       LONG    y;
;|***       LONG    x;
;|***       HWND    hwndInsertBehind;
;|***       HWND    hwnd;
;|***       ULONG   ulReserved1;
;|***       ULONG   ulReserved2;
;|***    } SWP;
;|*** #else
;|***    typedef struct _SWP {  /* swp */
;|***       USHORT  fs;
;|***       SHORT   cy;
;|***       SHORT   cx;
;|***       SHORT   y;
;|***       SHORT   x;
;|***       HWND    hwndInsertBehind;
;|***       HWND    hwnd;
;|***    } SWP;
;|*** #endif
;|*** typedef SWP FAR *PSWP;
;|*** 
;|*** #ifdef INCL_32
;|***    BOOL   APIENTRY WinSetWindowPos(HWND hwnd,
;|***                                    HWND hwndInsertBehind,
;|***                                    LONG x,
;|***                                    LONG y,
;|***                                    LONG cx,
;|***                                    LONG cy,
;|***                                    ULONG fl);
;|***    BOOL   APIENTRY WinSetMultWindowPos(HAB hab,
;|***                                        PSWP pswp,
;|***                                        ULONG cswp);
;|*** #else
;|***    BOOL   APIENTRY WinSetWindowPos(HWND hwnd,
;|***                                    HWND hwndInsertBehind,
;|***                                    SHORT x,
;|***                                    SHORT y,
;|***                                    SHORT cx,
;|***                                    SHORT cy,
;|***                                    USHORT fs);
;|***    BOOL   APIENTRY WinSetMultWindowPos(HAB hab,
;|***                                        PSWP pswp,
;|***                                        USHORT cswp);
;|*** #endif
;|*** BOOL   APIENTRY WinQueryWindowPos(HWND hwnd,
;|***                                   PSWP pswp);
;|*** 
;|*** /* Values returned from WM_ADJUSTWINDOWPOS and passed to WM_WINDOWPOSCHANGED */
;|*** 
;|*** #define AWP_MINIMIZED              0x00010000L
;|*** #define AWP_MAXIMIZED              0x00020000L
;|*** #define AWP_RESTORED               0x00040000L
;|*** #define AWP_ACTIVATE               0x00080000L
;|*** #define AWP_DEACTIVATE             0x00100000L
;|*** 
;|*** /* WinSetWindowPos() flags */
;|*** 
;|*** #define SWP_SIZE                   0x0001
;|*** #define SWP_MOVE                   0x0002
;|*** #define SWP_ZORDER                 0x0004
;|*** #define SWP_SHOW                   0x0008
;|*** #define SWP_HIDE                   0x0010
;|*** #define SWP_NOREDRAW               0x0020
;|*** #define SWP_NOADJUST               0x0040
;|*** #define SWP_ACTIVATE               0x0080
;|*** #define SWP_DEACTIVATE             0x0100
;|*** #define SWP_EXTSTATECHANGE         0x0200
;|*** #define SWP_MINIMIZE               0x0400
;|*** #define SWP_MAXIMIZE               0x0800
;|*** #define SWP_RESTORE                0x1000
;|*** #define SWP_FOCUSACTIVATE          0x2000
;|*** #define SWP_FOCUSDEACTIVATE        0x4000
;|*** #define SWP_NOAUTOCLOSE            0x8000    /* Valid in PROGDETAILS struct only */
;|*** 
;|*** /* Window painting */
;|*** 
;|*** BOOL  APIENTRY WinUpdateWindow(HWND hwnd);
;|*** 
;|*** BOOL  APIENTRY WinInvalidateRect(HWND hwnd,
;|***                                  PRECTL pwrc,
;|***                                  BOOL fIncludeChildren);
;|*** 
;|*** BOOL  APIENTRY WinInvalidateRegion(HWND hwnd,
;|***                                    HRGN hrgn,
;|***                                    BOOL fIncludeChildren);
;|*** 
;|*** 
;|*** /* Drawing helpers */
;|*** 
;|*** BOOL  APIENTRY WinInvertRect(HPS hps,
;|***                              PRECTL prcl);
;|*** #ifdef INCL_32
;|***    BOOL  APIENTRY WinDrawBitmap(HPS hpsDst,
;|***                                 HBITMAP hbm,
;|***                                 PRECTL pwrcSrc,
;|***                                 PPOINTL pptlDst,
;|***                                 LONG clrFore,
;|***                                 LONG clrBack,
;|***                                 ULONG fl);
;|*** #else
;|***    BOOL  APIENTRY WinDrawBitmap(HPS hpsDst,
;|***                                 HBITMAP hbm,
;|***                                 PRECTL pwrcSrc,
;|***                                 PPOINTL pptlDst,
;|***                                 LONG clrFore,
;|***                                 LONG clrBack,
;|***                                 USHORT fs);
;|*** #endif
;|*** 
;|*** /* WinDrawBitmap() flags */
;|*** 
;|*** #define DBM_NORMAL                 0x0000
;|*** #define DBM_INVERT                 0x0001
;|*** #define DBM_HALFTONE               0x0002
;|*** #define DBM_STRETCH                0x0004
;|*** #define DBM_IMAGEATTRS             0x0008
;|*** 
;|*** 
;|*** #ifdef INCL_32
;|*** 
;|***    LONG    APIENTRY WinDrawText(HPS hps,
;|***                                 LONG cchText,
;|***                                 PCH lpchText,
;|***                                 PRECTL prcl,
;|***                                 LONG clrFore,
;|***                                 LONG clrBack,
;|***                                 ULONG flCmd);
;|*** 
;|*** #else /* not INCL_32 */
;|*** 
;|***    SHORT APIENTRY WinDrawText(HPS hps,
;|***                               SHORT cchText,
;|***                               PCH lpchText,
;|***                               PRECTL prcl,
;|***                               LONG clrFore,
;|***                               LONG clrBack,
;|***                               USHORT fsCmd);
;|*** 
;|*** #endif /* INCL_32 */
;|*** 
;|*** /*
;|*** * WinDrawText() codes:
;|*** * From DT_LEFT to DT_EXTERNALLEADING, the codes are designed to be OR'ed with
;|*** * SS_TEXT to create variations of the basic text static item.
;|*** */
;|*** #define DT_LEFT                    0x0000
;|*** #define DT_QUERYEXTENT             0x0002
;|*** #define DT_UNDERSCORE              0x0010
;|*** #define DT_STRIKEOUT               0x0020
;|*** #define DT_TEXTATTRS               0x0040
;|*** #define DT_EXTERNALLEADING         0x0080
;|*** #define DT_CENTER                  0x0100
;|*** #define DT_RIGHT                   0x0200
;|*** #define DT_TOP                     0x0000
;|*** #define DT_VCENTER                 0x0400
;|*** #define DT_BOTTOM                  0x0800
;|*** #define DT_HALFTONE                0x1000
;|*** #define DT_MNEMONIC                0x2000
;|*** #define DT_WORDBREAK               0x4000
;|*** #define DT_ERASERECT               0x8000
;|*** 
;|*** 
;|*** #ifdef INCL_32
;|*** 
;|***    BOOL APIENTRY WinDrawBorder(HPS hps,
;|***                                PRECTL prcl,
;|***                                LONG cx,
;|***                                LONG cy,
;|***                                LONG clrFore,
;|***                                LONG clrBack,
;|***                                ULONG flCmd);
;|*** 
;|*** #else /* not INCL_32 */
;|*** 
;|***    BOOL APIENTRY WinDrawBorder(HPS hps,
;|***                                PRECTL prcl,
;|***                                SHORT cx,
;|***                                SHORT cy,
;|***                                LONG clrFore,
;|***                                LONG clrBack,
;|***                                USHORT fsCmd);
;|*** 
;|*** #endif /* INCL_32 */
;|*** 
;|*** /* WinDrawBorder() flags */
;|*** 
;|*** #define DB_PATCOPY                 0x0000
;|*** #define DB_PATINVERT               0x0001
;|*** #define DB_DESTINVERT              0x0002
;|*** #define DB_AREAMIXMODE             0x0003
;|*** 
;|*** #define DB_ROP                     0x0007
;|*** #define DB_INTERIOR                0x0008
;|*** #define DB_AREAATTRS               0x0010
;|*** #define DB_STANDARD                0x0100
;|*** #define DB_DLGBORDER               0x0200
;|*** 
;|*** 
;|*** 
;|*** /** Resource loading functions */
;|*** 
;|*** #ifdef INCL_32
;|***    LONG    APIENTRY WinLoadString(HAB hab,
;|***                                   HMODULE hmod,
;|***                                   ULONG id,
;|***                                   LONG cchMax,
;|***                                   PSZ pchBuffer);
;|*** #else
;|***    SHORT   APIENTRY WinLoadString(HAB hab,
;|***                                   HMODULE hmod,
;|***                                   USHORT id,
;|***                                   SHORT cchMax,
;|***                                   PSZ pchBuffer);
;|*** #endif
;|*** #ifndef INCL_SAADEFS
;|***    #ifdef INCL_32
;|***       LONG    APIENTRY WinLoadMessage(HAB hab,
;|***                                       HMODULE hmod,
;|***                                       ULONG id,
;|***                                       LONG cchMax,
;|***                                       PSZ pchBuffer);
;|***    #else
;|***       SHORT   APIENTRY WinLoadMessage(HAB hab,
;|***                                       HMODULE hmod,
;|***                                       USHORT id,
;|***                                       SHORT cchMax,
;|***                                       PSZ pchBuffer);
;|***    #endif
;|*** 
;|*** 
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** /***************************************************************************/
;|*** /****                 Window Manager Subsection part 2                  ****/
;|*** #if (defined(INCL_WINWINDOWMGR) || !defined(INCL_NOCOMMON))
;|*** 
;|***    BOOL APIENTRY WinSetActiveWindow(HWND hwndDesktop,
;|***                                     HWND hwnd);
;|*** 
;|*** #endif /* Window Manager COMMON subsection */
;|*** 
;|*** #ifdef INCL_WINWINDOWMGR
;|***    /* WM_CREATE structure */
;|*** 
;|***    #ifdef INCL_32
;|***       typedef struct _CREATESTRUCT {  /* crst */
;|***          PVOID   pPresParams;
;|***          PVOID   pCtlData;
;|***          ULONG   id;
;|***          HWND    hwndInsertBehind;
;|***          HWND    hwndOwner;
;|***          LONG    cy;
;|***          LONG    cx;
;|***          LONG    y;
;|***          LONG    x;
;|***          ULONG   flStyle;
;|***          PSZ     pszText;
;|***          PSZ     pszClass;
;|***          HWND    hwndParent;
;|***       } CREATESTRUCT;
;|***    #else
;|***       typedef struct _CREATESTRUCT {  /* crst */
;|***          PVOID   pPresParams;
;|***          PVOID   pCtlData;
;|***          USHORT  id;
;|***          HWND    hwndInsertBehind;
;|***          HWND    hwndOwner;
;|***          SHORT   cy;
;|***          SHORT   cx;
;|***          SHORT   y;
;|***          SHORT   x;
;|***          ULONG   flStyle;
;|***          PSZ     pszText;
;|***          PSZ     pszClass;
;|***          HWND    hwndParent;
;|***       } CREATESTRUCT;
;|***    #endif
;|***    typedef CREATESTRUCT FAR *PCREATESTRUCT;
;|*** 
;|***    /* WinQueryClassInfo() structure */
;|*** 
;|***    #ifdef INCL_32
;|***       typedef struct _CLASSINFO {  /* clsi */
;|***          ULONG   flClassStyle;
;|***          PFNWP   pfnWindowProc;
;|***          ULONG   cbWindowData;
;|***       } CLASSINFO;
;|***    #else
;|***       typedef struct _CLASSINFO {  /* clsi */
;|***          ULONG   flClassStyle;
;|***          PFNWP   pfnWindowProc;
;|***          USHORT  cbWindowData;
;|***       } CLASSINFO;
;|***    #endif
;|***    typedef CLASSINFO FAR *PCLASSINFO;
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       PFNWP  APIENTRY WinSubclassWindow(HWND hwnd,
;|***                                         PFNWP pfnwp);
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    #ifdef INCL_32
;|***       LONG    APIENTRY WinQueryClassName(HWND hwnd,
;|***                                          LONG cchMax,
;|***                                          PCH pch);
;|***    #else
;|***       SHORT  APIENTRY WinQueryClassName(HWND hwnd,
;|***                                         SHORT cchMax,
;|***                                         PCH pch);
;|***    #endif
;|***    BOOL   APIENTRY WinQueryClassInfo(HAB hab,
;|***                                      PSZ pszClassName,
;|***                                      PCLASSINFO pClassInfo);
;|*** 
;|***    #ifdef INCL_32
;|***       HWND   APIENTRY WinQueryActiveWindow(HWND hwndDesktop);
;|***    #else
;|***       HWND   APIENTRY WinQueryActiveWindow(HWND hwndDesktop,
;|***                                            BOOL fLock);
;|***    #endif  /* INCL_32 */
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       BOOL   APIENTRY WinIsThreadActive(HAB hab);
;|***    #endif /* !INCL_SAADEFS */
;|***    #ifdef INCL_32
;|***       HWND   APIENTRY WinQuerySysModalWindow(HWND hwndDesktop);
;|***    #else
;|***       HWND   APIENTRY WinQuerySysModalWindow(HWND hwndDesktop,
;|***                                              BOOL fLock);
;|***    #endif /* INCL_32 */
;|*** 
;|***    #ifndef INCL_32
;|***       HWND   APIENTRY WinLockWindow(HWND hwnd,
;|***                                     BOOL fLock);
;|***       #ifndef INCL_SAADEFS
;|***          BOOL   APIENTRY WinRegisterWindowDestroy(HWND hwnd,
;|***                                                   BOOL fRegister);
;|***       #endif /* !INCL_SAADEFS */
;|*** 
;|***       SHORT   APIENTRY WinQueryWindowLockCount(HWND hwnd);
;|***    #endif /* !INCL_32 */
;|*** 
;|***    BOOL   APIENTRY WinSetSysModalWindow(HWND hwndDesktop,
;|***                                         HWND hwnd);
;|*** 
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #ifdef INCL_32
;|***          USHORT APIENTRY WinQueryWindowUShort(HWND hwnd,
;|***                                               LONG index);
;|***          BOOL   APIENTRY WinSetWindowUShort(HWND hwnd,
;|***                                             LONG index,
;|***                                             USHORT us);
;|***          ULONG  APIENTRY WinQueryWindowULong(HWND hwnd,
;|***                                              LONG index);
;|***          BOOL   APIENTRY WinSetWindowULong(HWND hwnd,
;|***                                            LONG index,
;|***                                            ULONG ul);
;|***          PVOID  APIENTRY WinQueryWindowPtr(HWND hwnd,
;|***                                            LONG index);
;|***          BOOL   APIENTRY WinSetWindowPtr(HWND hwnd,
;|***                                          LONG index,
;|***                                          PVOID p);
;|***          BOOL   APIENTRY WinSetWindowBits(HWND hwnd,
;|***                                           LONG index,
;|***                                           ULONG flData,
;|***                                           ULONG flMask);
;|***       #else
;|***          USHORT APIENTRY WinQueryWindowUShort(HWND hwnd,
;|***                                               SHORT index);
;|***          BOOL   APIENTRY WinSetWindowUShort(HWND hwnd,
;|***                                             SHORT index,
;|***                                             USHORT us);
;|***          ULONG  APIENTRY WinQueryWindowULong(HWND hwnd,
;|***                                              SHORT index);
;|***          BOOL   APIENTRY WinSetWindowULong(HWND hwnd,
;|***                                            SHORT index,
;|***                                            ULONG ul);
;|***          PVOID  APIENTRY WinQueryWindowPtr(HWND hwnd,
;|***                                            SHORT index);
;|***          BOOL   APIENTRY WinSetWindowPtr(HWND hwnd,
;|***                                          SHORT index,
;|***                                          PVOID p);
;|***          BOOL   APIENTRY WinSetWindowBits(HWND hwnd,
;|***                                           SHORT index,
;|***                                           ULONG flData,
;|***                                           ULONG flMask);
;|***       #endif
;|*** 
;|***       /*** Standard WinQueryWindowUShort/ULong() indices *******************/
;|***       #define QWS_USER                   0
;|***       #define QWS_ID                     (-1)
;|***       #define QWS_MIN                    (-1)
;|*** 
;|***       #define QWL_USER                   0
;|***       #define QWL_STYLE                  (-2)
;|***       #define QWP_PFNWP                  (-3)
;|***       #define QWL_HMQ                    (-4)
;|***       #define QWL_RESERVED               (-5)
;|*** 
;|***       #define QWL_PENDATA                (-7)
;|***       #define QWL_MIN                    (-8)
;|*** 
;|***       /*** WC_FRAME WinQueryWindowUShort/ULong() indices *******************/
;|***       #define QWL_HHEAP                  0x0004
;|***       #define QWL_HWNDFOCUSSAVE          0x0018
;|***       #define QWL_DEFBUTTON              0x0040
;|***       #define QWL_PSSCBLK                0x0048
;|***       #define QWL_PFEPBLK                0x004c
;|***       #define QWL_PSTATBLK               0x0050
;|*** 
;|***       #define QWS_FLAGS                  0x0008
;|***       #define QWS_RESULT                 0x000a
;|***       #define QWS_XRESTORE               0x000c
;|***       #define QWS_YRESTORE               0x000e
;|***       #define QWS_CXRESTORE              0x0010
;|***       #define QWS_CYRESTORE              0x0012
;|***       #define QWS_XMINIMIZE              0x0014
;|***       #define QWS_YMINIMIZE              0x0016
;|*** 
;|*** 
;|***       /*** Window enumeration **********************************************/
;|***       typedef LHANDLE HENUM;  /* henum */
;|*** 
;|***       HENUM APIENTRY WinBeginEnumWindows(HWND hwnd);
;|***       HWND  APIENTRY WinGetNextWindow(HENUM henum);
;|***       BOOL  APIENTRY WinEndEnumWindows(HENUM henum);
;|*** 
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    #ifdef INCL_32
;|***       HWND  APIENTRY WinWindowFromPoint(HWND hwnd,
;|***                                         PPOINTL pptl,
;|***                                         BOOL fChildren);
;|*** 
;|***       BOOL  APIENTRY WinMapWindowPoints(HWND hwndFrom,
;|***                                         HWND hwndTo,
;|***                                         PPOINTL prgptl,
;|***                                         LONG cwpt);
;|***    #else
;|***       HWND  APIENTRY WinWindowFromPoint(HWND hwnd,
;|***                                         PPOINTL pptl,
;|***                                         BOOL fChildren,
;|***                                         BOOL fLock);
;|*** 
;|***       BOOL  APIENTRY WinMapWindowPoints(HWND hwndFrom,
;|***                                         HWND hwndTo,
;|***                                         PPOINTL prgptl,
;|***                                         SHORT cwpt);
;|***    #endif /* INCL_32 */
;|*** 
;|*** 
;|***    /* More window painting functions */
;|*** 
;|***    BOOL  APIENTRY WinValidateRect(HWND hwnd,
;|***                                   PRECTL prcl,
;|***                                   BOOL fIncludeChildren);
;|*** 
;|***    BOOL  APIENTRY WinValidateRegion(HWND hwnd,
;|***                                     HRGN hrgn,
;|***                                     BOOL fIncludeChildren);
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       HWND  APIENTRY WinWindowFromDC(HDC hdc);
;|*** 
;|***       HDC   APIENTRY WinQueryWindowDC(HWND hwnd);
;|*** 
;|***       HPS   APIENTRY WinGetScreenPS(HWND hwndDesktop);
;|*** 
;|***       BOOL  APIENTRY WinLockWindowUpdate(HWND hwndDesktop,
;|***                                          HWND hwndLockUpdate);
;|*** 
;|***       BOOL  APIENTRY WinLockVisRegions(HWND hwndDesktop,
;|***                                        BOOL fLock);
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    BOOL  APIENTRY WinQueryUpdateRect(HWND hwnd,
;|***                                      PRECTL prcl);
;|*** 
;|***    #ifdef INCL_32
;|***       LONG APIENTRY WinQueryUpdateRegion(HWND hwnd,
;|***                                          HRGN hrgn);
;|*** 
;|***       LONG APIENTRY WinExcludeUpdateRegion(HPS hps,
;|***                                            HWND hwnd);
;|***    #else
;|***       SHORT APIENTRY WinQueryUpdateRegion(HWND hwnd,
;|***                                           HRGN hrgn);
;|*** 
;|***       SHORT APIENTRY WinExcludeUpdateRegion(HPS hps,
;|***                                             HWND hwnd);
;|***    #endif
;|*** 
;|*** #endif /* INCL_WINWINDOWMGR */
;|*** 
;|*** #if (defined(INCL_WINMESSAGEMGR) || !defined(INCL_NOCOMMON))
;|*** 
;|***    /* QMSG structure */
;|***    #ifdef INCL_32
;|***       typedef struct _QMSG {  /* qmsg */
;|***          HWND    hwnd;
;|***          ULONG   msg;
;|***          MPARAM  mp1;
;|***          MPARAM  mp2;
;|***          ULONG   time;
;|***          POINTL  ptl;
;|***          ULONG   reserved;
;|***       } QMSG;
;|***    #else
;|***       typedef struct _QMSG {  /* qmsg */
;|***          HWND    hwnd;
;|***          USHORT  msg;
;|***          MPARAM  mp1;
;|***          MPARAM  mp2;
;|***          ULONG   time;
;|***          POINTL  ptl;
;|***       } QMSG;
;|***    #endif
;|***    typedef QMSG FAR *PQMSG;
;|*** 
;|***    /*** Standard Window Messages *******************************************/
;|***    #define WM_NULL                    0x0000
;|***    #define WM_CREATE                  0x0001
;|***    #define WM_DESTROY                 0x0002
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #ifndef INCL_32
;|***          #define WM_OTHERWINDOWDESTROYED    0x0003
;|***       #endif
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    #define WM_ENABLE                  0x0004
;|***    #define WM_SHOW                    0x0005
;|***    #define WM_MOVE                    0x0006
;|***    #define WM_SIZE                    0x0007
;|***    #define WM_ADJUSTWINDOWPOS         0x0008
;|*** 
;|***    #define WM_CALCVALIDRECTS          0x0009
;|*** 
;|***    #define WM_SETWINDOWPARAMS         0x000a
;|***    #define WM_QUERYWINDOWPARAMS       0x000b
;|***    #define WM_HITTEST                 0x000c
;|***    #define WM_ACTIVATE                0x000d
;|***    #define WM_SETFOCUS                0x000f
;|***    #define WM_SETSELECTION            0x0010
;|*** 
;|***    /* language support Winproc */
;|***    #define WM_PPAINT                  0x0011
;|***    #define WM_PSETFOCUS               0x0012
;|***    #define WM_PSYSCOLORCHANGE         0x0013
;|***    #define WM_PSIZE                   0x0014
;|***    #define WM_PACTIVATE               0x0015
;|***    #define WM_PCONTROL                0x0016
;|*** 
;|***    #define WM_COMMAND                 0x0020
;|***    #define WM_SYSCOMMAND              0x0021
;|***    #define WM_HELP                    0x0022
;|***    #define WM_PAINT                   0x0023
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #define WM_TIMER                0x0024
;|***       #define WM_SEM1                 0x0025
;|***       #define WM_SEM2                 0x0026
;|***       #define WM_SEM3                 0x0027
;|***       #define WM_SEM4                 0x0028
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    #define WM_CLOSE                   0x0029
;|***    #define WM_QUIT                    0x002a
;|***    #define WM_SYSCOLORCHANGE          0x002b
;|***    #define WM_SYSVALUECHANGED         0x002d
;|***    #define WM_APPTERMINATENOTIFY      0x002e
;|***    #define WM_PRESPARAMCHANGED        0x002f
;|*** 
;|***    /* Control notification messages */
;|***    #define WM_CONTROL                 0x0030
;|***    #define WM_VSCROLL                 0x0031
;|***    #define WM_HSCROLL                 0x0032
;|***    #define WM_INITMENU                0x0033
;|***    #define WM_MENUSELECT              0x0034
;|***    #define WM_MENUEND                 0x0035
;|***    #define WM_DRAWITEM                0x0036
;|***    #define WM_MEASUREITEM             0x0037
;|***    #define WM_CONTROLPOINTER          0x0038
;|***    #define WM_QUERYDLGCODE            0x003a
;|***    #define WM_INITDLG                 0x003b
;|***    #define WM_SUBSTITUTESTRING        0x003c
;|***    #define WM_MATCHMNEMONIC           0x003d
;|***    #define WM_SAVEAPPLICATION         0x003e
;|*** 
;|***    #ifdef INCL_16
;|***       #define WM_CONTROLHEAP          0x0039
;|***    #endif /* INCL_16 */
;|*** 
;|***    /*************************************************************************
;|***    * Reserve a range of messages for help manager.  This range includes
;|***    * public messages, defined below, and private ones, which need to be
;|***    * reserved here to prevent clashing with application messages
;|***    *************************************************************************/
;|*** 
;|***    #define WM_HELPBASE                0x0F00 /* Start of msgs for help manager   */
;|***    #define WM_HELPTOP                 0x0FFF /* End of msgs for help manager     */
;|*** 
;|***    #define WM_USER                    0x1000
;|*** 
;|***    /*** WM_COMMAND msg source codes ****************************************/
;|***    #define CMDSRC_PUSHBUTTON      1
;|***    #define CMDSRC_MENU            2
;|***    #define CMDSRC_ACCELERATOR     3
;|***    #define CMDSRC_FONTDLG         4
;|***    #define CMDSRC_FILEDLG         5
;|***    #define CMDSRC_PRINTDLG        6
;|***    #define CMDSRC_COLORDLG        7
;|***    #define CMDSRC_OTHER           0
;|*** 
;|***    #pragma pack(1) /* force structure alignment packing */
;|*** 
;|***    /*
;|***    * The following structure and macro are used to access the
;|***    * WM_COMMAND, WM_HELP, and WM_SYSCOMMAND message parameters:
;|***    */
;|***    #ifdef INCL_32
;|***       typedef struct _COMMANDMSG {  /* commandmsg */
;|***          USHORT  cmd;              /* mp1 */
;|***          USHORT  unused;
;|***          USHORT  source;           /* mp2 */
;|***          USHORT  fMouse;
;|***       } CMDMSG;
;|***       typedef CMDMSG FAR *PCMDMSG;
;|*** 
;|***       #define COMMANDMSG(pmsg) \
;|***       ((PCMDMSG)((PBYTE)pmsg + sizeof(MPARAM) ))
;|***    #else
;|***       typedef struct _COMMANDMSG {  /* commandmsg */
;|***          USHORT  source;           /* mp2 */
;|***          USHORT  fMouse;
;|***          USHORT  cmd;              /* mp1 */
;|***          USHORT  unused;
;|***       } CMDMSG;
;|***       typedef CMDMSG FAR *PCMDMSG;
;|*** 
;|***       #define COMMANDMSG(pmsg) \
;|***       ((PCMDMSG)((PBYTE)pmsg - sizeof(MPARAM) * 2))
;|***    #endif
;|*** 
;|***    #pragma pack()  /* restore packing to default */
;|*** 
;|***    /*** The following structure is used by the WinQueryQueueInfo() routine */
;|***    #ifdef INCL_32
;|***       typedef struct _MQINFO {  /* mqi */
;|***          ULONG   cb;
;|***          PID     pid;
;|***          TID     tid;
;|***          ULONG   cmsgs;
;|***          PVOID   pReserved;
;|***       } MQINFO;
;|***    #else
;|***       typedef struct _MQINFO {     /* mqi */
;|***          USHORT  cb;
;|***          USHORT  pid;
;|***          USHORT  tid;
;|***          USHORT  cmsgs;
;|***          PVOID   pReserved;
;|***       } MQINFO;
;|***    #endif
;|***    typedef MQINFO FAR *PMQINFO;
;|*** 
;|***    #ifdef INCL_32
;|***       MRESULT APIENTRY WinSendMsg(HWND hwnd,
;|***                                   ULONG msg,
;|***                                   MPARAM mp1,
;|***                                   MPARAM mp2);
;|*** 
;|***       HMQ     APIENTRY WinCreateMsgQueue(HAB hab,
;|***                                          LONG cmsg);
;|*** 
;|***       BOOL    APIENTRY WinDestroyMsgQueue(HMQ hmq);
;|*** 
;|***       BOOL    APIENTRY WinQueryQueueInfo(HMQ hmq,
;|***                                          PMQINFO pmqi,
;|***                                          ULONG cbCopy);
;|***    #else
;|***       MRESULT APIENTRY WinSendMsg(HWND hwnd,
;|***                                   USHORT msg,
;|***                                   MPARAM mp1,
;|***                                   MPARAM mp2);
;|*** 
;|***       HMQ     APIENTRY WinCreateMsgQueue(HAB hab,
;|***                                          SHORT cmsg);
;|*** 
;|***       BOOL    APIENTRY WinDestroyMsgQueue(HMQ hmq);
;|*** 
;|***       BOOL    APIENTRY WinQueryQueueInfo(HMQ hmq,
;|***                                          PMQINFO pmqi,
;|***                                          USHORT cbCopy);
;|***    #endif
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       BOOL    APIENTRY WinCancelShutdown(HMQ hmq,
;|***                                          BOOL fCancelAlways);
;|***    #endif /* INCL_SAADEFS */
;|*** 
;|***    #ifdef INCL_32
;|***       BOOL    APIENTRY WinGetMsg(HAB hab,
;|***                                  PQMSG pqmsg,
;|***                                  HWND hwndFilter,
;|***                                  ULONG msgFilterFirst,
;|***                                  ULONG msgFilterLast);
;|*** 
;|***       BOOL    APIENTRY WinPeekMsg(HAB hab,
;|***                                   PQMSG pqmsg,
;|***                                   HWND hwndFilter,
;|***                                   ULONG msgFilterFirst,
;|***                                   ULONG msgFilterLast,
;|***                                   ULONG fl);
;|*** 
;|***       MRESULT APIENTRY WinDispatchMsg(HAB hab,
;|***                                       PQMSG pqmsg);
;|*** 
;|***       BOOL    APIENTRY WinPostMsg(HWND hwnd,
;|***                                   ULONG msg,
;|***                                   MPARAM mp1,
;|***                                   MPARAM mp2);
;|*** 
;|***       BOOL    APIENTRY WinRegisterUserMsg(HAB hab,
;|***                                           ULONG msgid,
;|***                                           LONG datatype1,
;|***                                           LONG dir1,
;|***                                           LONG datatype2,
;|***                                           LONG dir2,
;|***                                           LONG datatyper);
;|*** 
;|***       BOOL    APIENTRY WinRegisterUserDatatype(HAB hab,
;|***                                                LONG datatype,
;|***                                                LONG count,
;|***                                                PLONG types);
;|***       BOOL    APIENTRY WinSetMsgMode(HAB hab,
;|***                                      PSZ classname,
;|***                                      LONG control);
;|*** 
;|***       BOOL    APIENTRY WinSetSynchroMode(HAB hab,
;|***                                          LONG mode);
;|***    #else
;|***       BOOL    APIENTRY WinGetMsg(HAB hab,
;|***                                  PQMSG pqmsg,
;|***                                  HWND hwndFilter,
;|***                                  USHORT msgFilterFirst,
;|***                                  USHORT msgFilterLast);
;|*** 
;|***       BOOL    APIENTRY WinPeekMsg(HAB hab,
;|***                                   PQMSG pqmsg,
;|***                                   HWND hwndFilter,
;|***                                   USHORT msgFilterFirst,
;|***                                   USHORT msgFilterLast,
;|***                                   USHORT fs);
;|*** 
;|***       MRESULT APIENTRY WinDispatchMsg(HAB hab,
;|***                                       PQMSG pqmsg);
;|*** 
;|***       BOOL    APIENTRY WinPostMsg(HWND hwnd,
;|***                                   USHORT msg,
;|***                                   MPARAM mp1,
;|***                                   MPARAM mp2);
;|*** 
;|***       BOOL    APIENTRY WinRegisterUserMsg(HAB hab,
;|***                                           USHORT msgid,
;|***                                           SHORT datatype1,
;|***                                           SHORT dir1,
;|***                                           SHORT datatype2,
;|***                                           SHORT dir2,
;|***                                           SHORT datatyper);
;|*** 
;|***       BOOL    APIENTRY WinRegisterUserDatatype(HAB hab,
;|***                                                SHORT datatype,
;|***                                                SHORT count,
;|***                                                PSHORT types);
;|*** 
;|***       BOOL    APIENTRY WinSetMsgMode(HAB hab,
;|***                                      PSZ classname,
;|***                                      SHORT control);
;|*** 
;|***       BOOL    APIENTRY WinSetSynchroMode(HAB hab,
;|***                                          SHORT mode);
;|***    #endif
;|*** 
;|***    /*** WinPeekMsg() constants *********************************************/
;|***    #define PM_REMOVE                  0x0001
;|***    #define PM_NOREMOVE                0x0000
;|*** 
;|***    /*** WinRegisterUserDatatype datatypes defined in separate file *********/
;|***    #ifdef INCL_WINTYPES
;|***       #include <pmtypes.h>
;|***    #endif /*INCL_WINTYPES*/
;|*** 
;|***    /*** WinRegisterUserMsg direction codes *********************************/
;|***    #define RUM_IN                     1
;|***    #define RUM_OUT                    2
;|***    #define RUM_INOUT                  3
;|*** 
;|***    /*** WinSetMsgMode constants *******************************************/
;|***    #define SMD_DELAYED                0x0001
;|***    #define SMD_IMMEDIATE              0x0002
;|*** 
;|***    /*** WinSetSynchroMode constants ***************************************/
;|***    #define SSM_SYNCHRONOUS            0x0001
;|***    #define SSM_ASYNCHRONOUS           0x0002
;|***    #define SSM_MIXED                  0x0003
;|*** 
;|*** #endif /* WINMESSAGEMGR || !INCL_NOCOMMON       */
;|*** 
;|*** #ifdef INCL_WINMESSAGEMGR
;|*** 
;|***    /*** WM_CALCVALIDRECTS return flags *************************************/
;|***    #define CVR_ALIGNLEFT               0x0001
;|***    #define CVR_ALIGNBOTTOM             0x0002
;|***    #define CVR_ALIGNRIGHT              0x0004
;|***    #define CVR_ALIGNTOP                0x0008
;|***    #define CVR_REDRAW                  0x0010
;|*** 
;|***    /*** WM_HITTEST return codes ********************************************/
;|***    #define HT_NORMAL                   0
;|***    #define HT_TRANSPARENT              (-1)
;|***    #define HT_DISCARD                  (-2)
;|***    #define HT_ERROR                    (-3)
;|*** 
;|***    /*** WM_SET/QUERYWINDOWPARAMS structures and flags **********************/
;|***    #ifdef INCL_32
;|***       typedef struct _WNDPARAMS {  /* wprm */
;|***          ULONG   fsStatus;
;|***          ULONG   cchText;
;|***          PSZ     pszText;
;|***          ULONG   cbPresParams;
;|***          PVOID   pPresParams;
;|***          ULONG   cbCtlData;
;|***          PVOID   pCtlData;
;|***       } WNDPARAMS;
;|***    #else
;|***       typedef struct _WNDPARAMS {  /* wprm */
;|***          USHORT  fsStatus;
;|***          USHORT  cchText;
;|***          PSZ     pszText;
;|***          USHORT  cbPresParams;
;|***          PVOID   pPresParams;
;|***          USHORT  cbCtlData;
;|***          PVOID   pCtlData;
;|***       } WNDPARAMS;
;|***    #endif
;|***    typedef WNDPARAMS FAR *PWNDPARAMS;
;|*** 
;|***    #define WPM_TEXT                   0x0001
;|***    #define WPM_CTLDATA                0x0002
;|***    #define WPM_PRESPARAMS             0x0004
;|***    #define WPM_CCHTEXT                0x0008
;|***    #define WPM_CBCTLDATA              0x0010
;|***    #define WPM_CBPRESPARAMS           0x0020
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       BOOL    APIENTRY WinInSendMsg(HAB hab);
;|***    #endif /* INCL_SAADEFS */
;|*** 
;|***    #ifdef INCL_32
;|***       BOOL    APIENTRY WinBroadcastMsg(HWND hwnd,
;|***                                        ULONG msg,
;|***                                        MPARAM mp1,
;|***                                        MPARAM mp2,
;|***                                        ULONG rgf);
;|***    #else
;|***       BOOL    APIENTRY WinBroadcastMsg(HWND hwnd,
;|***                                        USHORT msg,
;|***                                        MPARAM mp1,
;|***                                        MPARAM mp2,
;|***                                        USHORT rgf);
;|***    #endif
;|*** 
;|***    /*** WinBroadcastMsg codes **********************************************/
;|***    #define BMSG_POST                  0x0000
;|***    #define BMSG_SEND                  0x0001
;|***    #define BMSG_POSTQUEUE             0x0002
;|***    #define BMSG_DESCENDANTS           0x0004
;|***    #define BMSG_FRAMEONLY             0x0008
;|*** 
;|***    #ifdef INCL_32
;|***       BOOL  APIENTRY WinWaitMsg(HAB hab,
;|***                                 ULONG msgFirst,
;|***                                 ULONG msgLast);
;|***    #else
;|***       BOOL  APIENTRY WinWaitMsg(HAB hab,
;|***                                 USHORT msgFirst,
;|***                                 USHORT msgLast);
;|***    #endif
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       ULONG APIENTRY WinQueryQueueStatus(HWND hwndDesktop);
;|*** 
;|***       /*** WinQueryQueueStatus() constants *********************************/
;|***       #define QS_KEY                     0x0001
;|***       #define QS_MOUSEBUTTON             0x0002
;|***       #define QS_MOUSEMOVE               0x0004
;|***       #define QS_MOUSE                   0x0006   /* QS_MOUSEMOVE|QS_MOUSEBUTTON */
;|***       #define QS_TIMER                   0x0008
;|***       #define QS_PAINT                   0x0010
;|***       #define QS_POSTMSG                 0x0020
;|***       #define QS_SEM1                    0x0040
;|***       #define QS_SEM2                    0x0080
;|***       #define QS_SEM3                    0x0100
;|***       #define QS_SEM4                    0x0200
;|***       #define QS_SENDMSG                 0x0400
;|***       #define QS_MSGINPUT                0x0800
;|*** 
;|***       BOOL  APIENTRY WinQueryMsgPos(HAB hab,
;|***                                     PPOINTL pptl);
;|*** 
;|***       ULONG APIENTRY WinQueryMsgTime(HAB hab);
;|*** 
;|***       #ifdef INCL_32
;|***          #ifndef INCL_DOSSEMAPHORES
;|***             #ifndef __HEV__
;|***                #define __HEV__
;|***                typedef ULONG HEV;    /* hev */
;|***             #endif
;|***             typedef ULONG HMTX;   /* hmtx */
;|***             typedef ULONG HMUX;   /* hmux */
;|***          #endif
;|*** 
;|***          APIRET APIENTRY WinWaitEventSem(HEV hev,
;|***                                          ULONG ulTimeout);
;|*** 
;|***          APIRET APIENTRY WinRequestMutexSem(HMTX hmtx,
;|***                                             ULONG ulTimeout);
;|*** 
;|***          APIRET APIENTRY WinWaitMuxWaitSem(HMUX hmux,
;|***                                            ULONG ulTimeout,
;|***                                            PULONG pulUser);
;|*** 
;|***       #else
;|***          USHORT APIENTRY WinMsgSemWait(HSEM hsem,
;|***                                        LONG dtTimeout);
;|*** 
;|***          USHORT APIENTRY WinMsgMuxSemWait(PUSHORT pisemCleared,
;|***                                           PVOID pmxsl,
;|***                                           LONG dtTimeout);
;|***       #endif
;|*** 
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    #ifdef INCL_32
;|***       BOOL  APIENTRY WinPostQueueMsg(HMQ hmq,
;|***                                      ULONG msg,
;|***                                      MPARAM mp1,
;|***                                      MPARAM mp2);
;|***    #else
;|***       BOOL  APIENTRY WinPostQueueMsg(HMQ hmq,
;|***                                      USHORT msg,
;|***                                      MPARAM mp1,
;|***                                      MPARAM mp2);
;|***    #endif
;|*** 
;|***    /*** WinSetMsgInterest()/WinSetClassMsgInterest() constants *************/
;|***    #define SMIM_ALL                   0x0EFF
;|***    #define SMI_NOINTEREST             0x0001
;|***    #define SMI_INTEREST               0x0002
;|***    #define SMI_RESET                  0x0004
;|***    #define SMI_AUTODISPATCH           0x0008
;|*** 
;|***    #ifdef INCL_32
;|***       BOOL  APIENTRY WinSetMsgInterest(HWND hwnd,
;|***                                        ULONG msg_class,
;|***                                        LONG control);
;|*** 
;|***       BOOL  APIENTRY WinSetClassMsgInterest(HAB hab,
;|***                                             PSZ pszClassName,
;|***                                             ULONG msg_class,
;|***                                             LONG control);
;|***    #else
;|***       BOOL  APIENTRY WinSetMsgInterest(HWND hwnd,
;|***                                        USHORT msg_class,
;|***                                        SHORT control);
;|*** 
;|***       BOOL  APIENTRY WinSetClassMsgInterest(HAB hab,
;|***                                             PSZ pszClassName,
;|***                                             USHORT msg_class,
;|***                                             SHORT control);
;|***    #endif
;|*** 
;|*** #endif /* INCL_WINMESSAGEMGR */
;|*** 
;|*** /*** Keyboard and mouse ****************************************************/
;|*** 
;|*** #if (defined(INCL_WININPUT) || !defined(INCL_NOCOMMON))
;|*** 
;|***    /*** Keyboard and mouse input COMMON subsection *************************/
;|***    BOOL  APIENTRY WinSetFocus(HWND hwndDesktop,
;|***                               HWND hwndSetFocus);
;|*** 
;|***    #ifdef INCL_32
;|***       BOOL  APIENTRY WinFocusChange(HWND hwndDesktop,
;|***                                     HWND hwndSetFocus,
;|***                                     ULONG flFocusChange);
;|*** 
;|***       BOOL  EXPENTRY WinLockupSystem(HAB hab);
;|*** 
;|***       BOOL  EXPENTRY WinUnlockSystem(HAB hab, PSZ pszPassword);
;|***    #else
;|***       BOOL  APIENTRY WinFocusChange(HWND hwndDesktop,
;|***                                     HWND hwndSetFocus,
;|***                                     USHORT fsFocusChange);
;|***    #endif
;|*** 
;|***    #define FC_NOSETFOCUS              0x0001
;|***    #define FC_NOBRINGTOTOP            FC_NOSETFOCUS
;|***    #define FC_NOLOSEFOCUS             0x0002
;|***    #define FC_NOBRINGTOPFIRSTWINDOW   FC_NOLOSEFOCUS
;|***    #define FC_NOSETACTIVE             0x0004
;|***    #define FC_NOLOSEACTIVE            0x0008
;|***    #define FC_NOSETSELECTION          0x0010
;|***    #define FC_NOLOSESELECTION         0x0020
;|*** 
;|***    #define QFC_NEXTINCHAIN            0x0001
;|***    #define QFC_ACTIVE                 0x0002
;|***    #define QFC_FRAME                  0x0003
;|***    #define QFC_SELECTACTIVE           0x0004
;|***    #define QFC_PARTOFCHAIN            0x0005
;|*** 
;|*** #endif  /* Keyboard and mouse input COMMON subsection */
;|*** 
;|*** /*
;|*** ** @86823; added WM_VRNDISABLED, WM_VRNENABLED,
;|*** **               WinSetVisibleRegionNotify, WinQueryVisibleRegion
;|*** */
;|***    #define WM_VRNDISABLED             0x007e
;|***    #define WM_VRNENABLED              0x007f
;|*** 
;|***    BOOL APIENTRY WinSetVisibleRegionNotify( HWND hwnd, BOOL fEnable);
;|*** 
;|***    ULONG APIENTRY WinQueryVisibleRegion( HWND hwnd, HRGN hrgn);
;|*** 
;|*** 
;|*** #ifdef INCL_WININPUT
;|***    #ifndef INCL_SAADEFS
;|***       BOOL  APIENTRY WinSetCapture(HWND hwndDesktop,
;|***                                    HWND hwnd);
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    #ifdef INCL_32
;|***       HWND  APIENTRY WinQueryCapture(HWND hwndDesktop);
;|***    #else
;|***       HWND  APIENTRY WinQueryCapture(HWND hwndDesktop,
;|***                                      BOOL fLock);
;|***    #endif  /* INCL_32 */
;|*** 
;|***    #ifdef INCL_32
;|***       BOOL  APIENTRY WinCheckInput(HAB hab);
;|***    #endif
;|*** 
;|***    /*** Mouse input messages ***********************************************/
;|***    #ifndef INCL_SAADEFS
;|***       #define WM_MOUSEFIRST           0x0070
;|***       #define WM_MOUSELAST            0x0079
;|***       #define WM_BUTTONCLICKFIRST     0x0071
;|***       #define WM_BUTTONCLICKLAST      0x0079
;|***    #endif /* !INCL_SAADEFS */
;|***    #define WM_MOUSEMOVE               0x0070
;|*** 
;|***    #define WM_BUTTON1DOWN             0x0071
;|*** 
;|***    #define WM_BUTTON1UP               0x0072
;|***    #define WM_BUTTON1DBLCLK           0x0073
;|***    #define WM_BUTTON2DOWN             0x0074
;|***    #define WM_BUTTON2UP               0x0075
;|***    #define WM_BUTTON2DBLCLK           0x0076
;|***    #ifndef INCL_SAADEFS
;|***       #define WM_BUTTON3DOWN          0x0077
;|***       #define WM_BUTTON3UP            0x0078
;|***       #define WM_BUTTON3DBLCLK        0x0079
;|*** 
;|***       #define WM_MOUSEMAP             0x007D
;|*** 
;|***       #define WM_EXTMOUSEFIRST        0x0410
;|***       #define WM_EXTMOUSELAST         0x0419
;|*** 
;|***       #define WM_CHORD                0x0410
;|***       #define WM_BUTTON1MOTIONSTART   0x0411
;|***       #define WM_BUTTON1MOTIONEND     0x0412
;|***       #define WM_BUTTON1CLICK         0x0413
;|***       #define WM_BUTTON2MOTIONSTART   0x0414
;|***       #define WM_BUTTON2MOTIONEND     0x0415
;|***       #define WM_BUTTON2CLICK         0x0416
;|***       #define WM_BUTTON3MOTIONSTART   0x0417
;|***       #define WM_BUTTON3MOTIONEND     0x0418
;|***       #define WM_BUTTON3CLICK         0x0419
;|*** 
;|***       /* Messages 0x041A - 0x041F are reserved */
;|*** 
;|***       #define WM_MOUSETRANSLATEFIRST  0x0420
;|***       #define WM_MOUSETRANSLATELAST   0x0428
;|*** 
;|***       #define WM_BEGINDRAG            0x0420
;|***       #define WM_ENDDRAG              0x0421
;|***       #define WM_SINGLESELECT         0x0422
;|***       #define WM_OPEN                 0x0423
;|***       #define WM_CONTEXTMENU          0x0424
;|***       #define WM_CONTEXTHELP          0x0425
;|***       #define WM_TEXTEDIT             0x0426
;|***       #define WM_BEGINSELECT          0x0427
;|***       #define WM_ENDSELECT            0x0428
;|***       #define WM_PICKUP               0x0429
;|*** 
;|***       #define WM_PENFIRST             0x04C0
;|***       #define WM_PENLAST              0x04FF
;|***       #define WM_MMPMFIRST            0x0500
;|***       #define WM_MMPMLAST             0x05FF
;|*** 
;|***       /* Messages 0x0BD0 - 0x0BFF are reserved */
;|***       /* for bidirectional language support.   */
;|*** 
;|***       #define  WM_BIDI_FIRST           0x0BD0
;|***       #define  WM_BIDI_LAST            0x0BFF
;|*** 
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    #ifdef INCL_32
;|***       HWND  APIENTRY WinQueryFocus(HWND hwndDesktop);
;|***    #else
;|***       HWND  APIENTRY WinQueryFocus(HWND hwndDesktop,
;|***                                    BOOL fLock);
;|***    #endif
;|*** 
;|*** 
;|***    /*** Key/Character input messages ***************************************/
;|***    #define WM_CHAR                    0x007a
;|***    #define WM_VIOCHAR                 0x007b
;|*** 
;|***    /* WM_CHAR fs field bits */
;|***    #define KC_NONE                    0x0000     /* Reserved */
;|***    #define KC_CHAR                    0x0001
;|***    #define KC_VIRTUALKEY              0x0002
;|***    #define KC_SCANCODE                0x0004
;|*** 
;|***    #define KC_SHIFT                   0x0008
;|***    #define KC_CTRL                    0x0010
;|***    #define KC_ALT                     0x0020
;|***    #define KC_KEYUP                   0x0040
;|***    #define KC_PREVDOWN                0x0080
;|***    #define KC_LONEKEY                 0x0100
;|***    #define KC_DEADKEY                 0x0200
;|***    #define KC_COMPOSITE               0x0400
;|***    #define KC_INVALIDCOMP             0x0800
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #define KC_TOGGLE               0x1000
;|***       #define KC_INVALIDCHAR          0x2000
;|***       #define KC_DBCSRSRVD1           0x4000
;|***       #define KC_DBCSRSRVD2           0x8000
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    #pragma pack(1) /* force structure alignment packing */
;|*** 
;|***    /*
;|***    * The following structure and macro are used to access the
;|***    * WM_MOUSEMOVE, and WM_BUTTON message parameters
;|***    */
;|***    #ifdef INCL_32
;|***       typedef struct _MOUSEMSG {  /* mousemsg */
;|***          SHORT   x;             /* mp1      */
;|***          SHORT   y;
;|***          USHORT  codeHitTest;   /* mp2      */
;|***          USHORT  fsInp;         /* input flags */
;|***       } MSEMSG;
;|***       typedef MSEMSG FAR *PMSEMSG;
;|*** 
;|***       #define MOUSEMSG(pmsg) \
;|***       ((PMSEMSG)((PBYTE)pmsg + sizeof(MPARAM) ))
;|*** 
;|***       typedef struct _CHARMSG {  /* charmsg */
;|***          USHORT  fs;           /* mp1     */
;|***          UCHAR   cRepeat;
;|***          UCHAR   scancode;
;|***          USHORT  chr;          /* mp2     */
;|***          USHORT  vkey;
;|***       } CHRMSG;
;|***       typedef CHRMSG FAR *PCHRMSG;
;|*** 
;|***       #define CHARMSG(pmsg) \
;|***       ((PCHRMSG)((PBYTE)pmsg + sizeof(MPARAM) ))
;|***    #else
;|***       typedef struct _MOUSEMSG {  /* mousemsg */
;|***          USHORT  codeHitTest;   /* mp2      */
;|***          USHORT  fsInp;         /* input flags */
;|***          SHORT   x;             /* mp1      */
;|***          SHORT   y;
;|***       } MSEMSG;
;|***       typedef MSEMSG FAR *PMSEMSG;
;|*** 
;|***       #define MOUSEMSG(pmsg) \
;|***       ((PMSEMSG)((PBYTE)pmsg - sizeof(MPARAM) * 2))
;|*** 
;|***       typedef struct _CHARMSG {  /* charmsg */
;|***          USHORT  chr;          /* mp2     */
;|***          USHORT  vkey;
;|***          USHORT  fs;           /* mp1     */
;|***          UCHAR   cRepeat;
;|***          UCHAR   scancode;
;|***       } CHRMSG;
;|***       typedef CHRMSG FAR *PCHRMSG;
;|*** 
;|***       #define CHARMSG(pmsg) \
;|***       ((PCHRMSG)((PBYTE)pmsg - sizeof(MPARAM) * 2))
;|***    #endif
;|*** 
;|***    #pragma pack()  /* restore packing to default */
;|*** 
;|***    #define INP_NONE                   0x0000
;|***    #define INP_KBD                    0x0001
;|***    #define INP_MULT                   0x0002
;|***    #define INP_RES2                   0x0004
;|***    #define INP_SHIFT                  0x0008
;|***    #define INP_CTRL                   0x0010
;|***    #define INP_ALT                    0x0020
;|***    #define INP_RES3                   0x0040
;|***    #define INP_RES4                   0x0080
;|***    #define INP_IGNORE                 0xFFFF
;|*** 
;|***    /*** Virtual key values *************************************************/
;|***    #define VK_BUTTON1                 0x01
;|***    #define VK_BUTTON2                 0x02
;|***    #define VK_BUTTON3                 0x03
;|***    #define VK_BREAK                   0x04
;|***    #define VK_BACKSPACE               0x05
;|***    #define VK_TAB                     0x06
;|***    #define VK_BACKTAB                 0x07
;|***    #define VK_NEWLINE                 0x08
;|***    #define VK_SHIFT                   0x09
;|***    #define VK_CTRL                    0x0A
;|***    #define VK_ALT                     0x0B
;|***    #define VK_ALTGRAF                 0x0C
;|***    #define VK_PAUSE                   0x0D
;|***    #define VK_CAPSLOCK                0x0E
;|***    #define VK_ESC                     0x0F
;|***    #define VK_SPACE                   0x10
;|***    #define VK_PAGEUP                  0x11
;|***    #define VK_PAGEDOWN                0x12
;|***    #define VK_END                     0x13
;|***    #define VK_HOME                    0x14
;|***    #define VK_LEFT                    0x15
;|***    #define VK_UP                      0x16
;|***    #define VK_RIGHT                   0x17
;|***    #define VK_DOWN                    0x18
;|***    #define VK_PRINTSCRN               0x19
;|***    #define VK_INSERT                  0x1A
;|***    #define VK_DELETE                  0x1B
;|***    #define VK_SCRLLOCK                0x1C
;|***    #define VK_NUMLOCK                 0x1D
;|***    #define VK_ENTER                   0x1E
;|***    #define VK_SYSRQ                   0x1F
;|***    #define VK_F1                      0x20
;|***    #define VK_F2                      0x21
;|***    #define VK_F3                      0x22
;|***    #define VK_F4                      0x23
;|***    #define VK_F5                      0x24
;|***    #define VK_F6                      0x25
;|***    #define VK_F7                      0x26
;|***    #define VK_F8                      0x27
;|***    #define VK_F9                      0x28
;|***    #define VK_F10                     0x29
;|***    #define VK_F11                     0x2A
;|***    #define VK_F12                     0x2B
;|***    #define VK_F13                     0x2C
;|***    #define VK_F14                     0x2D
;|***    #define VK_F15                     0x2E
;|***    #define VK_F16                     0x2F
;|***    #define VK_F17                     0x30
;|***    #define VK_F18                     0x31
;|***    #define VK_F19                     0x32
;|***    #define VK_F20                     0x33
;|***    #define VK_F21                     0x34
;|***    #define VK_F22                     0x35
;|***    #define VK_F23                     0x36
;|***    #define VK_F24                     0x37
;|***    #define VK_ENDDRAG                 0x38
;|***    #define VK_CLEAR                   0x39
;|***    #define VK_EREOF                   0x3A
;|***    #define VK_PA1                     0x3B
;|***    #define VK_ATTN                    0x3C
;|***    #define VK_CRSEL                   0x3D
;|***    #define VK_EXSEL                   0x3E
;|***    #define VK_COPY                    0x3F
;|***    #define VK_BLK1                    0x40
;|***    #define VK_BLK2                    0x41
;|*** 
;|*** 
;|***    #define VK_MENU                    VK_F10
;|***    #ifdef INCL_NLS
;|***       #define VK_DBCSFIRST            0x0080
;|***       #define VK_DBCSLAST             0x00ff
;|*** 
;|***       /* VK_ vluaes 0xE0 - 0xFF are reserved   */
;|***       /* for bidirectional language support.   */
;|*** 
;|***       #define VK_BIDI_FIRST           0xE0
;|***       #define VK_BIDI_LAST            0xFF
;|*** 
;|***    #endif /* INCL_NLS */
;|*** 
;|***    #define VK_USERFIRST               0x0100
;|***    #define VK_USERLAST                0x01ff
;|*** 
;|***    #ifndef INCL_SAADEFS
;|*** 
;|***       #ifdef INCL_32
;|***          LONG APIENTRY WinGetKeyState(HWND hwndDesktop,
;|***                                       LONG vkey);
;|***          LONG APIENTRY WinGetPhysKeyState(HWND hwndDesktop,
;|***                                           LONG sc);
;|***       #else
;|***          SHORT APIENTRY WinGetKeyState(HWND hwndDesktop,
;|***                                        SHORT vkey);
;|***          SHORT APIENTRY WinGetPhysKeyState(HWND hwndDesktop,
;|***                                            SHORT sc);
;|***       #endif
;|***       BOOL  APIENTRY WinEnablePhysInput(HWND hwndDesktop,
;|***                                         BOOL fEnable);
;|***       BOOL  APIENTRY WinIsPhysInputEnabled(HWND hwndDesktop);
;|***       BOOL  APIENTRY WinSetKeyboardStateTable(HWND hwndDesktop,
;|***                                               PBYTE pKeyStateTable,
;|***                                               BOOL fSet);
;|*** 
;|*** 
;|***       /* Journal Notification messages  */
;|***       #define WM_JOURNALNOTIFY           0x007c
;|*** 
;|***       /*** Define the valid commands (lParm1) for journal notify message */
;|***       #define JRN_QUEUESTATUS            0x00000001L
;|***       #define JRN_PHYSKEYSTATE           0x00000002L
;|*** 
;|***    #endif /* !INCL_SAADEFS */
;|*** #endif /* INCL_WININPUT */
;|*** 
;|***    typedef LHANDLE HPOINTER;   /* hptr */
;|*** 
;|*** 
;|*** /**** Dialog Manager */
;|*** 
;|*** #if (defined(INCL_WINDIALOGS) || !defined(INCL_NOCOMMON))
;|***    /**** Dialog Manager COMMON subsection */
;|*** 
;|***    BOOL    APIENTRY WinGetDlgMsg(HWND hwndDlg,
;|***                                  PQMSG pqmsg);
;|*** 
;|***    #ifdef INCL_32
;|***       HWND    APIENTRY WinLoadDlg(HWND hwndParent,
;|***                                   HWND hwndOwner,
;|***                                   PFNWP pfnDlgProc,
;|***                                   HMODULE hmod,
;|***                                   ULONG idDlg,
;|***                                   PVOID pCreateParams);
;|***       ULONG  APIENTRY WinDlgBox(HWND hwndParent,
;|***                                 HWND hwndOwner,
;|***                                 PFNWP pfnDlgProc,
;|***                                 HMODULE hmod,
;|***                                 ULONG idDlg,
;|***                                 PVOID pCreateParams);
;|*** 
;|***       BOOL    APIENTRY WinDismissDlg(HWND hwndDlg,
;|***                                      ULONG usResult);
;|*** 
;|***       BOOL    APIENTRY WinQueryDlgItemShort(HWND hwndDlg,
;|***                                             ULONG idItem,
;|***                                             PSHORT pResult,
;|***                                             BOOL fSigned);
;|***       BOOL    APIENTRY WinSetDlgItemShort(HWND hwndDlg,
;|***                                           ULONG idItem,
;|***                                           USHORT usValue,
;|***                                           BOOL fSigned);
;|***       BOOL    APIENTRY WinSetDlgItemText(HWND hwndDlg,
;|***                                          ULONG idItem,
;|***                                          PSZ pszText);
;|***       ULONG  APIENTRY WinQueryDlgItemText(HWND hwndDlg,
;|***                                           ULONG idItem,
;|***                                           LONG cchBufferMax,
;|***                                           PSZ pchBuffer);
;|***       LONG   APIENTRY WinQueryDlgItemTextLength(HWND hwndDlg,
;|***                                                 ULONG idItem);
;|*** 
;|***       MRESULT APIENTRY WinDefDlgProc(HWND hwndDlg,
;|***                                      ULONG msg,
;|***                                      MPARAM mp1,
;|***                                      MPARAM mp2);
;|***    #else
;|***       HWND    APIENTRY WinLoadDlg(HWND hwndParent,
;|***                                   HWND hwndOwner,
;|***                                   PFNWP pfnDlgProc,
;|***                                   HMODULE hmod,
;|***                                   USHORT idDlg,
;|***                                   PVOID pCreateParams);
;|***       USHORT  APIENTRY WinDlgBox(HWND hwndParent,
;|***                                  HWND hwndOwner,
;|***                                  PFNWP pfnDlgProc,
;|***                                  HMODULE hmod,
;|***                                  USHORT idDlg,
;|***                                  PVOID pCreateParams);
;|*** 
;|***       BOOL    APIENTRY WinDismissDlg(HWND hwndDlg,
;|***                                      USHORT usResult);
;|*** 
;|***       BOOL    APIENTRY WinQueryDlgItemShort(HWND hwndDlg,
;|***                                             USHORT idItem,
;|***                                             PSHORT pResult,
;|***                                             BOOL fSigned);
;|***       BOOL    APIENTRY WinSetDlgItemShort(HWND hwndDlg,
;|***                                           USHORT idItem,
;|***                                           USHORT usValue,
;|***                                           BOOL fSigned);
;|***       BOOL    APIENTRY WinSetDlgItemText(HWND hwndDlg,
;|***                                          USHORT idItem,
;|***                                          PSZ pszText);
;|***       USHORT  APIENTRY WinQueryDlgItemText(HWND hwndDlg,
;|***                                            USHORT idItem,
;|***                                            SHORT cchBufferMax,
;|***                                            PSZ pchBuffer);
;|***       SHORT   APIENTRY WinQueryDlgItemTextLength(HWND hwndDlg,
;|***                                                  USHORT idItem);
;|*** 
;|***       MRESULT APIENTRY WinDefDlgProc(HWND hwndDlg,
;|***                                      USHORT msg,
;|***                                      MPARAM mp1,
;|***                                      MPARAM mp2);
;|***    #endif
;|*** 
;|***    /* Special item IDs */
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #define DID_OK      1
;|***       #define DID_CANCEL  2
;|***       #define DID_ERROR   0xffff
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    #ifdef INCL_32
;|***       BOOL APIENTRY WinAlarm(HWND hwndDesktop,
;|***                              ULONG rgfType);
;|***    #else
;|***       BOOL APIENTRY WinAlarm(HWND hwndDesktop,
;|***                              USHORT rgfType);
;|***    #endif
;|*** 
;|***    /* WinAlarm Codes */
;|*** 
;|***    #define WA_WARNING                 0
;|***    #define WA_NOTE                    1
;|***    #define WA_ERROR                   2
;|***    #define WA_CWINALARMS             13     /* count of valid alarms     53304*/
;|*** 
;|***    #ifdef INCL_32
;|*** 
;|***       ULONG APIENTRY WinMessageBox(HWND hwndParent,
;|***                                    HWND hwndOwner,
;|***                                    PSZ pszText,
;|***                                    PSZ pszCaption,
;|***                                    ULONG idWindow,
;|***                                    ULONG flStyle);
;|*** 
;|***    #else /* not INCL_32 */
;|*** 
;|***       USHORT APIENTRY WinMessageBox(HWND hwndParent,
;|***                                     HWND hwndOwner,
;|***                                     PSZ pszText,
;|***                                     PSZ pszCaption,
;|***                                     USHORT idWindow,
;|***                                     USHORT fsStyle);
;|*** 
;|***    #endif /* INCL_32 */
;|*** 
;|*** 
;|*** 
;|***    #define MAX_MBDTEXT               70
;|*** 
;|*** /* NOINC */
;|***    #pragma pack(4)
;|*** 
;|***    typedef struct _MB2D
;|***    {
;|***        CHAR   achText[MAX_MBDTEXT + 1]; /* Text of the button. eg. "~Cancel"    */
;|***        ULONG  idButton;                  /* Button ID returned when user chooses */
;|***        /*  button                              */
;|***        LONG   flStyle;                   /* Button style or'ed with internal     */
;|***        /*  styles                              */
;|***    } MB2D;
;|*** 
;|***    typedef MB2D * PMB2D;
;|*** 
;|***    typedef struct _MB2INFO
;|***    {
;|***       ULONG    cb;                  /* Size of fixed part of structure          */
;|***       HPOINTER hIcon;               /* Icon handle                              */
;|***       ULONG    cButtons;            /* Number of buttons                        */
;|***       ULONG    flStyle;             /* Icon style flags (MB_ICONQUESTION, etc...)*/
;|***       HWND     hwndNotify;          /* Reserved                                 */
;|***       MB2D     mb2d[1];             /* Array of button definitions              */
;|***    } MB2INFO;
;|*** 
;|***    typedef MB2INFO * PMB2INFO;
;|*** 
;|***    #pragma pack()
;|*** 
;|***    /************************************************************************/
;|***    /* WinMessageBox2                                                       */
;|***    /*                                                                      */
;|***    /* Parameters: HWND   hwndParent   - handle of the parent window.       */
;|***    /*             HWND   hwndOwner    - handle of the owner window.        */
;|***    /*             PSZ    pszText      - message text.                      */
;|***    /*             PSZ    pszCaption   - title of the message box.          */
;|***    /*             ULONG  idWindow     - Message box id                     */
;|***    /*             PMB2INFO pmb2info   - pointer to button/icon info        */
;|***    /************************************************************************/
;|***    ULONG  EXPENTRY  WinMessageBox2(HWND     hwndParent,
;|***                                    HWND     hwndOwner,
;|***                                    PSZ      pszText,
;|***                                    PSZ      pszCaption,
;|***                                    ULONG    idWindow,
;|***                                    PMB2INFO pmb2info);
;|*** 
;|*** /* INC */
;|*** 
;|***    /* Message box types */
;|*** 
;|***    #define MB_OK                      0x0000
;|***    #define MB_OKCANCEL                0x0001
;|***    #define MB_RETRYCANCEL             0x0002
;|***    #define MB_ABORTRETRYIGNORE        0x0003
;|***    #define MB_YESNO                   0x0004
;|***    #define MB_YESNOCANCEL             0x0005
;|***    #define MB_CANCEL                  0x0006
;|***    #define MB_ENTER                   0x0007
;|***    #define MB_ENTERCANCEL             0x0008
;|*** 
;|***    #define MB_NOICON                  0x0000
;|***    #define MB_CUANOTIFICATION         0x0000
;|***    #define MB_ICONQUESTION            0x0010
;|***    #define MB_ICONEXCLAMATION         0x0020
;|***    #define MB_CUAWARNING              0x0020
;|***    #define MB_ICONASTERISK            0x0030
;|***    #define MB_ICONHAND                0x0040
;|***    #define MB_CUACRITICAL             0x0040
;|***    #define MB_QUERY                   MB_ICONQUESTION
;|***    #define MB_WARNING                 MB_CUAWARNING
;|***    #define MB_INFORMATION             MB_ICONASTERISK
;|***    #define MB_CRITICAL                MB_CUACRITICAL
;|***    #define MB_ERROR                   MB_CRITICAL
;|***    #define MB_CUSTOMICON              0x0080
;|*** 
;|***    #define MB_DEFBUTTON1              0x0000
;|***    #define MB_DEFBUTTON2              0x0100
;|***    #define MB_DEFBUTTON3              0x0200
;|*** 
;|***    #define MB_APPLMODAL               0x0000
;|***    #define MB_SYSTEMMODAL             0x1000
;|***    #define MB_HELP                    0x2000
;|***    #define MB_MOVEABLE                0x4000
;|***    #define MB_NONMODAL                0x8000
;|*** 
;|*** 
;|***    /* Message box return codes */
;|*** 
;|***    #define MBID_OK                    1
;|***    #define MBID_CANCEL                2
;|***    #define MBID_ABORT                 3
;|***    #define MBID_RETRY                 4
;|***    #define MBID_IGNORE                5
;|***    #define MBID_YES                   6
;|***    #define MBID_NO                    7
;|***    #define MBID_HELP                  8
;|***    #define MBID_ENTER                 9
;|***    #define MBID_ERROR                 0xffff
;|*** 
;|*** 
;|***    /* Useful macros */
;|*** 
;|***    /***************************************************************************
;|***    * ULONG/USHORT WinCheckButton(HWND hwndDlg, USHORT id, USHORT checkState)
;|***    *    sets the check state of button #id.
;|***    *    returns the previous check state.
;|***    ***************************************************************************/
;|***    #ifdef INCL_32
;|***       #define WinCheckButton(hwndDlg, id, usCheckState) \
;|***       ((ULONG)WinSendDlgItemMsg(hwndDlg, id, BM_SETCHECK, \
;|***       MPFROMSHORT(usCheckState), (MPARAM)NULL))
;|***    #else
;|***       #define WinCheckButton(hwndDlg, id, usCheckState) \
;|***       ((USHORT)WinSendDlgItemMsg(hwndDlg, id, BM_SETCHECK, \
;|***       MPFROMSHORT(usCheckState), (MPARAM)NULL))
;|***    #endif
;|*** 
;|***    /***************************************************************************
;|***    * ULONG/USHORT WinQueryButtonCheckstate(HWND hwndDlg, USHORT id)
;|***    *    returns the check state of buttin #id.
;|***    *
;|***    ***************************************************************************/
;|***    #ifdef INCL_32
;|***       #define WinQueryButtonCheckstate(hwndDlg, id) \
;|***       ((ULONG)WinSendDlgItemMsg(hwndDlg, id, BM_QUERYCHECK, \
;|***       (MPARAM)NULL, (MPARAM)NULL))
;|***    #else
;|***       #define WinQueryButtonCheckstate(hwndDlg, id) \
;|***       ((USHORT)WinSendDlgItemMsg(hwndDlg, id, BM_QUERYCHECK, \
;|***       (MPARAM)NULL, (MPARAM)NULL))
;|***    #endif
;|*** 
;|***    /***************************************************************************
;|***    * BOOL WinEnableControl(HWND hwndDlg, USHORT id, BOOL fEnable)
;|***    *    sets the enable state of button #id.
;|***    *    returns fSuccess.
;|***    ***************************************************************************/
;|***    #define WinEnableControl(hwndDlg, id, fEnable) \
;|***    WinEnableWindow(WinWindowFromID(hwndDlg, id), fEnable)
;|*** 
;|***    /***************************************************************************
;|***    * BOOL WinIsControlEnabled(HWND hwndDlg, ULONG id)
;|***    *    returns the enable state of control #id.
;|***    *
;|***    ***************************************************************************/
;|***    #define WinIsControlEnabled(hwndDlg, id) \
;|***    ((BOOL)WinIsWindowEnabled(WinWindowFromID(hwndDlg, id)))
;|*** 
;|*** #endif /* Dialog Manager COMMON subsection */
;|*** 
;|*** 
;|*** #ifdef INCL_WINDIALOGS
;|*** 
;|***    /* Dialog codes: returned by WM_QUERYDLGCODE msg     */
;|*** 
;|***    #define DLGC_ENTRYFIELD    0x0001  /* Entry field item understands EM_SETSEL) */
;|***    #define DLGC_BUTTON        0x0002  /* Button item                             */
;|***    #define DLGC_RADIOBUTTON   0x0004  /* Radio button                            */
;|***    #define DLGC_STATIC        0x0008  /* Static item                             */
;|***    #define DLGC_DEFAULT       0x0010  /* Default push button                     */
;|***    #define DLGC_PUSHBUTTON    0x0020  /* Normal (Non-default) push button        */
;|***    #define DLGC_CHECKBOX      0x0040  /* Check box button control                */
;|***    #define DLGC_SCROLLBAR     0x0080  /* Scroll bar                              */
;|***    #define DLGC_MENU          0x0100  /* Menu                                    */
;|***    #define DLGC_TABONCLICK    0x0200
;|***    #define DLGC_MLE           0x0400  /* Multiple Line Entry                     */
;|*** 
;|*** 
;|***    #ifdef INCL_32
;|***       ULONG  APIENTRY WinProcessDlg(HWND hwndDlg);
;|***       MRESULT APIENTRY WinSendDlgItemMsg(HWND hwndDlg,
;|***                                          ULONG idItem,
;|***                                          ULONG msg,
;|***                                          MPARAM mp1,
;|***                                          MPARAM mp2);
;|***       BOOL    APIENTRY WinMapDlgPoints(HWND hwndDlg,
;|***                                        PPOINTL prgwptl,
;|***                                        ULONG cwpt,
;|***                                        BOOL fCalcWindowCoords);
;|***       HWND    APIENTRY WinEnumDlgItem(HWND hwndDlg,
;|***                                       HWND hwnd,
;|***                                       ULONG code);
;|***       LONG   APIENTRY WinSubstituteStrings(HWND hwnd,
;|***                                            PSZ pszSrc,
;|***                                            LONG cchDstMax,
;|***                                            PSZ pszDst);
;|***    #else
;|***       USHORT  APIENTRY WinProcessDlg(HWND hwndDlg);
;|***       MRESULT APIENTRY WinSendDlgItemMsg(HWND hwndDlg,
;|***                                          USHORT idItem,
;|***                                          USHORT msg,
;|***                                          MPARAM mp1,
;|***                                          MPARAM mp2);
;|***       BOOL    APIENTRY WinMapDlgPoints(HWND hwndDlg,
;|***                                        PPOINTL prgwptl,
;|***                                        USHORT cwpt,
;|***                                        BOOL fCalcWindowCoords);
;|***       HWND    APIENTRY WinEnumDlgItem(HWND hwndDlg,
;|***                                       HWND hwnd,
;|***                                       USHORT code,
;|***                                       BOOL fLock);
;|***       SHORT   APIENTRY WinSubstituteStrings(HWND hwnd,
;|***                                             PSZ pszSrc,
;|***                                             SHORT cchDstMax,
;|***                                             PSZ pszDst);
;|***    #endif  /* INCL_32 */
;|*** 
;|*** 
;|***    /* WinEnumDlgItem() constants */
;|*** 
;|***    #define EDI_FIRSTTABITEM           0
;|***    #define EDI_LASTTABITEM            1
;|***    #define EDI_NEXTTABITEM            2
;|***    #define EDI_PREVTABITEM            3
;|***    #define EDI_FIRSTGROUPITEM         4
;|***    #define EDI_LASTGROUPITEM          5
;|***    #define EDI_NEXTGROUPITEM          6
;|***    #define EDI_PREVGROUPITEM          7
;|*** 
;|***    /*** Dialog template definitions */
;|*** 
;|***    /*** Variable-sized dialog template items: ******************************/
;|*** 
;|***    #pragma pack(2) /* force structure alignment packing */
;|*** 
;|***    /*************************************************************************
;|***    *
;|***    *  We pack the structures _DLGTITEM and _DLGTEMPLATE so that the
;|***    *  structures are identical in the 32-bit and 16-bit worlds. We have
;|***    *  to do this because is has been documented that one can pass a
;|***    *  pointer to 'the binary resource format' when calling WinCreateDlg.
;|***    *
;|***    *************************************************************************/
;|*** 
;|***    /* Binary resources may be bound into application executables or */
;|***    /* passed as a parameter when creating a window or dialog        */
;|***    /* Currently they must be the same for both 16-bit and 32-bit    */
;|***    /* so we pack the structures.                                    */
;|***    typedef struct _DLGTITEM {  /* dlgti */
;|***       USHORT  fsItemStatus;
;|***       USHORT  cChildren;
;|***       USHORT  cchClassName;
;|***       USHORT  offClassName;
;|***       USHORT  cchText;
;|***       USHORT  offText;
;|***       ULONG   flStyle;
;|***       SHORT   x;
;|***       SHORT   y;
;|***       SHORT   cx;
;|***       SHORT   cy;
;|***       USHORT  id;
;|***       USHORT  offPresParams;
;|***       USHORT  offCtlData;
;|***    } DLGTITEM;
;|***    typedef DLGTITEM FAR *PDLGTITEM;
;|*** 
;|***    /*** Dialog Template structure ******************************************/
;|*** 
;|***    /* Binary resources may be bound into application executables or */
;|***    /* passed as a parameter when creating a window or dialog        */
;|***    /* Currently they must be the same for both 16-bit and 32-bit    */
;|***    /* so we pack the structures.                                    */
;|***    typedef struct _DLGTEMPLATE {  /* dlgt */
;|***       USHORT   cbTemplate;
;|***       USHORT   type;
;|***       USHORT   codepage;
;|***       USHORT   offadlgti;
;|***       USHORT   fsTemplateStatus;
;|***       USHORT   iItemFocus;
;|***       USHORT   coffPresParams;
;|***       DLGTITEM adlgti[1];
;|***    } DLGTEMPLATE;
;|***    typedef DLGTEMPLATE FAR *PDLGTEMPLATE;
;|*** 
;|***    #pragma pack()  /* restore packing to default */
;|*** 
;|***    HWND   APIENTRY WinCreateDlg(HWND hwndParent,
;|***                                 HWND hwndOwner,
;|***                                 PFNWP pfnDlgProc,
;|***                                 PDLGTEMPLATE pdlgt,
;|***                                 PVOID pCreateParams);
;|*** 
;|*** 
;|*** #endif /* INCL_WINDIALOGS */
;|*** 
;|*** 
;|*** #ifdef INCL_WINSTATICS
;|*** 
;|***    /*** Static Control Manager */
;|*** 
;|***    /* Static control styles:
;|***    *
;|***    * NOTE: the top 9 bits of the LOWORD of the window flStyle are used for
;|***    * DT_* flags.  The lower 7 bits are for SS_* styles.  This gives us up
;|***    * to 128 distinct static control types (we currently use 11 of them).
;|***    */
;|***    #define SS_TEXT                    0x0001L
;|***    #define SS_GROUPBOX                0x0002L
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #define SS_ICON                    0x0003L
;|***       #define SS_BITMAP                  0x0004L
;|***    #endif /* !INCL_SAADEFS */
;|***    #define SS_FGNDRECT                0x0005L
;|***    #ifndef INCL_SAADEFS
;|***       #define SS_HALFTONERECT            0x0006L
;|***    #endif /* !INCL_SAADEFS */
;|***    #define SS_BKGNDRECT               0x0007L
;|***    #define SS_FGNDFRAME               0x0008L
;|***    #ifndef INCL_SAADEFS
;|***       #define SS_HALFTONEFRAME           0x0009L
;|***    #endif /* !INCL_SAADEFS */
;|***    #define SS_BKGNDFRAME              0x000aL
;|***    #define SS_SYSICON                 0x000bL
;|***    #define SS_AUTOSIZE         0x0040L
;|*** 
;|*** 
;|***    /* Static control messages */
;|*** 
;|***    #define SM_SETHANDLE               0x0100
;|***    #define SM_QUERYHANDLE             0x0101
;|*** 
;|***    /* Message Box 2 notification messages */
;|***    #define WM_MSGBOXINIT              0x010E
;|***    #define WM_MSGBOXDISMISS           0x010F
;|*** #endif /* INCL_WINSTATICS */
;|*** 
;|*** 
;|*** #ifdef INCL_WINBUTTONS
;|***    /**** Button Controls Subsection */
;|*** 
;|***    /* Button control styles */
;|*** 
;|***    #define BS_PUSHBUTTON              0L
;|***    #define BS_CHECKBOX                1L
;|***    #define BS_AUTOCHECKBOX            2L
;|***    #define BS_RADIOBUTTON             3L
;|***    #define BS_AUTORADIOBUTTON         4L
;|***    #define BS_3STATE                  5L
;|***    #define BS_AUTO3STATE              6L
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #define BS_USERBUTTON              7L
;|***    #endif /* !INCL_SAADEFS */
;|***    #define BS_PRIMARYSTYLES       0x000fL
;|*** 
;|***    #define BS_TEXT                 0x0010
;|***    #define BS_MINIICON             0x0020
;|***    #define BS_BITMAP           0x0040L
;|***    #define BS_ICON             0x0080L
;|***    #define BS_HELP                    0x0100L
;|***    #define BS_SYSCOMMAND              0x0200L
;|***    #define BS_DEFAULT                 0x0400L
;|***    #define BS_NOPOINTERFOCUS          0x0800L
;|***    #define BS_NOBORDER                0x1000L
;|***    #define BS_NOCURSORSELECT          0x2000L
;|***    #define BS_AUTOSIZE             0x4000L
;|*** 
;|*** 
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #pragma pack(2) /* force structure alignment packing */
;|*** 
;|***       /* Binary resources may be bound into application executables or */
;|***       /* passed as a parameter when creating a window or dialog        */
;|***       /* Currently they must be the same for both 16-bit and 32-bit    */
;|***       /* so we pack the structures.                                    */
;|***       typedef struct _BTNCDATA {  /* btncd */
;|***          USHORT  cb;
;|***          USHORT  fsCheckState;
;|***          USHORT  fsHiliteState;
;|***          LHANDLE hImage;
;|***       } BTNCDATA;
;|***       typedef BTNCDATA FAR *PBTNCDATA;
;|*** 
;|***       #pragma pack()  /* restore packing to default */
;|*** 
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    /*** User button structure (passed in WM_CONTROL msg) *******************/
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #ifdef INCL_32
;|***          typedef struct _USERBUTTON {  /* ubtn */
;|***             HWND    hwnd;
;|***             HPS     hps;
;|***             ULONG   fsState;
;|***             ULONG   fsStateOld;
;|***          } USERBUTTON;
;|***       #else
;|***          typedef struct _USERBUTTON {  /* ubtn */
;|***             HWND    hwnd;
;|***             HPS     hps;
;|***             USHORT  fsState;
;|***             USHORT  fsStateOld;
;|***          } USERBUTTON;
;|***       #endif
;|***       typedef USERBUTTON FAR *PUSERBUTTON;
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    /* Button control messages */
;|*** 
;|***    #define BM_CLICK                   0x0120
;|***    #define BM_QUERYCHECKINDEX         0x0121
;|***    #define BM_QUERYHILITE             0x0122
;|***    #define BM_SETHILITE               0x0123
;|***    #define BM_QUERYCHECK              0x0124
;|***    #define BM_SETCHECK                0x0125
;|***    #define BM_SETDEFAULT              0x0126
;|*** 
;|***    /* Button notification codes */
;|*** 
;|***    #define BN_CLICKED                 1
;|***    #define BN_DBLCLICKED              2
;|***    #define BN_PAINT                   3
;|*** 
;|***    /* BN_PAINT button draw state codes (must be in high byte) */
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #define BDS_HILITED                0x0100
;|***       #define BDS_DISABLED               0x0200
;|***       #define BDS_DEFAULT                0x0400
;|*** 
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|*** #endif /* INCL_WINBUTTONS */
;|*** 
;|*** 
;|*** #ifdef INCL_WINENTRYFIELDS
;|***    /**** Entryfield controls Subsection */
;|*** 
;|***    /* Entry field  styles */
;|*** 
;|***    #define ES_LEFT                    0x00000000L
;|***    #define ES_CENTER                  0x00000001L
;|***    #define ES_RIGHT                   0x00000002L
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #define ES_AUTOSCROLL              0x00000004L
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    #define ES_MARGIN                  0x00000008L
;|***    #define ES_AUTOTAB                 0x00000010L
;|***    #define ES_READONLY                0x00000020L
;|***    #define ES_COMMAND                 0x00000040L
;|***    #define ES_UNREADABLE              0x00000080L
;|***    #define ES_AUTOSIZE                0x00000200L
;|*** 
;|***    #ifdef INCL_NLS
;|***       #define ES_ANY                     0x00000000L
;|***       #define ES_SBCS                    0x00001000L
;|***       #define ES_DBCS                    0x00002000L
;|***       #define ES_MIXED                   0x00003000L
;|***    #endif /* INCL_NLS */
;|*** 
;|*** 
;|***    /*
;|***    * combo box styles
;|***    */
;|***    #define CBS_SIMPLE                 0x0001L
;|***    #define CBS_DROPDOWN               0x0002L
;|***    #define CBS_DROPDOWNLIST           0x0004L
;|*** 
;|***    /*
;|***    * Use this bit for drop down combo boxes that do not want to
;|***    * receive a CBN_ENTER on a single click in their list boxes.
;|***    * This is for compatibility with releases prior to OS/2 2.0 which
;|***    * did not send this message
;|***    */
;|***    #define CBS_COMPATIBLE             0x0008L
;|*** 
;|***    /*
;|***    * The following edit and listbox styles may be used in conjunction
;|***    * with CBS_ styles
;|***    * ES_AUTOTAB ES_ANY ES_SBCS ES_DBCS ES_MIXED LS_HORZSCROLL
;|***    */
;|*** 
;|***    /*
;|***    * IDs of combobox entry field and listbox.
;|***    */
;|***    #define CBID_LIST                  0x029A
;|***    #define CBID_EDIT                  0x029B
;|*** 
;|***    #define CBM_SHOWLIST               0x0170
;|***    #define CBM_HILITE                 0x0171
;|***    #define CBM_ISLISTSHOWING          0x0172
;|*** 
;|***    #define CBN_EFCHANGE               1
;|***    #define CBN_EFSCROLL               2
;|***    #define CBN_MEMERROR               3
;|***    #define CBN_LBSELECT               4
;|***    #define CBN_LBSCROLL               5
;|***    #define CBN_SHOWLIST               6
;|***    #define CBN_ENTER                  7
;|*** 
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #pragma pack(2) /* force structure alignment packing */
;|*** 
;|***       /* Binary resources may be bound into application executables or */
;|***       /* passed as a parameter when creating a window or dialog        */
;|***       /* Currently they must be the same for both 16-bit and 32-bit    */
;|***       /* so we pack the structures.                                    */
;|*** 
;|***       /*******************************************************************/
;|***       /* Combobox control data structure                                 */
;|***       /*******************************************************************/
;|***       typedef struct _COMBOCDATA          /* combocdata */
;|***       {
;|***          ULONG   cbSize;             /* Size of control block             */
;|***          ULONG   reserved;           /* reserved field                    */
;|***          PVOID   pHWXCtlData;        /* reserved for Pen CtlData (penpm.h)*/
;|***       } COMBOCDATA;
;|***       typedef COMBOCDATA *PCOMBOCDATA;
;|*** 
;|***       typedef struct _ENTRYFDATA {  /* efd */
;|***          USHORT  cb;
;|***          USHORT  cchEditLimit;
;|***          USHORT  ichMinSel;
;|***          USHORT  ichMaxSel;
;|***          PVOID   pHWXCtlData;    /* reserved for Pen CtlData (penpm.h)  */
;|***       } ENTRYFDATA;
;|***       typedef ENTRYFDATA FAR *PENTRYFDATA;
;|*** 
;|***       #pragma pack()  /* restore packing to default */
;|*** 
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    /* Entry Field  messages */
;|*** 
;|***    #define EM_QUERYCHANGED            0x0140
;|***    #define EM_QUERYSEL                0x0141
;|***    #define EM_SETSEL                  0x0142
;|***    #define EM_SETTEXTLIMIT            0x0143
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #define EM_CUT                     0x0144
;|***       #define EM_COPY                    0x0145
;|***    #endif /* !INCL_SAADEFS */
;|***    #define EM_CLEAR                   0x0146
;|***    #ifndef INCL_SAADEFS
;|***       #define EM_PASTE                   0x0147
;|***    #endif /* !INCL_SAADEFS */
;|***    #define EM_QUERYFIRSTCHAR          0x0148
;|***    #define EM_SETFIRSTCHAR            0x0149
;|***    #ifndef INCL_SAADEFS
;|***       #define EM_QUERYREADONLY           0x014a
;|***       #define EM_SETREADONLY             0x014b
;|***       #define EM_SETINSERTMODE           0x014c
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    /* Entry Field notification messages */
;|*** 
;|***    #define EN_SETFOCUS                0x0001
;|***    #define EN_KILLFOCUS               0x0002
;|***    #define EN_CHANGE                  0x0004
;|***    #define EN_SCROLL                  0x0008
;|***    #ifndef INCL_SAADEFS
;|***       #define EN_MEMERROR                0x0010
;|***       #define EN_OVERFLOW                0x0020
;|***       #define EN_INSERTMODETOGGLE        0x0040
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|*** #endif /* INCL_WINENTRYFIELDS */
;|*** 
;|*** 
;|*** /*  Multiple Line Entrys */
;|*** #ifdef INCL_WINMLE
;|***    #include <pmmle.h>
;|*** #endif /* !INCL_WINMLE */
;|*** #ifdef INCL_WINLISTBOXES
;|*** 
;|***    /**** Listboxes */
;|*** 
;|***    /* List box styles */
;|*** 
;|***    #define LS_MULTIPLESEL             0x00000001L
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #define LS_OWNERDRAW               0x00000002L
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    #define LS_NOADJUSTPOS             0x00000004L
;|***    #define LS_HORZSCROLL              0x00000008L
;|*** 
;|***    #define LS_EXTENDEDSEL             0x00000010L
;|*** 
;|*** 
;|***    /* List box notification messages */
;|*** 
;|***    #define LN_SELECT                  1
;|***    #define LN_SETFOCUS                2
;|***    #define LN_KILLFOCUS               3
;|***    #define LN_SCROLL                  4
;|***    #define LN_ENTER                   5
;|*** 
;|***    /* List box messages */
;|*** 
;|***    #define LM_QUERYITEMCOUNT          0x0160
;|***    #define LM_INSERTITEM              0x0161
;|***    #define LM_SETTOPINDEX             0x0162
;|***    #define LM_DELETEITEM              0x0163
;|***    #define LM_SELECTITEM              0x0164
;|***    #define LM_QUERYSELECTION          0x0165
;|***    #define LM_SETITEMTEXT             0x0166
;|***    #define LM_QUERYITEMTEXTLENGTH     0x0167
;|***    #define LM_QUERYITEMTEXT           0x0168
;|*** 
;|***    #define LM_SETITEMHANDLE           0x0169
;|***    #define LM_QUERYITEMHANDLE         0x016a
;|***    #define LM_SEARCHSTRING            0x016b
;|***    #define LM_SETITEMHEIGHT           0x016c
;|***    #define LM_QUERYTOPINDEX           0x016d
;|***    #define LM_DELETEALL               0x016e
;|***    #define LM_INSERTMULTITEMS         0x016f
;|***    #define LM_SETITEMWIDTH            0x0660
;|*** 
;|*** 
;|***    /* List box constants */
;|*** 
;|***    #define LIT_CURSOR         (-4)
;|***    #define LIT_ERROR                  (-3)
;|***    #define LIT_MEMERROR               (-2)
;|***    #define LIT_NONE                   (-1)
;|***    #define LIT_FIRST                  (-1)
;|*** 
;|***    /* For LM_INSERTITEM msg */
;|*** 
;|***    #define LIT_END                    (-1)
;|***    #define LIT_SORTASCENDING          (-2)
;|***    #define LIT_SORTDESCENDING         (-3)
;|*** 
;|***    /* For LM_SEARCHSTRING msg */
;|*** 
;|***    #define LSS_SUBSTRING              0x0001
;|***    #define LSS_PREFIX                 0x0002
;|***    #define LSS_CASESENSITIVE          0x0004
;|*** 
;|***    /*******************************************************************/
;|***    /* Structure for use with LM_INSERTMULTITEMS                       */
;|***    /*******************************************************************/
;|*** 
;|***    typedef struct _LBOXINFO         /* lboxinfo */
;|***    {
;|***        LONG  lItemIndex;            /* Item index */
;|***        ULONG ulItemCount;           /* Item count */
;|***        ULONG reserved;              /* Reserved - must be zero */
;|***        ULONG reserved2;             /* Reserved - must be zero */
;|***    } LBOXINFO;
;|*** 
;|***    typedef LBOXINFO * PLBOXINFO;
;|*** 
;|***    /* Useful macros */
;|*** 
;|***    /***************************************************************************
;|***    * LONG/SHORT WinDeleteLboxItem(HWND hwndLbox, LONG/SHORT index)
;|***    *    deletes item index from the listbox.
;|***    *    returns the number of items left.
;|***    ***************************************************************************/
;|***    #ifdef INCL_32
;|***       #define WinDeleteLboxItem(hwndLbox, index) \
;|***       ((LONG)WinSendMsg(hwndLbox, LM_DELETEITEM, MPFROMLONG(index), \
;|***       (MPARAM)NULL))
;|***    #else
;|***       #define WinDeleteLboxItem(hwndLbox, index) \
;|***       ((SHORT)WinSendMsg(hwndLbox, LM_DELETEITEM, MPFROMSHORT(index), \
;|***       (MPARAM)NULL))
;|***    #endif
;|*** 
;|***    /***************************************************************************
;|***    * LONG/SHORT WinInsertLboxItem(HWND hwndLbox, LONG/SHORT index, PSZ psz)
;|***    *    inserts psz into a listbox at index.  Index may be an LIT_ constant.
;|***    *    returns the actual index where it was inserted.
;|***    ***************************************************************************/
;|***    #ifdef INCL_32
;|***       #define WinInsertLboxItem(hwndLbox, index, psz) \
;|***       ((LONG)WinSendMsg(hwndLbox, LM_INSERTITEM, MPFROMLONG(index), \
;|***       MPFROMP(psz)))
;|***    #else
;|***       #define WinInsertLboxItem(hwndLbox, index, psz) \
;|***       ((SHORT)WinSendMsg(hwndLbox, LM_INSERTITEM, MPFROMSHORT(index), \
;|***       MPFROMP(psz)))
;|***    #endif
;|*** 
;|***    /***************************************************************************
;|***    * LONG/SHORT WinQueryLboxCount(HWND hwndLbox)
;|***    *    returns the number of items in the listbox.
;|***    *
;|***    ***************************************************************************/
;|***    #ifdef INCL_32
;|***       #define WinQueryLboxCount(hwndLbox) \
;|***       ((LONG)WinSendMsg(hwndLbox, LM_QUERYITEMCOUNT, (MPARAM)NULL, \
;|***       (MPARAM)NULL))
;|***    #else
;|***       #define WinQueryLboxCount(hwndLbox) \
;|***       ((SHORT)WinSendMsg(hwndLbox, LM_QUERYITEMCOUNT, (MPARAM)NULL, \
;|***       (MPARAM)NULL))
;|***    #endif
;|*** 
;|***    /***************************************************************************
;|***    * LONG/SHORT WinQueryLboxItemText(HWND hwndLbox, LONG/SHORT index, PSZ psz, SHORT cchMax)
;|***    *    fills psz with the text if item index.
;|***    *    returns the text length copied.
;|***    ***************************************************************************/
;|***    #ifdef INCL_32
;|***       #define WinQueryLboxItemText(hwndLbox, index, psz, cchMax) \
;|***       ((LONG)WinSendMsg(hwndLbox, LM_QUERYITEMTEXT, \
;|***       MPFROM2SHORT((index), (cchMax)), MPFROMP(psz)))
;|***    #else
;|***       #define WinQueryLboxItemText(hwndLbox, index, psz, cchMax) \
;|***       ((SHORT)WinSendMsg(hwndLbox, LM_QUERYITEMTEXT, \
;|***       MPFROM2SHORT((index), (cchMax)), MPFROMP(psz)))
;|***    #endif
;|*** 
;|***    /***************************************************************************
;|***    * LONG/SHORT WinQueryLboxItemTextLength(HWND hwndLbox, LONG/SHORT index)
;|***    *    returns the length of item index.
;|***    *
;|***    ***************************************************************************/
;|***    #ifdef INCL_32
;|***       #define WinQueryLboxItemTextLength(hwndLbox, index)         \
;|***       ((SHORT)WinSendMsg(hwndLbox, LM_QUERYITEMTEXTLENGTH,    \
;|***       MPFROMSHORT(index), (MPARAM)NULL))
;|***    #else
;|***       #define WinQueryLboxItemTextLength(hwndLbox, index)         \
;|***       ((SHORT)WinSendMsg(hwndLbox, LM_QUERYITEMTEXTLENGTH,    \
;|***       MPFROMSHORT(index), (MPARAM)NULL))
;|***    #endif
;|*** 
;|***    /***************************************************************************
;|***    * BOOL WinSetLboxItemText(HWND hwndLbox, LONG/SHORT index, PSZ psz)
;|***    *    sets the text of item index to psz.
;|***    *    returns fSuccess.
;|***    ***************************************************************************/
;|***    #ifdef INCL_32
;|***       #define WinSetLboxItemText(hwndLbox, index, psz) \
;|***       ((BOOL)WinSendMsg(hwndLbox, LM_SETITEMTEXT, \
;|***       MPFROMLONG(index), MPFROMP(psz)))
;|***    #else
;|***       #define WinSetLboxItemText(hwndLbox, index, psz) \
;|***       ((BOOL)WinSendMsg(hwndLbox, LM_SETITEMTEXT, \
;|***       MPFROMSHORT(index), MPFROMP(psz)))
;|***    #endif
;|*** 
;|***    /***************************************************************************
;|***    * LONG/SHORT WinQueryLboxSelectedItem(HWND hwndLbox)
;|***    *    returns the item index selected. (for single selection only)
;|***    *
;|***    ***************************************************************************/
;|***    #ifdef INCL_32
;|***       #define WinQueryLboxSelectedItem(hwndLbox) \
;|***       ((LONG)WinSendMsg(hwndLbox, LM_QUERYSELECTION, MPFROMLONG(LIT_FIRST), \
;|***       (MPARAM)NULL))
;|***    #else
;|***       #define WinQueryLboxSelectedItem(hwndLbox) \
;|***       ((SHORT)WinSendMsg(hwndLbox, LM_QUERYSELECTION, MPFROMSHORT(LIT_FIRST), \
;|***       (MPARAM)NULL))
;|***    #endif
;|*** 
;|*** #endif /* INCL_WINLISTBOXES */
;|*** 
;|*** 
;|*** #ifdef INCL_WINMENUS
;|*** 
;|***    /**** Menu Manager Subsection */
;|*** 
;|***    /* Menu control styles */
;|*** 
;|***    #define MS_ACTIONBAR               0x00000001L
;|***    #define MS_TITLEBUTTON             0x00000002L
;|***    #define MS_VERTICALFLIP            0x00000004L
;|*** 
;|***    #define MS_CONDITIONALCASCADE      0x00000040L
;|*** 
;|***    #ifdef INCL_32
;|***       HWND APIENTRY WinLoadMenu(HWND hwndFrame,
;|***                                 HMODULE hmod,
;|***                                 ULONG idMenu);
;|***    #else
;|***       HWND APIENTRY WinLoadMenu(HWND hwndFrame,
;|***                                 HMODULE hmod,
;|***                                 USHORT idMenu);
;|***    #endif
;|*** 
;|*** 
;|***    /* Menu control messages */
;|*** 
;|***    #define MM_INSERTITEM              0x0180
;|***    #define MM_DELETEITEM              0x0181
;|***    #define MM_QUERYITEM               0x0182
;|***    #define MM_SETITEM                 0x0183
;|***    #define MM_QUERYITEMCOUNT          0x0184
;|***    #define MM_STARTMENUMODE           0x0185
;|***    #define MM_ENDMENUMODE             0x0186
;|***    #define MM_REMOVEITEM              0x0188
;|***    #define MM_SELECTITEM              0x0189
;|***    #define MM_QUERYSELITEMID          0x018a
;|***    #define MM_QUERYITEMTEXT           0x018b
;|***    #define MM_QUERYITEMTEXTLENGTH     0x018c
;|***    #define MM_SETITEMHANDLE           0x018d
;|***    #define MM_SETITEMTEXT             0x018e
;|***    #define MM_ITEMPOSITIONFROMID      0x018f
;|***    #define MM_ITEMIDFROMPOSITION      0x0190
;|***    #define MM_QUERYITEMATTR           0x0191
;|***    #define MM_SETITEMATTR             0x0192
;|***    #define MM_ISITEMVALID             0x0193
;|***    #define MM_QUERYITEMRECT           0x0194
;|*** 
;|***    #define MM_QUERYDEFAULTITEMID      0x0431
;|***    #define MM_SETDEFAULTITEMID        0x0432
;|*** 
;|***    #ifndef MTI_INCLUDED
;|***       #define MTI_INCLUDED
;|*** 
;|***       typedef struct _mti {   /* mti */
;|***          USHORT afStyle;      /* Style Flags      */
;|***          USHORT pad;          /* pad for template */
;|***          USHORT idItem;       /* Item ID          */
;|***          CHAR   c[2];         /*                  */
;|***       } MTI;
;|*** 
;|***       typedef struct _mt {    /* mt */
;|***          ULONG  len;          /* Length of template in bytes */
;|***          USHORT codepage;     /* Codepage                    */
;|***          USHORT reserved;     /* Reserved.                   */
;|***          USHORT cMti;         /* Count of template items.    */
;|***          MTI    rgMti[1];     /* Array of template items.    */
;|***       } MT;
;|***       typedef MT FAR * LPMT;
;|*** 
;|***    #endif
;|*** 
;|***    HWND APIENTRY WinCreateMenu(HWND hwndParent,
;|***                                PVOID lpmt);
;|*** 
;|***    /* Owner Item Structure (Also used for listboxes) */
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #ifdef INCL_32
;|***          typedef struct _OWNERITEM {  /* oi */
;|***             HWND    hwnd;
;|***             HPS     hps;
;|***             ULONG   fsState;
;|***             ULONG   fsAttribute;
;|***             ULONG   fsStateOld;
;|***             ULONG   fsAttributeOld;
;|***             RECTL   rclItem;
;|***             LONG    idItem; /* This field contains idItem for menus, iItem for lb. */
;|***             ULONG   hItem;
;|***          } OWNERITEM;
;|***       #else
;|***          typedef struct _OWNERITEM {  /* oi */
;|***             HWND    hwnd;
;|***             HPS     hps;
;|***             USHORT  fsState;
;|***             USHORT  fsAttribute;
;|***             USHORT  fsStateOld;
;|***             USHORT  fsAttributeOld;
;|***             RECTL   rclItem;
;|***             SHORT   idItem; /* This field contains idItem for menus, iItem for lb. */
;|***             ULONG   hItem;
;|***          } OWNERITEM;
;|***       #endif
;|***       typedef OWNERITEM FAR *POWNERITEM;
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    /* Menu item */
;|*** 
;|***    #pragma pack(2) /* force structure alignment packing */
;|*** 
;|***    /* Binary resources may be bound into application executables or */
;|***    /* passed as a parameter when creating a window or dialog        */
;|***    /* Currently they must be the same for both 16-bit and 32-bit    */
;|***    /* so we pack the structures.                                    */
;|***    typedef struct _MENUITEM {  /* mi */
;|***       SHORT   iPosition;
;|***       USHORT  afStyle;
;|***       USHORT  afAttribute;
;|***       USHORT  id;
;|***       HWND    hwndSubMenu;
;|***       ULONG   hItem;
;|***    } MENUITEM;
;|***    typedef MENUITEM FAR *PMENUITEM;
;|*** 
;|***    #pragma pack()  /* restore packing to default */
;|*** 
;|***    #define MIT_END                    (-1)
;|***    #define MIT_NONE                   (-1)
;|***    #define MIT_MEMERROR               (-1)
;|***    #define MIT_ERROR                  (-1)
;|***    #define MIT_FIRST                  (-2)
;|***    #define MIT_LAST                   (-3)
;|***    #define MID_NONE                   MIT_NONE
;|***    #define MID_ERROR                  (-1)
;|*** 
;|***    /* Menu item styles & attributes */
;|*** 
;|***    #define MIS_TEXT                   0x0001
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #define MIS_BITMAP                 0x0002
;|***    #endif /* !INCL_SAADEFS */
;|***    #define MIS_SEPARATOR              0x0004
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #define MIS_OWNERDRAW              0x0008
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    #define MIS_SUBMENU                0x0010
;|***    #define MIS_MULTMENU               0x0020      /* multiple choice submenu     */
;|***    #define MIS_SYSCOMMAND             0x0040
;|***    #define MIS_HELP                   0x0080
;|***    #define MIS_STATIC                 0x0100
;|***    #define MIS_BUTTONSEPARATOR        0x0200
;|***    #define MIS_BREAK                  0x0400
;|***    #define MIS_BREAKSEPARATOR         0x0800
;|***    #define MIS_GROUP                  0x1000      /* multiple choice group start */
;|***    /* In multiple choice submenus a style of 'single' denotes the item is a
;|***    ** radiobutton.  Absence of this style defaults the item to a checkbox.       */
;|***    #define MIS_SINGLE                 0x2000
;|*** 
;|***    #define MIA_NODISMISS              0x0020
;|***    #define MIA_FRAMED                 0x1000
;|***    #define MIA_CHECKED                0x2000
;|***    #define MIA_DISABLED               0x4000
;|***    #define MIA_HILITED                0x8000
;|*** 
;|*** 
;|***    #ifdef INCL_32
;|***       BOOL APIENTRY WinPopupMenu(HWND hwndParent,
;|***                                  HWND hwndOwner,
;|***                                  HWND hwndMenu,
;|***                                  LONG x,
;|***                                  LONG y,
;|***                                  LONG idItem,
;|***                                  ULONG fs);
;|***    #else
;|***       BOOL APIENTRY WinPopupMenu(HWND hwndParent,
;|***                                  HWND hwndOwner,
;|***                                  HWND hwndMenu,
;|***                                  SHORT x,
;|***                                  SHORT y,
;|***                                  SHORT idItem,
;|***                                  USHORT fs);
;|***    #endif
;|*** 
;|***    /* Values of fs in WinPopupMenu call */
;|*** 
;|***    #define PU_POSITIONONITEM          0x0001 /* Need idItem parameter */
;|*** 
;|***    #define PU_HCONSTRAIN              0x0002 /* Keep menu on left and right edge */
;|***    #define PU_VCONSTRAIN              0x0004 /* Keep menu on top and bottom edge */
;|*** 
;|***    #define PU_NONE                    0x0000 /* If invoked by keyboard */
;|***    #define PU_MOUSEBUTTON1DOWN        0x0008 /* If invoked by button 1 */
;|***    #define PU_MOUSEBUTTON2DOWN        0x0010 /* If invoked by button 2 */
;|***    #define PU_MOUSEBUTTON3DOWN        0x0018 /* If invoked by button 3 */
;|*** 
;|***    #define PU_SELECTITEM              0x0020 /* Set selected item (use with kbd) */
;|*** 
;|***    #define PU_MOUSEBUTTON1            0x0040 /* If button1 use allowed */
;|***    #define PU_MOUSEBUTTON2            0x0080 /* If button2 use allowed */
;|***    #define PU_MOUSEBUTTON3            0x0100 /* If button3 use allowed */
;|***    #define PU_KEYBOARD                0x0200 /* If keyboard use allowed */
;|*** 
;|*** 
;|***    /* Useful macros */
;|*** 
;|***    /***************************************************************************
;|***    * BOOL WinCheckMenuItem(HWND hwndMenu, ULONG/USHORT id, BOOL fcheck)
;|***    *    Sets the check state of menuitem #id to fcheck.
;|***    *    returns fSuccess.
;|***    ***************************************************************************/
;|***    #define WinCheckMenuItem(hwndMenu, id, fcheck) \
;|***    ((BOOL)WinSendMsg(hwndMenu, MM_SETITEMATTR, \
;|***    MPFROM2SHORT(id, TRUE), \
;|***    MPFROM2SHORT(MIA_CHECKED, (USHORT)(fcheck) ? MIA_CHECKED : 0)))
;|*** 
;|***    /***************************************************************************
;|***    * BOOL WinIsMenuItemChecked(HWND hwndMenu, USHORT/ULONG id)
;|***    *    returns the check state of menuitem #id.
;|***    *
;|***    ***************************************************************************/
;|***    #ifdef INCL_32
;|***       #define WinIsMenuItemChecked(hwndMenu, id) \
;|***       ((BOOL)WinSendMsg(hwndMenu, MM_QUERYITEMATTR, \
;|***       MPFROM2SHORT(id, TRUE), \
;|***       MPFROMLONG(MIA_CHECKED)))
;|***    #else
;|***       #define WinIsMenuItemChecked(hwndMenu, id) \
;|***       ((BOOL)WinSendMsg(hwndMenu, MM_QUERYITEMATTR, \
;|***       MPFROM2SHORT(id, TRUE), \
;|***       MPFROMSHORT(MIA_CHECKED)))
;|***    #endif
;|*** 
;|***    /***************************************************************************
;|***    * BOOL WinEnableMenuItem(HWND hwndMenu, ULONG/USHORT id, BOOL fenable)
;|***    *    sets the enable state of menuitem #id to fenable.
;|***    *    returns fSuccess.
;|***    ***************************************************************************/
;|***    #define WinEnableMenuItem(hwndMenu, id, fEnable) \
;|***    ((BOOL)WinSendMsg(hwndMenu, MM_SETITEMATTR, \
;|***    MPFROM2SHORT(id, TRUE), \
;|***    MPFROM2SHORT(MIA_DISABLED, (USHORT)(fEnable) ? 0 : MIA_DISABLED)))
;|*** 
;|***    /***************************************************************************
;|***    * BOOL WinIsMenuItemEnabled(HWND hwndMenu, USHORT/ULONG id)
;|***    *    returns the enable state of menuitem #id.
;|***    *
;|***    ***************************************************************************/
;|***    #ifdef INCL_32
;|***       #define WinIsMenuItemEnabled(hwndMenu, id)  \
;|***       (!(BOOL)WinSendMsg(hwndMenu, MM_QUERYITEMATTR, \
;|***       MPFROM2SHORT(id, TRUE), \
;|***       MPFROMLONG(MIA_DISABLED)))
;|***    #else
;|***       #define WinIsMenuItemEnabled(hwndMenu, id)  \
;|***       (!(BOOL)WinSendMsg(hwndMenu, MM_QUERYITEMATTR, \
;|***       MPFROM2SHORT(id, TRUE), \
;|***       MPFROMSHORT(MIA_DISABLED)))
;|***    #endif
;|*** 
;|***    /***************************************************************************
;|***    * BOOL WinSetMenuItemText(HWND hwndMenu, ULONG/USHORT id, PSZ psz)
;|***    *    sets the text of menuitem #id.
;|***    *    returns fSuccess.
;|***    ***************************************************************************/
;|***    #ifdef INCL_32
;|***       #define WinSetMenuItemText(hwndMenu, id, psz) \
;|***       ((BOOL)WinSendMsg(hwndMenu, MM_SETITEMTEXT, \
;|***       MPFROMLONG(id), MPFROMP(psz)))
;|***    #else
;|***       #define WinSetMenuItemText(hwndMenu, id, psz) \
;|***       ((BOOL)WinSendMsg(hwndMenu, MM_SETITEMTEXT, \
;|***       MPFROMSHORT(id), MPFROMP(psz)))
;|***    #endif
;|*** 
;|***    /***************************************************************************
;|***    * BOOL WinIsMenuItemValid(HWND hwndMenu, ULONG/USHORT id)
;|***    *    Returns TRUE if the specified item is a valid choice.
;|***    ***************************************************************************/
;|***    #ifdef INCL_32
;|***       #define WinIsMenuItemValid(hwndMenu, id) \
;|***       ((BOOL)WinSendMsg(hwndMenu, MM_ISITEMVALID, \
;|***       MPFROM2SHORT(id, TRUE), MPFROMLONG(FALSE)))
;|***    #else
;|***       #define WinIsMenuItemValid(hwndMenu, id) \
;|***       ((BOOL)WinSendMsg(hwndMenu, MM_ISITEMVALID, \
;|***       MPFROM2SHORT(id, TRUE), MPFROMSHORT(FALSE)))
;|***    #endif
;|*** 
;|*** #endif /* INCL_WINMENUS */
;|*** 
;|*** 
;|*** #ifdef INCL_WINSCROLLBARS
;|*** 
;|***    /*** Scroll Bar controls Subsection */
;|*** 
;|***    /* Scroll Bar styles */
;|*** 
;|***    #define SBS_HORZ                   0L
;|***    #define SBS_VERT                   1L
;|***    #define SBS_THUMBSIZE              2L
;|***    #define SBS_AUTOTRACK              4L
;|***    #define SBS_AUTOSIZE        0x2000L
;|*** 
;|*** 
;|*** 
;|***    /* Scroll Bar messages */
;|*** 
;|***    #define SBM_SETSCROLLBAR           0x01a0
;|***    #define SBM_SETPOS                 0x01a1
;|***    #define SBM_QUERYPOS               0x01a2
;|***    #define SBM_QUERYRANGE             0x01a3
;|***    #define SBM_SETTHUMBSIZE           0x01a6
;|*** 
;|***    /* Scroll Bar Commands */
;|*** 
;|***    #define SB_LINEUP                  1
;|***    #define SB_LINEDOWN                2
;|***    #define SB_LINELEFT                1
;|***    #define SB_LINERIGHT               2
;|***    #define SB_PAGEUP                  3
;|***    #define SB_PAGEDOWN                4
;|***    #define SB_PAGELEFT                3
;|***    #define SB_PAGERIGHT               4
;|***    #define SB_SLIDERTRACK             5
;|***    #define SB_SLIDERPOSITION          6
;|***    #define SB_ENDSCROLL               7
;|*** 
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #pragma pack(2) /* force structure alignment packing */
;|*** 
;|***       /* Binary resources may be bound into application executables or */
;|***       /* passed as a parameter when creating a window or dialog        */
;|***       /* Currently they must be the same for both 16-bit and 32-bit    */
;|***       /* so we pack the structures.                                    */
;|***       typedef struct _SBCDATA {  /* sbcd */
;|***          USHORT  cb;
;|***          USHORT  sHilite;      /* reserved, should be set to zero */
;|***          SHORT   posFirst;
;|***          SHORT   posLast;
;|***          SHORT   posThumb;
;|***          SHORT   cVisible;
;|***          SHORT   cTotal;
;|***       } SBCDATA;
;|***       typedef SBCDATA FAR *PSBCDATA;
;|*** 
;|***       #pragma pack()  /* restore packing to default */
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|*** #endif /* INCL_WINSCROLLBARS */
;|*** 
;|*** 
;|*** #if (defined(INCL_WINFRAMEMGR) || !defined(INCL_NOCOMMON))
;|***    /*** Frame Manager Common subsection */
;|*** 
;|***    #pragma pack(2) /* force structure alignment packing */
;|*** 
;|***    /* Binary resources may be bound into application executables or */
;|***    /* passed as a parameter when creating a window or dialog        */
;|***    /* Currently they must be the same for both 16-bit and 32-bit    */
;|***    /* so we pack the structures.                                    */
;|***    typedef struct _FRAMECDATA {  /* fcdata */
;|***       USHORT  cb;
;|***       ULONG   flCreateFlags;
;|***       USHORT  hmodResources;
;|***       USHORT  idResources;
;|***    } FRAMECDATA;
;|***    typedef FRAMECDATA FAR *PFRAMECDATA;
;|*** 
;|***    #pragma pack()  /* restore packing to default */
;|*** 
;|***    /* Frame window styles */
;|***    /* All unused FCF_xxx bits are reserved */
;|***    #define FCF_TITLEBAR               0x00000001L
;|***    #define FCF_SYSMENU                0x00000002L
;|***    #define FCF_MENU                   0x00000004L
;|***    #define FCF_SIZEBORDER             0x00000008L
;|***    #define FCF_MINBUTTON              0x00000010L
;|***    #define FCF_MAXBUTTON              0x00000020L
;|***    #define FCF_MINMAX                 0x00000030L /* minmax means BOTH buttons */
;|***    #define FCF_VERTSCROLL             0x00000040L
;|***    #define FCF_HORZSCROLL             0x00000080L
;|***    #define FCF_DLGBORDER              0x00000100L
;|***    #define FCF_BORDER                 0x00000200L
;|***    #define FCF_SHELLPOSITION          0x00000400L
;|***    #define FCF_TASKLIST               0x00000800L
;|***    #define FCF_NOBYTEALIGN            0x00001000L
;|***    #define FCF_NOMOVEWITHOWNER        0x00002000L
;|***    #define FCF_ICON                   0x00004000L
;|***    #define FCF_ACCELTABLE             0x00008000L
;|***    #define FCF_SYSMODAL               0x00010000L
;|***    #define FCF_SCREENALIGN            0x00020000L
;|***    #define FCF_MOUSEALIGN             0x00040000L
;|***    #define FCF_HIDEBUTTON             0x01000000L
;|***    #define FCF_HIDEMAX                0x01000020L /* hidemax means BOTH buttons */
;|***    #ifdef INCL_16
;|***       /* New values to enable multiple palettes.  Note that if none of the four   */
;|***       /* styles specified below are used then we default to the 'system' palette  */
;|***       #define FCF_PALETTE_NORMAL      0x00080000L /* normal palette            */
;|***       #define FCF_PALETTE_HELP        0x00100000L /* help palette              */
;|***       #define FCF_PALETTE_POPUPODD    0x00200000L /* odd level popup palette   */
;|***       #define FCF_PALETTE_POPUPEVEN   0x00400000L /* even level popup palette  */
;|***    #endif
;|***    #ifdef INCL_NLS
;|***       #define FCF_DBE_APPSTAT         0x80000000L
;|***    #endif /* INCL_NLS */
;|***    #define FCF_AUTOICON               0x40000000L
;|*** 
;|***    #ifdef INCL_32
;|***       /* FCF_TITLEBAR | FCF_SYSMENU | FCF_MENU | FCF_SIZEBORDER | FCF_MINMAX |
;|***       FCF_ICON | FCF_ACCELTABLE | FCF_SHELLPOSITION | FCF_TASKLIST */
;|***       #define FCF_STANDARD            0x0000CC3FL
;|***    #else
;|***       /* FCF_TITLEBAR | FCF_SYSMENU | FCF_MENU | FCF_SIZEBORDER | FCF_MINMAX |
;|***       FCF_ICON | FCF_ACCELTABLE | FCF_SHELLPOSITION | FCF_TASKLIST | FCF_PALETTE_NORMAL */
;|***       #define FCF_STANDARD            0x0008CC3FL
;|***    #endif
;|*** 
;|*** 
;|***    #define FS_ICON                    0x00000001L
;|***    #define FS_ACCELTABLE              0x00000002L
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #define FS_SHELLPOSITION        0x00000004L
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    #define FS_TASKLIST                0x00000008L
;|***    #define FS_NOBYTEALIGN             0x00000010L
;|***    #define FS_NOMOVEWITHOWNER         0x00000020L
;|***    #define FS_SYSMODAL                0x00000040L
;|***    #define FS_DLGBORDER               0x00000080L
;|***    #define FS_BORDER                  0x00000100L
;|***    #define FS_SCREENALIGN             0x00000200L
;|***    #define FS_MOUSEALIGN              0x00000400L
;|***    #define FS_SIZEBORDER              0x00000800L
;|***    #define FS_AUTOICON                0x00001000L
;|***    #ifdef INCL_NLS
;|***       #define FS_DBE_APPSTAT          0x00008000L
;|***    #endif /* INCL_NLS */
;|*** 
;|***    /* FS_ICON | FS_ACCELTABLE | FS_SHELLPOSITION | FS_TASKLIST */
;|***    #define FS_STANDARD                0x0000000FL
;|*** 
;|*** 
;|***    /* Frame Window Flags accessed via WinSet/QueryWindowUShort(QWS_FLAGS) */
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #define FF_FLASHWINDOW             0x0001
;|***       #define FF_ACTIVE                  0x0002
;|***       #define FF_FLASHHILITE             0x0004
;|***       #define FF_OWNERHIDDEN             0x0008
;|***       #define FF_DLGDISMISSED            0x0010
;|***       #define FF_OWNERDISABLED           0x0020
;|***       #define FF_SELECTED                0x0040
;|***       #define FF_NOACTIVATESWP           0x0080
;|***       #define FF_DIALOGBOX               0x0100
;|*** 
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|*** 
;|***    #ifdef INCL_32
;|***       HWND  APIENTRY WinCreateStdWindow(HWND hwndParent,
;|***                                         ULONG flStyle,
;|***                                         PULONG pflCreateFlags,
;|***                                         PSZ pszClientClass,
;|***                                         PSZ pszTitle,
;|***                                         ULONG styleClient,
;|***                                         HMODULE hmod,
;|***                                         ULONG idResources,
;|***                                         PHWND phwndClient);
;|***    #else
;|***       HWND  APIENTRY WinCreateStdWindow(HWND hwndParent,
;|***                                         ULONG flStyle,
;|***                                         PULONG pflCreateFlags,
;|***                                         PSZ pszClientClass,
;|***                                         PSZ pszTitle,
;|***                                         ULONG styleClient,
;|***                                         HMODULE hmod,
;|***                                         USHORT idResources,
;|***                                         PHWND phwndClient);
;|***    #endif
;|*** 
;|*** 
;|*** #endif /* Frame Manager Common subsection */
;|*** 
;|*** 
;|*** #ifdef INCL_WINFRAMEMGR
;|*** 
;|***    BOOL  APIENTRY WinFlashWindow(HWND hwndFrame,
;|***                                  BOOL fFlash);
;|*** 
;|***    /* Frame window related messages */
;|*** 
;|***    #define WM_FLASHWINDOW             0x0040
;|***    #define WM_FORMATFRAME             0x0041
;|***    #define WM_UPDATEFRAME             0x0042
;|***    #define WM_FOCUSCHANGE             0x0043
;|*** 
;|***    #define WM_SETBORDERSIZE           0x0044
;|***    #define WM_TRACKFRAME              0x0045
;|***    #define WM_MINMAXFRAME             0x0046
;|***    #define WM_SETICON                 0x0047
;|***    #define WM_QUERYICON               0x0048
;|***    #define WM_SETACCELTABLE           0x0049
;|***    #define WM_QUERYACCELTABLE         0x004a
;|***    #define WM_TRANSLATEACCEL          0x004b
;|***    #define WM_QUERYTRACKINFO          0x004c
;|***    #define WM_QUERYBORDERSIZE         0x004d
;|***    #define WM_NEXTMENU                0x004e
;|***    #define WM_ERASEBACKGROUND         0x004f
;|***    #define WM_QUERYFRAMEINFO          0x0050
;|***    #define WM_QUERYFOCUSCHAIN         0x0051
;|***    #define WM_OWNERPOSCHANGE          0x0052
;|***    #define WM_CALCFRAMERECT           0x0053
;|***    /* Note 0x0054 is reserved */
;|***    #define WM_WINDOWPOSCHANGED        0x0055
;|***    #define WM_ADJUSTFRAMEPOS          0x0056
;|***    #define WM_QUERYFRAMECTLCOUNT      0x0059
;|***    #ifndef INCL_SAADEFS
;|***       /* Note 0x005A is reserved */
;|***       #define WM_QUERYHELPINFO        0x005B
;|***       #define WM_SETHELPINFO          0x005C
;|***       #define WM_ERROR                0x005D
;|***       #define WM_REALIZEPALETTE       0x005E
;|*** 
;|*** 
;|***       /* WM_QUERYFRAMEINFO constants */
;|*** 
;|***       #define FI_FRAME                0x00000001L
;|***       #define FI_OWNERHIDE            0x00000002L
;|***       #define FI_ACTIVATEOK           0x00000004L
;|***       #define FI_NOMOVEWITHOWNER      0x00000008L
;|*** 
;|*** 
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|*** 
;|***    BOOL  APIENTRY WinCreateFrameControls(HWND hwndFrame,
;|***                                          PFRAMECDATA pfcdata,
;|***                                          PSZ pszTitle);
;|*** 
;|***    BOOL  APIENTRY WinCalcFrameRect(HWND hwndFrame,
;|***                                    PRECTL prcl,
;|***                                    BOOL fClient);
;|*** 
;|***    BOOL  APIENTRY WinGetMinPosition(HWND hwnd,
;|***                                     PSWP pswp,
;|***                                     PPOINTL pptl);
;|***    #ifndef INCL_SAADEFS
;|***       BOOL  APIENTRY WinGetMaxPosition(HWND hwnd,
;|***                                        PSWP pswp);
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    typedef LHANDLE HSAVEWP;      /* hsvwp */
;|*** 
;|***    #ifdef INCL_32
;|***       BOOL APIENTRY WinSaveWindowPos(HSAVEWP hsvwp,
;|***                                      PSWP pswp,
;|***                                      ULONG cswp);
;|***    #else
;|***       BOOL APIENTRY WinSaveWindowPos(HSAVEWP hsvwp,
;|***                                      PSWP pswp,
;|***                                      USHORT cswp);
;|***    #endif
;|*** 
;|***    /* Frame control IDs    */
;|*** 
;|***    #define FID_SYSMENU                0x8002
;|***    #define FID_TITLEBAR               0x8003
;|***    #define FID_MINMAX                 0x8004
;|***    #define FID_MENU                   0x8005
;|***    #define FID_VERTSCROLL             0x8006
;|***    #define FID_HORZSCROLL             0x8007
;|***    #define FID_CLIENT                 0x8008
;|***    /* Note 0x8009 is reserved */
;|*** 
;|***    #define FID_DBE_APPSTAT            0x8010
;|***    #define FID_DBE_KBDSTAT            0x8011
;|***    #define FID_DBE_PECIC              0x8012
;|***    #define FID_DBE_KKPOPUP            0x8013
;|*** 
;|***    /* Standard WM_SYSCOMMAND command values */
;|*** 
;|***    #define SC_SIZE                    0x8000
;|***    #define SC_MOVE                    0x8001
;|***    #define SC_MINIMIZE                0x8002
;|***    #define SC_MAXIMIZE                0x8003
;|***    #define SC_CLOSE                   0x8004
;|***    #define SC_NEXT                    0x8005
;|***    #define SC_APPMENU                 0x8006
;|***    #define SC_SYSMENU                 0x8007
;|***    #define SC_RESTORE                 0x8008
;|***    #define SC_NEXTFRAME               0x8009
;|***    #define SC_NEXTWINDOW              0x8010
;|***    #ifndef INCL_SAADEFS
;|***       #define SC_TASKMANAGER             0x8011
;|***       #define SC_HELPKEYS                0x8012
;|***       #define SC_HELPINDEX               0x8013
;|***       #define SC_HELPEXTENDED            0x8014
;|***       #define SC_SWITCHPANELIDS          0x8015
;|***       #define SC_DBE_FIRST               0x8018
;|***       #define SC_DBE_LAST                0x801F
;|*** 
;|***       #define SC_BEGINDRAG               0x8020
;|***       #define SC_ENDDRAG                 0x8021
;|***       #define SC_SELECT                  0x8022
;|***       #define SC_OPEN                    0x8023
;|***       #define SC_CONTEXTMENU             0x8024
;|***       #define SC_CONTEXTHELP             0x8025
;|***       #define SC_TEXTEDIT                0x8026
;|***       #define SC_BEGINSELECT             0x8027
;|***       #define SC_ENDSELECT               0x8028
;|***       #define SC_WINDOW                  0x8029
;|***       #define SC_HIDE                    0x802a
;|*** 
;|*** 
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|*** #endif /* INCL_WINFRAMEMGR */
;|*** 
;|*** /*** Frame controls */
;|*** 
;|*** #ifdef INCL_WINFRAMECTLS
;|*** 
;|***    /** Title bar controls */
;|*** 
;|*** 
;|***    /* Title bar control messages */
;|*** 
;|***    #define TBM_SETHILITE              0x01e3
;|***    #define TBM_QUERYHILITE            0x01e4
;|*** 
;|***    #ifdef INCL_16
;|***       #define TBM_TRACKMOVE              0x01e5
;|***    #endif /* INCL_16 */
;|*** 
;|*** #endif /* INCL_WINFRAMECTLS */
;|*** 
;|*** #ifdef INCL_WINRECTANGLES
;|***    /*** Rectangle routines */
;|*** 
;|***    BOOL APIENTRY WinCopyRect(HAB hab,
;|***                              PRECTL prclDst,
;|***                              PRECTL prclSrc);
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #ifdef INCL_32
;|***          BOOL APIENTRY WinSetRect(HAB hab,
;|***                                   PRECTL prcl,
;|***                                   LONG xLeft,
;|***                                   LONG yBottom,
;|***                                   LONG xRight,
;|***                                   LONG yTop);
;|***       #else
;|***          BOOL APIENTRY WinSetRect(HAB hab,
;|***                                   PRECTL prcl,
;|***                                   SHORT xLeft,
;|***                                   SHORT yBottom,
;|***                                   SHORT xRight,
;|***                                   SHORT yTop);
;|***       #endif
;|***       BOOL APIENTRY WinIsRectEmpty(HAB hab,
;|***                                    PRECTL prcl);
;|***       BOOL APIENTRY WinEqualRect(HAB hab,
;|***                                  PRECTL prcl1,
;|***                                  PRECTL prcl2);
;|***       BOOL APIENTRY WinSetRectEmpty(HAB hab,
;|***                                     PRECTL prcl);
;|***       #ifdef INCL_32
;|***          BOOL APIENTRY WinOffsetRect(HAB hab,
;|***                                      PRECTL prcl,
;|***                                      LONG cx,
;|***                                      LONG cy);
;|***          BOOL APIENTRY WinInflateRect(HAB hab,
;|***                                       PRECTL prcl,
;|***                                       LONG cx,
;|***                                       LONG cy);
;|***       #else
;|***          BOOL APIENTRY WinOffsetRect(HAB hab,
;|***                                      PRECTL prcl,
;|***                                      SHORT cx,
;|***                                      SHORT cy);
;|***          BOOL APIENTRY WinInflateRect(HAB hab,
;|***                                       PRECTL prcl,
;|***                                       SHORT cx,
;|***                                       SHORT cy);
;|***       #endif
;|***       BOOL APIENTRY WinPtInRect(HAB hab,
;|***                                 PRECTL prcl,
;|***                                 PPOINTL pptl);
;|***       BOOL APIENTRY WinIntersectRect(HAB hab,
;|***                                      PRECTL prclDst,
;|***                                      PRECTL prclSrc1,
;|***                                      PRECTL prclSrc2);
;|***       BOOL APIENTRY WinUnionRect(HAB hab,
;|***                                  PRECTL prclDst,
;|***                                  PRECTL prclSrc1,
;|***                                  PRECTL prclSrc2);
;|***       BOOL APIENTRY WinSubtractRect(HAB hab,
;|***                                     PRECTL prclDst,
;|***                                     PRECTL prclSrc1,
;|***                                     PRECTL prclSrc2);
;|***       #ifdef INCL_32
;|***          BOOL APIENTRY WinMakeRect(HAB hab,
;|***                                    PRECTL pwrc);
;|***          BOOL APIENTRY WinMakePoints(HAB hab,
;|***                                      PPOINTL pwpt,
;|***                                      ULONG cwpt);
;|***       #else
;|***          BOOL APIENTRY WinMakeRect(HAB hab,
;|***                                    PWRECT pwrc);
;|***          BOOL APIENTRY WinMakePoints(HAB hab,
;|***                                      PWPOINT pwpt,
;|***                                      USHORT cwpt);
;|***       #endif
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|*** #endif /* INCL_WINRECTANGLES */
;|*** 
;|*** 
;|*** #ifdef INCL_WINSYS
;|*** 
;|***    /*** System values */
;|*** 
;|***    #ifdef INCL_32
;|***       LONG APIENTRY WinQuerySysValue(HWND hwndDesktop,
;|***                                      LONG iSysValue);
;|***       BOOL  APIENTRY WinSetSysValue(HWND hwndDesktop,
;|***                                     LONG iSysValue,
;|***                                     LONG lValue);
;|***    #else
;|***       LONG APIENTRY WinQuerySysValue(HWND hwndDesktop,
;|***                                      SHORT iSysValue);
;|***       BOOL  APIENTRY WinSetSysValue(HWND hwndDesktop,
;|***                                     SHORT iSysValue,
;|***                                     LONG lValue);
;|***    #endif
;|*** 
;|***    #define SV_SWAPBUTTON              0
;|***    #define SV_DBLCLKTIME              1
;|***    #define SV_CXDBLCLK                2
;|***    #define SV_CYDBLCLK                3
;|***    #define SV_CXSIZEBORDER            4
;|***    #define SV_CYSIZEBORDER            5
;|***    #define SV_ALARM                   6
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #define SV_RESERVEDFIRST1          7
;|***       #define SV_RESERVEDLAST1           8
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    #define SV_CURSORRATE              9
;|***    #define SV_FIRSTSCROLLRATE         10
;|***    #define SV_SCROLLRATE              11
;|***    #define SV_NUMBEREDLISTS           12
;|***    #define SV_WARNINGFREQ             13
;|***    #define SV_NOTEFREQ                14
;|***    #define SV_ERRORFREQ               15
;|***    #define SV_WARNINGDURATION         16
;|***    #define SV_NOTEDURATION            17
;|***    #define SV_ERRORDURATION           18
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #define SV_RESERVEDFIRST           19
;|***       #define SV_RESERVEDLAST            19
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    #define SV_CXSCREEN                20
;|***    #define SV_CYSCREEN                21
;|***    #define SV_CXVSCROLL               22
;|***    #define SV_CYHSCROLL               23
;|***    #define SV_CYVSCROLLARROW          24
;|***    #define SV_CXHSCROLLARROW          25
;|***    #define SV_CXBORDER                26
;|***    #define SV_CYBORDER                27
;|***    #define SV_CXDLGFRAME              28
;|***    #define SV_CYDLGFRAME              29
;|***    #define SV_CYTITLEBAR              30
;|***    #define SV_CYVSLIDER               31
;|***    #define SV_CXHSLIDER               32
;|***    #define SV_CXMINMAXBUTTON          33
;|***    #define SV_CYMINMAXBUTTON          34
;|***    #define SV_CYMENU                  35
;|***    #define SV_CXFULLSCREEN            36
;|***    #define SV_CYFULLSCREEN            37
;|***    #define SV_CXICON                  38
;|***    #define SV_CYICON                  39
;|***    #define SV_CXPOINTER               40
;|***    #define SV_CYPOINTER               41
;|*** 
;|***    #define SV_DEBUG                   42
;|***    #define SV_CMOUSEBUTTONS           43
;|***    #define SV_CPOINTERBUTTONS         43
;|***    #define SV_POINTERLEVEL            44
;|***    #define SV_CURSORLEVEL             45
;|***    #define SV_TRACKRECTLEVEL          46
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #define SV_CTIMERS                 47
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    #define SV_MOUSEPRESENT            48
;|*** 
;|***    #define SV_CXBYTEALIGN             49
;|***    #define SV_CXALIGN                 49
;|***    #define SV_CYBYTEALIGN             50
;|***    #define SV_CYALIGN                 50
;|*** 
;|***    /* The following value enables any greater value to be set by WinSetSysVlaue. */
;|***    /* Values of 51-55 are spare for extra non-settable system values             */
;|***    /* This is to enable the setting of SV_EXTRAKEYBEEP by applications.          */
;|*** 
;|***    #define SV_NOTRESERVED             56
;|***    #define SV_EXTRAKEYBEEP            57
;|*** 
;|***    /* The following system value controls whether PM controls the keyboard      */
;|***    /* lights for light key keystrokes (else applications will)                  */
;|***    #define SV_SETLIGHTS               58
;|***    #define SV_INSERTMODE              59
;|*** 
;|*** 
;|***    #define SV_MENUROLLDOWNDELAY       64
;|***    #define SV_MENUROLLUPDELAY         65
;|***    #define SV_ALTMNEMONIC             66
;|***    #define SV_TASKLISTMOUSEACCESS     67
;|*** 
;|***    #define SV_CXICONTEXTWIDTH         68
;|***    #define SV_CICONTEXTLINES          69
;|*** 
;|***    #define SV_CHORDTIME               70
;|***    #define SV_CXCHORD                 71
;|***    #define SV_CYCHORD                 72
;|***    #define SV_CXMOTIONSTART           73
;|***    #define SV_CYMOTIONSTART           74
;|*** 
;|***    #define SV_BEGINDRAG               75
;|***    #define SV_ENDDRAG                 76
;|***    #define SV_SINGLESELECT            77
;|***    #define SV_OPEN                    78
;|***    #define SV_CONTEXTMENU             79
;|***    #define SV_CONTEXTHELP             80
;|***    #define SV_TEXTEDIT                81
;|***    #define SV_BEGINSELECT             82
;|***    #define SV_ENDSELECT               83
;|*** 
;|***    #define SV_BEGINDRAGKB             84
;|***    #define SV_ENDDRAGKB               85
;|***    #define SV_SELECTKB                86
;|***    #define SV_OPENKB                  87
;|***    #define SV_CONTEXTMENUKB           88
;|***    #define SV_CONTEXTHELPKB           89
;|***    #define SV_TEXTEDITKB              90
;|***    #define SV_BEGINSELECTKB           91
;|***    #define SV_ENDSELECTKB             92
;|*** 
;|***    #define SV_ANIMATION               93
;|***    #define SV_ANIMATIONSPEED          94
;|*** 
;|***    #define SV_MONOICONS               95
;|*** 
;|***    #define SV_KBDALTERED              96
;|*** 
;|***    #define SV_PRINTSCREEN             97
;|*** 
;|***    #define SV_LOCKSTARTINPUT          98
;|*** 
;|***    #define SV_CSYSVALUES              99
;|*** 
;|*** 
;|***    /*
;|***    * Presentation parameter structures.
;|***    */
;|***    typedef struct _PARAM {  /* param */
;|***       ULONG   id;
;|***       ULONG   cb;
;|***       BYTE    ab[1];
;|***    } PARAM;
;|***    typedef PARAM NEAR *NPPARAM;
;|***    typedef PARAM FAR  *PPARAM;
;|*** 
;|***    typedef struct _PRESPARAMS {  /* pres */
;|***       ULONG   cb;
;|***       PARAM   aparam[1];
;|***    } PRESPARAMS;
;|***    typedef PRESPARAMS NEAR *NPPRESPARAMS;
;|***    typedef PRESPARAMS FAR  *PPRESPARAMS;
;|*** 
;|***    /*
;|***    * Presentation parameter APIs
;|***    */
;|***    BOOL  APIENTRY WinSetPresParam(HWND hwnd,
;|***                                   ULONG id,
;|***                                   ULONG cbParam,
;|***                                   PVOID pbParam);
;|***    #ifdef INCL_32
;|***       ULONG APIENTRY WinQueryPresParam(HWND hwnd,
;|***                                        ULONG id1,
;|***                                        ULONG id2,
;|***                                        PULONG pulId,
;|***                                        ULONG cbBuf,
;|***                                        PVOID pbBuf,
;|***                                        ULONG fs);
;|***    #else
;|***       ULONG APIENTRY WinQueryPresParam(HWND hwnd,
;|***                                        ULONG id1,
;|***                                        ULONG id2,
;|***                                        PULONG pulId,
;|***                                        ULONG cbBuf,
;|***                                        PVOID pbBuf,
;|***                                        USHORT fs);
;|***    #endif
;|***    BOOL  APIENTRY WinRemovePresParam(HWND hwnd,
;|***                                      ULONG id);
;|*** 
;|***    /*
;|***    * Presentation parameter types.
;|***    */
;|*** 
;|***    #define PP_FOREGROUNDCOLOR                      1L
;|***    #define PP_FOREGROUNDCOLORINDEX                 2L
;|***    #define PP_BACKGROUNDCOLOR                      3L
;|***    #define PP_BACKGROUNDCOLORINDEX                 4L
;|***    #define PP_HILITEFOREGROUNDCOLOR                5L
;|***    #define PP_HILITEFOREGROUNDCOLORINDEX           6L
;|***    #define PP_HILITEBACKGROUNDCOLOR                7L
;|***    #define PP_HILITEBACKGROUNDCOLORINDEX           8L
;|***    #define PP_DISABLEDFOREGROUNDCOLOR              9L
;|***    #define PP_DISABLEDFOREGROUNDCOLORINDEX         10L
;|***    #define PP_DISABLEDBACKGROUNDCOLOR              11L
;|***    #define PP_DISABLEDBACKGROUNDCOLORINDEX         12L
;|***    #define PP_BORDERCOLOR                          13L
;|***    #define PP_BORDERCOLORINDEX                     14L
;|***    #define PP_FONTNAMESIZE                         15L
;|***    #define PP_FONTHANDLE                           16L
;|***    #define PP_RESERVED                             17L
;|***    #define PP_ACTIVECOLOR                          18L
;|***    #define PP_ACTIVECOLORINDEX                     19L
;|***    #define PP_INACTIVECOLOR                        20L
;|***    #define PP_INACTIVECOLORINDEX                   21L
;|***    #define PP_ACTIVETEXTFGNDCOLOR                  22L
;|***    #define PP_ACTIVETEXTFGNDCOLORINDEX             23L
;|***    #define PP_ACTIVETEXTBGNDCOLOR                  24L
;|***    #define PP_ACTIVETEXTBGNDCOLORINDEX             25L
;|***    #define PP_INACTIVETEXTFGNDCOLOR                26L
;|***    #define PP_INACTIVETEXTFGNDCOLORINDEX           27L
;|***    #define PP_INACTIVETEXTBGNDCOLOR                28L
;|***    #define PP_INACTIVETEXTBGNDCOLORINDEX           29L
;|***    #define PP_SHADOW                               30L
;|***    #define PP_MENUFOREGROUNDCOLOR                  31L
;|***    #define PP_MENUFOREGROUNDCOLORINDEX             32L
;|***    #define PP_MENUBACKGROUNDCOLOR                  33L
;|***    #define PP_MENUBACKGROUNDCOLORINDEX             34L
;|***    #define PP_MENUHILITEFGNDCOLOR                  35L
;|***    #define PP_MENUHILITEFGNDCOLORINDEX             36L
;|***    #define PP_MENUHILITEBGNDCOLOR                  37L
;|***    #define PP_MENUHILITEBGNDCOLORINDEX             38L
;|***    #define PP_MENUDISABLEDFGNDCOLOR                39L
;|***    #define PP_MENUDISABLEDFGNDCOLORINDEX           40L
;|***    #define PP_MENUDISABLEDBGNDCOLOR                41L
;|***    #define PP_MENUDISABLEDBGNDCOLORINDEX           42L
;|***    #define PP_SHADOWTEXTCOLOR                      43L
;|***    #define PP_SHADOWTEXTCOLORINDEX                 44L
;|***    #define PP_SHADOWHILITEFGNDCOLOR                45L
;|***    #define PP_SHADOWHILITEFGNDCOLORINDEX           46L
;|***    #define PP_SHADOWHILITEBGNDCOLOR                47L
;|***    #define PP_SHADOWHILITEBGNDCOLORINDEX           48L
;|***    #define PP_ICONTEXTBACKGROUNDCOLOR              49L
;|***    #define PP_ICONTEXTBACKGROUNDCOLORINDEX         50L
;|*** 
;|***    /* PP_ values 0x100 - 0x012F are reserved*/
;|***    /* for bidirectional language support.   */
;|*** 
;|***    #define PP_BIDI_FIRST                           0x0100L
;|***    #define PP_BIDI_LAST                            0x012FL
;|*** 
;|***    #define PP_USER                                 0x8000L
;|*** 
;|***    /*
;|***    * Flags for WinQueryPresParams()
;|***    */
;|***    #define QPF_NOINHERIT            0x0001 /* Don't inherit                      */
;|***    #define QPF_ID1COLORINDEX        0x0002 /* Convert id1 color index into RGB   */
;|***    #define QPF_ID2COLORINDEX        0x0004 /* Convert id2 color index into RGB   */
;|***    #define QPF_PURERGBCOLOR         0x0008 /* Return pure RGB colors             */
;|***    #define QPF_VALIDFLAGS           0x000F /* Valid WinQueryPresParams() flags.  */
;|*** 
;|***    /*** System color functions */
;|*** 
;|***    LONG APIENTRY WinQuerySysColor(HWND hwndDesktop,
;|***                                   LONG clr,
;|***                                   LONG lReserved);
;|***    BOOL APIENTRY WinSetSysColors(HWND hwndDesktop,
;|***                                  ULONG flOptions,
;|***                                  ULONG flFormat,
;|***                                  LONG clrFirst,
;|***                                  ULONG cclr,
;|***                                  PLONG pclr);
;|*** 
;|***    #define SYSCLR_SHADOWHILITEBGND         (-50L)
;|***    #define SYSCLR_SHADOWHILITEFGND         (-49L)
;|***    #define SYSCLR_SHADOWTEXT               (-48L)
;|***    #define SYSCLR_ENTRYFIELD               (-47L)
;|***    #define SYSCLR_MENUDISABLEDTEXT         (-46L)
;|***    #define SYSCLR_MENUHILITE               (-45L)
;|***    #define SYSCLR_MENUHILITEBGND           (-44L)
;|***    #define SYSCLR_PAGEBACKGROUND           (-43L)
;|***    #define SYSCLR_FIELDBACKGROUND          (-42L)
;|***    #define SYSCLR_BUTTONLIGHT              (-41L)
;|***    #define SYSCLR_BUTTONMIDDLE             (-40L)
;|***    #define SYSCLR_BUTTONDARK               (-39L)
;|***    #define SYSCLR_BUTTONDEFAULT            (-38L)
;|***    #define SYSCLR_TITLEBOTTOM              (-37L)
;|***    #define SYSCLR_SHADOW                   (-36L)
;|***    #define SYSCLR_ICONTEXT                 (-35L)
;|***    #define SYSCLR_DIALOGBACKGROUND         (-34L)
;|***    #define SYSCLR_HILITEFOREGROUND         (-33L)
;|***    #define SYSCLR_HILITEBACKGROUND         (-32L)
;|***    #define SYSCLR_INACTIVETITLETEXTBGND    (-31L)
;|***    #define SYSCLR_ACTIVETITLETEXTBGND      (-30L)
;|***    #define SYSCLR_INACTIVETITLETEXT        (-29L)
;|***    #define SYSCLR_ACTIVETITLETEXT          (-28L)
;|***    #define SYSCLR_OUTPUTTEXT               (-27L)
;|***    #define SYSCLR_WINDOWSTATICTEXT         (-26L)
;|***    #define SYSCLR_SCROLLBAR                (-25L)
;|***    #define SYSCLR_BACKGROUND               (-24L)
;|***    #define SYSCLR_ACTIVETITLE              (-23L)
;|***    #define SYSCLR_INACTIVETITLE            (-22L)
;|***    #define SYSCLR_MENU                     (-21L)
;|***    #define SYSCLR_WINDOW                   (-20L)
;|***    #define SYSCLR_WINDOWFRAME              (-19L)
;|***    #define SYSCLR_MENUTEXT                 (-18L)
;|***    #define SYSCLR_WINDOWTEXT               (-17L)
;|***    #define SYSCLR_TITLETEXT                (-16L)
;|***    #define SYSCLR_ACTIVEBORDER             (-15L)
;|***    #define SYSCLR_INACTIVEBORDER           (-14L)
;|***    #define SYSCLR_APPWORKSPACE             (-13L)
;|***    #define SYSCLR_HELPBACKGROUND           (-12L)
;|***    #define SYSCLR_HELPTEXT                 (-11L)
;|***    #define SYSCLR_HELPHILITE               (-10L)
;|*** 
;|***    #define SYSCLR_CSYSCOLORS               41L
;|*** 
;|*** #endif /* INCL_WINSYS */
;|*** 
;|*** 
;|*** #ifdef INCL_WINTIMER
;|***    /**** Timer manager */
;|*** 
;|***    #ifndef INCL_SAADEFS
;|*** 
;|***       #ifdef INCL_32
;|*** 
;|***          ULONG APIENTRY WinStartTimer(HAB hab,
;|***                                       HWND hwnd,
;|***                                       ULONG idTimer,
;|***                                       ULONG dtTimeout);
;|***          BOOL   APIENTRY WinStopTimer(HAB hab,
;|***                                       HWND hwnd,
;|***                                       ULONG idTimer);
;|*** 
;|***       #else /* not INCL_32 */
;|*** 
;|***          USHORT APIENTRY WinStartTimer(HAB hab,
;|***                                        HWND hwnd,
;|***                                        USHORT idTimer,
;|***                                        USHORT dtTimeout);
;|***          BOOL   APIENTRY WinStopTimer(HAB hab,
;|***                                       HWND hwnd,
;|***                                       USHORT idTimer);
;|*** 
;|***       #endif /* INCL_32 */
;|*** 
;|***       ULONG  APIENTRY WinGetCurrentTime(HAB hab);
;|*** 
;|***       #define TID_CURSOR          0xffff  /* Reserved cursor timer ID              */
;|***       #define TID_SCROLL          0xfffe  /* Reserved scrolling timer ID           */
;|***       #define TID_FLASHWINDOW     0xfffd  /* Reserved for window flashing timer ID */
;|***       #define TID_USERMAX         0x7fff  /* Maximum user timer ID                 */
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|*** #endif /* INCL_WINTIMER */
;|*** 
;|*** typedef LHANDLE HACCEL; /* haccel */
;|*** 
;|*** #ifdef INCL_WINACCELERATORS
;|***    /**** Accelerator functions */
;|*** 
;|***    /* ACCEL fs bits
;|***    *
;|***    * NOTE: the first six AF_ code bits have the same value
;|***    * as their KC_ counterparts
;|***    */
;|***    #ifndef INCL_SAADEFS
;|***       #define AF_CHAR                    0x0001
;|***       #define AF_VIRTUALKEY              0x0002
;|***       #define AF_SCANCODE                0x0004
;|***       #define AF_SHIFT                   0x0008
;|***       #define AF_CONTROL                 0x0010
;|***       #define AF_ALT                     0x0020
;|***       #define AF_LONEKEY                 0x0040
;|***       #define AF_SYSCOMMAND              0x0100
;|***       #define AF_HELP                    0x0200
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    #pragma pack(2) /* force structure alignment packing */
;|*** 
;|***    /* Binary resources may be bound into application executables or */
;|***    /* passed as a parameter when creating a window or dialog        */
;|***    /* Currently they must be the same for both 16-bit and 32-bit    */
;|***    /* so we pack the structures.                                    */
;|***    typedef struct _ACCEL {  /* acc */
;|***       USHORT  fs;
;|***       USHORT  key;
;|***       USHORT  cmd;
;|***    } ACCEL;
;|***    typedef ACCEL FAR *PACCEL;
;|*** 
;|***    /* Binary resources may be bound into application executables or */
;|***    /* passed as a parameter when creating a window or dialog        */
;|***    /* Currently they must be the same for both 16-bit and 32-bit    */
;|***    /* so we pack the structures.                                    */
;|***    typedef struct _ACCELTABLE {  /* acct  */
;|***       USHORT  cAccel;
;|***       USHORT  codepage;
;|***       ACCEL   aaccel[1];
;|***    } ACCELTABLE;
;|***    typedef ACCELTABLE FAR *PACCELTABLE;
;|*** 
;|***    #pragma pack()  /* restore packing to default */
;|*** 
;|***    #ifdef INCL_32
;|***       HACCEL APIENTRY WinLoadAccelTable(HAB hab,
;|***                                         HMODULE hmod,
;|***                                         ULONG idAccelTable);
;|***       ULONG APIENTRY WinCopyAccelTable(HACCEL haccel,
;|***                                        PACCELTABLE pAccelTable,
;|***                                        ULONG cbCopyMax);
;|***    #else
;|***       HACCEL APIENTRY WinLoadAccelTable(HAB hab,
;|***                                         HMODULE hmod,
;|***                                         USHORT idAccelTable);
;|***       USHORT APIENTRY WinCopyAccelTable(HACCEL haccel,
;|***                                         PACCELTABLE pAccelTable,
;|***                                         USHORT cbCopyMax);
;|***    #endif
;|***    HACCEL APIENTRY WinCreateAccelTable(HAB hab,
;|***                                        PACCELTABLE pAccelTable);
;|***    BOOL   APIENTRY WinDestroyAccelTable(HACCEL haccel);
;|***    BOOL   APIENTRY WinTranslateAccel(HAB hab,
;|***                                      HWND hwnd,
;|***                                      HACCEL haccel,
;|***                                      PQMSG pqmsg);
;|***    BOOL   APIENTRY WinSetAccelTable(HAB hab,
;|***                                     HACCEL haccel,
;|***                                     HWND hwndFrame);
;|***    HACCEL APIENTRY WinQueryAccelTable(HAB hab,
;|***                                       HWND hwndFrame);
;|*** 
;|*** #endif /* INCL_WINACCELERATORS */
;|*** 
;|*** /**** Extended Attribute Flags (Association Table) */
;|*** 
;|*** #define EAF_DEFAULTOWNER           0x0001
;|*** #define EAF_UNCHANGEABLE           0x0002
;|*** #define EAF_REUSEICON              0x0004
;|*** 
;|*** /*** WinTrackRect() information */
;|*** 
;|*** #ifdef INCL_WINTRACKRECT
;|*** 
;|***    /* WinTrackRect() tracking information structure */
;|*** 
;|***    #ifdef INCL_32
;|***       typedef struct _TRACKINFO {  /* ti */
;|***          LONG    cxBorder;
;|***          LONG    cyBorder;
;|***          LONG    cxGrid;
;|***          LONG    cyGrid;
;|***          LONG    cxKeyboard;
;|***          LONG    cyKeyboard;
;|***          RECTL   rclTrack;
;|***          RECTL   rclBoundary;
;|***          POINTL  ptlMinTrackSize;
;|***          POINTL  ptlMaxTrackSize;
;|***          ULONG   fs;
;|***       } TRACKINFO;
;|***    #else
;|***       typedef struct _TRACKINFO {  /* ti */
;|***          SHORT   cxBorder;
;|***          SHORT   cyBorder;
;|***          SHORT   cxGrid;
;|***          SHORT   cyGrid;
;|***          SHORT   cxKeyboard;
;|***          SHORT   cyKeyboard;
;|***          RECTL   rclTrack;
;|***          RECTL   rclBoundary;
;|***          POINTL  ptlMinTrackSize;
;|***          POINTL  ptlMaxTrackSize;
;|***          USHORT  fs;
;|***       } TRACKINFO;
;|***    #endif
;|***    typedef TRACKINFO FAR *PTRACKINFO;
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       BOOL APIENTRY WinTrackRect(HWND hwnd,
;|***                                  HPS hps,
;|***                                  PTRACKINFO pti);
;|***       BOOL APIENTRY WinShowTrackRect(HWND hwnd,
;|***                                      BOOL fShow);
;|*** 
;|***       /* WinTrackRect() flags */
;|*** 
;|***       #define TF_LEFT                    0x0001
;|***       #define TF_TOP                     0x0002
;|***       #define TF_RIGHT                   0x0004
;|***       #define TF_BOTTOM                  0x0008
;|***       /* TF_MOVE = TF_LEFT | TF_TOP | TF_RIGHT | TF_BOTTOM */
;|***       #define TF_MOVE                    0x000F
;|*** 
;|***       #define TF_SETPOINTERPOS           0x0010
;|***       #define TF_GRID                    0x0020
;|***       #define TF_STANDARD                0x0040
;|***       #define TF_ALLINBOUNDARY           0x0080
;|***       #define TF_VALIDATETRACKRECT       0x0100
;|***       #define TF_PARTINBOUNDARY          0x0200
;|*** 
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|*** #endif /* INCL_WINTRACKRECT */
;|*** 
;|*** 
;|*** /**** Clipboard Manager */
;|*** 
;|*** #if (defined(INCL_WINCLIPBOARD) || defined(INCL_WINDDE))
;|***    #ifndef INCL_SAADEFS
;|*** 
;|***       /* Clipboard messages */
;|*** 
;|***       #define WM_RENDERFMT               0x0060
;|***       #define WM_RENDERALLFMTS           0x0061
;|***       #define WM_DESTROYCLIPBOARD        0x0062
;|***       #define WM_PAINTCLIPBOARD          0x0063
;|***       #define WM_SIZECLIPBOARD           0x0064
;|***       #define WM_HSCROLLCLIPBOARD        0x0065
;|***       #define WM_VSCROLLCLIPBOARD        0x0066
;|***       #define WM_DRAWCLIPBOARD           0x0067
;|*** 
;|***       /*
;|***       * Standard Clipboard formats
;|***       */
;|***       #define CF_TEXT                    1
;|***       #define CF_BITMAP                  2
;|***       #define CF_DSPTEXT                 3
;|***       #define CF_DSPBITMAP               4
;|***       #define CF_METAFILE                5
;|***       #define CF_DSPMETAFILE             6
;|***       #define CF_PALETTE                 9
;|***       #define CF_MMPMFIRST              10
;|***       #define CF_MMPMLAST               19
;|***       /*
;|***       * standard DDE and clipboard format stings
;|***       */
;|***       #define SZFMT_TEXT                   "#1"
;|***       #define SZFMT_BITMAP                 "#2"
;|***       #define SZFMT_DSPTEXT                "#3"
;|***       #define SZFMT_DSPBITMAP              "#4"
;|***       #define SZFMT_METAFILE               "#5"
;|***       #define SZFMT_DSPMETAFILE            "#6"
;|***       #define SZFMT_PALETTE                "#9"
;|***       #define SZFMT_SYLK                   "Sylk"
;|***       #define SZFMT_DIF                    "Dif"
;|***       #define SZFMT_TIFF                   "Tiff"
;|***       #define SZFMT_OEMTEXT                "OemText"
;|***       #define SZFMT_DIB                    "Dib"
;|***       #define SZFMT_OWNERDISPLAY           "OwnerDisplay"
;|***       #define SZFMT_LINK                   "Link"
;|***       #define SZFMT_METAFILEPICT           "MetaFilePict"
;|***       #define SZFMT_DSPMETAFILEPICT        "DspMetaFilePict"
;|***       #define SZFMT_CPTEXT                 "Codepage Text"
;|***       #define SZDDEFMT_RTF                 "Rich Text Format"
;|***       #define SZDDEFMT_PTRPICT             "Printer_Picture"
;|*** 
;|***       #pragma pack(2) /* force structure alignment packing */
;|*** 
;|***       /* Metafiles are the same no matter whether they are used in     */
;|***       /* 16-bit or 32-bit applications. While not strictly necessary   */
;|***       /* because of inherent alignment we force packing on a 2 byte    */
;|***       /* boundary to avoid any confusion.                              */
;|***       typedef struct _MFP {  /* mfp */
;|***          POINTL sizeBounds;  /* metafile notional grid size      */
;|***          POINTL sizeMM;      /* metafile size high metric units  */
;|***          ULONG  cbLength;    /* length of metafile data          */
;|***          USHORT mapMode;     /* a PM metaflie map mode           */
;|***          USHORT reserved;
;|***          BYTE   abData[1];   /* metafile Data                    */
;|***       } MFP;
;|***       typedef MFP FAR *PMFP;
;|*** 
;|***       /* CPTEXT DDE data are the same no matter whether they are used  */
;|***       /* in 16-bit or 32-bit applications. While not strictly necessary*/
;|***       /* because of inherent alignment we force packing on a 2 byte    */
;|***       /* boundary to avoid any confusion.                              */
;|***       typedef struct _CPTEXT {  /* cptxt */
;|***          USHORT idCountry;
;|***          USHORT usCodepage;
;|***          USHORT usLangID;
;|***          USHORT usSubLangID;
;|***          BYTE   abText[1];   /* text string starts here          */
;|***       } CPTEXT;
;|***       typedef CPTEXT FAR *PCPTEXT;
;|*** 
;|***       #pragma pack()  /* restore packing to default */
;|*** 
;|***    #endif /* not INCL_SAADEFS */
;|*** #endif /* INCL_WINCLIPBOARD | INCL_WINDDE */
;|*** 
;|*** #ifdef INCL_WINCLIPBOARD
;|***    #ifndef INCL_SAADEFS
;|***       BOOL   APIENTRY WinSetClipbrdOwner(HAB hab,
;|***                                          HWND hwnd);
;|***       #ifdef INCL_32
;|***          BOOL   APIENTRY WinSetClipbrdData(HAB hab,
;|***                                            ULONG ulData,
;|***                                            ULONG fmt,
;|***                                            ULONG rgfFmtInfo);
;|***          ULONG  APIENTRY WinQueryClipbrdData(HAB hab,
;|***                                              ULONG fmt);
;|***          BOOL   APIENTRY WinQueryClipbrdFmtInfo(HAB hab,
;|***                                                 ULONG fmt,
;|***                                                 PULONG prgfFmtInfo);
;|***       #else
;|***          BOOL   APIENTRY WinSetClipbrdData(HAB hab,
;|***                                            ULONG ulData,
;|***                                            USHORT fmt,
;|***                                            USHORT rgfFmtInfo);
;|***          ULONG  APIENTRY WinQueryClipbrdData(HAB hab,
;|***                                              USHORT fmt);
;|***          BOOL   APIENTRY WinQueryClipbrdFmtInfo(HAB hab,
;|***                                                 USHORT fmt,
;|***                                                 PUSHORT prgfFmtInfo);
;|***       #endif
;|***       BOOL   APIENTRY WinSetClipbrdViewer(HAB hab,
;|***                                           HWND hwndNewClipViewer);
;|*** 
;|***       /* WinSetClipbrdData() flags */
;|*** 
;|***       #define CFI_OWNERFREE              0x0001
;|***       #define CFI_OWNERDISPLAY           0x0002
;|***       #ifdef INCL_32
;|***          #define CFI_POINTER                0x0400
;|***       #else
;|***          #define CFI_SELECTOR               0x0100
;|***       #endif
;|***       #define CFI_HANDLE                 0x0200
;|*** 
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    #ifdef INCL_32
;|***       ULONG APIENTRY WinEnumClipbrdFmts(HAB hab,
;|***                                         ULONG fmt);
;|***    #else
;|***       USHORT APIENTRY WinEnumClipbrdFmts(HAB hab,
;|***                                          USHORT fmt);
;|***    #endif
;|***    BOOL   APIENTRY WinEmptyClipbrd(HAB hab);
;|***    BOOL   APIENTRY WinOpenClipbrd(HAB hab);
;|***    BOOL   APIENTRY WinCloseClipbrd(HAB hab);
;|*** 
;|***    #ifdef INCL_32
;|***       HWND   APIENTRY WinQueryClipbrdOwner(HAB hab);
;|***       HWND   APIENTRY WinQueryClipbrdViewer(HAB hab);
;|***    #else
;|***       HWND   APIENTRY WinQueryClipbrdOwner(HAB hab,
;|***                                            BOOL fLock);
;|***       HWND   APIENTRY WinQueryClipbrdViewer(HAB hab,
;|***                                             BOOL fLock);
;|***    #endif  /* INCL_32 */
;|*** 
;|*** #endif /* INCL_WINCLIPBOARD */
;|*** 
;|*** 
;|*** #if (defined(INCL_WINCURSORS) || !defined(INCL_NOCOMMON))
;|***    /**** Cursor manager common subsection */
;|*** 
;|***    BOOL APIENTRY WinDestroyCursor(HWND hwnd);
;|***    BOOL APIENTRY WinShowCursor(HWND hwnd,
;|***                                BOOL fShow);
;|***    #ifdef INCL_32
;|***       BOOL APIENTRY WinCreateCursor(HWND hwnd,
;|***                                     LONG x,
;|***                                     LONG y,
;|***                                     LONG cx,
;|***                                     LONG cy,
;|***                                     ULONG fs,
;|***                                     PRECTL prclClip);
;|***    #else
;|***       BOOL APIENTRY WinCreateCursor(HWND hwnd,
;|***                                     SHORT x,
;|***                                     SHORT y,
;|***                                     SHORT cx,
;|***                                     SHORT cy,
;|***                                     USHORT fs,
;|***                                     PRECTL prclClip);
;|***    #endif
;|*** 
;|***    /* WinCreateCursor() flags */
;|*** 
;|***    #define CURSOR_SOLID               0x0000
;|***    #define CURSOR_HALFTONE            0x0001
;|***    #define CURSOR_FRAME               0x0002
;|***    #define CURSOR_FLASH               0x0004
;|***    #define CURSOR_SETPOS              0x8000
;|*** 
;|***    /* Cursor flags 0x0100 and 0x0200 reserved */
;|***    /* for bidirectional language support.     */
;|*** 
;|***    #define CURSOR_BIDI_FIRST          0x0100
;|***    #define CURSOR_BIDI_LAST           0x0200
;|*** 
;|*** 
;|*** #endif /* Cursor manager common subsection */
;|*** 
;|*** #ifdef INCL_WINCURSORS
;|*** 
;|***    #ifdef INCL_32
;|***       typedef struct _CURSORINFO {  /* csri */
;|***          HWND    hwnd;
;|***          LONG    x;
;|***          LONG    y;
;|***          LONG    cx;
;|***          LONG    cy;
;|***          ULONG   fs;
;|***          RECTL   rclClip;
;|***       } CURSORINFO;
;|***    #else
;|***       typedef struct _CURSORINFO {  /* csri */
;|***          HWND    hwnd;
;|***          SHORT   x;
;|***          SHORT   y;
;|***          SHORT   cx;
;|***          SHORT   cy;
;|***          USHORT  fs;
;|***          RECTL   rclClip;
;|***       } CURSORINFO;
;|***    #endif
;|***    typedef CURSORINFO FAR *PCURSORINFO;
;|*** 
;|***    BOOL APIENTRY WinQueryCursorInfo(HWND hwndDesktop,
;|***                                     PCURSORINFO pCursorInfo);
;|*** 
;|*** #endif /* INCL_WINCURSORS */
;|*** 
;|*** 
;|*** #ifdef INCL_WINPOINTERS
;|***    /**** Pointer manager */
;|*** 
;|***    BOOL     APIENTRY WinSetPointer(HWND hwndDesktop,
;|***                                    HPOINTER hptrNew);
;|***    BOOL     APIENTRY WinSetPointerOwner(HPOINTER hptr,
;|***                                         PID pid,
;|***                                         BOOL fDestroy);
;|***    BOOL     APIENTRY WinShowPointer(HWND hwndDesktop,
;|***                                     BOOL fShow);
;|***    #ifdef INCL_32
;|***    BOOL     APIENTRY WinLockPointerUpdate(HWND hwndDesktop,
;|***                                           HPOINTER hptrNew,
;|***                                           ULONG ulTimeInterval);
;|***       HPOINTER APIENTRY WinQuerySysPointer(HWND hwndDesktop,
;|***                                            LONG iptr,
;|***                                            BOOL fLoad);
;|***    #else
;|***    BOOL     APIENTRY WinLockPointerUpdate(HWND hwndDesktop,
;|***                                           HPOINTER hptrNew,
;|***                                           USHORT usTimeInterval);
;|***       HPOINTER APIENTRY WinQuerySysPointer(HWND hwndDesktop,
;|***                                            SHORT iptr,
;|***                                            BOOL fLoad);
;|***    #endif
;|*** 
;|***    #ifdef INCL_32
;|***       BOOL APIENTRY WinQuerySysPointerData(HWND hwndDesktop,
;|***                                            ULONG iptr,
;|***                                            PICONINFO pIconInfo);
;|***       BOOL APIENTRY WinSetSysPointerData(HWND hwndDesktop,
;|***                                          ULONG iptr,
;|***                                          PICONINFO pIconInfo);
;|***    #endif
;|*** 
;|***    /* System pointers (NOTE: these are 1-based) */
;|*** 
;|***    #define SPTR_ARROW                 1
;|***    #define SPTR_TEXT                  2
;|***    #define SPTR_WAIT                  3
;|***    #define SPTR_SIZE                  4
;|***    #define SPTR_MOVE                  5
;|***    #define SPTR_SIZENWSE              6
;|***    #define SPTR_SIZENESW              7
;|***    #define SPTR_SIZEWE                8
;|***    #define SPTR_SIZENS                9
;|***    #define SPTR_APPICON               10
;|*** 
;|***    #define SPTR_ICONINFORMATION       11
;|***    #define SPTR_ICONQUESTION          12
;|***    #define SPTR_ICONERROR             13
;|***    #define SPTR_ICONWARNING           14
;|*** 
;|***    #define SPTR_ILLEGAL               18
;|***    #define SPTR_FILE                  19
;|***    #define SPTR_FOLDER                20
;|***    #define SPTR_MULTFILE              21
;|***    #define SPTR_PROGRAM               22
;|***    #define SPTR_DISPLAY_PTRS          22
;|***    #define SPTR_PENFIRST              23
;|***    #define SPTR_PENLAST               39
;|***    #define SPTR_CPTR                  39  /* total # of system pointers */
;|*** 
;|***    /* backward compatibility */
;|***    #define SPTR_HANDICON         SPTR_ICONERROR
;|***    #define SPTR_QUESICON         SPTR_ICONQUESTION
;|***    #define SPTR_BANGICON         SPTR_ICONWARNING
;|***    #define SPTR_NOTEICON         SPTR_ICONINFORMATION
;|*** 
;|*** 
;|***    #ifdef INCL_32
;|***       HPOINTER APIENTRY WinLoadPointer(HWND hwndDesktop,
;|***                                        HMODULE hmod,
;|***                                        ULONG idres);
;|***       HPOINTER APIENTRY WinCreatePointer(HWND hwndDesktop,
;|***                                          HBITMAP hbmPointer,
;|***                                          BOOL fPointer,
;|***                                          LONG xHotspot,
;|***                                          LONG yHotspot);
;|***       BOOL     APIENTRY WinSetPointerPos(HWND hwndDesktop,
;|***                                          LONG x,
;|***                                          LONG y);
;|***    #else
;|***       HPOINTER APIENTRY WinLoadPointer(HWND hwndDesktop,
;|***                                        HMODULE hmod,
;|***                                        USHORT idres);
;|***       HPOINTER APIENTRY WinCreatePointer(HWND hwndDesktop,
;|***                                          HBITMAP hbmPointer,
;|***                                          BOOL fPointer,
;|***                                          SHORT xHotspot,
;|***                                          SHORT yHotspot);
;|***       BOOL     APIENTRY WinSetPointerPos(HWND hwndDesktop,
;|***                                          SHORT x,
;|***                                          SHORT y);
;|***    #endif
;|***    BOOL     APIENTRY WinDestroyPointer(HPOINTER hptr);
;|*** 
;|***    HPOINTER APIENTRY WinQueryPointer(HWND hwndDesktop);
;|***    BOOL     APIENTRY WinQueryPointerPos(HWND hwndDesktop,
;|***                                         PPOINTL pptl);
;|*** 
;|***    #ifdef INCL_32
;|***       typedef struct _POINTERINFO {  /* ptri */
;|***          ULONG   fPointer;
;|***          LONG    xHotspot;
;|***          LONG    yHotspot;
;|***          HBITMAP hbmPointer;
;|***          HBITMAP hbmColor;
;|***          HBITMAP hbmMiniPointer;
;|***          HBITMAP hbmMiniColor;
;|***       } POINTERINFO;
;|***    #else
;|***       typedef struct _POINTERINFO {  /* ptri */
;|***          USHORT  fPointer;
;|***          SHORT   xHotspot;
;|***          SHORT   yHotspot;
;|***          HBITMAP hbmPointer;
;|***          HBITMAP hbmColor;
;|***       } POINTERINFO;
;|***    #endif
;|***    typedef POINTERINFO FAR *PPOINTERINFO;
;|*** 
;|***    HPOINTER APIENTRY WinCreatePointerIndirect(HWND hwndDesktop,
;|***                                               PPOINTERINFO pptri);
;|***    BOOL     APIENTRY WinQueryPointerInfo(HPOINTER hptr,
;|***                                          PPOINTERINFO pPointerInfo);
;|***    #ifdef INCL_32
;|***       BOOL     APIENTRY WinDrawPointer(HPS hps,
;|***                                        LONG x,
;|***                                        LONG y,
;|***                                        HPOINTER hptr,
;|***                                        ULONG fs);
;|***    #else
;|***       BOOL     APIENTRY WinDrawPointer(HPS hps,
;|***                                        SHORT x,
;|***                                        SHORT y,
;|***                                        HPOINTER hptr,
;|***                                        USHORT fs);
;|***    #endif
;|*** 
;|*** 
;|*** 
;|***    /* WinDrawPointer() constants */
;|*** 
;|***    #define DP_NORMAL                  0x0000
;|***    #define DP_HALFTONED               0x0001
;|***    #define DP_INVERTED                0x0002
;|***    #define DP_MINI                    0x0004  /*   Feature:85493  */
;|*** 
;|*** 
;|***    #ifdef INCL_32
;|***       HBITMAP APIENTRY WinGetSysBitmap(HWND hwndDesktop,
;|***                                        ULONG ibm);
;|***    #else
;|***       HBITMAP APIENTRY WinGetSysBitmap(HWND hwndDesktop,
;|***                                        USHORT ibm);
;|***    #endif
;|*** 
;|***    /* System bitmaps (NOTE: these are 1-based) */
;|*** 
;|***    #define SBMP_OLD_SYSMENU           1
;|***    #define SBMP_OLD_SBUPARROW         2
;|***    #define SBMP_OLD_SBDNARROW         3
;|***    #define SBMP_OLD_SBRGARROW         4
;|***    #define SBMP_OLD_SBLFARROW         5
;|***    #define SBMP_MENUCHECK             6
;|***    #define SBMP_OLD_CHECKBOXES        7
;|***    #define SBMP_BTNCORNERS            8
;|***    #define SBMP_OLD_MINBUTTON         9
;|***    #define SBMP_OLD_MAXBUTTON         10
;|***    #define SBMP_OLD_RESTOREBUTTON     11
;|***    #define SBMP_OLD_CHILDSYSMENU      12
;|***    #define SBMP_DRIVE                 15
;|***    #define SBMP_FILE                  16
;|***    #define SBMP_FOLDER                17
;|***    #define SBMP_TREEPLUS              18
;|***    #define SBMP_TREEMINUS             19
;|***    #define SBMP_PROGRAM               22
;|***    #define SBMP_MENUATTACHED          23
;|***    #define SBMP_SIZEBOX               24
;|*** 
;|***    #define SBMP_SYSMENU               25
;|***    #define SBMP_MINBUTTON             26
;|***    #define SBMP_MAXBUTTON             27
;|***    #define SBMP_RESTOREBUTTON         28
;|***    #define SBMP_CHILDSYSMENU          29
;|***    #define SBMP_SYSMENUDEP            30
;|***    #define SBMP_MINBUTTONDEP          31
;|***    #define SBMP_MAXBUTTONDEP          32
;|***    #define SBMP_RESTOREBUTTONDEP      33
;|***    #define SBMP_CHILDSYSMENUDEP       34
;|***    #define SBMP_SBUPARROW             35
;|***    #define SBMP_SBDNARROW             36
;|***    #define SBMP_SBLFARROW             37
;|***    #define SBMP_SBRGARROW             38
;|***    #define SBMP_SBUPARROWDEP          39
;|***    #define SBMP_SBDNARROWDEP          40
;|***    #define SBMP_SBLFARROWDEP          41
;|***    #define SBMP_SBRGARROWDEP          42
;|***    #define SBMP_SBUPARROWDIS          43
;|***    #define SBMP_SBDNARROWDIS          44
;|***    #define SBMP_SBLFARROWDIS          45
;|***    #define SBMP_SBRGARROWDIS          46
;|***    #define SBMP_COMBODOWN             47
;|***    #define SBMP_CHECKBOXES        48
;|*** 
;|*** #endif /* INCL_WINPOINTERS */
;|*** 
;|*** 
;|*** /**** Hook manager */
;|*** 
;|*** #ifdef INCL_WINHOOKS
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #ifdef INCL_32
;|***          BOOL APIENTRY WinSetHook(HAB hab,
;|***                                   HMQ hmq,
;|***                                   LONG iHook,
;|***                                   PFN pfnHook,
;|***                                   HMODULE hmod);
;|***          BOOL APIENTRY WinReleaseHook(HAB hab,
;|***                                       HMQ hmq,
;|***                                       LONG iHook,
;|***                                       PFN pfnHook,
;|***                                       HMODULE hmod);
;|***          BOOL APIENTRY WinCallMsgFilter(HAB hab,
;|***                                         PQMSG pqmsg,
;|***                                         ULONG msgf);
;|***       #else
;|***          BOOL APIENTRY WinSetHook(HAB hab,
;|***                                   HMQ hmq,
;|***                                   SHORT iHook,
;|***                                   PFN pfnHook,
;|***                                   HMODULE hmod);
;|***          BOOL APIENTRY WinReleaseHook(HAB hab,
;|***                                       HMQ hmq,
;|***                                       SHORT iHook,
;|***                                       PFN pfnHook,
;|***                                       HMODULE hmod);
;|***          BOOL APIENTRY WinCallMsgFilter(HAB hab,
;|***                                         PQMSG pqmsg,
;|***                                         USHORT msgf);
;|***       #endif
;|*** 
;|*** 
;|***       /**********************************************************************
;|***       * Hook codes
;|***       *
;|***       * Whether the hook receives a (U)SHORT or (U)LONG parameter depends
;|***       * on the memory model that the hook executes in. 32-bit hook will
;|***       * receive long parameters
;|***       *
;|***       **********************************************************************/
;|*** 
;|***       #define HK_SENDMSG                 0
;|***       /* VOID EXPENTRY SendMsgHook(HAB hab,               ** installer's hab
;|***       *                            PSMHSTRUCT psmh,       ** p send msg struct
;|***       *                            BOOL fInterTask);      ** between threads */
;|*** 
;|***       #define HK_INPUT                   1
;|***       /* BOOL EXPENTRY InputHook(HAB hab,                 ** installer's hab
;|***       *                          PQMSG pQmsg,             ** p qmsg
;|***       *                          ULONG/USHORT fs);        ** remove/noremove */
;|*** 
;|***       #define HK_MSGFILTER               2
;|***       /* BOOL EXPENTRY MsgFilterHook(HAB hab,             ** installer's hab
;|***       *                              PQMSG pQmsg,         ** p qmsg
;|***       *                              ULONG/USHORT msgf);  ** filter flag */
;|*** 
;|***       #define HK_JOURNALRECORD           3
;|***       /* VOID EXPENTRY JournalRecordHook(HAB hab,         ** installer's hab
;|***       *                                  PQMSG pQmsg);    ** p qmsg */
;|*** 
;|***       #define HK_JOURNALPLAYBACK         4
;|***       /* ULONG EXPENTRY JournalPlaybackHook(HAB hab,      **installer's hab
;|***       *                                     BOOL fSkip,   ** skip messages
;|***       *                                     PQMSG pQmsg); ** p qmsg */
;|*** 
;|***       #define HK_HELP                    5
;|***       /* BOOL EXPENTRY HelpHook(HAB hab,                  ** installer's hab
;|***       *                         ULONG/USHORT usMode,      ** mode
;|***       *                         ULONG/USHORT idTopic,     ** main topic
;|***       *                         ULONG/USHORT idSubTopic,  ** sub topic
;|***       *                         PRECTL prcPosition);      ** associated position */
;|*** 
;|***       #define HK_LOADER                  6
;|***       /* BOOL EXPENTRY LoaderHook(HAB hab,                ** installer's hab
;|***       *                           LONG/USHORT idContext,  ** who called hook
;|***       *                           PSZ pszLibname,         ** lib name string
;|***       *                           PHLIB hlib,             ** p to lib handle
;|***       *                           PSZ pszProcname,        ** procedure name
;|***       *                           PFNWP wndProc);         ** window procedure */
;|*** 
;|***       #define HK_REGISTERUSERMSG         7
;|***       /* BOOL EXPENTRY RegisterUserHook(HAB hab,          ** installer's hab
;|***       *                                 ULONG cUshort,    ** entries in arRMP
;|***       *                                 PULONG/PUSHORT arRMP, ** RMP array
;|***       *                                 PBOOL fRegistered); ** msg parms already reg*/
;|*** 
;|***       #define HK_MSGCONTROL              8
;|***       /* BOOL EXPENTRY MsgControlHook(HAB hab,            ** installer's hab
;|***       *                               LONG/SHORT idContext,** who called hook
;|***       *                               HWND hwnd,          ** SEI window handle
;|***       *                               PSZ pszClassname,   ** window class name
;|***       *                               ULONG/USHORT usMsgclass,** interested msg class **
;|***       *                               LONG/SHORT idControl,** SMI_*
;|***       *                               PBOOL fSuccess);    ** mode already set */
;|*** 
;|***       #define HK_PLIST_ENTRY             9
;|***       /* BOOL EXPENTRY ProgramListEntryHook(HAB hab,      ** installer's hab
;|***       *                                     PPRFHOOKPARMS pProfileHookParams,** data
;|***       *                                     PBOOL fNoExecute);  ** cease hook processing*/
;|*** 
;|***       #define HK_PLIST_EXIT              10
;|***       /* BOOL EXPENTRY ProgramListExitHook(HAB hab,       ** installer's hab
;|***       *                                    PPRFHOOKPARMS pProfileHookParams);** data*/
;|*** 
;|***       #define HK_FINDWORD                11
;|***       /* BOOL EXPENTRY FindWordHook(usCodepage,           ** code page to use
;|***       *                             PSZ pszText,          ** text to break
;|***       *                             ULONG cb,             ** maximum text size
;|***       *                             ULONG ich,            ** break 'near' here
;|***       *                             PULONG pichStart,     ** where break began
;|***       *                             PULONG pichEnd,       ** where break ended
;|***       *                             PULONG pichNext);     ** where next word begin*/
;|*** 
;|***       #define HK_CODEPAGECHANGED         12
;|***       /* VOID EXPENTRY CodePageChangedHook(HMQ hmq,       ** msg q handle
;|***       *                                    ULONG/USHORT usOldCodepage, ** old code page
;|***       *                                    ULONG/USHORT usNewCodepage);** new code page*/
;|*** 
;|***       #define HK_WINDOWDC                15
;|***       /* BOOL EXPENTRY WindowDCHook(HAB  hab,             ** installer's hab
;|***       *                             HDC  hdc,             ** current hdc
;|***       *                             HWND hwnd,            ** current hwnd
;|***       *                             BOOL);                ** association flag */
;|*** 
;|***       #define HK_DESTROYWINDOW           16
;|***       /* BOOL EXPENTRY DestroyWindowHook (HAB  hab,       ** installer's hab
;|***       *                                   HWND hwnd,      ** destroyed win hwnd
;|***       *                                   ULONG Reserved);** association flag  */
;|*** 
;|***       #define HK_CHECKMSGFILTER          20
;|***       /* BOOL EXPENTRY CheckMsgFilteHook (HAB  hab,       ** installer's hab
;|***       *                                   PQMSG pQmsg,    ** p qmsg
;|***       *                                   ULONG/USHORT usFirst,  ** first msg
;|***       *                                   ULONG/USHORT usLast,   ** last msg
;|***       *                                   ULONG/USHORT fOptions);** flags  */
;|*** 
;|***       #define HK_MSGINPUT                21
;|***       /* BOOL EXPENTRY MsgInputHook (HAB  hab,          ** installer's hab
;|***       *                              PQMSG pQmsg,       ** p qmsg
;|***       *                              BOOL fSkip,        ** skip msg
;|***       *                              PBOOL pfNoRecord); ** journal record event */
;|*** 
;|***       #define HK_LOCKUP                  23
;|***       /* BOOL EXPENTRY LockupHook (HAB  hab,              ** installer's hab
;|***       *                           HWND hwndLockupFrame); ** hwnd     */
;|*** 
;|***       #define HK_FLUSHBUF                24
;|***       /* BOOL EXPENTRY FlushBufHook (HAB  hab);           ** installer's hab */
;|*** 
;|***       /*** Current message queue constant **********************************/
;|***       #define HMQ_CURRENT          ((HMQ)1)
;|*** 
;|***       /*** WH_MSGFILTER context codes **************************************/
;|***       #define MSGF_DIALOGBOX             1
;|***       #define MSGF_MESSAGEBOX            2
;|***       #define MSGF_TRACK                 8
;|***       #define MSGF_DDEPOSTMSG            3
;|*** 
;|***       /*** HK_HELP Help modes **********************************************/
;|***       #define HLPM_FRAME              (-1)
;|***       #define HLPM_WINDOW             (-2)
;|***       #define HLPM_MENU               (-3)
;|*** 
;|***       /*** HK_SENDMSG structure ********************************************/
;|***       #define PM_MODEL_1X      0
;|***       #define PM_MODEL_2X      1
;|*** 
;|***       #ifdef INCL_32
;|***          typedef struct _SMHSTRUCT {    /* smhs */
;|***             MPARAM mp2;
;|***             MPARAM mp1;
;|***             ULONG  msg;
;|***             HWND   hwnd;
;|***             ULONG  model;
;|***          } SMHSTRUCT;
;|***       #else
;|***          typedef struct _SMHSTRUCT {    /* smhs */
;|***             MPARAM mp2;
;|***             MPARAM mp1;
;|***             USHORT msg;
;|***             HWND   hwnd;
;|***             USHORT model;
;|***          } SMHSTRUCT;
;|***       #endif
;|***       typedef SMHSTRUCT *PSMHSTRUCT;
;|*** 
;|***       /*HK_LOADER context codes */
;|*** 
;|***       #define LHK_DELETEPROC             1
;|***       #define LHK_DELETELIB              2
;|***       #define LHK_LOADPROC               3
;|***       #define LHK_LOADLIB                4
;|*** 
;|***       /*HK_MSGCONTROL context codes */
;|*** 
;|***       #define MCHK_MSGINTEREST           1
;|***       #define MCHK_CLASSMSGINTEREST      2
;|***       #define MCHK_SYNCHRONISATION       3
;|***       #define MCHK_MSGMODE               4
;|*** 
;|***       /*HK_REGISTERUSERMSG conext codes */
;|*** 
;|***       #define RUMHK_DATATYPE             1
;|***       #define RUMHK_MSG                  2
;|*** 
;|***    #endif /* INCL_SAADEFS */
;|*** 
;|*** #endif /* INCL_WINHOOKS */
;|*** 
;|*** 
;|*** #ifdef INCL_WINTHUNKAPI
;|*** 
;|***    BOOL    APIENTRY WinSetClassThunkProc(PSZ pszClassname,
;|***                                          PFN pfnThunkProc);
;|***    PFN     APIENTRY WinQueryClassThunkProc(PSZ pszClassname);
;|***    BOOL    APIENTRY WinSetWindowThunkProc(HWND hwnd,
;|***                                           PFN pfnThunkProc);
;|***    PFN     APIENTRY WinQueryWindowThunkProc(HWND hwnd);
;|***    #ifdef INCL_32
;|***       LONG   APIENTRY WinQueryWindowModel(HWND hwnd);
;|***    #else
;|***       SHORT   APIENTRY WinQueryWindowModel(HWND hwnd);
;|***    #endif
;|*** 
;|*** #endif /* INCL_WINTHUNKAPI */
;|*** 
;|*** /*
;|*** * Include Shell API
;|*** */
;|*** #ifndef INCL_SAADEFS
;|***    #include <pmshl.h>      /* OS/2 Shell definitions */
; Line 4753
;|*** #include <pmgpi.h>        /* OS/2 GPI definitions               */
; Line 96
;|*** #include <pmdev.h>        /* OS/2 Device Context definitions    */
; Line 97
;|*** #ifndef __IBMC__
;|*** /* LATER should include pmwp.h for both IBM and MS, but I don't want */
;|*** /* to break anyone now! David Kerr */
;|*** #else
;|*** #include <pmwp.h>         /* OS/2 Workplace Shell               */
;|*** #endif
;|*** 
;|*** #ifdef INCL_AVIO
;|***    #ifndef __IBMC__
;|***       #ifdef INCL_16
;|***          #include <pmavio.h> /* OS/2 AVIO definitions              */
;|***       #endif
;|***    #else
;|***       #include <pmavio.h>    /* OS/2 AVIO definitions              */
;|***    #endif
;|*** #endif
;|*** 
;|*** #ifdef INCL_SPL
;|***    #include <pmspl.h>     /* OS/2 Spooler definitions           */
;|*** #endif
;|*** 
;|*** #ifdef INCL_PIC
;|***    #include <pmpic.h>     /* OS/2 Picture Utilities definitions */
;|*** #endif
;|*** 
;|*** #ifdef INCL_ORDERS
;|***    #include <pmord.h>     /* OS/2 Graphical Order Formats       */
;|*** #endif
;|*** 
;|*** #ifdef INCL_FONTFILEFORMAT
;|***    #include <pmfont.h>    /* OS/2 Font File Format definition   */
;|*** #endif
;|*** 
;|*** #include <pmstddlg.h>     /* CUA controls and dialogs           */
; Line 131
;|*** //#include <memory.h>
;|*** //#include <stdlib.h>
;|*** //#include <string.h>
;|*** #include "COMDD.H"
; Line 20
;|*** #include "COMDCB.H"
; Line 21
;|*** #include "CUTIL.H"
; Line 22
;|*** #include "RMCALLS.H"
; Line 23
;|*** /**************************************************************************
;|***  *
;|***  * SOURCE FILE NAME =  RMCALLS.H
;|***  *
;|***  * DESCRIPTIVE NAME =  RM function prototypes exported to drivers
;|***  *
;|***  *
;|***  * Copyright : COPYRIGHT IBM CORPORATION, 1994, 1995
;|***  *             LICENSED MATERIAL - PROGRAM PROPERTY OF IBM
;|***  *             REFER TO COPYRIGHT INSTRUCTION FORM#G120-2083
;|***  *             RESTRICTED MATERIALS OF IBM
;|***  *             IBM CONFIDENTIAL
;|***  *
;|***  * VERSION = V1.01
;|***  *
;|***  * DATE
;|***  *
;|***  * DESCRIPTION :
;|***  *
;|***  * Purpose:
;|***  *
;|***  *
;|***  *
;|***  * FUNCTIONS  :
;|***  *
;|***  * NOTES
;|***  *
;|***  *
;|***  * STRUCTURES
;|***  *
;|***  * EXTERNAL REFERENCES
;|***  *
;|***  *
;|***  *
;|***  * EXTERNAL FUNCTIONS
;|***  *
;|***  * CHANGE ACTIVITY =
;|***  *   DATE      FLAG        APAR   CHANGE DESCRIPTION
;|***  *   --------  ----------  -----  --------------------------------------
;|***  *
;|***  ****************************************************************************/
;|*** 
;|*** 
;|*** /****************************************************************************/
;|*** /*                                                                          */
;|*** /* Function Prototypes                                                      */
;|*** /*                                                                          */
;|*** /****************************************************************************/
;|*** 
;|*** 
;|*** 
;|*** #ifndef __RM_CALLS__
;|*** #define __RM_CALLS__
;|*** 
;|*** #include <rmbase.h>
; Line 55
;|*** #include <rmioctl.h>
; Line 56
;|*** 
;|*** #include "message.c"
; Line 25
;|*** 
;|*** #define FP_SEG(fp) (*((unsigned _far *)&(fp)+1))
;|*** #define FP_OFF(fp) (*((unsigned _far *)&(fp)))
;|*** 
;|*** #ifdef use_far
;|*** extern DEVHEAD _far _stDummyHeader;
;|*** extern BYTE _far _abyPath[];
;|*** extern sBOOL _far _bSharedInterrupts;
;|*** extern WORD _far _wIntIDregister;
;|*** extern WORD _far _wOEMjumpEntry;
;|*** extern WORD _far _wOEMjumpExit;
;|*** 
;|*** extern WORD _far _wMaxDeviceCount;
;|*** 
;|*** extern WORD _far _wEndOfData;
;|*** extern DEVDEF _far _stDeviceParms[];
;|*** extern WORD _far_ _wBusType;
;|*** #else
;|*** extern DEVHEAD _stDummyHeader;
;|*** extern BYTE _abyPath[];
;|*** extern sBOOL _bSharedInterrupts;
;|*** extern WORD _wIntIDregister;
;|*** extern WORD _wOEMjumpEntry;
;|*** extern WORD _wOEMjumpExit;
;|*** 
;|*** extern WORD _wMaxDeviceCount;
;|*** 
;|*** extern WORD _wEndOfData;
;|*** extern DEVDEF _stDeviceParms[];
;|*** 
;|*** extern ADDENTRY _stAttachDD;
;|*** extern WORD _wBusType;
;|*** extern WORD bDisableRM;
;|*** extern WORD bPnPcapable;
;|*** extern char _szName[];
;|*** extern BYTE _byAdapterType;
;|*** extern BYTE _byOEMtype;
;|*** //extern BYTE byHardwareType;
;|*** extern BYTE byNextPCIslot;
;|*** 
;|*** #pragma same_seg (_stDummyHeader,_abyPath,_bSharedInterrupts, _wIntIDregister,_wOEMjumpEntry,_wOEMjumpExit,_wMaxDeviceCount,_wEndOfData,_stAttachDD,_szName,_byAdapterType,_wBusType,_byOEMtype)
;|*** 
;|*** #endif
;|*** 
;|*** extern USHORT FAR RMHELP_GetStatusPort(void);
;|*** extern BOOL FAR RMHELP_HasPNPCaps(void);
;|*** extern USHORT FAR RMHELP_GetPorts(DCBHEAD *pComInfo, USHORT usPortNumber);
;|*** extern USHORT FAR RMHELP_StatusPortInitComplete(void);
;|*** extern void RMHELP_CreateDriver(void);
;|*** extern void RMHELP_DestroyDriver(void);
;|*** 
;|*** /*
;|*** ** don't need segment
;|*** */
;|*** extern VOID NEAR *_pCOMscopeStrategy;
;|*** extern VOID NEAR *_pDeviceStrategy;
;|*** 
;|*** extern char chFailedReadIni[];
;|*** extern char chFailedWriteIni[];
;|*** extern char chFailedIniCorrupt_1[];
;|*** extern char chFailedIniCorrupt_2[];
;|*** extern char chFailedIniNotInit_1[];
;|*** extern char chFailedIniNotInit_2[];
;|*** extern char chFailedBadPath[];
;|*** extern char chFailedBadVersion_1[];
;|*** extern char chFailedBadVersion_2[];
;|*** #ifndef NO_PCI
;|*** extern char chPCIMissing[];
;|*** extern char chPCIBadIRQ[];
;|*** extern char chTooManyPCIadapters[];
;|*** extern char chPCI_LoadOrder_1[];
;|*** extern char chPCI_LoadOrder_2[];
;|*** extern PCIADPT stPCIadapterTable[];
;|*** extern PCIADPT stPCIadapterHold[];
;|*** #else
;|*** extern char chPCInotSupported[];
;|*** #endif
;|*** 
;|*** extern COMDCB stConfigParms[];
;|*** extern sBOOL bVerbose;
;|*** extern BYTE abyFileBuffer[];
;|*** extern WORD bPrintLocation;
;|*** 
;|*** extern sBOOL bWaitForCR;
;|*** extern WORD wLoadNumber;
;|*** extern WORD wLoadCount;
;|*** extern WORD wLoadFlags;
;|*** extern BYTE *pbyData;
;|*** extern BYTE abyCOMnumbers[];
;|*** extern BYTE byLoadAdapterType;
;|*** extern sBOOL bABIOSpresent;
;|*** extern sBOOL bIsTheFirst;
;|*** extern LIDTAB LIDtable[];
;|*** extern ULONG ulAvailableBufferSpace;
;|*** extern ULONG ulRequiredBufferSpace;
;|*** extern ULONG ulWriteBufferSpace;
;|*** extern sBOOL bUseDDdataSegment;
;|*** 
;|*** extern WORD _wPCIvendor;
;|*** extern WORD _wPCIdevice;
;|*** extern WORD wPCIcount;
;|*** extern WORD wPCIadapterCount;
;|*** 
;|*** extern WORD wDeviceCount;
;|*** extern WORD wDriverLoadCount;
;|*** extern WORD wDelayCount;
;|*** 
;|*** #ifdef OEM
;|*** extern sBOOL _bOEMpresent;
;|*** extern char chWrongOEM_ss[];
;|*** extern char chCompanyName[];
;|*** extern char chAdapterName[];
;|*** #endif
;|*** 
;|*** extern char szMessage[];
;|*** 
;|*** extern INSTDEF astInstallParms[];
;|*** 
;|*** extern MCAPORT astMCAportTable[];
;|*** 
;|*** #ifdef debug_ini
;|*** extern char szTIF[];
;|*** extern char szDHI[];
;|*** extern char szCHR[];
;|*** extern char szAS[];
;|*** extern char szDHR[];
;|*** extern char szCHW[];
;|*** extern char szCHA[];
;|*** extern char szTLC[];
;|*** #endif
;|*** 
;|*** /*
;|*** **  All variables delcared in this module MUST be initialized in order to force
;|*** **  them into the initialized 'C' data segment.
;|*** */
;|*** CFGINFO stConfigInfo = {0};
;|*** CFGHEAD stConfigHeader = {0};
;|*** DCBHEAD stDCBheader = {0};
;|*** 
;|*** BOOL bPrevErrorMsg = FALSE;
;|*** 
;|*** HFILE hCom = 0;
;|*** HFILE hFile = 0;
;|*** 
;|*** 
;|*** DEVDEF _far *pDeviceParms = 0;
;|*** DEVHEAD _far *pStart = 0;
;|*** DEVHEAD _far *pPrevious = 0;
;|*** WORD wDeviceStrategy = 0;
;|*** extern WORD bSeparateIDreg;
;|*** 
;|*** #ifndef NO_COMscope
;|*** WORD wCOMscopeStrategy = 0;
;|*** VOID MakeCOMscopeName(char _far szString[]);
;|*** #endif
;|*** 
;|*** DEVHEAD stDefaultDevHeader = {0,0};
;|*** 
;|*** WORD bBreakInitialization = FALSE;
;|*** 
;|*** WORD StringLength(BYTE abyString[]);
;|*** 
;|*** WORD awPorts[17] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
;|*** 
;|*** void VerifyABIOSdefinitions(WORD wLoadCount);
;|*** /*
;|*** ** All data MUST be in the data segment of the device driver (RDGROUP)
;|*** ** for the AttachDD function.
;|*** */
;|*** WORD AttachDD(char szName[],ADDENTRY *pstAttachDD);// params assume DS=DGROUP
;|*** 
;|*** void MemCopy(char _far *pDest,char _far *pSource,WORD wCount)
;|***   {
; Line 198
	PUBLIC	_MemCopy
_MemCopy	PROC FAR
	*** 000000	c8 02 00 00 		enter	2,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	wIndex = -2
;	wCount = 14
;	pSource = 10
;	pDest = 6
;|***   WORD wIndex;
;|*** 
;|***   for (wIndex = 0;wIndex < wCount;wIndex++)
; Line 201
	*** 000006	c7 46 fe 00 00 		mov	WORD PTR [bp-2],0	;wIndex
	*** 00000b	e9 03 00 		jmp	$F2479
					$FC2480:
	*** 00000e	ff 46 fe 		inc	WORD PTR [bp-2]	;wIndex
					$F2479:
	*** 000011	8b 46 0e 		mov	ax,WORD PTR [bp+14]	;wCount
	*** 000014	39 46 fe 		cmp	WORD PTR [bp-2],ax	;wIndex
	*** 000017	72 03 			jb	$JCC23
	*** 000019	e9 15 00 		jmp	$FB2481
					$JCC23:
;|***     pDest[wIndex] = pSource[wIndex];
; Line 202
	*** 00001c	c4 5e 0a 		les	bx,DWORD PTR [bp+10]	;pSource
	*** 00001f	8b 76 fe 		mov	si,WORD PTR [bp-2]	;wIndex
	*** 000022	26 8a 00 		mov	al,BYTE PTR es:[bx][si]
	*** 000025	c4 5e 06 		les	bx,DWORD PTR [bp+6]	;pDest
	*** 000028	8b 76 fe 		mov	si,WORD PTR [bp-2]	;wIndex
	*** 00002b	26 88 00 		mov	BYTE PTR es:[bx][si],al
	*** 00002e	e9 dd ff 		jmp	$FC2480
					$FB2481:
;|***   }
; Line 203
					$EX2477:
	*** 000031	5e 			pop	si
	*** 000032	5f 			pop	di
	*** 000033	c9 			leave	
	*** 000034	cb 			ret	

_MemCopy	ENDP
;|*** 
;|*** #ifdef OEM
;|*** void PrintWrongOEM(void)
;|***   {
;|***   int iLen;
;|***   
;|***   iLen = sprintf(szMessage, 0, chWrongOEM_ss,chCompanyName,chAdapterName);
;|***   VioWrtTTY(szMessage,iLen,0);
;|*** //  VioWrtTTY(chCompanyName,StringLength(chCompanyName),0);
;|*** //  VioWrtTTY(chWrongOEM_2,StringLength(chWrongOEM_2),0);
;|*** //  VioWrtTTY(chAdapterName,StringLength(chAdapterName),0);
;|*** //  VioWrtTTY(chWrongOEM_3,StringLength(chWrongOEM_3),0);
;|***   }
;|*** #endif
;|*** 
;|*** void FAR GetIniInfo(void)
;|***   {
; Line 220
	PUBLIC	_GetIniInfo
_GetIniInfo	PROC FAR
	*** 000035	c8 46 00 00 		enter	70,0
	*** 000039	57 			push	di
	*** 00003a	56 			push	si
;	ulHeaderDummy = -14
;	bPCIadapter = -46
;	wError = -2
;	wPCIerror = -42
;	ulAction = -44
;	ulCount = -30
;	ulFileError = -32
;	iLen = -28
;	rc = -10
;	wDCBindex = -26
;	wIndex = -48
;	lSaveOffset = -6
;	lSaveDCBoffset = -36
;	iPortIndex = -20
;	wSaveExt = -24
;	wDummy = -8
;	byDummy = -22
;	abySaveExt = -40
;	ulFilePosition = -18
;|***   int iLen;
;|***   WORD rc;
;|***   WORD wDCBindex;
;|***   WORD wIndex;
;|***   LONG lSaveOffset;
;|***   LONG lSaveDCBoffset;
;|***   int iPortIndex;
;|***   WORD wSaveExt;
;|***   WORD wDummy;
;|***   BYTE byDummy;
;|***   char abySaveExt[4];
;|***   //WORD wTemp;
;|***   ULONG ulFilePosition;
;|***   ULONG ulHeaderDummy;
;|***   BOOL bPCIadapter = FALSE;
; Line 235
	*** 00003b	c7 46 d2 00 00 		mov	WORD PTR [bp-46],0	;bPCIadapter
;|***   WORD wError;
;|***   WORD wPCIerror;
;|*** #ifdef _32bitAPI
;|***   ULONG ulAction;
;|***   ULONG ulCount;
;|***   ULONG ulFileError;
;|*** #else
;|***   WORD ulAction;
;|***   WORD ulCount;
;|***   WORD ulFileError;
;|*** #endif
;|*** 
;|***   ulWriteBufferSpace = 0;
; Line 248
_TEXT      ENDS
CONST      SEGMENT
$T20000	DW SEG _ulWriteBufferSpace 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 000040	8e 06 00 00 		mov	es,WORD PTR $T20000
	*** 000044	2b c0 			sub	ax,ax
	*** 000046	26 a3 02 00 		mov	WORD PTR es:_ulWriteBufferSpace+2,ax
	*** 00004a	26 a3 00 00 		mov	WORD PTR es:_ulWriteBufferSpace,ax
;|***   ulRequiredBufferSpace = 0;
; Line 249
_TEXT      ENDS
CONST      SEGMENT
$T20001	DW SEG _ulRequiredBufferSpace 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 00004e	8e 06 02 00 		mov	es,WORD PTR $T20001
	*** 000052	2b c0 			sub	ax,ax
	*** 000054	26 a3 02 00 		mov	WORD PTR es:_ulRequiredBufferSpace+2,ax
	*** 000058	26 a3 00 00 		mov	WORD PTR es:_ulRequiredBufferSpace,ax
;|***   ulFileError = FALSE;
; Line 250
	*** 00005c	c7 46 e0 00 00 		mov	WORD PTR [bp-32],0	;ulFileError
;|***   wLoadNumber = NO_INI_FILE;
; Line 251
_TEXT      ENDS
CONST      SEGMENT
$T20002	DW SEG _wLoadNumber 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 000061	8e 06 04 00 		mov	es,WORD PTR $T20002
	*** 000065	26 c7 06 00 00 ff ff 	mov	WORD PTR es:_wLoadNumber,-1
;|***   wLoadCount = 0;
; Line 252
_TEXT      ENDS
CONST      SEGMENT
$T20003	DW SEG _wLoadCount 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 00006c	8e 06 06 00 		mov	es,WORD PTR $T20003
	*** 000070	26 c7 06 00 00 00 00 	mov	WORD PTR es:_wLoadCount,0
;|***   for (wIndex = 0;wIndex < (CCHMAXPATH - 8);wIndex++)
; Line 253
	*** 000077	c7 46 d0 00 00 		mov	WORD PTR [bp-48],0	;wIndex
	*** 00007c	e9 03 00 		jmp	$F2503
					$FC2504:
	*** 00007f	ff 46 d0 		inc	WORD PTR [bp-48]	;wIndex
					$F2503:
	*** 000082	81 7e d0 fc 00 		cmp	WORD PTR [bp-48],252	;wIndex
	*** 000087	72 03 			jb	$JCC135
	*** 000089	e9 2d 00 		jmp	$FB2505
					$JCC135:
;|***     {
; Line 254
;|***     if (_abyPath[wIndex] == ' ')
; Line 255
_TEXT      ENDS
CONST      SEGMENT
$T20004	DW SEG __abyPath 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 00008c	8e 06 08 00 		mov	es,WORD PTR $T20004
	*** 000090	8b 5e d0 		mov	bx,WORD PTR [bp-48]	;wIndex
	*** 000093	26 80 bf 00 00 20 	cmp	BYTE PTR es:__abyPath[bx],32
	*** 000099	74 03 			je	$JCC153
	*** 00009b	e9 03 00 		jmp	$I2506
					$JCC153:
;|***       break;
; Line 256
	*** 00009e	e9 18 00 		jmp	$FB2505
;|***     if (_abyPath[wIndex] == 0)
; Line 257
					$I2506:
	*** 0000a1	8e 06 08 00 		mov	es,WORD PTR $T20004
	*** 0000a5	8b 5e d0 		mov	bx,WORD PTR [bp-48]	;wIndex
	*** 0000a8	26 80 bf 00 00 00 	cmp	BYTE PTR es:__abyPath[bx],0
	*** 0000ae	74 03 			je	$JCC174
	*** 0000b0	e9 03 00 		jmp	$I2507
					$JCC174:
;|***       break;
; Line 258
	*** 0000b3	e9 03 00 		jmp	$FB2505
;|***     }
; Line 259
					$I2507:
	*** 0000b6	e9 c6 ff 		jmp	$FC2504
					$FB2505:
;|***   while (_abyPath[wIndex] != '.')
; Line 260
					$FC2509:
	*** 0000b9	8e 06 08 00 		mov	es,WORD PTR $T20004
	*** 0000bd	8b 5e d0 		mov	bx,WORD PTR [bp-48]	;wIndex
	*** 0000c0	26 80 bf 00 00 2e 	cmp	BYTE PTR es:__abyPath[bx],46
	*** 0000c6	75 03 			jne	$JCC198
	*** 0000c8	e9 30 00 		jmp	$FB2510
					$JCC198:
;|***     if (wIndex-- == 0)
; Line 261
	*** 0000cb	8b 46 d0 		mov	ax,WORD PTR [bp-48]	;wIndex
	*** 0000ce	ff 4e d0 		dec	WORD PTR [bp-48]	;wIndex
	*** 0000d1	3d 00 00 		cmp	ax,0
	*** 0000d4	74 03 			je	$JCC212
	*** 0000d6	e9 1f 00 		jmp	$I2511
					$JCC212:
;|***       {
; Line 262
;|***       VioWrtTTY(chFailedBadPath,StringLength(chFailedBadPath),0);
; Line 263
	*** 0000d9	68 00 00 		push	SEG _chFailedBadPath
	*** 0000dc	68 00 00 		push	OFFSET _chFailedBadPath
	*** 0000df	68 00 00 		push	SEG _chFailedBadPath
	*** 0000e2	68 00 00 		push	OFFSET _chFailedBadPath
	*** 0000e5	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 0000ea	83 c4 04 		add	sp,4
	*** 0000ed	50 			push	ax
	*** 0000ee	6a 00 			push	0
	*** 0000f0	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***       return;
; Line 264
	*** 0000f5	e9 36 0f 		jmp	$EX2483
;|***       }
; Line 265
;|***   wSaveExt = ++wIndex;
; Line 266
					$I2511:
	*** 0000f8	e9 be ff 		jmp	$FC2509
					$FB2510:
	*** 0000fb	ff 46 d0 		inc	WORD PTR [bp-48]	;wIndex
	*** 0000fe	8b 46 d0 		mov	ax,WORD PTR [bp-48]	;wIndex
	*** 000101	89 46 e8 		mov	WORD PTR [bp-24],ax	;wSaveExt
;|***   abySaveExt[0] = _abyPath[wIndex];
; Line 267
	*** 000104	8e 06 08 00 		mov	es,WORD PTR $T20004
	*** 000108	8b 5e d0 		mov	bx,WORD PTR [bp-48]	;wIndex
	*** 00010b	26 8a 87 00 00 		mov	al,BYTE PTR es:__abyPath[bx]
	*** 000110	88 46 d8 		mov	BYTE PTR [bp-40],al	;abySaveExt
;|***   _abyPath[wIndex] = 'I';
; Line 268
	*** 000113	8b 5e d0 		mov	bx,WORD PTR [bp-48]	;wIndex
	*** 000116	26 c6 87 00 00 49 	mov	BYTE PTR es:__abyPath[bx],73
;|***   abySaveExt[1] = _abyPath[++wIndex];
; Line 269
	*** 00011c	ff 46 d0 		inc	WORD PTR [bp-48]	;wIndex
	*** 00011f	8b 5e d0 		mov	bx,WORD PTR [bp-48]	;wIndex
	*** 000122	26 8a 87 00 00 		mov	al,BYTE PTR es:__abyPath[bx]
	*** 000127	88 46 d9 		mov	BYTE PTR [bp-39],al
;|***   _abyPath[wIndex] = 'N';
; Line 270
	*** 00012a	8b 5e d0 		mov	bx,WORD PTR [bp-48]	;wIndex
	*** 00012d	26 c6 87 00 00 4e 	mov	BYTE PTR es:__abyPath[bx],78
;|***   abySaveExt[2] = _abyPath[++wIndex];
; Line 271
	*** 000133	ff 46 d0 		inc	WORD PTR [bp-48]	;wIndex
	*** 000136	8b 5e d0 		mov	bx,WORD PTR [bp-48]	;wIndex
	*** 000139	26 8a 87 00 00 		mov	al,BYTE PTR es:__abyPath[bx]
	*** 00013e	88 46 da 		mov	BYTE PTR [bp-38],al
;|***   _abyPath[wIndex] = 'I';
; Line 272
	*** 000141	8b 5e d0 		mov	bx,WORD PTR [bp-48]	;wIndex
	*** 000144	26 c6 87 00 00 49 	mov	BYTE PTR es:__abyPath[bx],73
;|***   abySaveExt[3] = _abyPath[++wIndex];
; Line 273
	*** 00014a	ff 46 d0 		inc	WORD PTR [bp-48]	;wIndex
	*** 00014d	8b 5e d0 		mov	bx,WORD PTR [bp-48]	;wIndex
	*** 000150	26 8a 87 00 00 		mov	al,BYTE PTR es:__abyPath[bx]
	*** 000155	88 46 db 		mov	BYTE PTR [bp-37],al
;|***   _abyPath[wIndex] = 0;
; Line 274
	*** 000158	8b 5e d0 		mov	bx,WORD PTR [bp-48]	;wIndex
	*** 00015b	26 c6 87 00 00 00 	mov	BYTE PTR es:__abyPath[bx],0
;|*** #ifndef NO_PCI
;|***   #if MAX_PCI_ADAPTERS > 0
;|***   GetAllSerialPCIAdapters();
; Line 277
	*** 000161	9a 00 00 00 00 		call	FAR PTR _GetAllSerialPCIAdapters
;|***   if (wPCIadapterCount > 1)
; Line 278
_TEXT      ENDS
CONST      SEGMENT
$T20005	DW SEG _wPCIadapterCount 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 000166	8e 06 0a 00 		mov	es,WORD PTR $T20005
	*** 00016a	26 83 3e 00 00 01 	cmp	WORD PTR es:_wPCIadapterCount,1
	*** 000170	77 03 			ja	$JCC368
	*** 000172	e9 31 01 		jmp	$I2513
					$JCC368:
;|***     {
; Line 279
;	awIndexList = -70
;	xHighest = -54
;	xLowest = -56
;	xCurrent = -60
;	wListIndex = -58
;	wUsedIndex = -50
;	bSkipIndex = -52
;|***     WORD awIndexList[MAX_PCI_ADAPTERS + 1];
;|***     BYTE xHighest;
;|***     BYTE xLowest;
;|***     BYTE xCurrent;
;|***     WORD wListIndex;
;|***     WORD wUsedIndex;
;|***     BOOL bSkipIndex;
;|***     
;|*** #ifdef OEM
;|***     _bOEMpresent = TRUE;
;|*** #endif                               
;|***     for (wIndex = 0; wIndex < MAX_PCI_ADAPTERS; wIndex++)
; Line 291
	*** 000175	c7 46 d0 00 00 		mov	WORD PTR [bp-48],0	;wIndex
	*** 00017a	e9 03 00 		jmp	$F2521
					$FC2522:
	*** 00017d	ff 46 d0 		inc	WORD PTR [bp-48]	;wIndex
					$F2521:
	*** 000180	83 7e d0 04 		cmp	WORD PTR [bp-48],4	;wIndex
	*** 000184	72 03 			jb	$JCC388
	*** 000186	e9 0d 00 		jmp	$FB2523
					$JCC388:
;|***       awIndexList[wIndex] = -1;
; Line 292
	*** 000189	8b 76 d0 		mov	si,WORD PTR [bp-48]	;wIndex
	*** 00018c	d1 e6 			shl	si,1
	*** 00018e	c7 42 ba ff ff 		mov	WORD PTR [bp-70][si],-1
	*** 000193	e9 e7 ff 		jmp	$FC2522
					$FB2523:
;|***     for (wListIndex = 0; wListIndex < MAX_PCI_ADAPTERS; wListIndex++)  
; Line 293
	*** 000196	c7 46 c6 00 00 		mov	WORD PTR [bp-58],0	;wListIndex
	*** 00019b	e9 03 00 		jmp	$F2524
					$FC2525:
	*** 00019e	ff 46 c6 		inc	WORD PTR [bp-58]	;wListIndex
					$F2524:
	*** 0001a1	83 7e c6 04 		cmp	WORD PTR [bp-58],4	;wListIndex
	*** 0001a5	72 03 			jb	$JCC421
	*** 0001a7	e9 91 00 		jmp	$FB2526
					$JCC421:
;|***       {
; Line 294
;|***       xLowest = 0xff;
; Line 295
	*** 0001aa	c6 46 c8 ff 		mov	BYTE PTR [bp-56],255	;xLowest
;|***       for (wIndex = 0; wIndex < MAX_PCI_ADAPTERS; wIndex++)
; Line 296
	*** 0001ae	c7 46 d0 00 00 		mov	WORD PTR [bp-48],0	;wIndex
	*** 0001b3	e9 03 00 		jmp	$F2527
					$FC2528:
	*** 0001b6	ff 46 d0 		inc	WORD PTR [bp-48]	;wIndex
					$F2527:
	*** 0001b9	83 7e d0 04 		cmp	WORD PTR [bp-48],4	;wIndex
	*** 0001bd	72 03 			jb	$JCC445
	*** 0001bf	e9 76 00 		jmp	$FB2529
					$JCC445:
;|***         {
; Line 297
;|***         if ((xCurrent = stPCIadapterTable[wIndex].xDevFuncNum) == 0)
; Line 298
_TEXT      ENDS
CONST      SEGMENT
$T20006	DW SEG _stPCIadapterTable 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 0001c2	8e 06 0c 00 		mov	es,WORD PTR $T20006
	*** 0001c6	6b 5e d0 18 		imul	bx,WORD PTR [bp-48],24	;wIndex
	*** 0001ca	26 8a 87 00 00 		mov	al,BYTE PTR es:_stPCIadapterTable[bx]
	*** 0001cf	88 46 c4 		mov	BYTE PTR [bp-60],al	;xCurrent
	*** 0001d2	3c 00 			cmp	al,0
	*** 0001d4	74 03 			je	$JCC468
	*** 0001d6	e9 03 00 		jmp	$I2530
					$JCC468:
;|***           break;
; Line 299
	*** 0001d9	e9 5c 00 		jmp	$FB2529
;|***         bSkipIndex = FALSE;
; Line 300
					$I2530:
	*** 0001dc	c7 46 cc 00 00 		mov	WORD PTR [bp-52],0	;bSkipIndex
;|***         for (wUsedIndex = 0; wUsedIndex < MAX_PCI_ADAPTERS; wUsedIndex++)
; Line 301
	*** 0001e1	c7 46 ce 00 00 		mov	WORD PTR [bp-50],0	;wUsedIndex
	*** 0001e6	e9 03 00 		jmp	$F2531
					$FC2532:
	*** 0001e9	ff 46 ce 		inc	WORD PTR [bp-50]	;wUsedIndex
					$F2531:
	*** 0001ec	83 7e ce 04 		cmp	WORD PTR [bp-50],4	;wUsedIndex
	*** 0001f0	72 03 			jb	$JCC496
	*** 0001f2	e9 1b 00 		jmp	$FB2533
					$JCC496:
;|***           if (awIndexList[wUsedIndex] == wIndex)
; Line 302
	*** 0001f5	8b 46 d0 		mov	ax,WORD PTR [bp-48]	;wIndex
	*** 0001f8	8b 76 ce 		mov	si,WORD PTR [bp-50]	;wUsedIndex
	*** 0001fb	d1 e6 			shl	si,1
	*** 0001fd	39 42 ba 		cmp	WORD PTR [bp-70][si],ax
	*** 000200	74 03 			je	$JCC512
	*** 000202	e9 08 00 		jmp	$I2534
					$JCC512:
;|***             {
; Line 303
;|***             bSkipIndex = TRUE;
; Line 304
	*** 000205	c7 46 cc 01 00 		mov	WORD PTR [bp-52],1	;bSkipIndex
;|***             break;
; Line 305
	*** 00020a	e9 03 00 		jmp	$FB2533
;|***             }
; Line 306
;|***         if (!bSkipIndex)
; Line 307
					$I2534:
	*** 00020d	e9 d9 ff 		jmp	$FC2532
					$FB2533:
	*** 000210	83 7e cc 00 		cmp	WORD PTR [bp-52],0	;bSkipIndex
	*** 000214	74 03 			je	$JCC532
	*** 000216	e9 1c 00 		jmp	$I2535
					$JCC532:
;|***           if (xCurrent < xLowest)
; Line 308
	*** 000219	8a 46 c8 		mov	al,BYTE PTR [bp-56]	;xLowest
	*** 00021c	38 46 c4 		cmp	BYTE PTR [bp-60],al	;xCurrent
	*** 00021f	72 03 			jb	$JCC543
	*** 000221	e9 11 00 		jmp	$I2536
					$JCC543:
;|***             {
; Line 309
;|***             awIndexList[wListIndex] = wIndex;
; Line 310
	*** 000224	8b 46 d0 		mov	ax,WORD PTR [bp-48]	;wIndex
	*** 000227	8b 76 c6 		mov	si,WORD PTR [bp-58]	;wListIndex
	*** 00022a	d1 e6 			shl	si,1
	*** 00022c	89 42 ba 		mov	WORD PTR [bp-70][si],ax
;|***             xLowest = xCurrent;
; Line 311
	*** 00022f	8a 46 c4 		mov	al,BYTE PTR [bp-60]	;xCurrent
	*** 000232	88 46 c8 		mov	BYTE PTR [bp-56],al	;xLowest
;|***             }
; Line 312
;|***         }
; Line 313
					$I2536:
					$I2535:
	*** 000235	e9 7e ff 		jmp	$FC2528
					$FB2529:
;|***       }
; Line 314
	*** 000238	e9 63 ff 		jmp	$FC2525
					$FB2526:
;|***     for (wIndex = 0; wIndex < MAX_PCI_ADAPTERS; wIndex++)
; Line 315
	*** 00023b	c7 46 d0 00 00 		mov	WORD PTR [bp-48],0	;wIndex
	*** 000240	e9 03 00 		jmp	$F2537
					$FC2538:
	*** 000243	ff 46 d0 		inc	WORD PTR [bp-48]	;wIndex
					$F2537:
	*** 000246	83 7e d0 04 		cmp	WORD PTR [bp-48],4	;wIndex
	*** 00024a	72 03 			jb	$JCC586
	*** 00024c	e9 41 00 		jmp	$FB2539
					$JCC586:
;|***       if (stPCIadapterTable[wIndex].xDevFuncNum == 0)
; Line 316
	*** 00024f	8e 06 0c 00 		mov	es,WORD PTR $T20006
	*** 000253	6b 5e d0 18 		imul	bx,WORD PTR [bp-48],24	;wIndex
	*** 000257	26 80 bf 00 00 00 	cmp	BYTE PTR es:_stPCIadapterTable[bx],0
	*** 00025d	74 03 			je	$JCC605
	*** 00025f	e9 06 00 		jmp	$I2540
					$JCC605:
;|***         break;
; Line 317
	*** 000262	e9 2b 00 		jmp	$FB2539
;|***       else
; Line 318
	*** 000265	e9 25 00 		jmp	$I2541
					$I2540:
;|***         MemCopy((char _far *)&stPCIadapterHold[wIndex], (char _far *)&stPCIadapterTable[awIndexList[wIndex]], sizeof (PCIADPT));
; Line 319
	*** 000268	6a 18 			push	24
	*** 00026a	8b 76 d0 		mov	si,WORD PTR [bp-48]	;wIndex
	*** 00026d	d1 e6 			shl	si,1
	*** 00026f	6b 42 ba 18 		imul	ax,WORD PTR [bp-70][si],24
	*** 000273	05 00 00 		add	ax,OFFSET _stPCIadapterTable
	*** 000276	68 00 00 		push	SEG _stPCIadapterTable
	*** 000279	50 			push	ax
	*** 00027a	6b 46 d0 18 		imul	ax,WORD PTR [bp-48],24	;wIndex
	*** 00027e	05 00 00 		add	ax,OFFSET _stPCIadapterHold
	*** 000281	68 00 00 		push	SEG _stPCIadapterHold
	*** 000284	50 			push	ax
	*** 000285	9a 00 00 00 00 		call	FAR PTR _MemCopy
	*** 00028a	83 c4 0a 		add	sp,10
					$I2541:
	*** 00028d	e9 b3 ff 		jmp	$FC2538
					$FB2539:
;|***     MemCopy((char _far *)stPCIadapterTable, (char _far *)stPCIadapterHold, (sizeof (PCIADPT) * MAX_PCI_ADAPTERS));
; Line 320
	*** 000290	6a 60 			push	96
	*** 000292	68 00 00 		push	SEG _stPCIadapterHold
	*** 000295	68 00 00 		push	OFFSET _stPCIadapterHold
	*** 000298	68 00 00 		push	SEG _stPCIadapterTable
	*** 00029b	68 00 00 		push	OFFSET _stPCIadapterTable
	*** 00029e	9a 00 00 00 00 		call	FAR PTR _MemCopy
	*** 0002a3	83 c4 0a 		add	sp,10
;|***     }
; Line 321
;|***   #endif
;|*** #endif    
;|***   if (DosOpen(_abyPath,&hFile,&ulAction,0L,0,1,0x1312,0L) == 0)
; Line 324
					$I2513:
	*** 0002a6	68 00 00 		push	SEG __abyPath
	*** 0002a9	68 00 00 		push	OFFSET __abyPath
	*** 0002ac	1e 			push	ds
	*** 0002ad	68 a8 0f 		push	OFFSET DGROUP:_hFile
	*** 0002b0	8d 46 d4 		lea	ax,WORD PTR [bp-44]	;ulAction
	*** 0002b3	16 			push	ss
	*** 0002b4	50 			push	ax
	*** 0002b5	6a 00 			push	0
	*** 0002b7	6a 00 			push	0
	*** 0002b9	6a 00 			push	0
	*** 0002bb	6a 01 			push	1
	*** 0002bd	68 12 13 		push	4882
	*** 0002c0	6a 00 			push	0
	*** 0002c2	6a 00 			push	0
	*** 0002c4	9a 00 00 00 00 		call	FAR PTR DOS16OPEN
	*** 0002c9	3d 00 00 		cmp	ax,0
	*** 0002cc	74 03 			je	$JCC716
	*** 0002ce	e9 0e 0d 		jmp	$I2542
					$JCC716:
;|***     {
; Line 325
;|***     if ((ulFileError = DosRead(hFile,(PVOID)&stConfigInfo,sizeof(CFGINFO),&ulCount)) != 0)
; Line 326
	*** 0002d1	ff 36 a8 0f 		push	WORD PTR _hFile
	*** 0002d5	1e 			push	ds
	*** 0002d6	68 00 0f 		push	OFFSET DGROUP:_stConfigInfo
	*** 0002d9	6a 2c 			push	44
	*** 0002db	8d 46 e2 		lea	ax,WORD PTR [bp-30]	;ulCount
	*** 0002de	16 			push	ss
	*** 0002df	50 			push	ax
	*** 0002e0	9a 00 00 00 00 		call	FAR PTR DOS16READ
	*** 0002e5	89 46 e0 		mov	WORD PTR [bp-32],ax	;ulFileError
	*** 0002e8	3d 00 00 		cmp	ax,0
	*** 0002eb	75 03 			jne	$JCC747
	*** 0002ed	e9 24 00 		jmp	$I2543
					$JCC747:
;|***       {
; Line 327
;|***       VioWrtTTY(chFailedReadIni,StringLength(chFailedReadIni),0);
; Line 328
	*** 0002f0	68 00 00 		push	SEG _chFailedReadIni
	*** 0002f3	68 00 00 		push	OFFSET _chFailedReadIni
	*** 0002f6	68 00 00 		push	SEG _chFailedReadIni
	*** 0002f9	68 00 00 		push	OFFSET _chFailedReadIni
	*** 0002fc	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 000301	83 c4 04 		add	sp,4
	*** 000304	50 			push	ax
	*** 000305	6a 00 			push	0
	*** 000307	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***       ulFileError |= ERR_FILE_READ;
; Line 329
	*** 00030c	81 4e e0 00 a0 		or	WORD PTR [bp-32],-24576	;ulFileError
;|***       goto gtEarlyOut;
; Line 330
	*** 000311	e9 1f 0c 		jmp	$gtEarlyOut2544
;|***       }
; Line 331
;|***     if (stConfigInfo.ulSignature != INI_FILE_SIGNATURE)
; Line 332
					$I2543:
	*** 000314	81 3e 00 0f 35 18 	cmp	WORD PTR _stConfigInfo,6197
	*** 00031a	74 03 			je	$JCC794
	*** 00031c	e9 0b 00 		jmp	$L20007
					$JCC794:
	*** 00031f	81 3e 02 0f 84 19 	cmp	WORD PTR _stConfigInfo+2,6532
	*** 000325	75 03 			jne	$JCC805
	*** 000327	e9 5c 00 		jmp	$I2545
					$JCC805:
					$L20007:
;|***       {
; Line 333
;|***       VioWrtTTY(chFailedBadVersion_1,StringLength(chFailedBadVersion_1),0);
; Line 334
	*** 00032a	68 00 00 		push	SEG _chFailedBadVersion_1
	*** 00032d	68 00 00 		push	OFFSET _chFailedBadVersion_1
	*** 000330	68 00 00 		push	SEG _chFailedBadVersion_1
	*** 000333	68 00 00 		push	OFFSET _chFailedBadVersion_1
	*** 000336	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 00033b	83 c4 04 		add	sp,4
	*** 00033e	50 			push	ax
	*** 00033f	6a 00 			push	0
	*** 000341	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***       VioWrtTTY(_abyPath,StringLength(_abyPath),0);
; Line 335
	*** 000346	68 00 00 		push	SEG __abyPath
	*** 000349	68 00 00 		push	OFFSET __abyPath
	*** 00034c	68 00 00 		push	SEG __abyPath
	*** 00034f	68 00 00 		push	OFFSET __abyPath
	*** 000352	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 000357	83 c4 04 		add	sp,4
	*** 00035a	50 			push	ax
	*** 00035b	6a 00 			push	0
	*** 00035d	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***       VioWrtTTY(chFailedBadVersion_2,StringLength(chFailedBadVersion_2),0);
; Line 336
	*** 000362	68 00 00 		push	SEG _chFailedBadVersion_2
	*** 000365	68 00 00 		push	OFFSET _chFailedBadVersion_2
	*** 000368	68 00 00 		push	SEG _chFailedBadVersion_2
	*** 00036b	68 00 00 		push	OFFSET _chFailedBadVersion_2
	*** 00036e	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 000373	83 c4 04 		add	sp,4
	*** 000376	50 			push	ax
	*** 000377	6a 00 			push	0
	*** 000379	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***       ulFileError = BAD_INI_SIGNATURE;
; Line 337
	*** 00037e	c7 46 e0 00 e0 		mov	WORD PTR [bp-32],-8192	;ulFileError
;|***       goto gtEarlyOut;
; Line 338
	*** 000383	e9 ad 0b 		jmp	$gtEarlyOut2544
;|***       }
; Line 339
;|***     if (stConfigInfo.wCFGheaderCount == 0)
; Line 340
					$I2545:
	*** 000386	83 3e 06 0f 00 		cmp	WORD PTR _stConfigInfo+6,0
	*** 00038b	74 03 			je	$JCC907
	*** 00038d	e9 5c 00 		jmp	$I2546
					$JCC907:
;|***       {
; Line 341
;|***       VioWrtTTY(chFailedIniCorrupt_1,StringLength(chFailedIniCorrupt_1),0);
; Line 342
	*** 000390	68 00 00 		push	SEG _chFailedIniCorrupt_1
	*** 000393	68 00 00 		push	OFFSET _chFailedIniCorrupt_1
	*** 000396	68 00 00 		push	SEG _chFailedIniCorrupt_1
	*** 000399	68 00 00 		push	OFFSET _chFailedIniCorrupt_1
	*** 00039c	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 0003a1	83 c4 04 		add	sp,4
	*** 0003a4	50 			push	ax
	*** 0003a5	6a 00 			push	0
	*** 0003a7	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***       VioWrtTTY(_abyPath,StringLength(_abyPath),0);
; Line 343
	*** 0003ac	68 00 00 		push	SEG __abyPath
	*** 0003af	68 00 00 		push	OFFSET __abyPath
	*** 0003b2	68 00 00 		push	SEG __abyPath
	*** 0003b5	68 00 00 		push	OFFSET __abyPath
	*** 0003b8	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 0003bd	83 c4 04 		add	sp,4
	*** 0003c0	50 			push	ax
	*** 0003c1	6a 00 			push	0
	*** 0003c3	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***       VioWrtTTY(chFailedIniCorrupt_2,StringLength(chFailedIniCorrupt_2),0);
; Line 344
	*** 0003c8	68 00 00 		push	SEG _chFailedIniCorrupt_2
	*** 0003cb	68 00 00 		push	OFFSET _chFailedIniCorrupt_2
	*** 0003ce	68 00 00 		push	SEG _chFailedIniCorrupt_2
	*** 0003d1	68 00 00 		push	OFFSET _chFailedIniCorrupt_2
	*** 0003d4	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 0003d9	83 c4 04 		add	sp,4
	*** 0003dc	50 			push	ax
	*** 0003dd	6a 00 			push	0
	*** 0003df	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***       ulFileError |= ERR_FILE_CORRUPT;
; Line 345
	*** 0003e4	81 4e e0 00 d0 		or	WORD PTR [bp-32],-12288	;ulFileError
;|***       goto gtEarlyOut;
; Line 346
	*** 0003e9	e9 47 0b 		jmp	$gtEarlyOut2544
;|***       }
; Line 347
;|***     stConfigInfo.byOEMtype = _byOEMtype;
; Line 348
					$I2546:
_TEXT      ENDS
CONST      SEGMENT
$T20008	DW SEG __byOEMtype 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 0003ec	8e 06 0e 00 		mov	es,WORD PTR $T20008
	*** 0003f0	26 a0 00 00 		mov	al,BYTE PTR es:__byOEMtype
	*** 0003f4	a2 0d 0f 		mov	BYTE PTR _stConfigInfo+13,al
;|***     wDriverLoadCount = stConfigInfo.wCFGheaderCount;
; Line 349
	*** 0003f7	a1 06 0f 		mov	ax,WORD PTR _stConfigInfo+6
_TEXT      ENDS
CONST      SEGMENT
$T20009	DW SEG _wDriverLoadCount 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 0003fa	8e 06 10 00 		mov	es,WORD PTR $T20009
	*** 0003fe	26 a3 00 00 		mov	WORD PTR es:_wDriverLoadCount,ax
;|***     lSaveOffset = stConfigInfo.oFirstCFGheader;
; Line 350
	*** 000402	a1 08 0f 		mov	ax,WORD PTR _stConfigInfo+8
	*** 000405	89 46 fa 		mov	WORD PTR [bp-6],ax	;lSaveOffset
	*** 000408	c7 46 fc 00 00 		mov	WORD PTR [bp-4],0
;|***     DosChgFilePtr(hFile,lSaveOffset,0,&ulFilePosition);
; Line 351
	*** 00040d	ff 36 a8 0f 		push	WORD PTR _hFile
	*** 000411	ff 76 fc 		push	WORD PTR [bp-4]
	*** 000414	ff 76 fa 		push	WORD PTR [bp-6]	;lSaveOffset
	*** 000417	6a 00 			push	0
	*** 000419	8d 46 ee 		lea	ax,WORD PTR [bp-18]	;ulFilePosition
	*** 00041c	16 			push	ss
	*** 00041d	50 			push	ax
	*** 00041e	9a 00 00 00 00 		call	FAR PTR DOS16CHGFILEPTR
;|***     _byAdapterType = stConfigHeader.byAdapterType;
; Line 352
	*** 000423	a0 36 0f 		mov	al,BYTE PTR _stConfigHeader+10
_TEXT      ENDS
CONST      SEGMENT
$T20010	DW SEG __byAdapterType 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 000426	8e 06 12 00 		mov	es,WORD PTR $T20010
	*** 00042a	26 a2 00 00 		mov	BYTE PTR es:__byAdapterType,al
;|***     byNextPCIslot = stConfigInfo.byNextPCIslot;
; Line 353
	*** 00042e	a0 0c 0f 		mov	al,BYTE PTR _stConfigInfo+12
_TEXT      ENDS
CONST      SEGMENT
$T20011	DW SEG _byNextPCIslot 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 000431	8e 06 14 00 		mov	es,WORD PTR $T20011
	*** 000435	26 a2 00 00 		mov	BYTE PTR es:_byNextPCIslot,al
;|***     if (bIsTheFirst)
; Line 354
_TEXT      ENDS
CONST      SEGMENT
$T20012	DW SEG _bIsTheFirst 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 000439	8e 06 16 00 		mov	es,WORD PTR $T20012
	*** 00043d	26 83 3e 00 00 00 	cmp	WORD PTR es:_bIsTheFirst,0
	*** 000443	75 03 			jne	$JCC1091
	*** 000445	e9 99 02 		jmp	$I2547
					$JCC1091:
;|***       {
; Line 355
;|***       byNextPCIslot = 0;
; Line 356
	*** 000448	8e 06 14 00 		mov	es,WORD PTR $T20011
	*** 00044c	26 c6 06 00 00 00 	mov	BYTE PTR es:_byNextPCIslot,0
;|***       stConfigInfo.byNextPCIslot = 0;
; Line 357
	*** 000452	c6 06 0c 0f 00 		mov	BYTE PTR _stConfigInfo+12,0
;|***       /*
;|***       **  Clear HeaderIsAvailable flags for all config headers if this is the
;|***       **  first COMi load.
;|***       */
;|***       DosChgFilePtr(hFile,0,0,&ulFilePosition);
; Line 362
	*** 000457	ff 36 a8 0f 		push	WORD PTR _hFile
	*** 00045b	6a 00 			push	0
	*** 00045d	6a 00 			push	0
	*** 00045f	6a 00 			push	0
	*** 000461	8d 46 ee 		lea	ax,WORD PTR [bp-18]	;ulFilePosition
	*** 000464	16 			push	ss
	*** 000465	50 			push	ax
	*** 000466	9a 00 00 00 00 		call	FAR PTR DOS16CHGFILEPTR
;|***       if ((ulFileError = DosWrite(hFile,(PVOID)&stConfigInfo,sizeof(CFGINFO),&ulCount)) != 0)
; Line 363
	*** 00046b	ff 36 a8 0f 		push	WORD PTR _hFile
	*** 00046f	1e 			push	ds
	*** 000470	68 00 0f 		push	OFFSET DGROUP:_stConfigInfo
	*** 000473	6a 2c 			push	44
	*** 000475	8d 46 e2 		lea	ax,WORD PTR [bp-30]	;ulCount
	*** 000478	16 			push	ss
	*** 000479	50 			push	ax
	*** 00047a	9a 00 00 00 00 		call	FAR PTR DOS16WRITE
	*** 00047f	89 46 e0 		mov	WORD PTR [bp-32],ax	;ulFileError
	*** 000482	3d 00 00 		cmp	ax,0
	*** 000485	75 03 			jne	$JCC1157
	*** 000487	e9 24 00 		jmp	$I2548
					$JCC1157:
;|***         {
; Line 364
;|***         VioWrtTTY(chFailedWriteIni,StringLength(chFailedWriteIni),0);
; Line 365
	*** 00048a	68 00 00 		push	SEG _chFailedWriteIni
	*** 00048d	68 00 00 		push	OFFSET _chFailedWriteIni
	*** 000490	68 00 00 		push	SEG _chFailedWriteIni
	*** 000493	68 00 00 		push	OFFSET _chFailedWriteIni
	*** 000496	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 00049b	83 c4 04 		add	sp,4
	*** 00049e	50 			push	ax
	*** 00049f	6a 00 			push	0
	*** 0004a1	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***         ulFileError |= ERR_FILE_WRITE;
; Line 366
	*** 0004a6	81 4e e0 00 c0 		or	WORD PTR [bp-32],-16384	;ulFileError
;|***         goto gtEarlyOut;
; Line 367
	*** 0004ab	e9 85 0a 		jmp	$gtEarlyOut2544
;|***         }
; Line 368
;|***       for (wIndex = 0;wIndex < stConfigInfo.wCFGheaderCount;wIndex++)
; Line 369
					$I2548:
	*** 0004ae	c7 46 d0 00 00 		mov	WORD PTR [bp-48],0	;wIndex
	*** 0004b3	e9 03 00 		jmp	$F2549
					$FC2550:
	*** 0004b6	ff 46 d0 		inc	WORD PTR [bp-48]	;wIndex
					$F2549:
	*** 0004b9	a1 06 0f 		mov	ax,WORD PTR _stConfigInfo+6
	*** 0004bc	39 46 d0 		cmp	WORD PTR [bp-48],ax	;wIndex
	*** 0004bf	72 03 			jb	$JCC1215
	*** 0004c1	e9 1d 02 		jmp	$FB2551
					$JCC1215:
;|***         {
; Line 370
;|***         if ((ulFileError = DosRead(hFile,(PVOID)&stConfigHeader,sizeof(CFGHEAD),&ulCount)) != 0)
; Line 371
	*** 0004c4	ff 36 a8 0f 		push	WORD PTR _hFile
	*** 0004c8	1e 			push	ds
	*** 0004c9	68 2c 0f 		push	OFFSET DGROUP:_stConfigHeader
	*** 0004cc	6a 3e 			push	62
	*** 0004ce	8d 46 e2 		lea	ax,WORD PTR [bp-30]	;ulCount
	*** 0004d1	16 			push	ss
	*** 0004d2	50 			push	ax
	*** 0004d3	9a 00 00 00 00 		call	FAR PTR DOS16READ
	*** 0004d8	89 46 e0 		mov	WORD PTR [bp-32],ax	;ulFileError
	*** 0004db	3d 00 00 		cmp	ax,0
	*** 0004de	75 03 			jne	$JCC1246
	*** 0004e0	e9 24 00 		jmp	$I2552
					$JCC1246:
;|***           {
; Line 372
;|***           VioWrtTTY(chFailedReadIni,StringLength(chFailedReadIni),0);
; Line 373
	*** 0004e3	68 00 00 		push	SEG _chFailedReadIni
	*** 0004e6	68 00 00 		push	OFFSET _chFailedReadIni
	*** 0004e9	68 00 00 		push	SEG _chFailedReadIni
	*** 0004ec	68 00 00 		push	OFFSET _chFailedReadIni
	*** 0004ef	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 0004f4	83 c4 04 		add	sp,4
	*** 0004f7	50 			push	ax
	*** 0004f8	6a 00 			push	0
	*** 0004fa	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***           ulFileError |= ERR_FILE_READ;
; Line 374
	*** 0004ff	81 4e e0 00 a0 		or	WORD PTR [bp-32],-24576	;ulFileError
;|***           goto gtEarlyOut;
; Line 375
	*** 000504	e9 2c 0a 		jmp	$gtEarlyOut2544
;|***           }
; Line 376
;|*** //        byAdapterType = stConfigHeader.byAdapterType;
;|*** #ifdef OEM
;|***         if (wIndex == 0)
;|***           {
;|***   #ifdef this_junk //NO_PCI
;|***           int iPCIindex;
;|***           for (iPCIindex = 0; iPCIindex < MAX_PCI_ADAPTERS; iPCIindex++)
;|***             {
;|***             if (stPCIadapterTable[iPCIindex].xDevFuncNum == 0)
;|***               break; 
;|***             if (stPCIadapterTable[wIndex].usVendorID == OEM_PCI_VENDOR)
;|***               {
;|***               _bOEMpresent = TRUE;
;|***               break;
;|***               }
;|***             }
;|***   #endif
;|***           if (!_bOEMpresent)
;|***             if ((byLoadAdapterType != HDWTYPE_NONE) && !_bSharedInterrupts)
;|***               {
;|***               if (byLoadAdapterType != stConfigHeader.byAdapterType)
;|***                 {
;|***                 if (byLoadAdapterType == HDWTYPE_DIGIBOARD)
;|***                   {
;|***                   if ((stConfigHeader.byAdapterType != HDWTYPE_FIVE) && (stConfigHeader.byAdapterType != HDWTYPE_FOUR))
;|***                     {
;|***                     PrintWrongOEM();
;|***                     ulFileError |= ERR_BAD_OEM;
;|***                     bBreakInitialization = TRUE;
;|***                     }
;|***                   }
;|***                 else
;|***                   {
;|***                   PrintWrongOEM();
;|***                   ulFileError |= ERR_BAD_OEM;
;|***                   bBreakInitialization = TRUE;
;|***                   }
;|***                 }
;|***               else
;|***                 _bOEMpresent = TRUE;
;|***               }
;|***             }
;|*** #endif
;|***         DosChgFilePtr(hFile,lSaveOffset,0,&ulFilePosition);
; Line 420
					$I2552:
	*** 000507	ff 36 a8 0f 		push	WORD PTR _hFile
	*** 00050b	ff 76 fc 		push	WORD PTR [bp-4]
	*** 00050e	ff 76 fa 		push	WORD PTR [bp-6]	;lSaveOffset
	*** 000511	6a 00 			push	0
	*** 000513	8d 46 ee 		lea	ax,WORD PTR [bp-18]	;ulFilePosition
	*** 000516	16 			push	ss
	*** 000517	50 			push	ax
	*** 000518	9a 00 00 00 00 		call	FAR PTR DOS16CHGFILEPTR
;|***         if (bBreakInitialization)
; Line 421
	*** 00051d	83 3e d4 0f 00 		cmp	WORD PTR _bBreakInitialization,0
	*** 000522	75 03 			jne	$JCC1314
	*** 000524	e9 09 00 		jmp	$I2553
					$JCC1314:
;|***           stConfigHeader.bHeaderIsAvailable = FALSE;
; Line 422
	*** 000527	c7 06 42 0f 00 00 	mov	WORD PTR _stConfigHeader+22,0
;|***         else
; Line 423
	*** 00052d	e9 06 00 		jmp	$I2554
					$I2553:
;|***           stConfigHeader.bHeaderIsAvailable = TRUE;
; Line 424
	*** 000530	c7 06 42 0f 01 00 	mov	WORD PTR _stConfigHeader+22,1
					$I2554:
;|***         if ((ulFileError = DosWrite(hFile,(PVOID)&stConfigHeader,sizeof(CFGHEAD),&ulCount)) != 0)
; Line 425
	*** 000536	ff 36 a8 0f 		push	WORD PTR _hFile
	*** 00053a	1e 			push	ds
	*** 00053b	68 2c 0f 		push	OFFSET DGROUP:_stConfigHeader
	*** 00053e	6a 3e 			push	62
	*** 000540	8d 46 e2 		lea	ax,WORD PTR [bp-30]	;ulCount
	*** 000543	16 			push	ss
	*** 000544	50 			push	ax
	*** 000545	9a 00 00 00 00 		call	FAR PTR DOS16WRITE
	*** 00054a	89 46 e0 		mov	WORD PTR [bp-32],ax	;ulFileError
	*** 00054d	3d 00 00 		cmp	ax,0
	*** 000550	75 03 			jne	$JCC1360
	*** 000552	e9 24 00 		jmp	$I2555
					$JCC1360:
;|***           {
; Line 426
;|***           VioWrtTTY(chFailedWriteIni,StringLength(chFailedWriteIni),0);
; Line 427
	*** 000555	68 00 00 		push	SEG _chFailedWriteIni
	*** 000558	68 00 00 		push	OFFSET _chFailedWriteIni
	*** 00055b	68 00 00 		push	SEG _chFailedWriteIni
	*** 00055e	68 00 00 		push	OFFSET _chFailedWriteIni
	*** 000561	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 000566	83 c4 04 		add	sp,4
	*** 000569	50 			push	ax
	*** 00056a	6a 00 			push	0
	*** 00056c	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***           ulFileError |= ERR_FILE_WRITE;
; Line 428
	*** 000571	81 4e e0 00 c0 		or	WORD PTR [bp-32],-16384	;ulFileError
;|***           goto gtEarlyOut;
; Line 429
	*** 000576	e9 ba 09 		jmp	$gtEarlyOut2544
;|***           }
; Line 430
;|***         if ((_wMaxDeviceCount != 0) && !bBreakInitialization)
; Line 431
					$I2555:
_TEXT      ENDS
CONST      SEGMENT
$T20013	DW SEG __wMaxDeviceCount 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 000579	8e 06 18 00 		mov	es,WORD PTR $T20013
	*** 00057d	26 83 3e 00 00 00 	cmp	WORD PTR es:__wMaxDeviceCount,0
	*** 000583	75 03 			jne	$JCC1411
	*** 000585	e9 35 01 		jmp	$I2556
					$JCC1411:
	*** 000588	83 3e d4 0f 00 		cmp	WORD PTR _bBreakInitialization,0
	*** 00058d	74 03 			je	$JCC1421
	*** 00058f	e9 2b 01 		jmp	$I2556
					$JCC1421:
;|***           {
; Line 432
;|***           DosChgFilePtr(hFile,(LONG)stConfigHeader.oFirstDCBheader,0,&ulFilePosition);
; Line 433
	*** 000592	ff 36 a8 0f 		push	WORD PTR _hFile
	*** 000596	6a 00 			push	0
	*** 000598	ff 36 48 0f 		push	WORD PTR _stConfigHeader+28
	*** 00059c	6a 00 			push	0
	*** 00059e	8d 46 ee 		lea	ax,WORD PTR [bp-18]	;ulFilePosition
	*** 0005a1	16 			push	ss
	*** 0005a2	50 			push	ax
	*** 0005a3	9a 00 00 00 00 		call	FAR PTR DOS16CHGFILEPTR
;|***           for (wDCBindex = 0;wDCBindex < stConfigHeader.wDCBcount;wDCBindex++)
; Line 434
	*** 0005a8	c7 46 e6 00 00 		mov	WORD PTR [bp-26],0	;wDCBindex
	*** 0005ad	e9 03 00 		jmp	$F2557
					$FC2558:
	*** 0005b0	ff 46 e6 		inc	WORD PTR [bp-26]	;wDCBindex
					$F2557:
	*** 0005b3	a1 2e 0f 		mov	ax,WORD PTR _stConfigHeader+2
	*** 0005b6	39 46 e6 		cmp	WORD PTR [bp-26],ax	;wDCBindex
	*** 0005b9	72 03 			jb	$JCC1465
	*** 0005bb	e9 ff 00 		jmp	$FB2559
					$JCC1465:
;|***             {
; Line 435
;|***             lSaveDCBoffset = ulFilePosition;
; Line 436
	*** 0005be	8b 46 ee 		mov	ax,WORD PTR [bp-18]	;ulFilePosition
	*** 0005c1	8b 56 f0 		mov	dx,WORD PTR [bp-16]
	*** 0005c4	89 46 dc 		mov	WORD PTR [bp-36],ax	;lSaveDCBoffset
	*** 0005c7	89 56 de 		mov	WORD PTR [bp-34],dx
;|***             if ((ulFileError = DosRead(hFile,(PVOID)&stDCBheader,sizeof(DCBHEAD),&ulCount)) != 0)
; Line 437
	*** 0005ca	ff 36 a8 0f 		push	WORD PTR _hFile
	*** 0005ce	1e 			push	ds
	*** 0005cf	68 6a 0f 		push	OFFSET DGROUP:_stDCBheader
	*** 0005d2	6a 3a 			push	58
	*** 0005d4	8d 46 e2 		lea	ax,WORD PTR [bp-30]	;ulCount
	*** 0005d7	16 			push	ss
	*** 0005d8	50 			push	ax
	*** 0005d9	9a 00 00 00 00 		call	FAR PTR DOS16READ
	*** 0005de	89 46 e0 		mov	WORD PTR [bp-32],ax	;ulFileError
	*** 0005e1	3d 00 00 		cmp	ax,0
	*** 0005e4	75 03 			jne	$JCC1508
	*** 0005e6	e9 24 00 		jmp	$I2560
					$JCC1508:
;|***               {
; Line 438
;|***               VioWrtTTY(chFailedReadIni,StringLength(chFailedReadIni),0);
; Line 439
	*** 0005e9	68 00 00 		push	SEG _chFailedReadIni
	*** 0005ec	68 00 00 		push	OFFSET _chFailedReadIni
	*** 0005ef	68 00 00 		push	SEG _chFailedReadIni
	*** 0005f2	68 00 00 		push	OFFSET _chFailedReadIni
	*** 0005f5	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 0005fa	83 c4 04 		add	sp,4
	*** 0005fd	50 			push	ax
	*** 0005fe	6a 00 			push	0
	*** 000600	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***               ulFileError |= ERR_FILE_READ;
; Line 440
	*** 000605	81 4e e0 00 a0 		or	WORD PTR [bp-32],-24576	;ulFileError
;|***               goto gtEarlyOut;
; Line 441
	*** 00060a	e9 26 09 		jmp	$gtEarlyOut2544
;|***               }
; Line 442
;|***             if (!bBreakInitialization)
; Line 443
					$I2560:
	*** 00060d	83 3e d4 0f 00 		cmp	WORD PTR _bBreakInitialization,0
	*** 000612	74 03 			je	$JCC1554
	*** 000614	e9 2e 00 		jmp	$I2561
					$JCC1554:
;|***               {
; Line 444
;|***               if (stDCBheader.bHeaderIsInitialized)
; Line 445
	*** 000617	83 3e 72 0f 00 		cmp	WORD PTR _stDCBheader+8,0
	*** 00061c	75 03 			jne	$JCC1564
	*** 00061e	e9 21 00 		jmp	$I2562
					$JCC1564:
;|***                 if (++wDeviceCount == _wMaxDeviceCount)
; Line 446
	*** 000621	8e 06 18 00 		mov	es,WORD PTR $T20013
	*** 000625	26 a1 00 00 		mov	ax,WORD PTR es:__wMaxDeviceCount
_TEXT      ENDS
CONST      SEGMENT
$T20014	DW SEG _wDeviceCount 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 000629	8e 06 1a 00 		mov	es,WORD PTR $T20014
	*** 00062d	26 ff 06 00 00 		inc	WORD PTR es:_wDeviceCount
	*** 000632	26 39 06 00 00 		cmp	WORD PTR es:_wDeviceCount,ax
	*** 000637	74 03 			je	$JCC1591
	*** 000639	e9 06 00 		jmp	$I2563
					$JCC1591:
;|***                   bBreakInitialization = TRUE;
; Line 447
	*** 00063c	c7 06 d4 0f 01 00 	mov	WORD PTR _bBreakInitialization,1
;|***               }
; Line 448
					$I2563:
					$I2562:
;|***             else
; Line 449
	*** 000642	e9 5f 00 		jmp	$I2564
					$I2561:
;|***               {
; Line 450
;|***               stDCBheader.bHeaderIsInitialized = FALSE;
; Line 451
	*** 000645	c7 06 72 0f 00 00 	mov	WORD PTR _stDCBheader+8,0
;|***               DosChgFilePtr(hFile,lSaveDCBoffset,0,&ulFilePosition);
; Line 452
	*** 00064b	ff 36 a8 0f 		push	WORD PTR _hFile
	*** 00064f	ff 76 de 		push	WORD PTR [bp-34]
	*** 000652	ff 76 dc 		push	WORD PTR [bp-36]	;lSaveDCBoffset
	*** 000655	6a 00 			push	0
	*** 000657	8d 46 ee 		lea	ax,WORD PTR [bp-18]	;ulFilePosition
	*** 00065a	16 			push	ss
	*** 00065b	50 			push	ax
	*** 00065c	9a 00 00 00 00 		call	FAR PTR DOS16CHGFILEPTR
;|***               if ((ulFileError = DosWrite(hFile,(PVOID)&stDCBheader,sizeof(DCBHEAD),&ulCount)) != 0)
; Line 453
	*** 000661	ff 36 a8 0f 		push	WORD PTR _hFile
	*** 000665	1e 			push	ds
	*** 000666	68 6a 0f 		push	OFFSET DGROUP:_stDCBheader
	*** 000669	6a 3a 			push	58
	*** 00066b	8d 46 e2 		lea	ax,WORD PTR [bp-30]	;ulCount
	*** 00066e	16 			push	ss
	*** 00066f	50 			push	ax
	*** 000670	9a 00 00 00 00 		call	FAR PTR DOS16WRITE
	*** 000675	89 46 e0 		mov	WORD PTR [bp-32],ax	;ulFileError
	*** 000678	3d 00 00 		cmp	ax,0
	*** 00067b	75 03 			jne	$JCC1659
	*** 00067d	e9 24 00 		jmp	$I2565
					$JCC1659:
;|***                 {
; Line 454
;|***                 VioWrtTTY(chFailedWriteIni,StringLength(chFailedWriteIni),0);
; Line 455
	*** 000680	68 00 00 		push	SEG _chFailedWriteIni
	*** 000683	68 00 00 		push	OFFSET _chFailedWriteIni
	*** 000686	68 00 00 		push	SEG _chFailedWriteIni
	*** 000689	68 00 00 		push	OFFSET _chFailedWriteIni
	*** 00068c	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 000691	83 c4 04 		add	sp,4
	*** 000694	50 			push	ax
	*** 000695	6a 00 			push	0
	*** 000697	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***                 ulFileError |= ERR_FILE_WRITE;
; Line 456
	*** 00069c	81 4e e0 00 c0 		or	WORD PTR [bp-32],-16384	;ulFileError
;|***                 goto gtEarlyOut;
; Line 457
	*** 0006a1	e9 8f 08 		jmp	$gtEarlyOut2544
;|***                 }
; Line 458
;|***               }
; Line 459
					$I2565:
					$I2564:
;|***             DosChgFilePtr(hFile,(LONG)stDCBheader.oNextDCBheader,0,&ulFilePosition);
; Line 460
	*** 0006a4	ff 36 a8 0f 		push	WORD PTR _hFile
	*** 0006a8	6a 00 			push	0
	*** 0006aa	ff 36 74 0f 		push	WORD PTR _stDCBheader+10
	*** 0006ae	6a 00 			push	0
	*** 0006b0	8d 46 ee 		lea	ax,WORD PTR [bp-18]	;ulFilePosition
	*** 0006b3	16 			push	ss
	*** 0006b4	50 			push	ax
	*** 0006b5	9a 00 00 00 00 		call	FAR PTR DOS16CHGFILEPTR
;|***             }
; Line 461
	*** 0006ba	e9 f3 fe 		jmp	$FC2558
					$FB2559:
;|***           }
; Line 462
;|***         DosChgFilePtr(hFile,(LONG)stConfigHeader.oNextCFGheader,0,&ulFilePosition);
; Line 463
					$I2556:
	*** 0006bd	ff 36 a8 0f 		push	WORD PTR _hFile
	*** 0006c1	6a 00 			push	0
	*** 0006c3	ff 36 46 0f 		push	WORD PTR _stConfigHeader+26
	*** 0006c7	6a 00 			push	0
	*** 0006c9	8d 46 ee 		lea	ax,WORD PTR [bp-18]	;ulFilePosition
	*** 0006cc	16 			push	ss
	*** 0006cd	50 			push	ax
	*** 0006ce	9a 00 00 00 00 		call	FAR PTR DOS16CHGFILEPTR
;|***         lSaveOffset = stConfigHeader.oNextCFGheader;
; Line 464
	*** 0006d3	a1 46 0f 		mov	ax,WORD PTR _stConfigHeader+26
	*** 0006d6	89 46 fa 		mov	WORD PTR [bp-6],ax	;lSaveOffset
	*** 0006d9	c7 46 fc 00 00 		mov	WORD PTR [bp-4],0
;|***         }
; Line 465
	*** 0006de	e9 d5 fd 		jmp	$FC2550
					$FB2551:
;|***       }
; Line 466
;|*** #ifndef NO_RESOURCE_MGR
;|***     if (!bDisableRM)
; Line 468
					$I2547:
_TEXT      ENDS
CONST      SEGMENT
$T20015	DW SEG _bDisableRM 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 0006e1	8e 06 1c 00 		mov	es,WORD PTR $T20015
	*** 0006e5	26 83 3e 00 00 00 	cmp	WORD PTR es:_bDisableRM,0
	*** 0006eb	74 03 			je	$JCC1771
	*** 0006ed	e9 12 00 		jmp	$I2566
					$JCC1771:
;|***       {
; Line 469
;|***       bPnPcapable = RMHELP_HasPNPCaps();
; Line 470
	*** 0006f0	9a 00 00 00 00 		call	FAR PTR _RMHELP_HasPNPCaps
_TEXT      ENDS
CONST      SEGMENT
$T20016	DW SEG _bPnPcapable 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 0006f5	8e 06 1e 00 		mov	es,WORD PTR $T20016
	*** 0006f9	26 a3 00 00 		mov	WORD PTR es:_bPnPcapable,ax
;|***       RMHELP_CreateDriver();
; Line 471
	*** 0006fd	9a 00 00 00 00 		call	FAR PTR _RMHELP_CreateDriver
;|***       }
; Line 472
;|*** #endif
;|***     DosChgFilePtr(hFile,(LONG)stConfigInfo.oFirstCFGheader,0,&ulFilePosition);
; Line 474
					$I2566:
	*** 000702	ff 36 a8 0f 		push	WORD PTR _hFile
	*** 000706	6a 00 			push	0
	*** 000708	ff 36 08 0f 		push	WORD PTR _stConfigInfo+8
	*** 00070c	6a 00 			push	0
	*** 00070e	8d 46 ee 		lea	ax,WORD PTR [bp-18]	;ulFilePosition
	*** 000711	16 			push	ss
	*** 000712	50 			push	ax
	*** 000713	9a 00 00 00 00 		call	FAR PTR DOS16CHGFILEPTR
;|***     for (wIndex = 0;wIndex < stConfigInfo.wCFGheaderCount;wIndex++)
; Line 475
	*** 000718	c7 46 d0 00 00 		mov	WORD PTR [bp-48],0	;wIndex
	*** 00071d	e9 03 00 		jmp	$F2567
					$FC2568:
	*** 000720	ff 46 d0 		inc	WORD PTR [bp-48]	;wIndex
					$F2567:
	*** 000723	a1 06 0f 		mov	ax,WORD PTR _stConfigInfo+6
	*** 000726	39 46 d0 		cmp	WORD PTR [bp-48],ax	;wIndex
	*** 000729	72 03 			jb	$JCC1833
	*** 00072b	e9 05 08 		jmp	$FB2569
					$JCC1833:
;|***       {
; Line 476
;|***       if ((ulFileError = DosRead(hFile,(PVOID)&stConfigHeader,sizeof(CFGHEAD),&ulCount)) != 0)
; Line 477
	*** 00072e	ff 36 a8 0f 		push	WORD PTR _hFile
	*** 000732	1e 			push	ds
	*** 000733	68 2c 0f 		push	OFFSET DGROUP:_stConfigHeader
	*** 000736	6a 3e 			push	62
	*** 000738	8d 46 e2 		lea	ax,WORD PTR [bp-30]	;ulCount
	*** 00073b	16 			push	ss
	*** 00073c	50 			push	ax
	*** 00073d	9a 00 00 00 00 		call	FAR PTR DOS16READ
	*** 000742	89 46 e0 		mov	WORD PTR [bp-32],ax	;ulFileError
	*** 000745	3d 00 00 		cmp	ax,0
	*** 000748	75 03 			jne	$JCC1864
	*** 00074a	e9 24 00 		jmp	$I2570
					$JCC1864:
;|***         {
; Line 478
;|***         VioWrtTTY(chFailedReadIni,StringLength(chFailedReadIni),0);
; Line 479
	*** 00074d	68 00 00 		push	SEG _chFailedReadIni
	*** 000750	68 00 00 		push	OFFSET _chFailedReadIni
	*** 000753	68 00 00 		push	SEG _chFailedReadIni
	*** 000756	68 00 00 		push	OFFSET _chFailedReadIni
	*** 000759	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 00075e	83 c4 04 		add	sp,4
	*** 000761	50 			push	ax
	*** 000762	6a 00 			push	0
	*** 000764	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***         ulFileError |= ERR_FILE_READ;
; Line 480
	*** 000769	81 4e e0 00 a0 		or	WORD PTR [bp-32],-24576	;ulFileError
;|***         goto gtEarlyOut;
; Line 481
	*** 00076e	e9 c2 07 		jmp	$gtEarlyOut2544
;|***         }
; Line 482
;|***       if (stConfigHeader.bHeaderIsAvailable && (stConfigHeader.wDCBcount != 0))
; Line 483
					$I2570:
	*** 000771	83 3e 42 0f 00 		cmp	WORD PTR _stConfigHeader+22,0
	*** 000776	75 03 			jne	$JCC1910
	*** 000778	e9 9f 07 		jmp	$I2571
					$JCC1910:
	*** 00077b	83 3e 2e 0f 00 		cmp	WORD PTR _stConfigHeader+2,0
	*** 000780	75 03 			jne	$JCC1920
	*** 000782	e9 95 07 		jmp	$I2571
					$JCC1920:
;|***         {
; Line 484
;|***         if (stConfigInfo.wCFGheaderCount > 1)
; Line 485
	*** 000785	83 3e 06 0f 01 		cmp	WORD PTR _stConfigInfo+6,1
	*** 00078a	77 03 			ja	$JCC1930
	*** 00078c	e9 2c 00 		jmp	$I2572
					$JCC1930:
;|***           {
; Line 486
;|***           iLen = sprintf(szMessage,0,"Load Number %u\r\n",(wIndex + 1));
; Line 487
	*** 00078f	8b 46 d0 		mov	ax,WORD PTR [bp-48]	;wIndex
	*** 000792	40 			inc	ax
	*** 000793	50 			push	ax
	*** 000794	1e 			push	ds
	*** 000795	68 f8 0f 		push	OFFSET DGROUP:$SG2573
	*** 000798	6a 00 			push	0
	*** 00079a	68 00 00 		push	SEG _szMessage
	*** 00079d	68 00 00 		push	OFFSET _szMessage
	*** 0007a0	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 0007a5	83 c4 0c 		add	sp,12
	*** 0007a8	89 46 e4 		mov	WORD PTR [bp-28],ax	;iLen
;|***           VioWrtTTY(szMessage,iLen,0);
; Line 488
	*** 0007ab	68 00 00 		push	SEG _szMessage
	*** 0007ae	68 00 00 		push	OFFSET _szMessage
	*** 0007b1	ff 76 e4 		push	WORD PTR [bp-28]	;iLen
	*** 0007b4	6a 00 			push	0
	*** 0007b6	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***           }
; Line 489
;|***         if ((wDelayCount = stConfigHeader.wDelayCount) != 0)
; Line 490
					$I2572:
	*** 0007bb	a1 30 0f 		mov	ax,WORD PTR _stConfigHeader+4
_TEXT      ENDS
CONST      SEGMENT
$T20017	DW SEG _wDelayCount 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 0007be	8e 06 20 00 		mov	es,WORD PTR $T20017
	*** 0007c2	26 a3 00 00 		mov	WORD PTR es:_wDelayCount,ax
	*** 0007c6	3d 00 00 		cmp	ax,0
	*** 0007c9	75 03 			jne	$JCC1993
	*** 0007cb	e9 0b 00 		jmp	$I2574
					$JCC1993:
;|***           bWaitForCR = TRUE;
; Line 491
_TEXT      ENDS
CONST      SEGMENT
$T20018	DW SEG _bWaitForCR 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 0007ce	8e 06 22 00 		mov	es,WORD PTR $T20018
	*** 0007d2	26 c7 06 00 00 01 00 	mov	WORD PTR es:_bWaitForCR,1
;|***         wLoadFlags = stConfigHeader.wLoadFlags;
; Line 492
					$I2574:
	*** 0007d9	a1 3e 0f 		mov	ax,WORD PTR _stConfigHeader+18
_TEXT      ENDS
CONST      SEGMENT
$T20019	DW SEG _wLoadFlags 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 0007dc	8e 06 24 00 		mov	es,WORD PTR $T20019
	*** 0007e0	26 a3 00 00 		mov	WORD PTR es:_wLoadFlags,ax
;|***         if (wLoadFlags & LOAD_FLAG1_VERBOSE)
; Line 493
	*** 0007e4	26 f6 06 01 00 40 	test	BYTE PTR es:_wLoadFlags+1,64
	*** 0007ea	75 03 			jne	$JCC2026
	*** 0007ec	e9 0b 00 		jmp	$I2575
					$JCC2026:
;|***           bVerbose = TRUE;
; Line 494
_TEXT      ENDS
CONST      SEGMENT
$T20020	DW SEG _bVerbose 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 0007ef	8e 06 26 00 		mov	es,WORD PTR $T20020
	*** 0007f3	26 c7 06 00 00 01 00 	mov	WORD PTR es:_bVerbose,1
;|***         if (wLoadFlags & LOAD_FLAG1_PRINT_LOCAL)
; Line 495
					$I2575:
	*** 0007fa	8e 06 24 00 		mov	es,WORD PTR $T20019
	*** 0007fe	26 f6 06 01 00 20 	test	BYTE PTR es:_wLoadFlags+1,32
	*** 000804	75 03 			jne	$JCC2052
	*** 000806	e9 0b 00 		jmp	$I2576
					$JCC2052:
;|***           bPrintLocation = TRUE;
; Line 496
_TEXT      ENDS
CONST      SEGMENT
$T20021	DW SEG _bPrintLocation 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 000809	8e 06 28 00 		mov	es,WORD PTR $T20021
	*** 00080d	26 c7 06 00 00 01 00 	mov	WORD PTR es:_bPrintLocation,1
;|***         bSeparateIDreg = TRUE;
; Line 497
					$I2576:
_TEXT      ENDS
CONST      SEGMENT
$T20022	DW SEG _bSeparateIDreg 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 000814	8e 06 2a 00 		mov	es,WORD PTR $T20022
	*** 000818	26 c7 06 00 00 01 00 	mov	WORD PTR es:_bSeparateIDreg,1
;|***         if (stConfigHeader.byAdapterType != HDWTYPE_PCI)
; Line 498
	*** 00081f	80 3e 36 0f 09 		cmp	BYTE PTR _stConfigHeader+10,9
	*** 000824	75 03 			jne	$JCC2084
	*** 000826	e9 55 00 		jmp	$I2577
					$JCC2084:
;|***           {
; Line 499
;|***           _wIntIDregister = stConfigHeader.wIntIDregister;
; Line 500
	*** 000829	a1 40 0f 		mov	ax,WORD PTR _stConfigHeader+20
_TEXT      ENDS
CONST      SEGMENT
$T20023	DW SEG __wIntIDregister 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 00082c	8e 06 2c 00 		mov	es,WORD PTR $T20023
	*** 000830	26 a3 00 00 		mov	WORD PTR es:__wIntIDregister,ax
;|***           /*
;|***           ** if device is DigiBoard (<=8 port) and interrupt level is even then
;|***           ** increment ID register address
;|***           */
;|***           if (wLoadFlags & LOAD_FLAG1_DIGIBOARD08_INT_ID)
; Line 505
	*** 000834	8e 06 24 00 		mov	es,WORD PTR $T20019
	*** 000838	26 f6 06 00 00 02 	test	BYTE PTR es:_wLoadFlags,2
	*** 00083e	75 03 			jne	$JCC2110
	*** 000840	e9 13 00 		jmp	$I2578
					$JCC2110:
;|***             if ((stConfigHeader.byInterruptLevel & 0x01) == 0)
; Line 506
	*** 000843	f6 06 37 0f 01 		test	BYTE PTR _stConfigHeader+11,1
	*** 000848	74 03 			je	$JCC2120
	*** 00084a	e9 09 00 		jmp	$I2579
					$JCC2120:
;|***               _wIntIDregister++;
; Line 507
	*** 00084d	8e 06 2c 00 		mov	es,WORD PTR $T20023
	*** 000851	26 ff 06 00 00 		inc	WORD PTR es:__wIntIDregister
;|***           if (_wIntIDregister != 0)
; Line 508
					$I2579:
					$I2578:
	*** 000856	8e 06 2c 00 		mov	es,WORD PTR $T20023
	*** 00085a	26 83 3e 00 00 00 	cmp	WORD PTR es:__wIntIDregister,0
	*** 000860	75 03 			jne	$JCC2144
	*** 000862	e9 16 00 		jmp	$I2580
					$JCC2144:
;|***             {
; Line 509
;|***             _wOEMjumpEntry = stConfigHeader.wOEMentryVector;
; Line 510
	*** 000865	a1 38 0f 		mov	ax,WORD PTR _stConfigHeader+12
_TEXT      ENDS
CONST      SEGMENT
$T20024	DW SEG __wOEMjumpEntry 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 000868	8e 06 2e 00 		mov	es,WORD PTR $T20024
	*** 00086c	26 a3 00 00 		mov	WORD PTR es:__wOEMjumpEntry,ax
;|***             _wOEMjumpExit = stConfigHeader.wOEMexitVector;
; Line 511
	*** 000870	a1 3a 0f 		mov	ax,WORD PTR _stConfigHeader+14
_TEXT      ENDS
CONST      SEGMENT
$T20025	DW SEG __wOEMjumpExit 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 000873	8e 06 30 00 		mov	es,WORD PTR $T20025
	*** 000877	26 a3 00 00 		mov	WORD PTR es:__wOEMjumpExit,ax
;|***             }
; Line 512
;|***           }
; Line 513
					$I2580:
;|***         else
; Line 514
	*** 00087b	e9 50 01 		jmp	$I2581
					$I2577:
;|***           {
; Line 515
;	bForceInterrupt = -70
;|*** #ifndef NO_PCI
;|***           BOOL bForceInterrupt = FALSE;
; Line 517
	*** 00087e	c7 46 ba 00 00 		mov	WORD PTR [bp-70],0	;awIndexList
;|***           
;|***           if ((wPCIerror = LoadPCIAdapter(wIndex,&stConfigHeader.byInterruptLevel,awPorts)) != NO_ERROR)
; Line 519
	*** 000883	1e 			push	ds
	*** 000884	68 d6 0f 		push	OFFSET DGROUP:_awPorts
	*** 000887	1e 			push	ds
	*** 000888	68 37 0f 		push	OFFSET DGROUP:_stConfigHeader+11
	*** 00088b	ff 76 d0 		push	WORD PTR [bp-48]	;wIndex
	*** 00088e	9a 00 00 00 00 		call	FAR PTR _LoadPCIAdapter
	*** 000893	83 c4 0a 		add	sp,10
	*** 000896	89 46 d6 		mov	WORD PTR [bp-42],ax	;wPCIerror
	*** 000899	3d 00 00 		cmp	ax,0
	*** 00089c	75 03 			jne	$JCC2204
	*** 00089e	e9 75 00 		jmp	$I2584
					$JCC2204:
;|***             {
; Line 520
;|***             if (wPCIerror == 0xfffe)
; Line 521
	*** 0008a1	83 7e d6 fe 		cmp	WORD PTR [bp-42],-2	;wPCIerror
	*** 0008a5	74 03 			je	$JCC2213
	*** 0008a7	e9 1f 00 		jmp	$I2585
					$JCC2213:
;|***               VioWrtTTY(chPCIBadIRQ,StringLength(chPCIBadIRQ),0);
; Line 522
	*** 0008aa	68 00 00 		push	SEG _chPCIBadIRQ
	*** 0008ad	68 00 00 		push	OFFSET _chPCIBadIRQ
	*** 0008b0	68 00 00 		push	SEG _chPCIBadIRQ
	*** 0008b3	68 00 00 		push	OFFSET _chPCIBadIRQ
	*** 0008b6	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 0008bb	83 c4 04 		add	sp,4
	*** 0008be	50 			push	ax
	*** 0008bf	6a 00 			push	0
	*** 0008c1	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***             else
; Line 523
	*** 0008c6	e9 44 00 		jmp	$I2586
					$I2585:
;|***               if (wPCIerror == 0xfffd)
; Line 524
	*** 0008c9	83 7e d6 fd 		cmp	WORD PTR [bp-42],-3	;wPCIerror
	*** 0008cd	74 03 			je	$JCC2253
	*** 0008cf	e9 1f 00 		jmp	$I2587
					$JCC2253:
;|***                 VioWrtTTY(chTooManyPCIadapters,StringLength(chTooManyPCIadapters),0);
; Line 525
	*** 0008d2	68 00 00 		push	SEG _chTooManyPCIadapters
	*** 0008d5	68 00 00 		push	OFFSET _chTooManyPCIadapters
	*** 0008d8	68 00 00 		push	SEG _chTooManyPCIadapters
	*** 0008db	68 00 00 		push	OFFSET _chTooManyPCIadapters
	*** 0008de	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 0008e3	83 c4 04 		add	sp,4
	*** 0008e6	50 			push	ax
	*** 0008e7	6a 00 			push	0
	*** 0008e9	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***               else
; Line 526
	*** 0008ee	e9 1c 00 		jmp	$I2588
					$I2587:
;|***                 VioWrtTTY(chPCIMissing,StringLength(chPCIMissing),0);
; Line 527
	*** 0008f1	68 00 00 		push	SEG _chPCIMissing
	*** 0008f4	68 00 00 		push	OFFSET _chPCIMissing
	*** 0008f7	68 00 00 		push	SEG _chPCIMissing
	*** 0008fa	68 00 00 		push	OFFSET _chPCIMissing
	*** 0008fd	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 000902	83 c4 04 		add	sp,4
	*** 000905	50 			push	ax
	*** 000906	6a 00 			push	0
	*** 000908	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
					$I2588:
					$I2586:
;|***             bPrevErrorMsg = TRUE;
; Line 528
	*** 00090d	c7 06 a4 0f 01 00 	mov	WORD PTR _bPrevErrorMsg,1
;|***             goto gtEarlyOut;
; Line 529
	*** 000913	e9 1d 06 		jmp	$gtEarlyOut2544
;|***             }
; Line 530
;|***           bPCIadapter = TRUE;
; Line 531
					$I2584:
	*** 000916	c7 46 d2 01 00 		mov	WORD PTR [bp-46],1	;bPCIadapter
;|***           _wBusType = BUSTYPE_PCI;
; Line 532
_TEXT      ENDS
CONST      SEGMENT
$T20026	DW SEG __wBusType 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 00091b	8e 06 32 00 		mov	es,WORD PTR $T20026
	*** 00091f	26 c7 06 00 00 05 00 	mov	WORD PTR es:__wBusType,5
;|***           byNextPCIslot++;
; Line 533
	*** 000926	8e 06 14 00 		mov	es,WORD PTR $T20011
	*** 00092a	26 fe 06 00 00 		inc	BYTE PTR es:_byNextPCIslot
;|***           stConfigHeader.byPCIslot = byNextPCIslot;
; Line 534
	*** 00092f	26 a0 00 00 		mov	al,BYTE PTR es:_byNextPCIslot
	*** 000933	a2 4e 0f 		mov	BYTE PTR _stConfigHeader+34,al
;|***           stConfigHeader.wPCIvendor = stPCIadapterTable[wIndex].usVendorID;
; Line 535
	*** 000936	8e 06 0c 00 		mov	es,WORD PTR $T20006
	*** 00093a	6b 5e d0 18 		imul	bx,WORD PTR [bp-48],24	;wIndex
	*** 00093e	26 8b 87 04 00 		mov	ax,WORD PTR es:_stPCIadapterTable[bx+4]
	*** 000943	a3 4a 0f 		mov	WORD PTR _stConfigHeader+30,ax
;|***           _wPCIvendor = stConfigHeader.wPCIvendor;
; Line 536
	*** 000946	a1 4a 0f 		mov	ax,WORD PTR _stConfigHeader+30
_TEXT      ENDS
CONST      SEGMENT
$T20027	DW SEG __wPCIvendor 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 000949	8e 06 34 00 		mov	es,WORD PTR $T20027
	*** 00094d	26 a3 00 00 		mov	WORD PTR es:__wPCIvendor,ax
;|***           stConfigHeader.wPCIdevice = stPCIadapterTable[wIndex].usDeviceID;
; Line 537
	*** 000951	8e 06 0c 00 		mov	es,WORD PTR $T20006
	*** 000955	6b 5e d0 18 		imul	bx,WORD PTR [bp-48],24	;wIndex
	*** 000959	26 8b 87 06 00 		mov	ax,WORD PTR es:_stPCIadapterTable[bx+6]
	*** 00095e	a3 4c 0f 		mov	WORD PTR _stConfigHeader+32,ax
;|***           _wPCIdevice = stConfigHeader.wPCIdevice;
; Line 538
	*** 000961	a1 4c 0f 		mov	ax,WORD PTR _stConfigHeader+32
_TEXT      ENDS
CONST      SEGMENT
$T20028	DW SEG __wPCIdevice 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 000964	8e 06 36 00 		mov	es,WORD PTR $T20028
	*** 000968	26 a3 00 00 		mov	WORD PTR es:__wPCIdevice,ax
;|***           stConfigInfo.byNextPCIslot = byNextPCIslot;
; Line 539
	*** 00096c	8e 06 14 00 		mov	es,WORD PTR $T20011
	*** 000970	26 a0 00 00 		mov	al,BYTE PTR es:_byNextPCIslot
	*** 000974	a2 0c 0f 		mov	BYTE PTR _stConfigInfo+12,al
;|***           DosChgFilePtr(hFile,0,0,&ulHeaderDummy);
; Line 540
	*** 000977	ff 36 a8 0f 		push	WORD PTR _hFile
	*** 00097b	6a 00 			push	0
	*** 00097d	6a 00 			push	0
	*** 00097f	6a 00 			push	0
	*** 000981	8d 46 f2 		lea	ax,WORD PTR [bp-14]	;ulHeaderDummy
	*** 000984	16 			push	ss
	*** 000985	50 			push	ax
	*** 000986	9a 00 00 00 00 		call	FAR PTR DOS16CHGFILEPTR
;|***           if ((ulFileError = DosWrite(hFile,(PVOID)&stConfigInfo,sizeof(CFGINFO),&ulCount)) != 0)
; Line 541
	*** 00098b	ff 36 a8 0f 		push	WORD PTR _hFile
	*** 00098f	1e 			push	ds
	*** 000990	68 00 0f 		push	OFFSET DGROUP:_stConfigInfo
	*** 000993	6a 2c 			push	44
	*** 000995	8d 46 e2 		lea	ax,WORD PTR [bp-30]	;ulCount
	*** 000998	16 			push	ss
	*** 000999	50 			push	ax
	*** 00099a	9a 00 00 00 00 		call	FAR PTR DOS16WRITE
	*** 00099f	89 46 e0 		mov	WORD PTR [bp-32],ax	;ulFileError
	*** 0009a2	3d 00 00 		cmp	ax,0
	*** 0009a5	75 03 			jne	$JCC2469
	*** 0009a7	e9 24 00 		jmp	$I2589
					$JCC2469:
;|***             {
; Line 542
;|***             VioWrtTTY(chFailedWriteIni,StringLength(chFailedWriteIni),0);
; Line 543
	*** 0009aa	68 00 00 		push	SEG _chFailedWriteIni
	*** 0009ad	68 00 00 		push	OFFSET _chFailedWriteIni
	*** 0009b0	68 00 00 		push	SEG _chFailedWriteIni
	*** 0009b3	68 00 00 		push	OFFSET _chFailedWriteIni
	*** 0009b6	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 0009bb	83 c4 04 		add	sp,4
	*** 0009be	50 			push	ax
	*** 0009bf	6a 00 			push	0
	*** 0009c1	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***             ulFileError |= ERR_FILE_WRITE;
; Line 544
	*** 0009c6	81 4e e0 00 c0 		or	WORD PTR [bp-32],-16384	;ulFileError
;|***             goto gtEarlyOut;
; Line 545
	*** 0009cb	e9 65 05 		jmp	$gtEarlyOut2544
;|***             }
; Line 546
;|*** #else
;|***           // PCI not allowed in this version
;|***           VioWrtTTY(chPCInotSupported,StringLength(chPCInotSupported),0);
;|***           bPrevErrorMsg = TRUE;
;|***           goto gtEarlyOut;
;|*** #endif
;|***           }
; Line 553
					$I2589:
					$I2581:
;|***         stConfigHeader.bHeaderIsAvailable = FALSE;
; Line 554
	*** 0009ce	c7 06 42 0f 00 00 	mov	WORD PTR _stConfigHeader+22,0
;|***         DosChgFilePtr(hFile,ulFilePosition,0,&ulFilePosition);
; Line 555
	*** 0009d4	ff 36 a8 0f 		push	WORD PTR _hFile
	*** 0009d8	ff 76 f0 		push	WORD PTR [bp-16]
	*** 0009db	ff 76 ee 		push	WORD PTR [bp-18]	;ulFilePosition
	*** 0009de	6a 00 			push	0
	*** 0009e0	8d 46 ee 		lea	ax,WORD PTR [bp-18]	;ulFilePosition
	*** 0009e3	16 			push	ss
	*** 0009e4	50 			push	ax
	*** 0009e5	9a 00 00 00 00 		call	FAR PTR DOS16CHGFILEPTR
;|***         if ((ulFileError = DosWrite(hFile,(PVOID)&stConfigHeader,sizeof(CFGHEAD),&ulCount)) != 0)
; Line 556
	*** 0009ea	ff 36 a8 0f 		push	WORD PTR _hFile
	*** 0009ee	1e 			push	ds
	*** 0009ef	68 2c 0f 		push	OFFSET DGROUP:_stConfigHeader
	*** 0009f2	6a 3e 			push	62
	*** 0009f4	8d 46 e2 		lea	ax,WORD PTR [bp-30]	;ulCount
	*** 0009f7	16 			push	ss
	*** 0009f8	50 			push	ax
	*** 0009f9	9a 00 00 00 00 		call	FAR PTR DOS16WRITE
	*** 0009fe	89 46 e0 		mov	WORD PTR [bp-32],ax	;ulFileError
	*** 000a01	3d 00 00 		cmp	ax,0
	*** 000a04	75 03 			jne	$JCC2564
	*** 000a06	e9 24 00 		jmp	$I2590
					$JCC2564:
;|***           {
; Line 557
;|***           VioWrtTTY(chFailedWriteIni,StringLength(chFailedWriteIni),0);
; Line 558
	*** 000a09	68 00 00 		push	SEG _chFailedWriteIni
	*** 000a0c	68 00 00 		push	OFFSET _chFailedWriteIni
	*** 000a0f	68 00 00 		push	SEG _chFailedWriteIni
	*** 000a12	68 00 00 		push	OFFSET _chFailedWriteIni
	*** 000a15	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 000a1a	83 c4 04 		add	sp,4
	*** 000a1d	50 			push	ax
	*** 000a1e	6a 00 			push	0
	*** 000a20	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***           ulFileError |= ERR_FILE_WRITE;
; Line 559
	*** 000a25	81 4e e0 00 c0 		or	WORD PTR [bp-32],-16384	;ulFileError
;|***           goto gtEarlyOut;
; Line 560
	*** 000a2a	e9 06 05 		jmp	$gtEarlyOut2544
;|***           }
; Line 561
;|***         DosChgFilePtr(hFile,(LONG)stConfigHeader.oFirstDCBheader,0,&ulFilePosition);
; Line 562
					$I2590:
	*** 000a2d	ff 36 a8 0f 		push	WORD PTR _hFile
	*** 000a31	6a 00 			push	0
	*** 000a33	ff 36 48 0f 		push	WORD PTR _stConfigHeader+28
	*** 000a37	6a 00 			push	0
	*** 000a39	8d 46 ee 		lea	ax,WORD PTR [bp-18]	;ulFilePosition
	*** 000a3c	16 			push	ss
	*** 000a3d	50 			push	ax
	*** 000a3e	9a 00 00 00 00 		call	FAR PTR DOS16CHGFILEPTR
;|***         if (stConfigHeader.wDCBcount > MAX_DEVICE)
; Line 563
	*** 000a43	83 3e 2e 0f 08 		cmp	WORD PTR _stConfigHeader+2,8
	*** 000a48	77 03 			ja	$JCC2632
	*** 000a4a	e9 06 00 		jmp	$I2591
					$JCC2632:
;|***           stConfigHeader.wDCBcount = MAX_DEVICE;
; Line 564
	*** 000a4d	c7 06 2e 0f 08 00 	mov	WORD PTR _stConfigHeader+2,8
;|***         pDeviceParms = (DEVDEF _far *)_stDeviceParms;
; Line 565
					$I2591:
	*** 000a53	c7 06 aa 0f 00 00 	mov	WORD PTR _pDeviceParms,OFFSET __stDeviceParms
	*** 000a59	c7 06 ac 0f 00 00 	mov	WORD PTR _pDeviceParms+2,SEG __stDeviceParms
;|*** #ifndef NO_COMscope
;|***         wCOMscopeStrategy = (WORD)&_pCOMscopeStrategy;
; Line 567
	*** 000a5f	c7 06 b8 0f 00 00 	mov	WORD PTR _wCOMscopeStrategy,OFFSET __pCOMscopeStrategy
;|*** #endif
;|***         wDeviceStrategy = (WORD)&_pDeviceStrategy;
; Line 569
	*** 000a65	c7 06 b6 0f 00 00 	mov	WORD PTR _wDeviceStrategy,OFFSET __pDeviceStrategy
;|***         pPrevious = NULL;
; Line 570
	*** 000a6b	2b c0 			sub	ax,ax
	*** 000a6d	a3 b4 0f 		mov	WORD PTR _pPrevious+2,ax
	*** 000a70	a3 b2 0f 		mov	WORD PTR _pPrevious,ax
;|*** //        wEndOfData = ((WORD)DeviceParms + (stConfigHeader.wDCBcount * sizeof(DEVDEF)));
;|***         for (wDCBindex = 0;wDCBindex < stConfigHeader.wDCBcount;wDCBindex++)
; Line 572
	*** 000a73	c7 46 e6 00 00 		mov	WORD PTR [bp-26],0	;wDCBindex
	*** 000a78	e9 03 00 		jmp	$F2592
					$FC2593:
	*** 000a7b	ff 46 e6 		inc	WORD PTR [bp-26]	;wDCBindex
					$F2592:
	*** 000a7e	a1 2e 0f 		mov	ax,WORD PTR _stConfigHeader+2
	*** 000a81	39 46 e6 		cmp	WORD PTR [bp-26],ax	;wDCBindex
	*** 000a84	72 03 			jb	$JCC2692
	*** 000a86	e9 79 03 		jmp	$FB2594
					$JCC2692:
;|***           {
; Line 573
;|***           if ((ulFileError = DosRead(hFile,(PVOID)&stDCBheader,sizeof(DCBHEAD),&ulCount)) != 0)
; Line 574
	*** 000a89	ff 36 a8 0f 		push	WORD PTR _hFile
	*** 000a8d	1e 			push	ds
	*** 000a8e	68 6a 0f 		push	OFFSET DGROUP:_stDCBheader
	*** 000a91	6a 3a 			push	58
	*** 000a93	8d 46 e2 		lea	ax,WORD PTR [bp-30]	;ulCount
	*** 000a96	16 			push	ss
	*** 000a97	50 			push	ax
	*** 000a98	9a 00 00 00 00 		call	FAR PTR DOS16READ
	*** 000a9d	89 46 e0 		mov	WORD PTR [bp-32],ax	;ulFileError
	*** 000aa0	3d 00 00 		cmp	ax,0
	*** 000aa3	75 03 			jne	$JCC2723
	*** 000aa5	e9 24 00 		jmp	$I2595
					$JCC2723:
;|***             {
; Line 575
;|***             VioWrtTTY(chFailedReadIni,StringLength(chFailedReadIni),0);
; Line 576
	*** 000aa8	68 00 00 		push	SEG _chFailedReadIni
	*** 000aab	68 00 00 		push	OFFSET _chFailedReadIni
	*** 000aae	68 00 00 		push	SEG _chFailedReadIni
	*** 000ab1	68 00 00 		push	OFFSET _chFailedReadIni
	*** 000ab4	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 000ab9	83 c4 04 		add	sp,4
	*** 000abc	50 			push	ax
	*** 000abd	6a 00 			push	0
	*** 000abf	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***             ulFileError |= ERR_FILE_READ;
; Line 577
	*** 000ac4	81 4e e0 00 a0 		or	WORD PTR [bp-32],-24576	;ulFileError
;|***             goto gtEarlyOut;
; Line 578
	*** 000ac9	e9 67 04 		jmp	$gtEarlyOut2544
;|***             }
; Line 579
;|***           if (stDCBheader.bHeaderIsInitialized)
; Line 580
					$I2595:
	*** 000acc	83 3e 72 0f 00 		cmp	WORD PTR _stDCBheader+8,0
	*** 000ad1	75 03 			jne	$JCC2769
	*** 000ad3	e9 b1 02 		jmp	$I2596
					$JCC2769:
;|***             {
; Line 581
;|***             /*
;|***             ** if global IRQ is defined then make device IRQ equal to
;|***             ** global IRQ
;|***             */
;|***             if (stConfigHeader.byInterruptLevel != 0)
; Line 586
	*** 000ad6	80 3e 37 0f 00 		cmp	BYTE PTR _stConfigHeader+11,0
	*** 000adb	75 03 			jne	$JCC2779
	*** 000add	e9 06 00 		jmp	$I2597
					$JCC2779:
;|***               stDCBheader.stComDCB.byInterruptLevel = stConfigHeader.byInterruptLevel;
; Line 587
	*** 000ae0	a0 37 0f 		mov	al,BYTE PTR _stConfigHeader+11
	*** 000ae3	a2 9a 0f 		mov	BYTE PTR _stDCBheader+48,al
;|*** 
;|***             if (bPCIadapter)
; Line 589
					$I2597:
	*** 000ae6	83 7e d2 00 		cmp	WORD PTR [bp-46],0	;bPCIadapter
	*** 000aea	75 03 			jne	$JCC2794
	*** 000aec	e9 0f 00 		jmp	$I2598
					$JCC2794:
;|***               stDCBheader.stComDCB.wIObaseAddress = awPorts[wDCBindex];
; Line 590
	*** 000aef	8b 5e e6 		mov	bx,WORD PTR [bp-26]	;wDCBindex
	*** 000af2	d1 e3 			shl	bx,1
	*** 000af4	8b 87 d6 0f 		mov	ax,WORD PTR _awPorts[bx]
	*** 000af8	a3 80 0f 		mov	WORD PTR _stDCBheader+22,ax
;|***             else
; Line 591
	*** 000afb	e9 0f 00 		jmp	$I2599
					$I2598:
;|***               {
; Line 592
;|***               /*
;|***               **  Transfer load flag interrupt status/ID bits to device flags
;|***               */
;|***               stDCBheader.stComDCB.wConfigFlags1 |= (wLoadFlags & LOAD_FLAG1_INT_ID_LOAD_MASK);
; Line 596
	*** 000afe	8e 06 24 00 		mov	es,WORD PTR $T20019
	*** 000b02	26 a1 00 00 		mov	ax,WORD PTR es:_wLoadFlags
	*** 000b06	25 0f 80 		and	ax,-32753
	*** 000b09	09 06 7a 0f 		or	WORD PTR _stDCBheader+16,ax
;|***               }
; Line 597
					$I2599:
;|*** #ifndef NO_RESOURCE_MGR
;|***             if (!bDisableRM)
; Line 599
	*** 000b0d	8e 06 1c 00 		mov	es,WORD PTR $T20015
	*** 000b11	26 83 3e 00 00 00 	cmp	WORD PTR es:_bDisableRM,0
	*** 000b17	74 03 			je	$JCC2839
	*** 000b19	e9 69 00 		jmp	$I2600
					$JCC2839:
;|***               {
; Line 600
;|***               /*
;|***               ** Test if interrupt status register is inside UART address space
;|***               */
;|***               if ((_wIntIDregister == 0) ||
;|***                   (_wIntIDregister >= stDCBheader.stComDCB.wIObaseAddress) &&
;|***                   (_wIntIDregister <= (stDCBheader.stComDCB.wIObaseAddress + 7)))
; Line 606
	*** 000b1c	8e 06 2c 00 		mov	es,WORD PTR $T20023
	*** 000b20	26 83 3e 00 00 00 	cmp	WORD PTR es:__wIntIDregister,0
	*** 000b26	75 03 			jne	$JCC2854
	*** 000b28	e9 1d 00 		jmp	$I2602
					$JCC2854:
	*** 000b2b	a1 80 0f 		mov	ax,WORD PTR _stDCBheader+22
	*** 000b2e	26 39 06 00 00 		cmp	WORD PTR es:__wIntIDregister,ax
	*** 000b33	73 03 			jae	$JCC2867
	*** 000b35	e9 1b 00 		jmp	$I2601
					$JCC2867:
	*** 000b38	a1 80 0f 		mov	ax,WORD PTR _stDCBheader+22
	*** 000b3b	05 07 00 		add	ax,7
	*** 000b3e	26 39 06 00 00 		cmp	WORD PTR es:__wIntIDregister,ax
	*** 000b43	76 03 			jbe	$JCC2883
	*** 000b45	e9 0b 00 		jmp	$I2601
					$JCC2883:
					$I2602:
;|***                   bSeparateIDreg = FALSE;
; Line 607
	*** 000b48	8e 06 2a 00 		mov	es,WORD PTR $T20022
	*** 000b4c	26 c7 06 00 00 00 00 	mov	WORD PTR es:_bSeparateIDreg,0
;|*** //  _asm int 3
;|***               if ((rc = RMHELP_GetPorts(&stDCBheader,wLoadCount)) != 0)
; Line 609
					$I2601:
	*** 000b53	8e 06 06 00 		mov	es,WORD PTR $T20003
	*** 000b57	26 ff 36 00 00 		push	WORD PTR es:_wLoadCount
	*** 000b5c	1e 			push	ds
	*** 000b5d	68 6a 0f 		push	OFFSET DGROUP:_stDCBheader
	*** 000b60	9a 00 00 00 00 		call	FAR PTR _RMHELP_GetPorts
	*** 000b65	83 c4 06 		add	sp,6
	*** 000b68	89 46 f6 		mov	WORD PTR [bp-10],ax	;rc
	*** 000b6b	3d 00 00 		cmp	ax,0
	*** 000b6e	75 03 			jne	$JCC2926
	*** 000b70	e9 12 00 		jmp	$I2603
					$JCC2926:
;|***                 {
; Line 610
;|***                 if (rc != 0xffff)
; Line 611
	*** 000b73	83 7e f6 ff 		cmp	WORD PTR [bp-10],-1	;rc
	*** 000b77	75 03 			jne	$JCC2935
	*** 000b79	e9 09 00 		jmp	$I2604
					$JCC2935:
;|***                   {
; Line 612
;|***                   bPrevErrorMsg = TRUE;
; Line 613
	*** 000b7c	c7 06 a4 0f 01 00 	mov	WORD PTR _bPrevErrorMsg,1
;|***                   goto gtNextDCBheader;
; Line 614
	*** 000b82	e9 02 02 		jmp	$gtNextDCBheader2605
;|***                   }
; Line 615
;|***                 }
; Line 616
					$I2604:
;|***               }
; Line 617
					$I2603:
;|*** #endif
;|***             /*
;|***             ** if starting header address is not defined then define it
;|***             ** and set dummy header to point to it
;|***             */
;|***             if (pStart == NULL)
; Line 623
					$I2600:
	*** 000b85	a1 b0 0f 		mov	ax,WORD PTR _pStart+2
	*** 000b88	0b 06 ae 0f 		or	ax,WORD PTR _pStart
	*** 000b8c	74 03 			je	$JCC2956
	*** 000b8e	e9 11 00 		jmp	$I2606
					$JCC2956:
;|***               pStart = &pDeviceParms->stDeviceHeader;
; Line 624
	*** 000b91	a1 aa 0f 		mov	ax,WORD PTR _pDeviceParms
	*** 000b94	8b 16 ac 0f 		mov	dx,WORD PTR _pDeviceParms+2
	*** 000b98	05 bc 00 		add	ax,188
	*** 000b9b	a3 ae 0f 		mov	WORD PTR _pStart,ax
	*** 000b9e	89 16 b0 0f 		mov	WORD PTR _pStart+2,dx
;|***             /*
;|***             ** Initialized device headers
;|***             */
;|***             MemCopy((BYTE _far *)&pDeviceParms->stDeviceHeader.abyDeviceName,(BYTE *)(stDCBheader.abyPortName),8);
; Line 628
					$I2606:
	*** 000ba2	6a 08 			push	8
	*** 000ba4	1e 			push	ds
	*** 000ba5	68 6a 0f 		push	OFFSET DGROUP:_stDCBheader
	*** 000ba8	a1 aa 0f 		mov	ax,WORD PTR _pDeviceParms
	*** 000bab	8b 16 ac 0f 		mov	dx,WORD PTR _pDeviceParms+2
	*** 000baf	05 c6 00 		add	ax,198
	*** 000bb2	52 			push	dx
	*** 000bb3	50 			push	ax
	*** 000bb4	9a 00 00 00 00 		call	FAR PTR _MemCopy
	*** 000bb9	83 c4 0a 		add	sp,10
;|***             pDeviceParms->stDeviceHeader.StrategyOffset = wDeviceStrategy;
; Line 629
	*** 000bbc	a1 b6 0f 		mov	ax,WORD PTR _wDeviceStrategy
	*** 000bbf	c4 1e aa 0f 		les	bx,DWORD PTR _pDeviceParms
	*** 000bc3	26 89 87 c2 00 		mov	WORD PTR es:[bx+194],ax
;|***             abyCOMnumbers[wLoadCount] = (BYTE)atoi(&stDCBheader.abyPortName[3]);
; Line 630
	*** 000bc8	1e 			push	ds
	*** 000bc9	68 6d 0f 		push	OFFSET DGROUP:_stDCBheader+3
	*** 000bcc	9a 00 00 00 00 		call	FAR PTR _atoi
	*** 000bd1	83 c4 04 		add	sp,4
	*** 000bd4	8e 06 06 00 		mov	es,WORD PTR $T20003
	*** 000bd8	26 8b 1e 00 00 		mov	bx,WORD PTR es:_wLoadCount
_TEXT      ENDS
CONST      SEGMENT
$T20029	DW SEG _abyCOMnumbers 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 000bdd	8e 06 38 00 		mov	es,WORD PTR $T20029
	*** 000be1	26 88 87 00 00 		mov	BYTE PTR es:_abyCOMnumbers[bx],al
;|***             if (pPrevious != NULL)
; Line 631
	*** 000be6	a1 b4 0f 		mov	ax,WORD PTR _pPrevious+2
	*** 000be9	0b 06 b2 0f 		or	ax,WORD PTR _pPrevious
	*** 000bed	75 03 			jne	$JCC3053
	*** 000bef	e9 15 00 		jmp	$I2608
					$JCC3053:
;|***               pPrevious->pNextHeader = &pDeviceParms->stDeviceHeader;
; Line 632
	*** 000bf2	a1 aa 0f 		mov	ax,WORD PTR _pDeviceParms
	*** 000bf5	8b 16 ac 0f 		mov	dx,WORD PTR _pDeviceParms+2
	*** 000bf9	05 bc 00 		add	ax,188
	*** 000bfc	c4 1e b2 0f 		les	bx,DWORD PTR _pPrevious
	*** 000c00	26 89 07 		mov	WORD PTR es:[bx],ax
	*** 000c03	26 89 57 02 		mov	WORD PTR es:[bx+2],dx
;|*** #ifndef NO_COMscope
;|***             if (stDCBheader.stComDCB.wConfigFlags1 & CFG_FLAG1_COMSCOPE)
; Line 634
					$I2608:
	*** 000c07	f6 06 7a 0f 40 		test	BYTE PTR _stDCBheader+16,64
	*** 000c0c	75 03 			jne	$JCC3084
	*** 000c0e	e9 a6 00 		jmp	$I2609
					$JCC3084:
;|***               {
; Line 635
;|***               if (stDCBheader.stComDCB.wCOMscopeBuffLen != 0)
; Line 636
	*** 000c11	83 3e 7e 0f 00 		cmp	WORD PTR _stDCBheader+20,0
	*** 000c16	75 03 			jne	$JCC3094
	*** 000c18	e9 16 00 		jmp	$I2610
					$JCC3094:
;|***                 ulRequiredBufferSpace += stDCBheader.stComDCB.wCOMscopeBuffLen;
; Line 637
	*** 000c1b	a1 7e 0f 		mov	ax,WORD PTR _stDCBheader+20
	*** 000c1e	2b d2 			sub	dx,dx
	*** 000c20	8e 06 02 00 		mov	es,WORD PTR $T20001
	*** 000c24	26 01 06 00 00 		add	WORD PTR es:_ulRequiredBufferSpace,ax
	*** 000c29	26 11 16 02 00 		adc	WORD PTR es:_ulRequiredBufferSpace+2,dx
;|***               else
; Line 638
	*** 000c2e	e9 11 00 		jmp	$I2611
					$I2610:
;|***                 ulRequiredBufferSpace += DEF_COMscope_BUFF_LEN;
; Line 639
	*** 000c31	8e 06 02 00 		mov	es,WORD PTR $T20001
	*** 000c35	26 81 06 00 00 00 10 	add	WORD PTR es:_ulRequiredBufferSpace,4096
	*** 000c3c	26 83 16 02 00 00 	adc	WORD PTR es:_ulRequiredBufferSpace+2,0
					$I2611:
;|***               MemCopy((BYTE _far *)&pDeviceParms->stCOMscopeHeader.abyDeviceName,(BYTE *)(stDCBheader.abyPortName),8);
; Line 640
	*** 000c42	6a 08 			push	8
	*** 000c44	1e 			push	ds
	*** 000c45	68 6a 0f 		push	OFFSET DGROUP:_stDCBheader
	*** 000c48	a1 aa 0f 		mov	ax,WORD PTR _pDeviceParms
	*** 000c4b	8b 16 ac 0f 		mov	dx,WORD PTR _pDeviceParms+2
	*** 000c4f	05 e0 00 		add	ax,224
	*** 000c52	52 			push	dx
	*** 000c53	50 			push	ax
	*** 000c54	9a 00 00 00 00 		call	FAR PTR _MemCopy
	*** 000c59	83 c4 0a 		add	sp,10
;|***               pDeviceParms->stCOMscopeHeader.StrategyOffset = wCOMscopeStrategy;
; Line 641
	*** 000c5c	a1 b8 0f 		mov	ax,WORD PTR _wCOMscopeStrategy
	*** 000c5f	c4 1e aa 0f 		les	bx,DWORD PTR _pDeviceParms
	*** 000c63	26 89 87 dc 00 		mov	WORD PTR es:[bx+220],ax
;|***               MakeCOMscopeName(pDeviceParms->stCOMscopeHeader.abyDeviceName);
; Line 642
	*** 000c68	a1 aa 0f 		mov	ax,WORD PTR _pDeviceParms
	*** 000c6b	8b 16 ac 0f 		mov	dx,WORD PTR _pDeviceParms+2
	*** 000c6f	05 e0 00 		add	ax,224
	*** 000c72	52 			push	dx
	*** 000c73	50 			push	ax
	*** 000c74	9a 00 00 00 00 		call	FAR PTR _MakeCOMscopeName
	*** 000c79	83 c4 04 		add	sp,4
;|***               pDeviceParms->stDeviceHeader.pNextHeader = &pDeviceParms->stCOMscopeHeader;
; Line 643
	*** 000c7c	a1 aa 0f 		mov	ax,WORD PTR _pDeviceParms
	*** 000c7f	8b 16 ac 0f 		mov	dx,WORD PTR _pDeviceParms+2
	*** 000c83	05 d6 00 		add	ax,214
	*** 000c86	c4 1e aa 0f 		les	bx,DWORD PTR _pDeviceParms
	*** 000c8a	26 89 87 bc 00 		mov	WORD PTR es:[bx+188],ax
	*** 000c8f	26 89 97 be 00 		mov	WORD PTR es:[bx+190],dx
;|***               pPrevious = &pDeviceParms->stCOMscopeHeader;
; Line 644
	*** 000c94	a1 aa 0f 		mov	ax,WORD PTR _pDeviceParms
	*** 000c97	8b 16 ac 0f 		mov	dx,WORD PTR _pDeviceParms+2
	*** 000c9b	05 d6 00 		add	ax,214
	*** 000c9e	a3 b2 0f 		mov	WORD PTR _pPrevious,ax
	*** 000ca1	89 16 b4 0f 		mov	WORD PTR _pPrevious+2,dx
;|***               pPrevious->pNextHeader = (VOID *)-1;
; Line 645
	*** 000ca5	c4 1e b2 0f 		les	bx,DWORD PTR _pPrevious
	*** 000ca9	26 c7 07 ff ff 		mov	WORD PTR es:[bx],-1
	*** 000cae	26 c7 47 02 ff ff 	mov	WORD PTR es:[bx+2],-1
;|***               }
; Line 646
;|***             else
; Line 647
	*** 000cb4	e9 20 00 		jmp	$I2612
					$I2609:
;|*** #endif
;|***               {
; Line 649
;|***               pPrevious = &pDeviceParms->stDeviceHeader;
; Line 650
	*** 000cb7	a1 aa 0f 		mov	ax,WORD PTR _pDeviceParms
	*** 000cba	8b 16 ac 0f 		mov	dx,WORD PTR _pDeviceParms+2
	*** 000cbe	05 bc 00 		add	ax,188
	*** 000cc1	a3 b2 0f 		mov	WORD PTR _pPrevious,ax
	*** 000cc4	89 16 b4 0f 		mov	WORD PTR _pPrevious+2,dx
;|***               pPrevious->pNextHeader = (VOID *)-1;
; Line 651
	*** 000cc8	c4 1e b2 0f 		les	bx,DWORD PTR _pPrevious
	*** 000ccc	26 c7 07 ff ff 		mov	WORD PTR es:[bx],-1
	*** 000cd1	26 c7 47 02 ff ff 	mov	WORD PTR es:[bx+2],-1
;|***               }
; Line 652
					$I2612:
;|***             if (stDCBheader.stComDCB.wReadBufferLength != 0)
; Line 653
	*** 000cd7	83 3e 82 0f 00 		cmp	WORD PTR _stDCBheader+24,0
	*** 000cdc	75 03 			jne	$JCC3292
	*** 000cde	e9 2c 00 		jmp	$I2613
					$JCC3292:
;|***               {
; Line 654
;|***               ulRequiredBufferSpace += stDCBheader.stComDCB.wReadBufferLength;
; Line 655
	*** 000ce1	a1 82 0f 		mov	ax,WORD PTR _stDCBheader+24
	*** 000ce4	2b d2 			sub	dx,dx
	*** 000ce6	8e 06 02 00 		mov	es,WORD PTR $T20001
	*** 000cea	26 01 06 00 00 		add	WORD PTR es:_ulRequiredBufferSpace,ax
	*** 000cef	26 11 16 02 00 		adc	WORD PTR es:_ulRequiredBufferSpace+2,dx
;|***               if (stDCBheader.stComDCB.wReadBufferLength == 0xffff)
; Line 656
	*** 000cf4	83 3e 82 0f ff 		cmp	WORD PTR _stDCBheader+24,-1
	*** 000cf9	74 03 			je	$JCC3321
	*** 000cfb	e9 0c 00 		jmp	$I2614
					$JCC3321:
;|***                 ulRequiredBufferSpace++;
; Line 657
	*** 000cfe	26 83 06 00 00 01 	add	WORD PTR es:_ulRequiredBufferSpace,1
	*** 000d04	26 83 16 02 00 00 	adc	WORD PTR es:_ulRequiredBufferSpace+2,0
;|***               }
; Line 658
					$I2614:
;|***             else
; Line 659
	*** 000d0a	e9 11 00 		jmp	$I2615
					$I2613:
;|***               ulRequiredBufferSpace += DEF_READ_BUFF_LEN;
; Line 660
	*** 000d0d	8e 06 02 00 		mov	es,WORD PTR $T20001
	*** 000d11	26 81 06 00 00 00 10 	add	WORD PTR es:_ulRequiredBufferSpace,4096
	*** 000d18	26 83 16 02 00 00 	adc	WORD PTR es:_ulRequiredBufferSpace+2,0
					$I2615:
;|***             if (stDCBheader.stComDCB.wWrtBufferLength != 0)
; Line 661
	*** 000d1e	83 3e 84 0f 00 		cmp	WORD PTR _stDCBheader+26,0
	*** 000d23	75 03 			jne	$JCC3363
	*** 000d25	e9 16 00 		jmp	$I2616
					$JCC3363:
;|***               ulWriteBufferSpace += stDCBheader.stComDCB.wWrtBufferLength;
; Line 662
	*** 000d28	a1 84 0f 		mov	ax,WORD PTR _stDCBheader+26
	*** 000d2b	2b d2 			sub	dx,dx
	*** 000d2d	8e 06 00 00 		mov	es,WORD PTR $T20000
	*** 000d31	26 01 06 00 00 		add	WORD PTR es:_ulWriteBufferSpace,ax
	*** 000d36	26 11 16 02 00 		adc	WORD PTR es:_ulWriteBufferSpace+2,dx
;|***             else
; Line 663
	*** 000d3b	e9 11 00 		jmp	$I2617
					$I2616:
;|***               ulWriteBufferSpace += DEF_WRITE_BUFF_LEN;
; Line 664
	*** 000d3e	8e 06 00 00 		mov	es,WORD PTR $T20000
	*** 000d42	26 81 06 00 00 00 01 	add	WORD PTR es:_ulWriteBufferSpace,256
	*** 000d49	26 83 16 02 00 00 	adc	WORD PTR es:_ulWriteBufferSpace+2,0
					$I2617:
;|***             MemCopy((BYTE *)(&stConfigParms[wLoadCount]),(BYTE *)(&stDCBheader.stComDCB),sizeof(COMDCB));
; Line 665
	*** 000d4f	6a 2a 			push	42
	*** 000d51	1e 			push	ds
	*** 000d52	68 7a 0f 		push	OFFSET DGROUP:_stDCBheader+16
	*** 000d55	8e 06 06 00 		mov	es,WORD PTR $T20003
	*** 000d59	26 6b 06 00 00 2a 	imul	ax,WORD PTR es:_wLoadCount,42
	*** 000d5f	05 00 00 		add	ax,OFFSET _stConfigParms
	*** 000d62	68 00 00 		push	SEG _stConfigParms
	*** 000d65	50 			push	ax
	*** 000d66	9a 00 00 00 00 		call	FAR PTR _MemCopy
	*** 000d6b	83 c4 0a 		add	sp,10
;|***             pDeviceParms++;
; Line 666
	*** 000d6e	81 06 aa 0f f0 00 	add	WORD PTR _pDeviceParms,240
;|*** #ifndef NO_COMscope
;|***             wCOMscopeStrategy += 6;
; Line 668
	*** 000d74	83 06 b8 0f 06 		add	WORD PTR _wCOMscopeStrategy,6
;|*** #endif
;|***             wDeviceStrategy += 6;
; Line 670
	*** 000d79	83 06 b6 0f 06 		add	WORD PTR _wDeviceStrategy,6
;|***             wLoadCount++;
; Line 671
	*** 000d7e	8e 06 06 00 		mov	es,WORD PTR $T20003
	*** 000d82	26 ff 06 00 00 		inc	WORD PTR es:_wLoadCount
;|***             }
; Line 672
;|*** gtNextDCBheader:
; Line 673
					$I2596:
					$gtNextDCBheader2605:
;|***           if (bPCIadapter)
; Line 674
	*** 000d87	83 7e d2 00 		cmp	WORD PTR [bp-46],0	;bPCIadapter
	*** 000d8b	75 03 			jne	$JCC3467
	*** 000d8d	e9 59 00 		jmp	$I2618
					$JCC3467:
;|***             {
; Line 675
;|***             // write back I/O addresses
;|***             DosChgFilePtr(hFile,ulFilePosition,0,&ulFilePosition);
; Line 677
	*** 000d90	ff 36 a8 0f 		push	WORD PTR _hFile
	*** 000d94	ff 76 f0 		push	WORD PTR [bp-16]
	*** 000d97	ff 76 ee 		push	WORD PTR [bp-18]	;ulFilePosition
	*** 000d9a	6a 00 			push	0
	*** 000d9c	8d 46 ee 		lea	ax,WORD PTR [bp-18]	;ulFilePosition
	*** 000d9f	16 			push	ss
	*** 000da0	50 			push	ax
	*** 000da1	9a 00 00 00 00 		call	FAR PTR DOS16CHGFILEPTR
;|***             if ((ulFileError = DosWrite(hFile,(PVOID)&stDCBheader,sizeof(DCBHEAD),&ulCount)) != 0)
; Line 678
	*** 000da6	ff 36 a8 0f 		push	WORD PTR _hFile
	*** 000daa	1e 			push	ds
	*** 000dab	68 6a 0f 		push	OFFSET DGROUP:_stDCBheader
	*** 000dae	6a 3a 			push	58
	*** 000db0	8d 46 e2 		lea	ax,WORD PTR [bp-30]	;ulCount
	*** 000db3	16 			push	ss
	*** 000db4	50 			push	ax
	*** 000db5	9a 00 00 00 00 		call	FAR PTR DOS16WRITE
	*** 000dba	89 46 e0 		mov	WORD PTR [bp-32],ax	;ulFileError
	*** 000dbd	3d 00 00 		cmp	ax,0
	*** 000dc0	75 03 			jne	$JCC3520
	*** 000dc2	e9 24 00 		jmp	$I2619
					$JCC3520:
;|***               {
; Line 679
;|***               VioWrtTTY(chFailedWriteIni,StringLength(chFailedWriteIni),0);
; Line 680
	*** 000dc5	68 00 00 		push	SEG _chFailedWriteIni
	*** 000dc8	68 00 00 		push	OFFSET _chFailedWriteIni
	*** 000dcb	68 00 00 		push	SEG _chFailedWriteIni
	*** 000dce	68 00 00 		push	OFFSET _chFailedWriteIni
	*** 000dd1	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 000dd6	83 c4 04 		add	sp,4
	*** 000dd9	50 			push	ax
	*** 000dda	6a 00 			push	0
	*** 000ddc	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***               ulFileError |= ERR_FILE_WRITE;
; Line 681
	*** 000de1	81 4e e0 00 c0 		or	WORD PTR [bp-32],-16384	;ulFileError
;|***               goto gtEarlyOut;
; Line 682
	*** 000de6	e9 4a 01 		jmp	$gtEarlyOut2544
;|***               }
; Line 683
;|***             }
; Line 684
					$I2619:
;|***           DosChgFilePtr(hFile,(LONG)stDCBheader.oNextDCBheader,0,&ulFilePosition);
; Line 685
					$I2618:
	*** 000de9	ff 36 a8 0f 		push	WORD PTR _hFile
	*** 000ded	6a 00 			push	0
	*** 000def	ff 36 74 0f 		push	WORD PTR _stDCBheader+10
	*** 000df3	6a 00 			push	0
	*** 000df5	8d 46 ee 		lea	ax,WORD PTR [bp-18]	;ulFilePosition
	*** 000df8	16 			push	ss
	*** 000df9	50 			push	ax
	*** 000dfa	9a 00 00 00 00 		call	FAR PTR DOS16CHGFILEPTR
;|***           }
; Line 686
	*** 000dff	e9 79 fc 		jmp	$FC2593
					$FB2594:
;|***         if (wLoadCount > 0)
; Line 687
	*** 000e02	8e 06 06 00 		mov	es,WORD PTR $T20003
	*** 000e06	26 83 3e 00 00 00 	cmp	WORD PTR es:_wLoadCount,0
	*** 000e0c	77 03 			ja	$JCC3596
	*** 000e0e	e9 06 01 		jmp	$I2620
					$JCC3596:
;|***           {
; Line 688
;|***           _wEndOfData = ((WORD)_stDeviceParms + (wLoadCount * sizeof(DEVDEF)));
; Line 689
	*** 000e11	26 69 06 00 00 f0 00 	imul	ax,WORD PTR es:_wLoadCount,240
	*** 000e18	05 00 00 		add	ax,OFFSET __stDeviceParms
_TEXT      ENDS
CONST      SEGMENT
$T20030	DW SEG __wEndOfData 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 000e1b	8e 06 3a 00 		mov	es,WORD PTR $T20030
	*** 000e1f	26 a3 00 00 		mov	WORD PTR es:__wEndOfData,ax
;|***           ulAvailableBufferSpace = (0x10000 - (ulWriteBufferSpace + (ULONG)_wEndOfData));
; Line 690
	*** 000e23	b8 00 00 		mov	ax,0
	*** 000e26	ba 01 00 		mov	dx,1
	*** 000e29	8e 06 00 00 		mov	es,WORD PTR $T20000
	*** 000e2d	26 2b 06 00 00 		sub	ax,WORD PTR es:_ulWriteBufferSpace
	*** 000e32	26 1b 16 02 00 		sbb	dx,WORD PTR es:_ulWriteBufferSpace+2
	*** 000e37	8e 06 3a 00 		mov	es,WORD PTR $T20030
	*** 000e3b	26 2b 06 00 00 		sub	ax,WORD PTR es:__wEndOfData
	*** 000e40	83 da 00 		sbb	dx,0
_TEXT      ENDS
CONST      SEGMENT
$T20031	DW SEG _ulAvailableBufferSpace 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 000e43	8e 06 3c 00 		mov	es,WORD PTR $T20031
	*** 000e47	26 a3 00 00 		mov	WORD PTR es:_ulAvailableBufferSpace,ax
	*** 000e4b	26 89 16 02 00 		mov	WORD PTR es:_ulAvailableBufferSpace+2,dx
;|***           if (ulRequiredBufferSpace >= ulAvailableBufferSpace)
; Line 691
	*** 000e50	26 a1 00 00 		mov	ax,WORD PTR es:_ulAvailableBufferSpace
	*** 000e54	26 8b 16 02 00 		mov	dx,WORD PTR es:_ulAvailableBufferSpace+2
	*** 000e59	8e 06 02 00 		mov	es,WORD PTR $T20001
	*** 000e5d	26 39 16 02 00 		cmp	WORD PTR es:_ulRequiredBufferSpace+2,dx
	*** 000e62	73 03 			jae	$JCC3682
	*** 000e64	e9 1a 00 		jmp	$I2621
					$JCC3682:
	*** 000e67	76 03 			jbe	$JCC3687
	*** 000e69	e9 0a 00 		jmp	$L20032
					$JCC3687:
	*** 000e6c	26 39 06 00 00 		cmp	WORD PTR es:_ulRequiredBufferSpace,ax
	*** 000e71	73 03 			jae	$JCC3697
	*** 000e73	e9 0b 00 		jmp	$I2621
					$JCC3697:
					$L20032:
;|***             bUseDDdataSegment = FALSE;
; Line 692
_TEXT      ENDS
CONST      SEGMENT
$T20033	DW SEG _bUseDDdataSegment 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 000e76	8e 06 3e 00 		mov	es,WORD PTR $T20033
	*** 000e7a	26 c7 06 00 00 00 00 	mov	WORD PTR es:_bUseDDdataSegment,0
;|***           pDeviceParms--;
; Line 693
					$I2621:
	*** 000e81	81 2e aa 0f f0 00 	sub	WORD PTR _pDeviceParms,240
;|***           _stDummyHeader.pNextHeader = pStart;
; Line 694
	*** 000e87	a1 ae 0f 		mov	ax,WORD PTR _pStart
	*** 000e8a	8b 16 b0 0f 		mov	dx,WORD PTR _pStart+2
_TEXT      ENDS
CONST      SEGMENT
$T20034	DW SEG __stDummyHeader 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 000e8e	8e 06 40 00 		mov	es,WORD PTR $T20034
	*** 000e92	26 a3 00 00 		mov	WORD PTR es:__stDummyHeader,ax
	*** 000e96	26 89 16 02 00 		mov	WORD PTR es:__stDummyHeader+2,dx
;|*** #ifdef this_junk
;|***           _stDummyHeader.sCodeSegment = pDeviceParms->stDeviceHeader.sCodeSegment;
;|***  #ifndef NO_COMscope
;|***           if (pDeviceParms->stDeviceHeader.pNextHeader != 0xffff)
;|***             pDeviceParms->stCOMscopeHeader.sCodeSegment = 0xffff;
;|***           else
;|***  #endif
;|***             pDeviceParms->stDeviceHeader.sCodeSegment = 0xffff;
;|*** #endif
;|***           wLoadNumber = (wIndex + 1);
; Line 704
	*** 000e9b	8b 46 d0 		mov	ax,WORD PTR [bp-48]	;wIndex
	*** 000e9e	40 			inc	ax
	*** 000e9f	8e 06 04 00 		mov	es,WORD PTR $T20002
	*** 000ea3	26 a3 00 00 		mov	WORD PTR es:_wLoadNumber,ax
;|*** #ifndef NO_RESOURCE_MGR
;|***           if (!bDisableRM)
; Line 706
	*** 000ea7	8e 06 1c 00 		mov	es,WORD PTR $T20015
	*** 000eab	26 83 3e 00 00 00 	cmp	WORD PTR es:_bDisableRM,0
	*** 000eb1	74 03 			je	$JCC3761
	*** 000eb3	e9 2f 00 		jmp	$I2622
					$JCC3761:
;|***             {
; Line 707
;|***             if (bSeparateIDreg)
; Line 708
	*** 000eb6	8e 06 2a 00 		mov	es,WORD PTR $T20022
	*** 000eba	26 83 3e 00 00 00 	cmp	WORD PTR es:_bSeparateIDreg,0
	*** 000ec0	75 03 			jne	$JCC3776
	*** 000ec2	e9 20 00 		jmp	$I2623
					$JCC3776:
;|***               {
; Line 709
;|*** //              RMHELP_CreateStatusPort();
;|***               if (RMHELP_GetStatusPort() != 0)
; Line 711
	*** 000ec5	9a 00 00 00 00 		call	FAR PTR _RMHELP_GetStatusPort
	*** 000eca	3d 00 00 		cmp	ax,0
	*** 000ecd	75 03 			jne	$JCC3789
	*** 000ecf	e9 0e 00 		jmp	$I2624
					$JCC3789:
;|***                 {
; Line 712
;|***                 wLoadCount = 0;
; Line 713
	*** 000ed2	8e 06 06 00 		mov	es,WORD PTR $T20003
	*** 000ed6	26 c7 06 00 00 00 00 	mov	WORD PTR es:_wLoadCount,0
;|***                 goto gtEarlyOut;
; Line 714
	*** 000edd	e9 53 00 		jmp	$gtEarlyOut2544
;|***                 }
; Line 715
;|***               RMHELP_StatusPortInitComplete();
; Line 716
					$I2624:
	*** 000ee0	9a 00 00 00 00 		call	FAR PTR _RMHELP_StatusPortInitComplete
;|***               }
; Line 717
;|***             }
; Line 718
					$I2623:
;|*** #endif
;|***           if (bABIOSpresent && bIsTheFirst)
; Line 720
					$I2622:
_TEXT      ENDS
CONST      SEGMENT
$T20035	DW SEG _bABIOSpresent 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 000ee5	8e 06 42 00 		mov	es,WORD PTR $T20035
	*** 000ee9	26 83 3e 00 00 00 	cmp	WORD PTR es:_bABIOSpresent,0
	*** 000eef	75 03 			jne	$JCC3823
	*** 000ef1	e9 20 00 		jmp	$I2625
					$JCC3823:
	*** 000ef4	8e 06 16 00 		mov	es,WORD PTR $T20012
	*** 000ef8	26 83 3e 00 00 00 	cmp	WORD PTR es:_bIsTheFirst,0
	*** 000efe	75 03 			jne	$JCC3838
	*** 000f00	e9 11 00 		jmp	$I2625
					$JCC3838:
;|***             VerifyABIOSdefinitions(wLoadCount);
; Line 721
	*** 000f03	8e 06 06 00 		mov	es,WORD PTR $T20003
	*** 000f07	26 ff 36 00 00 		push	WORD PTR es:_wLoadCount
	*** 000f0c	9a 00 00 00 00 		call	FAR PTR _VerifyABIOSdefinitions
	*** 000f11	83 c4 02 		add	sp,2
;|***           break;
; Line 722
					$I2625:
	*** 000f14	e9 1c 00 		jmp	$FB2569
;|***           }
; Line 723
;|***         }
; Line 724
					$I2620:
;|***       else
; Line 725
	*** 000f17	e9 16 00 		jmp	$I2626
					$I2571:
;|***         DosChgFilePtr(hFile,(LONG)stConfigHeader.oNextCFGheader,0,&ulFilePosition);
; Line 726
	*** 000f1a	ff 36 a8 0f 		push	WORD PTR _hFile
	*** 000f1e	6a 00 			push	0
	*** 000f20	ff 36 46 0f 		push	WORD PTR _stConfigHeader+26
	*** 000f24	6a 00 			push	0
	*** 000f26	8d 46 ee 		lea	ax,WORD PTR [bp-18]	;ulFilePosition
	*** 000f29	16 			push	ss
	*** 000f2a	50 			push	ax
	*** 000f2b	9a 00 00 00 00 		call	FAR PTR DOS16CHGFILEPTR
					$I2626:
;|***       }
; Line 727
	*** 000f30	e9 ed f7 		jmp	$FC2568
					$FB2569:
;|*** gtEarlyOut:
; Line 728
					$gtEarlyOut2544:
;|***     if (wLoadCount == 0)
; Line 729
	*** 000f33	8e 06 06 00 		mov	es,WORD PTR $T20003
	*** 000f37	26 83 3e 00 00 00 	cmp	WORD PTR es:_wLoadCount,0
	*** 000f3d	74 03 			je	$JCC3901
	*** 000f3f	e9 94 00 		jmp	$I2627
					$JCC3901:
;|***       {
; Line 730
;|*** #ifndef NO_RESOURCE_MGR
;|***       if (!bDisableRM)
; Line 732
	*** 000f42	8e 06 1c 00 		mov	es,WORD PTR $T20015
	*** 000f46	26 83 3e 00 00 00 	cmp	WORD PTR es:_bDisableRM,0
	*** 000f4c	74 03 			je	$JCC3916
	*** 000f4e	e9 05 00 		jmp	$I2628
					$JCC3916:
;|***         RMHELP_DestroyDriver();
; Line 733
	*** 000f51	9a 00 00 00 00 		call	FAR PTR _RMHELP_DestroyDriver
;|*** #endif
;|*** //#ifdef OEM
;|***       if (ulFileError == 0)
; Line 736
					$I2628:
	*** 000f56	83 7e e0 00 		cmp	WORD PTR [bp-32],0	;ulFileError
	*** 000f5a	74 03 			je	$JCC3930
	*** 000f5c	e9 6c 00 		jmp	$I2629
					$JCC3930:
;|***         {
; Line 737
;|*** //#endif
;|***         if (!bPrevErrorMsg)
; Line 739
	*** 000f5f	83 3e a4 0f 00 		cmp	WORD PTR _bPrevErrorMsg,0
	*** 000f64	74 03 			je	$JCC3940
	*** 000f66	e9 54 00 		jmp	$I2630
					$JCC3940:
;|***           {
; Line 740
;|***           VioWrtTTY(chFailedIniNotInit_1,StringLength(chFailedIniNotInit_1),0);
; Line 741
	*** 000f69	68 00 00 		push	SEG _chFailedIniNotInit_1
	*** 000f6c	68 00 00 		push	OFFSET _chFailedIniNotInit_1
	*** 000f6f	68 00 00 		push	SEG _chFailedIniNotInit_1
	*** 000f72	68 00 00 		push	OFFSET _chFailedIniNotInit_1
	*** 000f75	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 000f7a	83 c4 04 		add	sp,4
	*** 000f7d	50 			push	ax
	*** 000f7e	6a 00 			push	0
	*** 000f80	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***           VioWrtTTY(_abyPath,StringLength(_abyPath),0);
; Line 742
	*** 000f85	68 00 00 		push	SEG __abyPath
	*** 000f88	68 00 00 		push	OFFSET __abyPath
	*** 000f8b	68 00 00 		push	SEG __abyPath
	*** 000f8e	68 00 00 		push	OFFSET __abyPath
	*** 000f91	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 000f96	83 c4 04 		add	sp,4
	*** 000f99	50 			push	ax
	*** 000f9a	6a 00 			push	0
	*** 000f9c	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***           VioWrtTTY(chFailedIniNotInit_2,StringLength(chFailedIniNotInit_2),0);
; Line 743
	*** 000fa1	68 00 00 		push	SEG _chFailedIniNotInit_2
	*** 000fa4	68 00 00 		push	OFFSET _chFailedIniNotInit_2
	*** 000fa7	68 00 00 		push	SEG _chFailedIniNotInit_2
	*** 000faa	68 00 00 		push	OFFSET _chFailedIniNotInit_2
	*** 000fad	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 000fb2	83 c4 04 		add	sp,4
	*** 000fb5	50 			push	ax
	*** 000fb6	6a 00 			push	0
	*** 000fb8	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***           }
; Line 744
;|***         wLoadNumber = NO_DEFINED_DEVICES;
; Line 745
					$I2630:
	*** 000fbd	8e 06 04 00 		mov	es,WORD PTR $T20002
	*** 000fc1	26 c7 06 00 00 00 80 	mov	WORD PTR es:_wLoadNumber,-32768
;|*** //#ifdef OEM
;|***         }
; Line 747
;|***       else
; Line 748
	*** 000fc8	e9 0b 00 		jmp	$I2631
					$I2629:
;|***         wLoadNumber = FILE_ACCESS_ERROR;
; Line 749
	*** 000fcb	8e 06 04 00 		mov	es,WORD PTR $T20002
	*** 000fcf	26 c7 06 00 00 00 c0 	mov	WORD PTR es:_wLoadNumber,-16384
					$I2631:
;|*** //#endif
;|***       }
; Line 751
;|***     DosClose(hFile);
; Line 752
					$I2627:
	*** 000fd6	ff 36 a8 0f 		push	WORD PTR _hFile
	*** 000fda	9a 00 00 00 00 		call	FAR PTR DOS16CLOSE
;|***     }
; Line 753
;|***   _abyPath[wSaveExt++] = abySaveExt[0];
; Line 754
					$I2542:
	*** 000fdf	8a 46 d8 		mov	al,BYTE PTR [bp-40]	;abySaveExt
	*** 000fe2	8e 06 08 00 		mov	es,WORD PTR $T20004
	*** 000fe6	8b 5e e8 		mov	bx,WORD PTR [bp-24]	;wSaveExt
	*** 000fe9	26 88 87 00 00 		mov	BYTE PTR es:__abyPath[bx],al
	*** 000fee	ff 46 e8 		inc	WORD PTR [bp-24]	;wSaveExt
;|***   _abyPath[wSaveExt++] = abySaveExt[1];
; Line 755
	*** 000ff1	8a 46 d9 		mov	al,BYTE PTR [bp-39]
	*** 000ff4	8b 5e e8 		mov	bx,WORD PTR [bp-24]	;wSaveExt
	*** 000ff7	26 88 87 00 00 		mov	BYTE PTR es:__abyPath[bx],al
	*** 000ffc	ff 46 e8 		inc	WORD PTR [bp-24]	;wSaveExt
;|***   _abyPath[wSaveExt++] = abySaveExt[2];
; Line 756
	*** 000fff	8a 46 da 		mov	al,BYTE PTR [bp-38]
	*** 001002	8b 5e e8 		mov	bx,WORD PTR [bp-24]	;wSaveExt
	*** 001005	26 88 87 00 00 		mov	BYTE PTR es:__abyPath[bx],al
	*** 00100a	ff 46 e8 		inc	WORD PTR [bp-24]	;wSaveExt
;|***   _abyPath[wSaveExt] = abySaveExt[3];
; Line 757
	*** 00100d	8a 46 db 		mov	al,BYTE PTR [bp-37]
	*** 001010	8b 5e e8 		mov	bx,WORD PTR [bp-24]	;wSaveExt
	*** 001013	26 88 87 00 00 		mov	BYTE PTR es:__abyPath[bx],al
;|***   if (ulFileError != 0)
; Line 758
	*** 001018	83 7e e0 00 		cmp	WORD PTR [bp-32],0	;ulFileError
	*** 00101c	75 03 			jne	$JCC4124
	*** 00101e	e9 0a 00 		jmp	$I2632
					$JCC4124:
;|***     DosSleep(1000);
; Line 759
	*** 001021	6a 00 			push	0
	*** 001023	68 e8 03 		push	1000
	*** 001026	9a 00 00 00 00 		call	FAR PTR DOS16SLEEP
;|***   return;
; Line 760
					$I2632:
	*** 00102b	e9 00 00 		jmp	$EX2483
;|***   }
; Line 761
					$EX2483:
	*** 00102e	5e 			pop	si
	*** 00102f	5f 			pop	di
	*** 001030	c9 			leave	
	*** 001031	cb 			ret	

_GetIniInfo	ENDP
;|*** 
;|*** void VerifyABIOSdefinitions(WORD wLoadCount)
;|***   {
; Line 764
	PUBLIC	_VerifyABIOSdefinitions
_VerifyABIOSdefinitions	PROC FAR
	*** 001032	c8 06 00 00 		enter	6,0
	*** 001036	57 			push	di
	*** 001037	56 			push	si
;	wDCBindex = -2
;	wIndex = -6
;	wTemp = -4
;	wLoadCount = 6
;|***   WORD wDCBindex;
;|***   WORD wIndex;
;|***   WORD wTemp;
;|*** 
;|***   for (wDCBindex = 0;wDCBindex < wLoadCount;wDCBindex++)
; Line 769
	*** 001038	c7 46 fe 00 00 		mov	WORD PTR [bp-2],0	;wDCBindex
	*** 00103d	e9 03 00 		jmp	$F2638
					$FC2639:
	*** 001040	ff 46 fe 		inc	WORD PTR [bp-2]	;wDCBindex
					$F2638:
	*** 001043	8b 46 06 		mov	ax,WORD PTR [bp+6]	;wLoadCount
	*** 001046	39 46 fe 		cmp	WORD PTR [bp-2],ax	;wDCBindex
	*** 001049	72 03 			jb	$JCC4169
	*** 00104b	e9 d0 01 		jmp	$FB2640
					$JCC4169:
;|***     {
; Line 770
;|***     if (LIDtable[wDCBindex].fFlags & LID_ALREADY_OWNED)
; Line 771
_TEXT      ENDS
CONST      SEGMENT
$T20036	DW SEG _LIDtable 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 00104e	8e 06 44 00 		mov	es,WORD PTR $T20036
	*** 001052	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;wDCBindex
	*** 001055	c1 e3 04 		shl	bx,4
	*** 001058	26 f6 87 0c 00 01 	test	BYTE PTR es:_LIDtable[bx+12],1
	*** 00105e	75 03 			jne	$JCC4190
	*** 001060	e9 4b 00 		jmp	$I2641
					$JCC4190:
;|***       {
; Line 772
;|***       wTemp = LIDtable[wDCBindex].wBaseAddress;
; Line 773
	*** 001063	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;wDCBindex
	*** 001066	c1 e3 04 		shl	bx,4
	*** 001069	26 8b 87 06 00 		mov	ax,WORD PTR es:_LIDtable[bx+6]
	*** 00106e	89 46 fc 		mov	WORD PTR [bp-4],ax	;wTemp
;|***       for (wIndex = 0;wIndex < 8;wIndex++)
; Line 774
	*** 001071	c7 46 fa 00 00 		mov	WORD PTR [bp-6],0	;wIndex
	*** 001076	e9 03 00 		jmp	$F2642
					$FC2643:
	*** 001079	ff 46 fa 		inc	WORD PTR [bp-6]	;wIndex
					$F2642:
	*** 00107c	83 7e fa 08 		cmp	WORD PTR [bp-6],8	;wIndex
	*** 001080	72 03 			jb	$JCC4224
	*** 001082	e9 26 00 		jmp	$FB2644
					$JCC4224:
;|***       if (stConfigParms[wIndex].wIObaseAddress == wTemp)
; Line 775
	*** 001085	8b 46 fc 		mov	ax,WORD PTR [bp-4]	;wTemp
_TEXT      ENDS
CONST      SEGMENT
$T20037	DW SEG _stConfigParms 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 001088	8e 06 46 00 		mov	es,WORD PTR $T20037
	*** 00108c	6b 5e fa 2a 		imul	bx,WORD PTR [bp-6],42	;wIndex
	*** 001090	26 39 87 06 00 		cmp	WORD PTR es:_stConfigParms[bx+6],ax
	*** 001095	74 03 			je	$JCC4245
	*** 001097	e9 0e 00 		jmp	$I2645
					$JCC4245:
;|***         {
; Line 776
;|***         stConfigParms[wIndex].wIObaseAddress = PORT_LID_ALREADY_OWNED;
; Line 777
	*** 00109a	6b 5e fa 2a 		imul	bx,WORD PTR [bp-6],42	;wIndex
	*** 00109e	26 c7 87 06 00 fe ff 	mov	WORD PTR es:_stConfigParms[bx+6],-2
;|***         break;
; Line 778
	*** 0010a5	e9 03 00 		jmp	$FB2644
;|***         }
; Line 779
;|***       }
; Line 780
					$I2645:
	*** 0010a8	e9 ce ff 		jmp	$FC2643
					$FB2644:
;|***     else
; Line 781
	*** 0010ab	e9 6d 01 		jmp	$I2646
					$I2641:
;|***       {
; Line 782
;|***       if (stConfigParms[wDCBindex].wIObaseAddress != PORT_USER_DISABLED)
; Line 783
	*** 0010ae	8e 06 46 00 		mov	es,WORD PTR $T20037
	*** 0010b2	6b 5e fe 2a 		imul	bx,WORD PTR [bp-2],42	;wDCBindex
	*** 0010b6	26 83 bf 06 00 ff 	cmp	WORD PTR es:_stConfigParms[bx+6],-1
	*** 0010bc	75 03 			jne	$JCC4284
	*** 0010be	e9 5a 01 		jmp	$I2647
					$JCC4284:
;|***         {
; Line 784
;|***         wTemp = stConfigParms[wDCBindex].wIObaseAddress;
; Line 785
	*** 0010c1	6b 5e fe 2a 		imul	bx,WORD PTR [bp-2],42	;wDCBindex
	*** 0010c5	26 8b 87 06 00 		mov	ax,WORD PTR es:_stConfigParms[bx+6]
	*** 0010ca	89 46 fc 		mov	WORD PTR [bp-4],ax	;wTemp
;|***         for (wIndex = 0;wIndex < 8;wIndex++)
; Line 786
	*** 0010cd	c7 46 fa 00 00 		mov	WORD PTR [bp-6],0	;wIndex
	*** 0010d2	e9 03 00 		jmp	$F2648
					$FC2649:
	*** 0010d5	ff 46 fa 		inc	WORD PTR [bp-6]	;wIndex
					$F2648:
	*** 0010d8	83 7e fa 08 		cmp	WORD PTR [bp-6],8	;wIndex
	*** 0010dc	72 03 			jb	$JCC4316
	*** 0010de	e9 20 00 		jmp	$FB2650
					$JCC4316:
;|***           if (astMCAportTable[wIndex].wAddress == wTemp)
; Line 787
	*** 0010e1	8b 46 fc 		mov	ax,WORD PTR [bp-4]	;wTemp
_TEXT      ENDS
CONST      SEGMENT
$T20038	DW SEG _astMCAportTable 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 0010e4	8e 06 48 00 		mov	es,WORD PTR $T20038
	*** 0010e8	8b 5e fa 		mov	bx,WORD PTR [bp-6]	;wIndex
	*** 0010eb	8b cb 			mov	cx,bx
	*** 0010ed	d1 e3 			shl	bx,1
	*** 0010ef	03 d9 			add	bx,cx
	*** 0010f1	26 39 87 00 00 		cmp	WORD PTR es:_astMCAportTable[bx],ax
	*** 0010f6	74 03 			je	$JCC4342
	*** 0010f8	e9 03 00 		jmp	$I2651
					$JCC4342:
;|***             break;
; Line 788
	*** 0010fb	e9 03 00 		jmp	$FB2650
;|***         if (wIndex < 8)
; Line 789
					$I2651:
	*** 0010fe	e9 d4 ff 		jmp	$FC2649
					$FB2650:
	*** 001101	83 7e fa 08 		cmp	WORD PTR [bp-6],8	;wIndex
	*** 001105	72 03 			jb	$JCC4357
	*** 001107	e9 11 01 		jmp	$I2652
					$JCC4357:
;|***           {
; Line 790
;|***           for (wIndex = 0;wIndex < 8;wIndex++)
; Line 791
	*** 00110a	c7 46 fa 00 00 		mov	WORD PTR [bp-6],0	;wIndex
	*** 00110f	e9 03 00 		jmp	$F2653
					$FC2654:
	*** 001112	ff 46 fa 		inc	WORD PTR [bp-6]	;wIndex
					$F2653:
	*** 001115	83 7e fa 08 		cmp	WORD PTR [bp-6],8	;wIndex
	*** 001119	72 03 			jb	$JCC4377
	*** 00111b	e9 1d 00 		jmp	$FB2655
					$JCC4377:
;|***             if (LIDtable[wIndex].wBaseAddress == wTemp)
; Line 792
	*** 00111e	8b 46 fc 		mov	ax,WORD PTR [bp-4]	;wTemp
	*** 001121	8e 06 44 00 		mov	es,WORD PTR $T20036
	*** 001125	8b 5e fa 		mov	bx,WORD PTR [bp-6]	;wIndex
	*** 001128	c1 e3 04 		shl	bx,4
	*** 00112b	26 39 87 06 00 		cmp	WORD PTR es:_LIDtable[bx+6],ax
	*** 001130	74 03 			je	$JCC4400
	*** 001132	e9 03 00 		jmp	$I2656
					$JCC4400:
;|***               break;
; Line 793
	*** 001135	e9 03 00 		jmp	$FB2655
;|***           if (wIndex >= 8)
; Line 794
					$I2656:
	*** 001138	e9 d7 ff 		jmp	$FC2654
					$FB2655:
	*** 00113b	83 7e fa 08 		cmp	WORD PTR [bp-6],8	;wIndex
	*** 00113f	73 03 			jae	$JCC4415
	*** 001141	e9 12 00 		jmp	$I2657
					$JCC4415:
;|***             stConfigParms[wDCBindex].wIObaseAddress = PORT_ADDRESS_INVALID;
; Line 795
	*** 001144	8e 06 46 00 		mov	es,WORD PTR $T20037
	*** 001148	6b 5e fe 2a 		imul	bx,WORD PTR [bp-2],42	;wDCBindex
	*** 00114c	26 c7 87 06 00 fc ff 	mov	WORD PTR es:_stConfigParms[bx+6],-4
;|***           else
; Line 796
	*** 001153	e9 c5 00 		jmp	$I2658
					$I2657:
;|***             {
; Line 797
;|***             MemCopy(_szName,_stDeviceParms[wDCBindex].stDeviceHeader.abyDeviceName,8);
; Line 798
	*** 001156	6a 08 			push	8
	*** 001158	69 46 fe f0 00 		imul	ax,WORD PTR [bp-2],240	;wDCBindex
	*** 00115d	05 c6 00 		add	ax,OFFSET __stDeviceParms+198
	*** 001160	68 00 00 		push	SEG __stDeviceParms
	*** 001163	50 			push	ax
	*** 001164	68 00 00 		push	SEG __szName
	*** 001167	68 00 00 		push	OFFSET __szName
	*** 00116a	9a 00 00 00 00 		call	FAR PTR _MemCopy
	*** 00116f	83 c4 0a 		add	sp,10
;|***             _szName[8] = 0;
; Line 799
_TEXT      ENDS
CONST      SEGMENT
$T20039	DW SEG __szName 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 001172	8e 06 4a 00 		mov	es,WORD PTR $T20039
	*** 001176	26 c6 06 08 00 00 	mov	BYTE PTR es:__szName+8,0
;|***             if (AttachDD(_szName,&_stAttachDD) == DRIVER_ATTACHED)
; Line 800
	*** 00117c	68 00 00 		push	SEG __stAttachDD
	*** 00117f	68 00 00 		push	OFFSET __stAttachDD
	*** 001182	06 			push	es
	*** 001183	68 00 00 		push	OFFSET __szName
	*** 001186	9a 00 00 00 00 		call	FAR PTR _AttachDD
	*** 00118b	83 c4 08 		add	sp,8
	*** 00118e	3d 00 00 		cmp	ax,0
	*** 001191	74 03 			je	$JCC4497
	*** 001193	e9 34 00 		jmp	$I2659
					$JCC4497:
;|***               {
; Line 801
;|***               if (LIDtable[abyCOMnumbers[wDCBindex] - 1].wBaseAddress != wTemp)
; Line 802
	*** 001196	8b 46 fc 		mov	ax,WORD PTR [bp-4]	;wTemp
	*** 001199	8e 06 38 00 		mov	es,WORD PTR $T20029
	*** 00119d	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;wDCBindex
	*** 0011a0	26 8a 9f 00 00 		mov	bl,BYTE PTR es:_abyCOMnumbers[bx]
	*** 0011a5	2a ff 			sub	bh,bh
	*** 0011a7	c1 e3 04 		shl	bx,4
	*** 0011aa	8e 06 44 00 		mov	es,WORD PTR $T20036
	*** 0011ae	26 39 87 f6 ff 		cmp	WORD PTR es:_LIDtable[bx-10],ax
	*** 0011b3	75 03 			jne	$JCC4531
	*** 0011b5	e9 0f 00 		jmp	$I2660
					$JCC4531:
;|***                 stConfigParms[wDCBindex].wIObaseAddress = PORT_ADDRESS_TAKEN;
; Line 803
	*** 0011b8	8e 06 46 00 		mov	es,WORD PTR $T20037
	*** 0011bc	6b 5e fe 2a 		imul	bx,WORD PTR [bp-2],42	;wDCBindex
	*** 0011c0	26 c7 87 06 00 fb ff 	mov	WORD PTR es:_stConfigParms[bx+6],-5
;|***               }
; Line 804
					$I2660:
;|***             else
; Line 805
	*** 0011c7	e9 51 00 		jmp	$I2661
					$I2659:
;|***               {
; Line 806
;|***               for (wIndex = 0;wIndex < 8;wIndex++)
; Line 807
	*** 0011ca	c7 46 fa 00 00 		mov	WORD PTR [bp-6],0	;wIndex
	*** 0011cf	e9 03 00 		jmp	$F2662
					$FC2663:
	*** 0011d2	ff 46 fa 		inc	WORD PTR [bp-6]	;wIndex
					$F2662:
	*** 0011d5	83 7e fa 08 		cmp	WORD PTR [bp-6],8	;wIndex
	*** 0011d9	72 03 			jb	$JCC4569
	*** 0011db	e9 3d 00 		jmp	$FB2664
					$JCC4569:
;|***                 if (LIDtable[wIndex].wBaseAddress == wTemp)
; Line 808
	*** 0011de	8b 46 fc 		mov	ax,WORD PTR [bp-4]	;wTemp
	*** 0011e1	8e 06 44 00 		mov	es,WORD PTR $T20036
	*** 0011e5	8b 5e fa 		mov	bx,WORD PTR [bp-6]	;wIndex
	*** 0011e8	c1 e3 04 		shl	bx,4
	*** 0011eb	26 39 87 06 00 		cmp	WORD PTR es:_LIDtable[bx+6],ax
	*** 0011f0	74 03 			je	$JCC4592
	*** 0011f2	e9 23 00 		jmp	$I2665
					$JCC4592:
;|***                   {
; Line 809
;|***                   if (LIDtable[wIndex].bNameTaken)
; Line 810
	*** 0011f5	8b 5e fa 		mov	bx,WORD PTR [bp-6]	;wIndex
	*** 0011f8	c1 e3 04 		shl	bx,4
	*** 0011fb	26 83 bf 0a 00 00 	cmp	WORD PTR es:_LIDtable[bx+10],0
	*** 001201	75 03 			jne	$JCC4609
	*** 001203	e9 0f 00 		jmp	$I2666
					$JCC4609:
;|***                     stConfigParms[wDCBindex].wIObaseAddress = PORT_ADDRESS_TAKEN;
; Line 811
	*** 001206	8e 06 46 00 		mov	es,WORD PTR $T20037
	*** 00120a	6b 5e fe 2a 		imul	bx,WORD PTR [bp-2],42	;wDCBindex
	*** 00120e	26 c7 87 06 00 fb ff 	mov	WORD PTR es:_stConfigParms[bx+6],-5
;|***                   break;
; Line 812
					$I2666:
	*** 001215	e9 03 00 		jmp	$FB2664
;|***                   }
; Line 813
;|***               }
; Line 814
					$I2665:
	*** 001218	e9 b7 ff 		jmp	$FC2663
					$FB2664:
					$I2661:
;|***             }
; Line 815
					$I2658:
;|***           }
; Line 816
;|***         }
; Line 817
					$I2652:
;|***       }
; Line 818
					$I2647:
					$I2646:
;|***     }
; Line 819
	*** 00121b	e9 22 fe 		jmp	$FC2639
					$FB2640:
;|***   }
; Line 820
					$EX2634:
	*** 00121e	5e 			pop	si
	*** 00121f	5f 			pop	di
	*** 001220	c9 			leave	
	*** 001221	cb 			ret	

_VerifyABIOSdefinitions	ENDP
;|*** 
;|*** #ifndef x16_BIT
;|*** #ifndef RTEST
;|*** BYTE GetDeviceInterrupt(WORD wLID);
;|*** WORD GetDeviceBlockOffset(WORD wLID);
;|*** WORD GetDeviceBlockLen(WORD wLID);
;|*** WORD GetKernalData(WORD wLID,WORD wSrcOffset,BYTE *pDest,ULONG ulCount );
;|*** WORD GetDeviceAddress(WORD wLID);
;|*** WORD _far GetLIDentry(WORD *pwLID);
;|*** void FreeLIDentry(WORD wLID);
;|*** 
;|*** int iLIDcount = 0;
;|*** 
;|*** void _far BuildLIDtable(void)
;|***   {
; Line 835
	PUBLIC	_BuildLIDtable
_BuildLIDtable	PROC FAR
	*** 001222	c8 2a 00 00 		enter	42,0
	*** 001226	57 			push	di
	*** 001227	56 			push	si
;	wError = -10
;	pstDevBlock = -8
;	wBlockLen = -4
;	wOffset = -36
;	bDone = -22
;	iLastAvailable = -34
;	iFirstAvailable = -14
;	bDeviceOwned = -40
;	bDeviceAvailable = -16
;	pWord = -32
;	wMaxCount = -18
;	wSaveExt = -20
;	abySaveExt = -28
;	wLID = -2
;	ulAction = -38
;	ulCount = -24
;	iIndex = -12
;|***   int iIndex;
;|***   WORD wError;
;|***   DEVBLK *pstDevBlock;
;|***   WORD wBlockLen;
;|***   WORD wOffset;
;|***   BOOL bDone;
;|***   int iLastAvailable = -1;
; Line 842
	*** 001228	c7 46 de ff ff 		mov	WORD PTR [bp-34],-1	;iLastAvailable
;|***   int iFirstAvailable = -1;
; Line 843
	*** 00122d	c7 46 f2 ff ff 		mov	WORD PTR [bp-14],-1	;iFirstAvailable
;|***   BOOL bDeviceOwned = FALSE;
; Line 844
	*** 001232	c7 46 d8 00 00 		mov	WORD PTR [bp-40],0	;bDeviceOwned
;|***   BOOL bDeviceAvailable = FALSE;
; Line 845
	*** 001237	c7 46 f0 00 00 		mov	WORD PTR [bp-16],0	;bDeviceAvailable
;|***   WORD *pWord = (WORD *)abyFileBuffer;
; Line 846
	*** 00123c	c7 46 e0 00 00 		mov	WORD PTR [bp-32],OFFSET _abyFileBuffer	;pWord
	*** 001241	c7 46 e2 00 00 		mov	WORD PTR [bp-30],SEG _abyFileBuffer
;|***   WORD wMaxCount;
;|***   WORD wSaveExt;
;|***   char abySaveExt[4];
;|***   WORD wLID;
;|*** #ifdef _32bitAPI
;|***   ULONG ulAction;
;|***   ULONG ulCount;
;|*** #else
;|***   WORD ulAction;
;|***   WORD ulCount;
;|*** #endif
;|*** 
;|***   for (iIndex = 0;iIndex < 8;iIndex++)
; Line 859
	*** 001246	c7 46 f4 00 00 		mov	WORD PTR [bp-12],0	;iIndex
	*** 00124b	e9 03 00 		jmp	$F2704
					$FC2705:
	*** 00124e	ff 46 f4 		inc	WORD PTR [bp-12]	;iIndex
					$F2704:
	*** 001251	83 7e f4 08 		cmp	WORD PTR [bp-12],8	;iIndex
	*** 001255	7c 03 			jl	$JCC4693
	*** 001257	e9 03 01 		jmp	$FB2706
					$JCC4693:
;|***     {
; Line 860
;|***     iLIDcount++;
; Line 861
	*** 00125a	ff 06 14 10 		inc	WORD PTR _iLIDcount
;|***     wLID = iIndex + 1;
; Line 862
	*** 00125e	8b 46 f4 		mov	ax,WORD PTR [bp-12]	;iIndex
	*** 001261	40 			inc	ax
	*** 001262	89 46 fe 		mov	WORD PTR [bp-2],ax	;wLID
;|***     if ((wError = GetLIDentry(&wLID)) == NO_ERROR)
; Line 863
	*** 001265	8d 46 fe 		lea	ax,WORD PTR [bp-2]	;wLID
	*** 001268	16 			push	ss
	*** 001269	50 			push	ax
	*** 00126a	9a 00 00 00 00 		call	FAR PTR _GetLIDentry
	*** 00126f	83 c4 04 		add	sp,4
	*** 001272	89 46 f6 		mov	WORD PTR [bp-10],ax	;wError
	*** 001275	3d 00 00 		cmp	ax,0
	*** 001278	74 03 			je	$JCC4728
	*** 00127a	e9 9d 00 		jmp	$I2707
					$JCC4728:
;|***       {
; Line 864
;|***       bDeviceAvailable = TRUE;
; Line 865
	*** 00127d	c7 46 f0 01 00 		mov	WORD PTR [bp-16],1	;bDeviceAvailable
;|***       LIDtable[iIndex].wDeviceNumber = (iIndex + 1);
; Line 866
	*** 001282	8b 46 f4 		mov	ax,WORD PTR [bp-12]	;iIndex
	*** 001285	40 			inc	ax
	*** 001286	8e 06 44 00 		mov	es,WORD PTR $T20036
	*** 00128a	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 00128d	c1 e3 04 		shl	bx,4
	*** 001290	26 89 87 08 00 		mov	WORD PTR es:_LIDtable[bx+8],ax
;|***       LIDtable[iIndex].wLID = wLID;
; Line 867
	*** 001295	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;wLID
	*** 001298	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 00129b	c1 e3 04 		shl	bx,4
	*** 00129e	26 89 87 04 00 		mov	WORD PTR es:_LIDtable[bx+4],ax
;|***       LIDtable[iIndex].fFlags = LID_AVAILABLE;
; Line 868
	*** 0012a3	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 0012a6	c1 e3 04 		shl	bx,4
	*** 0012a9	26 c6 87 0c 00 08 	mov	BYTE PTR es:_LIDtable[bx+12],8
;|***       LIDtable[iIndex].wBaseAddress = GetDeviceAddress(wLID);
; Line 869
	*** 0012af	ff 76 fe 		push	WORD PTR [bp-2]	;wLID
	*** 0012b2	9a 00 00 00 00 		call	FAR PTR _GetDeviceAddress
	*** 0012b7	83 c4 02 		add	sp,2
	*** 0012ba	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 0012bd	c1 e3 04 		shl	bx,4
	*** 0012c0	8e 06 44 00 		mov	es,WORD PTR $T20036
	*** 0012c4	26 89 87 06 00 		mov	WORD PTR es:_LIDtable[bx+6],ax
;|***       LIDtable[iIndex].wBlockLen = GetDeviceBlockLen(wLID);
; Line 870
	*** 0012c9	ff 76 fe 		push	WORD PTR [bp-2]	;wLID
	*** 0012cc	9a 00 00 00 00 		call	FAR PTR _GetDeviceBlockLen
	*** 0012d1	83 c4 02 		add	sp,2
	*** 0012d4	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 0012d7	c1 e3 04 		shl	bx,4
	*** 0012da	8e 06 44 00 		mov	es,WORD PTR $T20036
	*** 0012de	26 89 87 02 00 		mov	WORD PTR es:_LIDtable[bx+2],ax
;|***       LIDtable[iIndex].wDevBlkOffset = GetDeviceBlockOffset(wLID);
; Line 871
	*** 0012e3	ff 76 fe 		push	WORD PTR [bp-2]	;wLID
	*** 0012e6	9a 00 00 00 00 		call	FAR PTR _GetDeviceBlockOffset
	*** 0012eb	83 c4 02 		add	sp,2
	*** 0012ee	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 0012f1	c1 e3 04 		shl	bx,4
	*** 0012f4	8e 06 44 00 		mov	es,WORD PTR $T20036
	*** 0012f8	26 89 87 00 00 		mov	WORD PTR es:_LIDtable[bx],ax
;|***       LIDtable[iIndex].byInterruptLevel = GetDeviceInterrupt(wLID);
; Line 872
	*** 0012fd	ff 76 fe 		push	WORD PTR [bp-2]	;wLID
	*** 001300	9a 00 00 00 00 		call	FAR PTR _GetDeviceInterrupt
	*** 001305	83 c4 02 		add	sp,2
	*** 001308	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 00130b	c1 e3 04 		shl	bx,4
	*** 00130e	8e 06 44 00 		mov	es,WORD PTR $T20036
	*** 001312	26 88 87 0d 00 		mov	BYTE PTR es:_LIDtable[bx+13],al
;|***       }
; Line 873
;|***     else
; Line 874
	*** 001317	e9 40 00 		jmp	$I2708
					$I2707:
;|***       if (wError == ERROR_LID_ALREADY_OWNED)
; Line 875
	*** 00131a	83 7e f6 01 		cmp	WORD PTR [bp-10],1	;wError
	*** 00131e	74 03 			je	$JCC4894
	*** 001320	e9 27 00 		jmp	$I2709
					$JCC4894:
;|***         {
; Line 876
;|***         bDeviceOwned = TRUE;
; Line 877
	*** 001323	c7 46 d8 01 00 		mov	WORD PTR [bp-40],1	;bDeviceOwned
;|***         LIDtable[iIndex].wDeviceNumber = (iIndex + 1);
; Line 878
	*** 001328	8b 46 f4 		mov	ax,WORD PTR [bp-12]	;iIndex
	*** 00132b	40 			inc	ax
	*** 00132c	8e 06 44 00 		mov	es,WORD PTR $T20036
	*** 001330	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 001333	c1 e3 04 		shl	bx,4
	*** 001336	26 89 87 08 00 		mov	WORD PTR es:_LIDtable[bx+8],ax
;|***         LIDtable[iIndex].fFlags |= LID_ALREADY_OWNED;
; Line 879
	*** 00133b	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 00133e	c1 e3 04 		shl	bx,4
	*** 001341	26 80 8f 0c 00 01 	or	BYTE PTR es:_LIDtable[bx+12],1
;|***         }
; Line 880
;|***       else
; Line 881
	*** 001347	e9 10 00 		jmp	$I2710
					$I2709:
;|***         if (wError == ERROR_LID_DOES_NOT_EXIST)
; Line 882
	*** 00134a	83 7e f6 02 		cmp	WORD PTR [bp-10],2	;wError
	*** 00134e	74 03 			je	$JCC4942
	*** 001350	e9 07 00 		jmp	$I2711
					$JCC4942:
;|***           {
; Line 883
;|***           iLIDcount--;
; Line 884
	*** 001353	ff 0e 14 10 		dec	WORD PTR _iLIDcount
;|***           break;
; Line 885
	*** 001357	e9 03 00 		jmp	$FB2706
;|***           }
; Line 886
;|***     }
; Line 887
					$I2711:
					$I2710:
					$I2708:
	*** 00135a	e9 f1 fe 		jmp	$FC2705
					$FB2706:
;|***   for (;iIndex < 8;iIndex++)
; Line 888
	*** 00135d	e9 03 00 		jmp	$F2712
					$FC2713:
	*** 001360	ff 46 f4 		inc	WORD PTR [bp-12]	;iIndex
					$F2712:
	*** 001363	83 7e f4 08 		cmp	WORD PTR [bp-12],8	;iIndex
	*** 001367	7c 03 			jl	$JCC4967
	*** 001369	e9 13 00 		jmp	$FB2714
					$JCC4967:
;|***     LIDtable[iIndex].fFlags |= LID_DOES_NOT_EXIST;
; Line 889
	*** 00136c	8e 06 44 00 		mov	es,WORD PTR $T20036
	*** 001370	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 001373	c1 e3 04 		shl	bx,4
	*** 001376	26 80 8f 0c 00 02 	or	BYTE PTR es:_LIDtable[bx+12],2
	*** 00137c	e9 e1 ff 		jmp	$FC2713
					$FB2714:
;|*** 
;|***   if (bDeviceOwned && bDeviceAvailable)
; Line 891
	*** 00137f	83 7e d8 00 		cmp	WORD PTR [bp-40],0	;bDeviceOwned
	*** 001383	75 03 			jne	$JCC4995
	*** 001385	e9 4a 02 		jmp	$I2715
					$JCC4995:
	*** 001388	83 7e f0 00 		cmp	WORD PTR [bp-16],0	;bDeviceAvailable
	*** 00138c	75 03 			jne	$JCC5004
	*** 00138e	e9 41 02 		jmp	$I2715
					$JCC5004:
;|***     {
; Line 892
;|***     for (iIndex = 0;iIndex < iLIDcount;iIndex++)
; Line 893
	*** 001391	c7 46 f4 00 00 		mov	WORD PTR [bp-12],0	;iIndex
	*** 001396	e9 03 00 		jmp	$F2716
					$FC2717:
	*** 001399	ff 46 f4 		inc	WORD PTR [bp-12]	;iIndex
					$F2716:
	*** 00139c	8b 46 f4 		mov	ax,WORD PTR [bp-12]	;iIndex
	*** 00139f	39 06 14 10 		cmp	WORD PTR _iLIDcount,ax
	*** 0013a3	7f 03 			jg	$JCC5027
	*** 0013a5	e9 0a 01 		jmp	$FB2718
					$JCC5027:
;|***       {
; Line 894
;|***       if (LIDtable[iIndex].fFlags & LID_ALREADY_OWNED)
; Line 895
	*** 0013a8	8e 06 44 00 		mov	es,WORD PTR $T20036
	*** 0013ac	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 0013af	c1 e3 04 		shl	bx,4
	*** 0013b2	26 f6 87 0c 00 01 	test	BYTE PTR es:_LIDtable[bx+12],1
	*** 0013b8	75 03 			jne	$JCC5048
	*** 0013ba	e9 dd 00 		jmp	$I2719
					$JCC5048:
;|***         {
; Line 896
;|***         if (iLastAvailable != -1)
; Line 897
	*** 0013bd	83 7e de ff 		cmp	WORD PTR [bp-34],-1	;iLastAvailable
	*** 0013c1	75 03 			jne	$JCC5057
	*** 0013c3	e9 d1 00 		jmp	$I2720
					$JCC5057:
;|***           {
; Line 898
;|***           wLID = LIDtable[iLastAvailable].wLID;
; Line 899
	*** 0013c6	8b 5e de 		mov	bx,WORD PTR [bp-34]	;iLastAvailable
	*** 0013c9	c1 e3 04 		shl	bx,4
	*** 0013cc	26 8b 87 04 00 		mov	ax,WORD PTR es:_LIDtable[bx+4]
	*** 0013d1	89 46 fe 		mov	WORD PTR [bp-2],ax	;wLID
;|***           wBlockLen = LIDtable[iLastAvailable].wBlockLen;
; Line 900
	*** 0013d4	8b 5e de 		mov	bx,WORD PTR [bp-34]	;iLastAvailable
	*** 0013d7	c1 e3 04 		shl	bx,4
	*** 0013da	26 8b 87 02 00 		mov	ax,WORD PTR es:_LIDtable[bx+2]
	*** 0013df	89 46 fc 		mov	WORD PTR [bp-4],ax	;wBlockLen
;|***           wOffset = (wBlockLen + LIDtable[iLastAvailable].wDevBlkOffset);
; Line 901
	*** 0013e2	8b 5e de 		mov	bx,WORD PTR [bp-34]	;iLastAvailable
	*** 0013e5	c1 e3 04 		shl	bx,4
	*** 0013e8	26 8b 87 00 00 		mov	ax,WORD PTR es:_LIDtable[bx]
	*** 0013ed	03 46 fc 		add	ax,WORD PTR [bp-4]	;wBlockLen
	*** 0013f0	89 46 dc 		mov	WORD PTR [bp-36],ax	;wOffset
;|***           GetKernalData(wLID,wOffset,abyFileBuffer,(wBlockLen * (iIndex - iLastAvailable)));
; Line 902
	*** 0013f3	8b 46 f4 		mov	ax,WORD PTR [bp-12]	;iIndex
	*** 0013f6	2b 46 de 		sub	ax,WORD PTR [bp-34]	;iLastAvailable
	*** 0013f9	f7 66 fc 		mul	WORD PTR [bp-4]	;wBlockLen
	*** 0013fc	6a 00 			push	0
	*** 0013fe	50 			push	ax
	*** 0013ff	68 00 00 		push	SEG _abyFileBuffer
	*** 001402	68 00 00 		push	OFFSET _abyFileBuffer
	*** 001405	ff 76 dc 		push	WORD PTR [bp-36]	;wOffset
	*** 001408	ff 76 fe 		push	WORD PTR [bp-2]	;wLID
	*** 00140b	9a 00 00 00 00 		call	FAR PTR _GetKernalData
	*** 001410	83 c4 0c 		add	sp,12
;|***           bDone = FALSE;
; Line 903
	*** 001413	c7 46 ea 00 00 		mov	WORD PTR [bp-22],0	;bDone
;|***           pWord = (WORD *)&abyFileBuffer[wBlockLen * (iIndex - iLastAvailable - 1)];
; Line 904
	*** 001418	8b 46 f4 		mov	ax,WORD PTR [bp-12]	;iIndex
	*** 00141b	2b 46 de 		sub	ax,WORD PTR [bp-34]	;iLastAvailable
	*** 00141e	48 			dec	ax
	*** 00141f	f7 66 fc 		mul	WORD PTR [bp-4]	;wBlockLen
	*** 001422	05 00 00 		add	ax,OFFSET _abyFileBuffer
	*** 001425	89 46 e0 		mov	WORD PTR [bp-32],ax	;pWord
	*** 001428	c7 46 e2 00 00 		mov	WORD PTR [bp-30],SEG _abyFileBuffer
;|***           while (!bDone)
; Line 905
					$FC2722:
	*** 00142d	83 7e ea 00 		cmp	WORD PTR [bp-22],0	;bDone
	*** 001431	74 03 			je	$JCC5169
	*** 001433	e9 4b 00 		jmp	$FB2723
					$JCC5169:
;|***             {
; Line 906
;|***             wMaxCount = wBlockLen;
; Line 907
	*** 001436	8b 46 fc 		mov	ax,WORD PTR [bp-4]	;wBlockLen
	*** 001439	89 46 ee 		mov	WORD PTR [bp-18],ax	;wMaxCount
;|***             while (*pWord != wBlockLen)
; Line 908
					$FC2725:
	*** 00143c	8b 46 fc 		mov	ax,WORD PTR [bp-4]	;wBlockLen
	*** 00143f	c4 5e e0 		les	bx,DWORD PTR [bp-32]	;pWord
	*** 001442	26 39 07 		cmp	WORD PTR es:[bx],ax
	*** 001445	75 03 			jne	$JCC5189
	*** 001447	e9 16 00 		jmp	$FB2726
					$JCC5189:
;|***               {
; Line 909
;|***               if (--wMaxCount == 0)
; Line 910
	*** 00144a	ff 4e ee 		dec	WORD PTR [bp-18]	;wMaxCount
	*** 00144d	83 7e ee 00 		cmp	WORD PTR [bp-18],0	;wMaxCount
	*** 001451	74 03 			je	$JCC5201
	*** 001453	e9 03 00 		jmp	$I2727
					$JCC5201:
;|***                 return;
; Line 911
	*** 001456	e9 91 03 		jmp	$EX2686
;|***               pWord++;
; Line 912
					$I2727:
	*** 001459	83 46 e0 02 		add	WORD PTR [bp-32],2	;pWord
;|***               }
; Line 913
	*** 00145d	e9 dc ff 		jmp	$FC2725
					$FB2726:
;|***             pstDevBlock = (DEVBLK *)pWord;
; Line 914
	*** 001460	8b 46 e0 		mov	ax,WORD PTR [bp-32]	;pWord
	*** 001463	8b 56 e2 		mov	dx,WORD PTR [bp-30]
	*** 001466	89 46 f8 		mov	WORD PTR [bp-8],ax	;pstDevBlock
	*** 001469	89 56 fa 		mov	WORD PTR [bp-6],dx
;|***             if (pstDevBlock->wDeviceID == ASYNC_DEVICE_ID)
; Line 915
	*** 00146c	c4 5e f8 		les	bx,DWORD PTR [bp-8]	;pstDevBlock
	*** 00146f	26 83 7f 06 06 		cmp	WORD PTR es:[bx+6],6
	*** 001474	74 03 			je	$JCC5236
	*** 001476	e9 05 00 		jmp	$I2728
					$JCC5236:
;|***               bDone = TRUE;
; Line 916
	*** 001479	c7 46 ea 01 00 		mov	WORD PTR [bp-22],1	;bDone
;|***             }
; Line 917
					$I2728:
	*** 00147e	e9 ac ff 		jmp	$FC2722
					$FB2723:
;|***           LIDtable[iIndex].wBaseAddress = pstDevBlock->wDataArea;
; Line 918
	*** 001481	c4 5e f8 		les	bx,DWORD PTR [bp-8]	;pstDevBlock
	*** 001484	26 8b 47 0c 		mov	ax,WORD PTR es:[bx+12]
	*** 001488	8e 06 44 00 		mov	es,WORD PTR $T20036
	*** 00148c	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 00148f	c1 e3 04 		shl	bx,4
	*** 001492	26 89 87 06 00 		mov	WORD PTR es:_LIDtable[bx+6],ax
;|***           }
; Line 919
;|***         }
; Line 920
					$I2720:
;|***       else
; Line 921
	*** 001497	e9 15 00 		jmp	$I2729
					$I2719:
;|***         {
; Line 922
;|***         if (iFirstAvailable == -1)
; Line 923
	*** 00149a	83 7e f2 ff 		cmp	WORD PTR [bp-14],-1	;iFirstAvailable
	*** 00149e	74 03 			je	$JCC5278
	*** 0014a0	e9 06 00 		jmp	$I2730
					$JCC5278:
;|***           iFirstAvailable = iIndex;
; Line 924
	*** 0014a3	8b 46 f4 		mov	ax,WORD PTR [bp-12]	;iIndex
	*** 0014a6	89 46 f2 		mov	WORD PTR [bp-14],ax	;iFirstAvailable
;|***         iLastAvailable = iIndex;
; Line 925
					$I2730:
	*** 0014a9	8b 46 f4 		mov	ax,WORD PTR [bp-12]	;iIndex
	*** 0014ac	89 46 de 		mov	WORD PTR [bp-34],ax	;iLastAvailable
;|***         }
; Line 926
					$I2729:
;|***       }
; Line 927
	*** 0014af	e9 e7 fe 		jmp	$FC2717
					$FB2718:
;|***     if (iFirstAvailable > 0)
; Line 928
	*** 0014b2	83 7e f2 00 		cmp	WORD PTR [bp-14],0	;iFirstAvailable
	*** 0014b6	7f 03 			jg	$JCC5302
	*** 0014b8	e9 17 01 		jmp	$I2731
					$JCC5302:
;|***       {
; Line 929
;|***       wLID = LIDtable[iFirstAvailable].wLID;
; Line 930
	*** 0014bb	8e 06 44 00 		mov	es,WORD PTR $T20036
	*** 0014bf	8b 5e f2 		mov	bx,WORD PTR [bp-14]	;iFirstAvailable
	*** 0014c2	c1 e3 04 		shl	bx,4
	*** 0014c5	26 8b 87 04 00 		mov	ax,WORD PTR es:_LIDtable[bx+4]
	*** 0014ca	89 46 fe 		mov	WORD PTR [bp-2],ax	;wLID
;|***       wBlockLen = LIDtable[iFirstAvailable].wBlockLen;
; Line 931
	*** 0014cd	8b 5e f2 		mov	bx,WORD PTR [bp-14]	;iFirstAvailable
	*** 0014d0	c1 e3 04 		shl	bx,4
	*** 0014d3	26 8b 87 02 00 		mov	ax,WORD PTR es:_LIDtable[bx+2]
	*** 0014d8	89 46 fc 		mov	WORD PTR [bp-4],ax	;wBlockLen
;|***       wOffset = LIDtable[iFirstAvailable].wDevBlkOffset;
; Line 932
	*** 0014db	8b 5e f2 		mov	bx,WORD PTR [bp-14]	;iFirstAvailable
	*** 0014de	c1 e3 04 		shl	bx,4
	*** 0014e1	26 8b 87 00 00 		mov	ax,WORD PTR es:_LIDtable[bx]
	*** 0014e6	89 46 dc 		mov	WORD PTR [bp-36],ax	;wOffset
;|***       wOffset -= ((wBlockLen * (iFirstAvailable + 1)) - 8);
; Line 933
	*** 0014e9	b8 ff ff 		mov	ax,-1
	*** 0014ec	2b 46 f2 		sub	ax,WORD PTR [bp-14]	;iFirstAvailable
	*** 0014ef	f7 66 fc 		mul	WORD PTR [bp-4]	;wBlockLen
	*** 0014f2	05 08 00 		add	ax,8
	*** 0014f5	01 46 dc 		add	WORD PTR [bp-36],ax	;wOffset
;|***       GetKernalData(wLID,wOffset,abyFileBuffer,(wBlockLen * (iFirstAvailable + 2)));
; Line 934
	*** 0014f8	8b 46 f2 		mov	ax,WORD PTR [bp-14]	;iFirstAvailable
	*** 0014fb	05 02 00 		add	ax,2
	*** 0014fe	f7 66 fc 		mul	WORD PTR [bp-4]	;wBlockLen
	*** 001501	6a 00 			push	0
	*** 001503	50 			push	ax
	*** 001504	68 00 00 		push	SEG _abyFileBuffer
	*** 001507	68 00 00 		push	OFFSET _abyFileBuffer
	*** 00150a	ff 76 dc 		push	WORD PTR [bp-36]	;wOffset
	*** 00150d	ff 76 fe 		push	WORD PTR [bp-2]	;wLID
	*** 001510	9a 00 00 00 00 		call	FAR PTR _GetKernalData
	*** 001515	83 c4 0c 		add	sp,12
;|***       pWord = (WORD *)abyFileBuffer;
; Line 935
	*** 001518	c7 46 e0 00 00 		mov	WORD PTR [bp-32],OFFSET _abyFileBuffer	;pWord
	*** 00151d	c7 46 e2 00 00 		mov	WORD PTR [bp-30],SEG _abyFileBuffer
;|***       pWord--;
; Line 936
	*** 001522	83 6e e0 02 		sub	WORD PTR [bp-32],2	;pWord
;|***       wMaxCount = (wBlockLen * 3);
; Line 937
	*** 001526	8b 46 fc 		mov	ax,WORD PTR [bp-4]	;wBlockLen
	*** 001529	8b c8 			mov	cx,ax
	*** 00152b	d1 e0 			shl	ax,1
	*** 00152d	03 c1 			add	ax,cx
	*** 00152f	89 46 ee 		mov	WORD PTR [bp-18],ax	;wMaxCount
;|***       for (iIndex = iFirstAvailable;iIndex > 0;iIndex--)
; Line 938
	*** 001532	8b 46 f2 		mov	ax,WORD PTR [bp-14]	;iFirstAvailable
	*** 001535	89 46 f4 		mov	WORD PTR [bp-12],ax	;iIndex
	*** 001538	e9 03 00 		jmp	$F2732
					$FC2733:
	*** 00153b	ff 4e f4 		dec	WORD PTR [bp-12]	;iIndex
					$F2732:
	*** 00153e	83 7e f4 00 		cmp	WORD PTR [bp-12],0	;iIndex
	*** 001542	7f 03 			jg	$JCC5442
	*** 001544	e9 8b 00 		jmp	$FB2734
					$JCC5442:
;|***         {
; Line 939
;|***         pWord++;
; Line 940
	*** 001547	83 46 e0 02 		add	WORD PTR [bp-32],2	;pWord
;|***         bDone = FALSE;
; Line 941
	*** 00154b	c7 46 ea 00 00 		mov	WORD PTR [bp-22],0	;bDone
;|***         while (!bDone)
; Line 942
					$FC2736:
	*** 001550	83 7e ea 00 		cmp	WORD PTR [bp-22],0	;bDone
	*** 001554	74 03 			je	$JCC5460
	*** 001556	e9 57 00 		jmp	$FB2737
					$JCC5460:
;|***           {
; Line 943
;|***           while (*pWord != wBlockLen)
; Line 944
					$FC2739:
	*** 001559	8b 46 fc 		mov	ax,WORD PTR [bp-4]	;wBlockLen
	*** 00155c	c4 5e e0 		les	bx,DWORD PTR [bp-32]	;pWord
	*** 00155f	26 39 07 		cmp	WORD PTR es:[bx],ax
	*** 001562	75 03 			jne	$JCC5474
	*** 001564	e9 16 00 		jmp	$FB2740
					$JCC5474:
;|***             {
; Line 945
;|***             if (--wMaxCount == 0)
; Line 946
	*** 001567	ff 4e ee 		dec	WORD PTR [bp-18]	;wMaxCount
	*** 00156a	83 7e ee 00 		cmp	WORD PTR [bp-18],0	;wMaxCount
	*** 00156e	74 03 			je	$JCC5486
	*** 001570	e9 03 00 		jmp	$I2741
					$JCC5486:
;|***               return;
; Line 947
	*** 001573	e9 74 02 		jmp	$EX2686
;|***             pWord++;
; Line 948
					$I2741:
	*** 001576	83 46 e0 02 		add	WORD PTR [bp-32],2	;pWord
;|***             }
; Line 949
	*** 00157a	e9 dc ff 		jmp	$FC2739
					$FB2740:
;|***           pstDevBlock = (DEVBLK *)pWord;
; Line 950
	*** 00157d	8b 46 e0 		mov	ax,WORD PTR [bp-32]	;pWord
	*** 001580	8b 56 e2 		mov	dx,WORD PTR [bp-30]
	*** 001583	89 46 f8 		mov	WORD PTR [bp-8],ax	;pstDevBlock
	*** 001586	89 56 fa 		mov	WORD PTR [bp-6],dx
;|***           if ((pstDevBlock->wDeviceID == ASYNC_DEVICE_ID) &&
;|***               (pstDevBlock->wLogicalID == (wLID - iIndex)))
; Line 952
	*** 001589	c4 5e f8 		les	bx,DWORD PTR [bp-8]	;pstDevBlock
	*** 00158c	26 83 7f 06 06 		cmp	WORD PTR es:[bx+6],6
	*** 001591	74 03 			je	$JCC5521
	*** 001593	e9 17 00 		jmp	$I2742
					$JCC5521:
	*** 001596	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;wLID
	*** 001599	c4 5e f8 		les	bx,DWORD PTR [bp-8]	;pstDevBlock
	*** 00159c	26 2b 47 04 		sub	ax,WORD PTR es:[bx+4]
	*** 0015a0	3b 46 f4 		cmp	ax,WORD PTR [bp-12]	;iIndex
	*** 0015a3	74 03 			je	$JCC5539
	*** 0015a5	e9 05 00 		jmp	$I2742
					$JCC5539:
;|***             bDone = TRUE;
; Line 953
	*** 0015a8	c7 46 ea 01 00 		mov	WORD PTR [bp-22],1	;bDone
;|***           }
; Line 954
					$I2742:
	*** 0015ad	e9 a0 ff 		jmp	$FC2736
					$FB2737:
;|***         wMaxCount = wBlockLen;
; Line 955
	*** 0015b0	8b 46 fc 		mov	ax,WORD PTR [bp-4]	;wBlockLen
	*** 0015b3	89 46 ee 		mov	WORD PTR [bp-18],ax	;wMaxCount
;|***         LIDtable[iFirstAvailable - iIndex].wBaseAddress = pstDevBlock->wDataArea;
; Line 956
	*** 0015b6	c4 5e f8 		les	bx,DWORD PTR [bp-8]	;pstDevBlock
	*** 0015b9	26 8b 47 0c 		mov	ax,WORD PTR es:[bx+12]
	*** 0015bd	8e 06 44 00 		mov	es,WORD PTR $T20036
	*** 0015c1	8b 5e f2 		mov	bx,WORD PTR [bp-14]	;iFirstAvailable
	*** 0015c4	2b 5e f4 		sub	bx,WORD PTR [bp-12]	;iIndex
	*** 0015c7	c1 e3 04 		shl	bx,4
	*** 0015ca	26 89 87 06 00 		mov	WORD PTR es:_LIDtable[bx+6],ax
;|***         }
; Line 957
	*** 0015cf	e9 69 ff 		jmp	$FC2733
					$FB2734:
;|***       }
; Line 958
;|***     }
; Line 959
					$I2731:
;|***   for (iIndex = 0;iIndex < 8;iIndex++)
; Line 960
					$I2715:
	*** 0015d2	c7 46 f4 00 00 		mov	WORD PTR [bp-12],0	;iIndex
	*** 0015d7	e9 03 00 		jmp	$F2743
					$FC2744:
	*** 0015da	ff 46 f4 		inc	WORD PTR [bp-12]	;iIndex
					$F2743:
	*** 0015dd	83 7e f4 08 		cmp	WORD PTR [bp-12],8	;iIndex
	*** 0015e1	7c 03 			jl	$JCC5601
	*** 0015e3	e9 31 00 		jmp	$FB2745
					$JCC5601:
;|***     {
; Line 961
;|***     if (LIDtable[iIndex].fFlags & LID_AVAILABLE)
; Line 962
	*** 0015e6	8e 06 44 00 		mov	es,WORD PTR $T20036
	*** 0015ea	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 0015ed	c1 e3 04 		shl	bx,4
	*** 0015f0	26 f6 87 0c 00 08 	test	BYTE PTR es:_LIDtable[bx+12],8
	*** 0015f6	75 03 			jne	$JCC5622
	*** 0015f8	e9 19 00 		jmp	$I2746
					$JCC5622:
;|***       {
; Line 963
;|***       wLID = LIDtable[iIndex].wLID;
; Line 964
	*** 0015fb	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 0015fe	c1 e3 04 		shl	bx,4
	*** 001601	26 8b 87 04 00 		mov	ax,WORD PTR es:_LIDtable[bx+4]
	*** 001606	89 46 fe 		mov	WORD PTR [bp-2],ax	;wLID
;|***       FreeLIDentry(wLID);
; Line 965
	*** 001609	ff 76 fe 		push	WORD PTR [bp-2]	;wLID
	*** 00160c	9a 00 00 00 00 		call	FAR PTR _FreeLIDentry
	*** 001611	83 c4 02 		add	sp,2
;|***       }
; Line 966
;|***     }
; Line 967
					$I2746:
	*** 001614	e9 c3 ff 		jmp	$FC2744
					$FB2745:
;|***   if (iLIDcount > 0)
; Line 968
	*** 001617	83 3e 14 10 00 		cmp	WORD PTR _iLIDcount,0
	*** 00161c	7f 03 			jg	$JCC5660
	*** 00161e	e9 c9 01 		jmp	$I2747
					$JCC5660:
;|***     {
; Line 969
;|*** //_asm INT 3
;|***     for (iIndex = 0;iIndex < iLIDcount;iIndex++)
; Line 971
	*** 001621	c7 46 f4 00 00 		mov	WORD PTR [bp-12],0	;iIndex
	*** 001626	e9 03 00 		jmp	$F2748
					$FC2749:
	*** 001629	ff 46 f4 		inc	WORD PTR [bp-12]	;iIndex
					$F2748:
	*** 00162c	8b 46 f4 		mov	ax,WORD PTR [bp-12]	;iIndex
	*** 00162f	39 06 14 10 		cmp	WORD PTR _iLIDcount,ax
	*** 001633	7f 03 			jg	$JCC5683
	*** 001635	e9 49 00 		jmp	$FB2750
					$JCC5683:
;|***       {
; Line 972
;|***       sprintf(_szName,0,"COM%d    ",(iIndex + 1));
; Line 973
	*** 001638	8b 46 f4 		mov	ax,WORD PTR [bp-12]	;iIndex
	*** 00163b	40 			inc	ax
	*** 00163c	50 			push	ax
	*** 00163d	1e 			push	ds
	*** 00163e	68 09 10 		push	OFFSET DGROUP:$SG2751
	*** 001641	6a 00 			push	0
	*** 001643	68 00 00 		push	SEG __szName
	*** 001646	68 00 00 		push	OFFSET __szName
	*** 001649	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 00164e	83 c4 0c 		add	sp,12
;|***       if (AttachDD(_szName,&_stAttachDD) == DRIVER_ATTACHED)
; Line 974
	*** 001651	68 00 00 		push	SEG __stAttachDD
	*** 001654	68 00 00 		push	OFFSET __stAttachDD
	*** 001657	68 00 00 		push	SEG __szName
	*** 00165a	68 00 00 		push	OFFSET __szName
	*** 00165d	9a 00 00 00 00 		call	FAR PTR _AttachDD
	*** 001662	83 c4 08 		add	sp,8
	*** 001665	3d 00 00 		cmp	ax,0
	*** 001668	74 03 			je	$JCC5736
	*** 00166a	e9 11 00 		jmp	$I2752
					$JCC5736:
;|***         LIDtable[iIndex].bNameTaken = TRUE;
; Line 975
	*** 00166d	8e 06 44 00 		mov	es,WORD PTR $T20036
	*** 001671	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 001674	c1 e3 04 		shl	bx,4
	*** 001677	26 c7 87 0a 00 01 00 	mov	WORD PTR es:_LIDtable[bx+10],1
;|***       }
; Line 976
					$I2752:
	*** 00167e	e9 a8 ff 		jmp	$FC2749
					$FB2750:
;|***     iIndex = 0;
; Line 977
	*** 001681	c7 46 f4 00 00 		mov	WORD PTR [bp-12],0	;iIndex
;|***     while (iIndex < (CCHMAXPATH - 8))
; Line 978
					$FC2754:
	*** 001686	81 7e f4 fc 00 		cmp	WORD PTR [bp-12],252	;iIndex
	*** 00168b	7c 03 			jl	$JCC5771
	*** 00168d	e9 30 00 		jmp	$FB2755
					$JCC5771:
;|***       {
; Line 979
;|***       if (_abyPath[iIndex] == ' ')
; Line 980
	*** 001690	8e 06 08 00 		mov	es,WORD PTR $T20004
	*** 001694	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 001697	26 80 bf 00 00 20 	cmp	BYTE PTR es:__abyPath[bx],32
	*** 00169d	74 03 			je	$JCC5789
	*** 00169f	e9 03 00 		jmp	$I2756
					$JCC5789:
;|***         break;
; Line 981
	*** 0016a2	e9 1b 00 		jmp	$FB2755
;|***       if (_abyPath[iIndex] == 0)
; Line 982
					$I2756:
	*** 0016a5	8e 06 08 00 		mov	es,WORD PTR $T20004
	*** 0016a9	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 0016ac	26 80 bf 00 00 00 	cmp	BYTE PTR es:__abyPath[bx],0
	*** 0016b2	74 03 			je	$JCC5810
	*** 0016b4	e9 03 00 		jmp	$I2757
					$JCC5810:
;|***         break;
; Line 983
	*** 0016b7	e9 06 00 		jmp	$FB2755
;|***       iIndex++;
; Line 984
					$I2757:
	*** 0016ba	ff 46 f4 		inc	WORD PTR [bp-12]	;iIndex
;|***       }
; Line 985
	*** 0016bd	e9 c6 ff 		jmp	$FC2754
					$FB2755:
;|***     while (_abyPath[iIndex] != '.')
; Line 986
					$FC2759:
	*** 0016c0	8e 06 08 00 		mov	es,WORD PTR $T20004
	*** 0016c4	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 0016c7	26 80 bf 00 00 2e 	cmp	BYTE PTR es:__abyPath[bx],46
	*** 0016cd	75 03 			jne	$JCC5837
	*** 0016cf	e9 30 00 		jmp	$FB2760
					$JCC5837:
;|***       if (iIndex-- == 0)
; Line 987
	*** 0016d2	8b 46 f4 		mov	ax,WORD PTR [bp-12]	;iIndex
	*** 0016d5	ff 4e f4 		dec	WORD PTR [bp-12]	;iIndex
	*** 0016d8	3d 00 00 		cmp	ax,0
	*** 0016db	74 03 			je	$JCC5851
	*** 0016dd	e9 1f 00 		jmp	$I2761
					$JCC5851:
;|***         {
; Line 988
;|***         VioWrtTTY(chFailedBadPath,StringLength(chFailedBadPath),0);
; Line 989
	*** 0016e0	68 00 00 		push	SEG _chFailedBadPath
	*** 0016e3	68 00 00 		push	OFFSET _chFailedBadPath
	*** 0016e6	68 00 00 		push	SEG _chFailedBadPath
	*** 0016e9	68 00 00 		push	OFFSET _chFailedBadPath
	*** 0016ec	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 0016f1	83 c4 04 		add	sp,4
	*** 0016f4	50 			push	ax
	*** 0016f5	6a 00 			push	0
	*** 0016f7	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***         return;
; Line 990
	*** 0016fc	e9 eb 00 		jmp	$EX2686
;|***         }
; Line 991
;|***     wSaveExt = ++iIndex;
; Line 992
					$I2761:
	*** 0016ff	e9 be ff 		jmp	$FC2759
					$FB2760:
	*** 001702	ff 46 f4 		inc	WORD PTR [bp-12]	;iIndex
	*** 001705	8b 46 f4 		mov	ax,WORD PTR [bp-12]	;iIndex
	*** 001708	89 46 ec 		mov	WORD PTR [bp-20],ax	;wSaveExt
;|***     abySaveExt[0] = _abyPath[iIndex];
; Line 993
	*** 00170b	8e 06 08 00 		mov	es,WORD PTR $T20004
	*** 00170f	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 001712	26 8a 87 00 00 		mov	al,BYTE PTR es:__abyPath[bx]
	*** 001717	88 46 e4 		mov	BYTE PTR [bp-28],al	;abySaveExt
;|***     _abyPath[iIndex] = 'M';
; Line 994
	*** 00171a	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 00171d	26 c6 87 00 00 4d 	mov	BYTE PTR es:__abyPath[bx],77
;|***     abySaveExt[1] = _abyPath[++iIndex];
; Line 995
	*** 001723	ff 46 f4 		inc	WORD PTR [bp-12]	;iIndex
	*** 001726	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 001729	26 8a 87 00 00 		mov	al,BYTE PTR es:__abyPath[bx]
	*** 00172e	88 46 e5 		mov	BYTE PTR [bp-27],al
;|***     _abyPath[iIndex] = 'A';
; Line 996
	*** 001731	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 001734	26 c6 87 00 00 41 	mov	BYTE PTR es:__abyPath[bx],65
;|***     abySaveExt[2] = _abyPath[++iIndex];
; Line 997
	*** 00173a	ff 46 f4 		inc	WORD PTR [bp-12]	;iIndex
	*** 00173d	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 001740	26 8a 87 00 00 		mov	al,BYTE PTR es:__abyPath[bx]
	*** 001745	88 46 e6 		mov	BYTE PTR [bp-26],al
;|***     _abyPath[iIndex] = 'P';
; Line 998
	*** 001748	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 00174b	26 c6 87 00 00 50 	mov	BYTE PTR es:__abyPath[bx],80
;|***     abySaveExt[3] = _abyPath[++iIndex];
; Line 999
	*** 001751	ff 46 f4 		inc	WORD PTR [bp-12]	;iIndex
	*** 001754	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 001757	26 8a 87 00 00 		mov	al,BYTE PTR es:__abyPath[bx]
	*** 00175c	88 46 e7 		mov	BYTE PTR [bp-25],al
;|***     _abyPath[iIndex] = 0;
; Line 1000
	*** 00175f	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 001762	26 c6 87 00 00 00 	mov	BYTE PTR es:__abyPath[bx],0
;|***     if (DosOpen(_abyPath,&hFile,&ulAction,0L,0,0x0012,0x1012,0L) == 0)
; Line 1001
	*** 001768	06 			push	es
	*** 001769	68 00 00 		push	OFFSET __abyPath
	*** 00176c	1e 			push	ds
	*** 00176d	68 a8 0f 		push	OFFSET DGROUP:_hFile
	*** 001770	8d 46 da 		lea	ax,WORD PTR [bp-38]	;ulAction
	*** 001773	16 			push	ss
	*** 001774	50 			push	ax
	*** 001775	6a 00 			push	0
	*** 001777	6a 00 			push	0
	*** 001779	6a 00 			push	0
	*** 00177b	6a 12 			push	18
	*** 00177d	68 12 10 		push	4114
	*** 001780	6a 00 			push	0
	*** 001782	6a 00 			push	0
	*** 001784	9a 00 00 00 00 		call	FAR PTR DOS16OPEN
	*** 001789	3d 00 00 		cmp	ax,0
	*** 00178c	74 03 			je	$JCC6028
	*** 00178e	e9 20 00 		jmp	$I2762
					$JCC6028:
;|***       {
; Line 1002
;|***       DosWrite(hFile,&LIDtable,(sizeof(LIDTAB) * 8),&ulCount);
; Line 1003
	*** 001791	ff 36 a8 0f 		push	WORD PTR _hFile
	*** 001795	68 00 00 		push	SEG _LIDtable
	*** 001798	68 00 00 		push	OFFSET _LIDtable
	*** 00179b	68 80 00 		push	128
	*** 00179e	8d 46 e8 		lea	ax,WORD PTR [bp-24]	;ulCount
	*** 0017a1	16 			push	ss
	*** 0017a2	50 			push	ax
	*** 0017a3	9a 00 00 00 00 		call	FAR PTR DOS16WRITE
;|***       DosClose(hFile);
; Line 1004
	*** 0017a8	ff 36 a8 0f 		push	WORD PTR _hFile
	*** 0017ac	9a 00 00 00 00 		call	FAR PTR DOS16CLOSE
;|***       }
; Line 1005
;|***     _abyPath[wSaveExt++] = abySaveExt[0];
; Line 1006
					$I2762:
	*** 0017b1	8a 46 e4 		mov	al,BYTE PTR [bp-28]	;abySaveExt
	*** 0017b4	8e 06 08 00 		mov	es,WORD PTR $T20004
	*** 0017b8	8b 5e ec 		mov	bx,WORD PTR [bp-20]	;wSaveExt
	*** 0017bb	26 88 87 00 00 		mov	BYTE PTR es:__abyPath[bx],al
	*** 0017c0	ff 46 ec 		inc	WORD PTR [bp-20]	;wSaveExt
;|***     _abyPath[wSaveExt++] = abySaveExt[1];
; Line 1007
	*** 0017c3	8a 46 e5 		mov	al,BYTE PTR [bp-27]
	*** 0017c6	8b 5e ec 		mov	bx,WORD PTR [bp-20]	;wSaveExt
	*** 0017c9	26 88 87 00 00 		mov	BYTE PTR es:__abyPath[bx],al
	*** 0017ce	ff 46 ec 		inc	WORD PTR [bp-20]	;wSaveExt
;|***     _abyPath[wSaveExt++] = abySaveExt[2];
; Line 1008
	*** 0017d1	8a 46 e6 		mov	al,BYTE PTR [bp-26]
	*** 0017d4	8b 5e ec 		mov	bx,WORD PTR [bp-20]	;wSaveExt
	*** 0017d7	26 88 87 00 00 		mov	BYTE PTR es:__abyPath[bx],al
	*** 0017dc	ff 46 ec 		inc	WORD PTR [bp-20]	;wSaveExt
;|***     _abyPath[wSaveExt] = abySaveExt[3];
; Line 1009
	*** 0017df	8a 46 e7 		mov	al,BYTE PTR [bp-25]
	*** 0017e2	8b 5e ec 		mov	bx,WORD PTR [bp-20]	;wSaveExt
	*** 0017e5	26 88 87 00 00 		mov	BYTE PTR es:__abyPath[bx],al
;|***     }
; Line 1010
;|***   }
; Line 1011
					$I2747:
					$EX2686:
	*** 0017ea	5e 			pop	si
	*** 0017eb	5f 			pop	di
	*** 0017ec	c9 			leave	
	*** 0017ed	cb 			ret	

_BuildLIDtable	ENDP
;|*** 
;|*** void _far LoadHeadersFromABIOStable(void)
;|***   {
; Line 1014
	PUBLIC	_LoadHeadersFromABIOStable
_LoadHeadersFromABIOStable	PROC FAR
	*** 0017ee	c8 04 00 00 		enter	4,0
	*** 0017f2	57 			push	di
	*** 0017f3	56 			push	si
;	iIndex = -2
;	wMaxDevice = -4
;|***   int iIndex;
;|***   WORD wMaxDevice;
;|*** 
;|***   if (_wMaxDeviceCount == 0)
; Line 1018
	*** 0017f4	8e 06 18 00 		mov	es,WORD PTR $T20013
	*** 0017f8	26 83 3e 00 00 00 	cmp	WORD PTR es:__wMaxDeviceCount,0
	*** 0017fe	74 03 			je	$JCC6142
	*** 001800	e9 08 00 		jmp	$I2767
					$JCC6142:
;|***     wMaxDevice = 8;
; Line 1019
	*** 001803	c7 46 fc 08 00 		mov	WORD PTR [bp-4],8	;wMaxDevice
;|***   else
; Line 1020
	*** 001808	e9 0b 00 		jmp	$I2768
					$I2767:
;|***     wMaxDevice = _wMaxDeviceCount;
; Line 1021
	*** 00180b	8e 06 18 00 		mov	es,WORD PTR $T20013
	*** 00180f	26 a1 00 00 		mov	ax,WORD PTR es:__wMaxDeviceCount
	*** 001813	89 46 fc 		mov	WORD PTR [bp-4],ax	;wMaxDevice
					$I2768:
;|***   pDeviceParms = (DEVDEF _far *)_stDeviceParms;
; Line 1022
	*** 001816	c7 06 aa 0f 00 00 	mov	WORD PTR _pDeviceParms,OFFSET __stDeviceParms
	*** 00181c	c7 06 ac 0f 00 00 	mov	WORD PTR _pDeviceParms+2,SEG __stDeviceParms
;|***   wDeviceStrategy = (WORD)&_pDeviceStrategy;
; Line 1023
	*** 001822	c7 06 b6 0f 00 00 	mov	WORD PTR _wDeviceStrategy,OFFSET __pDeviceStrategy
;|***   pStart = &pDeviceParms->stDeviceHeader;
; Line 1024
	*** 001828	a1 aa 0f 		mov	ax,WORD PTR _pDeviceParms
	*** 00182b	8b 16 ac 0f 		mov	dx,WORD PTR _pDeviceParms+2
	*** 00182f	05 bc 00 		add	ax,188
	*** 001832	a3 ae 0f 		mov	WORD PTR _pStart,ax
	*** 001835	89 16 b0 0f 		mov	WORD PTR _pStart+2,dx
;|***   pPrevious = &_stDummyHeader;
; Line 1025
	*** 001839	c7 06 b2 0f 00 00 	mov	WORD PTR _pPrevious,OFFSET __stDummyHeader
	*** 00183f	c7 06 b4 0f 00 00 	mov	WORD PTR _pPrevious+2,SEG __stDummyHeader
;|***   for (iIndex = 0;iIndex < iLIDcount;iIndex++)
; Line 1026
	*** 001845	c7 46 fe 00 00 		mov	WORD PTR [bp-2],0	;iIndex
	*** 00184a	e9 03 00 		jmp	$F2769
					$FC2770:
	*** 00184d	ff 46 fe 		inc	WORD PTR [bp-2]	;iIndex
					$F2769:
	*** 001850	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;iIndex
	*** 001853	39 06 14 10 		cmp	WORD PTR _iLIDcount,ax
	*** 001857	7f 03 			jg	$JCC6231
	*** 001859	e9 5d 01 		jmp	$FB2771
					$JCC6231:
;|***     {
; Line 1027
;|***     if (LIDtable[iIndex].fFlags & LID_DOES_NOT_EXIST)
; Line 1028
	*** 00185c	8e 06 44 00 		mov	es,WORD PTR $T20036
	*** 001860	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;iIndex
	*** 001863	c1 e3 04 		shl	bx,4
	*** 001866	26 f6 87 0c 00 02 	test	BYTE PTR es:_LIDtable[bx+12],2
	*** 00186c	75 03 			jne	$JCC6252
	*** 00186e	e9 03 00 		jmp	$I2772
					$JCC6252:
;|***       break;
; Line 1029
	*** 001871	e9 45 01 		jmp	$FB2771
;|***     if ((LIDtable[iIndex].fFlags & LID_ALREADY_OWNED) == 0)
; Line 1030
					$I2772:
	*** 001874	8e 06 44 00 		mov	es,WORD PTR $T20036
	*** 001878	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;iIndex
	*** 00187b	c1 e3 04 		shl	bx,4
	*** 00187e	26 f6 87 0c 00 01 	test	BYTE PTR es:_LIDtable[bx+12],1
	*** 001884	74 03 			je	$JCC6276
	*** 001886	e9 2d 01 		jmp	$I2773
					$JCC6276:
;|***       {
; Line 1031
;|***       sprintf(_szName,0,"COM%u    ",(iIndex + 1));
; Line 1032
	*** 001889	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;iIndex
	*** 00188c	40 			inc	ax
	*** 00188d	50 			push	ax
	*** 00188e	1e 			push	ds
	*** 00188f	68 16 10 		push	OFFSET DGROUP:$SG2774
	*** 001892	6a 00 			push	0
	*** 001894	68 00 00 		push	SEG __szName
	*** 001897	68 00 00 		push	OFFSET __szName
	*** 00189a	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 00189f	83 c4 0c 		add	sp,12
;|***       MemCopy(pDeviceParms->stDeviceHeader.abyDeviceName,_szName,8);
; Line 1033
	*** 0018a2	6a 08 			push	8
	*** 0018a4	68 00 00 		push	SEG __szName
	*** 0018a7	68 00 00 		push	OFFSET __szName
	*** 0018aa	a1 aa 0f 		mov	ax,WORD PTR _pDeviceParms
	*** 0018ad	8b 16 ac 0f 		mov	dx,WORD PTR _pDeviceParms+2
	*** 0018b1	05 c6 00 		add	ax,198
	*** 0018b4	52 			push	dx
	*** 0018b5	50 			push	ax
	*** 0018b6	9a 00 00 00 00 		call	FAR PTR _MemCopy
	*** 0018bb	83 c4 0a 		add	sp,10
;|***       if (!LIDtable[iIndex].bNameTaken)
; Line 1034
	*** 0018be	8e 06 44 00 		mov	es,WORD PTR $T20036
	*** 0018c2	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;iIndex
	*** 0018c5	c1 e3 04 		shl	bx,4
	*** 0018c8	26 83 bf 0a 00 00 	cmp	WORD PTR es:_LIDtable[bx+10],0
	*** 0018ce	74 03 			je	$JCC6350
	*** 0018d0	e9 e3 00 		jmp	$I2775
					$JCC6350:
;|***         {
; Line 1035
;|***         abyCOMnumbers[wLoadCount] = (BYTE)(iIndex + 1);
; Line 1036
	*** 0018d3	8a 46 fe 		mov	al,BYTE PTR [bp-2]	;iIndex
	*** 0018d6	fe c0 			inc	al
	*** 0018d8	8e 06 06 00 		mov	es,WORD PTR $T20003
	*** 0018dc	26 8b 1e 00 00 		mov	bx,WORD PTR es:_wLoadCount
	*** 0018e1	8e 06 38 00 		mov	es,WORD PTR $T20029
	*** 0018e5	26 88 87 00 00 		mov	BYTE PTR es:_abyCOMnumbers[bx],al
;|***         stConfigParms[wLoadCount].wIObaseAddress = LIDtable[iIndex].wBaseAddress;
; Line 1037
	*** 0018ea	8e 06 44 00 		mov	es,WORD PTR $T20036
	*** 0018ee	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;iIndex
	*** 0018f1	c1 e3 04 		shl	bx,4
	*** 0018f4	26 8b 87 06 00 		mov	ax,WORD PTR es:_LIDtable[bx+6]
	*** 0018f9	8e 06 06 00 		mov	es,WORD PTR $T20003
	*** 0018fd	26 6b 1e 00 00 2a 	imul	bx,WORD PTR es:_wLoadCount,42
	*** 001903	8e 06 46 00 		mov	es,WORD PTR $T20037
	*** 001907	26 89 87 06 00 		mov	WORD PTR es:_stConfigParms[bx+6],ax
;|***         stConfigParms[wLoadCount].byInterruptLevel = LIDtable[iIndex].byInterruptLevel;
; Line 1038
	*** 00190c	8e 06 44 00 		mov	es,WORD PTR $T20036
	*** 001910	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;iIndex
	*** 001913	c1 e3 04 		shl	bx,4
	*** 001916	26 8a 87 0d 00 		mov	al,BYTE PTR es:_LIDtable[bx+13]
	*** 00191b	8e 06 06 00 		mov	es,WORD PTR $T20003
	*** 00191f	26 6b 1e 00 00 2a 	imul	bx,WORD PTR es:_wLoadCount,42
	*** 001925	8e 06 46 00 		mov	es,WORD PTR $T20037
	*** 001929	26 88 87 20 00 		mov	BYTE PTR es:_stConfigParms[bx+32],al
;|***         astInstallParms[wLoadCount].wLID = LIDtable[iIndex].wDeviceNumber;
; Line 1039
	*** 00192e	8e 06 44 00 		mov	es,WORD PTR $T20036
	*** 001932	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;iIndex
	*** 001935	c1 e3 04 		shl	bx,4
	*** 001938	26 8b 87 08 00 		mov	ax,WORD PTR es:_LIDtable[bx+8]
	*** 00193d	8e 06 06 00 		mov	es,WORD PTR $T20003
	*** 001941	26 8b 1e 00 00 		mov	bx,WORD PTR es:_wLoadCount
	*** 001946	d1 e3 			shl	bx,1
_TEXT      ENDS
CONST      SEGMENT
$T20040	DW SEG _astInstallParms 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 001948	8e 06 4c 00 		mov	es,WORD PTR $T20040
	*** 00194c	26 89 87 00 00 		mov	WORD PTR es:_astInstallParms[bx],ax
;|***         pDeviceParms->stDeviceHeader.StrategyOffset = wDeviceStrategy;
; Line 1040
	*** 001951	a1 b6 0f 		mov	ax,WORD PTR _wDeviceStrategy
	*** 001954	c4 1e aa 0f 		les	bx,DWORD PTR _pDeviceParms
	*** 001958	26 89 87 c2 00 		mov	WORD PTR es:[bx+194],ax
;|***         pPrevious->pNextHeader = &pDeviceParms->stDeviceHeader;
; Line 1041
	*** 00195d	a1 aa 0f 		mov	ax,WORD PTR _pDeviceParms
	*** 001960	8b 16 ac 0f 		mov	dx,WORD PTR _pDeviceParms+2
	*** 001964	05 bc 00 		add	ax,188
	*** 001967	c4 1e b2 0f 		les	bx,DWORD PTR _pPrevious
	*** 00196b	26 89 07 		mov	WORD PTR es:[bx],ax
	*** 00196e	26 89 57 02 		mov	WORD PTR es:[bx+2],dx
;|***         pPrevious = &pDeviceParms->stDeviceHeader;
; Line 1042
	*** 001972	a1 aa 0f 		mov	ax,WORD PTR _pDeviceParms
	*** 001975	8b 16 ac 0f 		mov	dx,WORD PTR _pDeviceParms+2
	*** 001979	05 bc 00 		add	ax,188
	*** 00197c	a3 b2 0f 		mov	WORD PTR _pPrevious,ax
	*** 00197f	89 16 b4 0f 		mov	WORD PTR _pPrevious+2,dx
;|***         pPrevious->pNextHeader = (VOID *)-1;
; Line 1043
	*** 001983	c4 1e b2 0f 		les	bx,DWORD PTR _pPrevious
	*** 001987	26 c7 07 ff ff 		mov	WORD PTR es:[bx],-1
	*** 00198c	26 c7 47 02 ff ff 	mov	WORD PTR es:[bx+2],-1
;|***         pDeviceParms++;
; Line 1044
	*** 001992	81 06 aa 0f f0 00 	add	WORD PTR _pDeviceParms,240
;|***         wDeviceStrategy += 6;
; Line 1045
	*** 001998	83 06 b6 0f 06 		add	WORD PTR _wDeviceStrategy,6
;|***         if (++wLoadCount >= wMaxDevice)
; Line 1046
	*** 00199d	8b 46 fc 		mov	ax,WORD PTR [bp-4]	;wMaxDevice
	*** 0019a0	8e 06 06 00 		mov	es,WORD PTR $T20003
	*** 0019a4	26 ff 06 00 00 		inc	WORD PTR es:_wLoadCount
	*** 0019a9	26 39 06 00 00 		cmp	WORD PTR es:_wLoadCount,ax
	*** 0019ae	73 03 			jae	$JCC6574
	*** 0019b0	e9 03 00 		jmp	$I2776
					$JCC6574:
;|***           break;
; Line 1047
	*** 0019b3	e9 03 00 		jmp	$FB2771
;|***         }
; Line 1048
					$I2776:
;|***       }
; Line 1049
					$I2775:
;|***     }
; Line 1050
					$I2773:
	*** 0019b6	e9 94 fe 		jmp	$FC2770
					$FB2771:
;|***   if (wLoadCount > 0)
; Line 1051
	*** 0019b9	8e 06 06 00 		mov	es,WORD PTR $T20003
	*** 0019bd	26 83 3e 00 00 00 	cmp	WORD PTR es:_wLoadCount,0
	*** 0019c3	77 03 			ja	$JCC6595
	*** 0019c5	e9 1a 00 		jmp	$I2777
					$JCC6595:
;|***     {
; Line 1052
;|***     pDeviceParms--;
; Line 1053
	*** 0019c8	81 2e aa 0f f0 00 	sub	WORD PTR _pDeviceParms,240
;|*** //    pDeviceParms->stDeviceHeader.sCodeSegment = 0xffff;
;|***     _stDummyHeader.pNextHeader = pStart;
; Line 1055
	*** 0019ce	a1 ae 0f 		mov	ax,WORD PTR _pStart
	*** 0019d1	8b 16 b0 0f 		mov	dx,WORD PTR _pStart+2
	*** 0019d5	8e 06 40 00 		mov	es,WORD PTR $T20034
	*** 0019d9	26 a3 00 00 		mov	WORD PTR es:__stDummyHeader,ax
	*** 0019dd	26 89 16 02 00 		mov	WORD PTR es:__stDummyHeader+2,dx
;|***     }
; Line 1056
;|*** //  else
;|*** //    _stDummyHeader.sCodeSegment = -1;
;|***   _wEndOfData = ((WORD)_stDeviceParms + (wLoadCount * sizeof(DEVDEF)));
; Line 1059
					$I2777:
	*** 0019e2	8e 06 06 00 		mov	es,WORD PTR $T20003
	*** 0019e6	26 69 06 00 00 f0 00 	imul	ax,WORD PTR es:_wLoadCount,240
	*** 0019ed	05 00 00 		add	ax,OFFSET __stDeviceParms
	*** 0019f0	8e 06 3a 00 		mov	es,WORD PTR $T20030
	*** 0019f4	26 a3 00 00 		mov	WORD PTR es:__wEndOfData,ax
;|***   }
; Line 1060
					$EX2764:
	*** 0019f8	5e 			pop	si
	*** 0019f9	5f 			pop	di
	*** 0019fa	c9 			leave	
	*** 0019fb	cb 			ret	

_LoadHeadersFromABIOStable	ENDP
_TEXT	ENDS
END
;|*** 
;|*** #ifdef this_junk
;|*** WORD CopyDeviceBlocks(WORD *pwBlockLen)
;|***   {
;|***   int iIndex;
;|***   int iFirstIndex;
;|***   WORD wBlockLen = 0;
;|***   WORD wStartOffset;
;|***   WORD wOffset = 0;
;|***   WORD wFirstLID;
;|***   WORD wError;
;|***   WORD wLIDcount = 0;
;|***   WORD wTableSize = 0;
;|***   WORD wByteIndex;
;|***   int iLastIndex;
;|*** 
;|***   for (iIndex = 0;iIndex < wMaxDevice;iIndex++)
;|***     {
;|***     wLIDcount++;
;|***     wLID = iIndex + 1;
;|***     if ((wError = GetLIDentry(&wLID)) == NO_ERROR)
;|***       {
;|***       wBlockLen = GetDeviceBlockLen(wLID);
;|***       wStartOffset = GetDeviceBlockOffset(wLID);
;|***       break;
;|***       }
;|***     else
;|***       if (wError == ERROR_LID_DOES_NOT_EXIST)
;|***         {
;|***         wLIDcount--;
;|***         break;
;|***         }
;|***     }
;|***   if (wStartOffset != 0)
;|***     {
;|***     wFirstLID = wLID;
;|***     iFirstIndex = iIndex++;
;|***     for (;iIndex < 8;iIndex++)
;|***       {
;|***       wLID = iIndex + 1;
;|***       wLIDcount++;
;|***       if ((wError = GetLIDentry(&wLID)) == NO_ERROR)
;|***         {
;|***         wOffset = GetDeviceBlockOffset(wLID);
;|***         FreeLIDentry(wLID);
;|***         break;
;|***         }
;|***       else
;|***         if (wError == ERROR_LID_DOES_NOT_EXIST)
;|***           {
;|***           wLIDcount--;
;|***           break;
;|***           }
;|***       }
;|***     if (wOffset != 0)
;|***       {
;|***       wBlockLen = ((wOffset - wStartOffset) / (iIndex - iFirstIndex));
;|***       wOffset = (wStartOffset - (iFirstIndex * wBlockLen));
;|***       GetKernalData(wFirstLID,wOffset,abyFileBuffer,(wBlockLen * 8));
;|***       FreeLIDentry(wFirstLID);
;|***       }
;|***     else
;|***       {
;|***       iLastIndex = iIndex;
;|***       wTableSize = GetKernalData(wFirstLID,0,abyFileBuffer,0xffff);
;|***       if (wFirstIndex == 0)
;|***         {
;|***         if (wLIDcount == 1)
;|***           wBlockLen = GetDeviceBlockLen(wFirstLID);
;|***         else
;|***           {
;|***           wCurrentAddress = GetDeviceAddress(wFirstLID);
;|***           for (iIndex = 0;iIndex < 8;iIndex++)
;|***             if (wCurrentAddress == astMCAportTable[iIndex]
;|***               {
;|***               iIndex++;
;|***               break;
;|***               }
;|***           if ((wBlockSize * 9) < wTableSize)
;|***             wTableSize = (wBlockSize * 9);
;|***           for (;iIndex < 8;iIndex++)
;|***             {
;|***             wSearchAddress = astMCAportTable[iIndex]
;|***             for (wByteIndex = wStartOffset;wByteIndex < wTableSize;wByteIndex++)
;|***               {
;|***               if ((abyFileBuffer[wByteIndex] == wSearchAddress) &&
;|***                   (abyFileBuffer[wByteIndex - 0x000c] == wBlockLen) &&
;|***                   (abyFileBuffer[wByteIndex - 0x0008] == ASYNC_DEVICE_ID))
;|***                 {
;|***                 wBlockLen = (wByteIndex - 0x000c - wStartOffset);
;|***                 GetKernalData(wFirstLID,wStartOffset,abyFileBuffer,(wBlockLen * 8));
;|***                 FreeLIDentry(wFirstLID);
;|***                 break;
;|***                 }
;|***               }
;|***             }
;|***           }
;|***         }
;|***       else
;|***         {
;|***         }
;|***       }
;|***     }
;|***   *pwBlockLen = wBlockLen;
;|***   return(wLIDcount);
;|***   }
;|*** #endif
;|*** #endif /* RTEST */
;|*** #endif /* x16_BIT */
