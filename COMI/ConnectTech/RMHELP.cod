;	Static Name Aliases
;
	TITLE   RMHELP.c
	.286p
	.287
INCLUDELIB	LLIBCE
_TEXT	SEGMENT  WORD PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT  WORD PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT  WORD PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT  WORD PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT  BYTE PUBLIC 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT  BYTE PUBLIC 'DEBTYP'
$$TYPES	ENDS
RMCode	SEGMENT  WORD PUBLIC 'CODE'
RMCode	ENDS
DGROUP	GROUP	CONST, _BSS, _DATA
	ASSUME DS: DGROUP
	ASSUME  SS: NOTHING
PUBLIC  _hDriver
PUBLIC  _hAdapter
PUBLIC  _hResPorts
PUBLIC  _hResIRQs
PUBLIC  _szAdapterDescription
PUBLIC  _pszUART
PUBLIC  _sz16650UART
PUBLIC  _sz16750UART
PUBLIC  _sz16654UART
PUBLIC  _sz16550UART
PUBLIC  _sz16950UART
PUBLIC  _szUART
PUBLIC  _DriverStruct
PUBLIC  _AdapterStruct
PUBLIC  _LComName
PUBLIC  _aszFSComName
PUBLIC  _szErrMsg
PUBLIC  _usIDregIndex
PUBLIC  _RM_Help
PUBLIC  _RMFlags
PUBLIC  _Device_Help
PUBLIC  _RM_Help0
PUBLIC  _RM_Help3
PUBLIC  _cSerialNodes
EXTRN	_RMCreateAdapter:FAR
EXTRN	_RMDestroyAdapter:FAR
EXTRN	_sprintf:FAR
EXTRN	_RMAllocResource:FAR
EXTRN	_memset:FAR
EXTRN	_RMDeallocResource:FAR
EXTRN	_RMGetNodeInfo:FAR
EXTRN	_RMCreateLDev:FAR
EXTRN	_RMDestroyLDev:FAR
EXTRN	_DevHelp_GetDOSVar:FAR
EXTRN	_RMCreateSysName:FAR
EXTRN	_RMDestroySysName:FAR
EXTRN	VIO16WRTTTY:FAR
EXTRN	_RMDevIDToHandleList:FAR
EXTRN	_RMKeyToHandleList:FAR
EXTRN	_RMCreateDriver:FAR
EXTRN	_RMDestroyDriver:FAR
EXTRN	_RMConvertID:FAR
EXTRN	__wIntIDregister:WORD
EXTRN	__wBusType:WORD
EXTRN	__stDeviceParms:BYTE
EXTRN	_stRMparms:BYTE
EXTRN	_wLoadCount:WORD
EXTRN	_wLoadNumber:WORD
EXTRN	_bPnPcapable:WORD
_DATA      SEGMENT
$SG1842	DB	'COMDD.SYS',  00H
$SG1843	DB	'COMi Asynchronous Communications Driver',  00H
$SG1844	DB	'OS/tools Inc.',  00H
	ORG	$+670
$SG1880	DB	'SERIAL*',  00H
$SG1899	DB	'SERIAL_# %s Serial Controller',  00H
$SG1901	DB	'SERIAL_#  %s Serial Controller',  00H
$SG1910	DB	'Serial Controller interrupt status register',  00H
$SG1956	DB	1bH, '[1m',  07H, '%s was not installed, RM I/O address rang'
	DB	'e 0x%X-0x%X is not available.',  1bH, '[0m',  0dH,  0aH,  00H
$SG1959	DB	1bH, '[1m',  07H, '%s was not installed, RM interrupt level '
	DB	'%u is not available.',  1bH, '[0m',  0dH,  0aH,  00H
$SG1965	DB	'Load Number %u',  0dH,  0aH,  1bH, '[1m',  07H, 'RM I/O addr'
	DB	'ess 0x%04X is not available for interrupt status port. This '
	DB	'load',  0dH,  0aH, 'will NOT be initialized (0x04x)',  1bH, '['
	DB	'0m',  0dH,  0aH,  00H
$SG2027	DB	'PCMCIA*',  00H
$SG2104	DB	'PNP0500',  00H
	ORG	$-1090
_szAdapterDescription	DB	'SERIAL_# Serial Adapter',  00H
 	DB	56 DUP(0)

_pszUART	DD	00H
_sz16650UART	DB	'16650',  00H
_sz16750UART	DB	'16750',  00H
_sz16654UART	DB	'16654',  00H
_sz16550UART	DB	'16550',  00H
_sz16950UART	DB	'16950',  00H
_szUART	DB	'16450',  00H
_DriverStruct	DD	DGROUP:$SG1842
	DD	DGROUP:$SG1843
	DD	DGROUP:$SG1844
	DB	01H
	DB	01H
	DW	07ccH
	DB	04H
	DB	01H
	DW	00H
	DW	03H
	DW	01H
	DD	00H
_AdapterStruct	DD	DGROUP:_szAdapterDescription
	DW	00H
	DW	07H
	DW	01H
	DW	02H
	DW	00H
	DW	020H
	DD	00H
 	DB	4 DUP(0)

_LComName	DB	'COMM_#      ',  00H
	ORG	$+1
_aszFSComName	DB	'COM0',  00H
 	DB	5 DUP(0)

	DB	'COM1',  00H
 	DB	5 DUP(0)

 	DB	140 DUP(0)

_szErrMsg	DB	'Just init',  00H
 	DB	90 DUP(0)

_usIDregIndex	DW	0ffffH
_RM_Help	DD	00H
_RMFlags	DD	00H
_Device_Help	DD	00H
_RM_Help0	DD	00H
_RM_Help3	DD	00H
_cSerialNodes	DW	00H
_hDriver	DD	00H
_hAdapter	DD	00H
	DD	00H
 	DB	60 DUP(0)

_hResPorts	DD	00H
	DD	00H
 	DB	60 DUP(0)

_hResIRQs	DD	00H
	DD	00H
 	DB	52 DUP(0)

_DATA      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
;|*** /*DDK*************************************************************************/
; Line 1
;|*** /*                                                                           */
;|*** /* COPYRIGHT    Copyright (C) 1995 IBM Corporation                           */
;|*** /*                                                                           */
;|*** /*    The following IBM OS/2 WARP source code is provided to you solely for  */
;|*** /*    the purpose of assisting you in your development of OS/2 WARP device   */
;|*** /*    drivers. You may use this code in accordance with the IBM License      */
;|*** /*    Agreement provided in the IBM Device Driver Source Kit for OS/2. This  */
;|*** /*    Copyright statement may not be removed.                                */
;|*** /*                                                                           */
;|*** /*****************************************************************************/
;|*** /**************************************************************************
;|***  *
;|***  * SOURCE FILE NAME =  RMHELP.C
;|***  *
;|***  * DESCRIPTIVE NAME =  Helpers for COMDD.SYS
;|***  *
;|***  *
;|***  *
;|***  * VERSION = V0.1
;|***  *
;|***  * DATE  09/07/94
;|***  *
;|***  * DESCRIPTION : (see above)
;|***  *
;|***  * Purpose: (see above)
;|***  *
;|***  *
;|***  *
;|***  * FUNCTIONS  :
;|***  *
;|***  * NOTES
;|***  *
;|***  *
;|***  * STRUCTURES
;|***  *
;|***  * EXTERNAL REFERENCES
;|***  *
;|***  *
;|***  *
;|***  * EXTERNAL FUNCTIONS
;|***  *
;|*** */
;|*** #define INCL_VIO
;|*** #define INCL_NOXLATE_DOS16
;|*** #define INCL_NOPMAPI
;|*** #define INCL_DOS
;|*** #define INCL_NOPM
;|*** #include <os2.h>
; Line 49
;|*** /*DDK*************************************************************************/
;|*** /*                                                                           */
;|*** /* COPYRIGHT (C) Microsoft Corporation, 1989                                 */
;|*** /* COPYRIGHT    Copyright (C) 1995 IBM Corporation                           */
;|*** /*                                                                           */
;|*** /*    The following IBM OS/2 WARP source code is provided to you solely for  */
;|*** /*    the purpose of assisting you in your development of OS/2 WARP device   */
;|*** /*    drivers. You may use this code in accordance with the IBM License      */
;|*** /*    Agreement provided in the IBM Device Driver Source Kit for OS/2. This  */
;|*** /*    Copyright statement may not be removed.                                */
;|*** /*                                                                           */
;|*** /*****************************************************************************/
;|*** /*static char *SCCSID = "@(#)os2.h	6.3 91/05/26";*/
;|*** /****************************** Module Header ******************************\
;|*** *
;|*** *
;|*** * Module Name: OS2.H
;|*** *
;|*** * This is the top level include file that includes all the files necessary
;|*** * for writing an OS/2 application.
;|*** *
;|*** \***************************************************************************/
;|*** 
;|*** #define OS2_INCLUDED
;|*** 
;|*** #if !(defined(INCL_32) || defined(INCL_16))
;|*** #ifdef M_I386
;|***     #define INCL_32
;|*** #else /* not M_I386 */
;|***     #define INCL_16
;|*** #endif /* M_I386 */
;|*** #endif /* INCL_32 || INCL_16 */
;|*** 
;|*** /* XLATOFF */
;|*** #if (defined(INCL_32) && defined(INCL_16))
;|*** #error message ("Illegal combination of API Flags - 32 && 16")
;|*** #endif /* INCL_32 && INCL_16 */
;|*** /* XLATON */
;|*** 
;|*** /* Common definitions */
;|*** 
;|*** #include <os2def.h>
; Line 42
;|*** /*DDK*************************************************************************/
;|*** /*                                                                           */
;|*** /* COPYRIGHT    Copyright (C) 1995 IBM Corporation                           */
;|*** /*                                                                           */
;|*** /*    The following IBM OS/2 WARP source code is provided to you solely for  */
;|*** /*    the purpose of assisting you in your development of OS/2 WARP device   */
;|*** /*    drivers. You may use this code in accordance with the IBM License      */
;|*** /*    Agreement provided in the IBM Device Driver Source Kit for OS/2. This  */
;|*** /*    Copyright statement may not be removed.                                */
;|*** /*                                                                           */
;|*** /*****************************************************************************/
;|*** /****************************** Module Header ******************************\
;|*** *
;|*** * Module Name: OS2DEF.H
;|*** *
;|*** * OS/2 Common Definitions file
;|*** *
;|*** *
;|*** * ===========================================================================
;|*** *
;|*** * Comments at the end of each typedef line give the name tags used in
;|*** * the assembler include version of this file.
;|*** *
;|*** * The assembler include version of this file excludes lines between NOINC
;|*** * and INC comments.
;|*** *
;|*** #ifndef __IBMC__
;|***    * The public version of this file (as shipped with the OS/2 Toolkit
;|***    * product) excludes all non 32-bit material marked in this file
;|***    * as well as any areas specifically marked with __IBMC__ conditional
;|***    * sections - including this paragraph. The H2IBMH rexx command file
;|***    * removes these sections.
;|*** #endif
;|*** \***************************************************************************/
;|*** 
;|*** #ifdef __IBMC__
;|***    #pragma checkout( suspend )
;|***       #ifndef __CHKHDR__
;|***          #pragma checkout( suspend )
;|***       #endif
;|***    #pragma checkout( resume )
;|*** #endif
;|*** 
;|*** #define OS2DEF_INCLUDED
;|*** 
;|*** #ifndef INCL_32         /* If neither INCL_32 or INCL_16 set already */
;|***    #ifndef INCL_16      /* find out from compiler if 32-bit or not.  */
;|***      #ifdef M_I386
;|***         #define INCL_32 /* Compiling for 32-bit */
;|***      #else
;|***         #define INCL_16 /* Compiling for 16-bit */
;|***      #endif
;|***   #endif
;|*** #endif
;|*** 
;|*** #ifdef INCL_32
;|***    #ifndef __IBMC__
;|***    /*****************************************************************/
;|***    /* This #ifdef brackets the rest of this entire file.  It is     */
;|***    /* used to include either the 32-bit or 16-bit base definitions. */
;|***    /* No definitions (other than 16/32-bit determination) must be   */
;|***    /* placed above this.                                            */
;|***    /*****************************************************************/
;|***    #endif
;|*** 
;|***    /* NOINC */
;|***    #ifdef INCL_16
;|***       #error message ("Using 32 bit definitions when compiling 16 bit code")
;|***    #endif /* INCL_16 */
;|***    #ifdef __IBMC__
;|***       #define FAR         /* this will be deleted shortly */
;|***       #define NEAR        /* this will be deleted shortly */
;|*** 
;|***       #define APIENTRY    _System
;|***       #define EXPENTRY    _System
;|*** 
;|***       #define APIENTRY16  _Far16 _Pascal
;|***       #define PASCAL16    _Far16 _Pascal
;|***       #define CDECL16     _Far16 _Cdecl
;|***    #else
;|***       #define FAR         /* nothing */
;|***       #define NEAR        /* nothing */
;|*** 
;|***       #define APIENTRY    _syscall
;|***       #define EXPENTRY    _syscall
;|*** 
;|***       #define PASCAL      /* nothing */
;|***    #endif
;|*** 
;|***    #define VOID        void
;|***    /* INC */
;|*** 
;|***    typedef unsigned long  APIRET;
;|***    typedef unsigned short APIRET16;
;|***    typedef unsigned long  APIRET32;
;|*** 
;|***    #ifndef FALSE
;|***       #define FALSE   0
;|***    #endif
;|*** 
;|***    #ifndef TRUE
;|***       #define TRUE    1
;|***    #endif
;|*** 
;|***    #ifndef NULL
;|***       #ifdef __IBMC__
;|***          #define NULL ((void *)0)
;|***       #else
;|***          #define NULL 0
;|***       #endif
;|***    #endif
;|*** 
;|***    #ifdef __IBMC__
;|***       typedef unsigned short   SHANDLE;
;|***    #else
;|***       /* TEMP      - David Kerr, this will change to short when the    */
;|***       /*             rest of the BSExxx.H files are changed to LHANDLE */
;|***       typedef unsigned long   SHANDLE;
;|***    #endif
;|***    typedef unsigned long    LHANDLE;
;|*** 
;|***    #define NULLHANDLE    ( (LHANDLE) 0)
;|***    #define NULLSHANDLE   ( (SHANDLE) 0)
;|*** 
;|***    /* NOINC */
;|***    #define CHAR    char            /* ch  */
;|***    #define SHORT   short           /* s   */
;|***    #define LONG    long            /* l   */
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #define INT  int             /* i   */
;|***    #endif /* !INCL_SAADEFS */
;|***    /* INC */
;|*** 
;|***    typedef unsigned char  UCHAR;   /* uch */
;|***    typedef unsigned short USHORT;  /* us  */
;|***    typedef unsigned long  ULONG;   /* ul  */
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       typedef unsigned int UINT;   /* ui  */
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    #ifdef __IBMC__
;|***       typedef UCHAR     * _Seg16 PUCHAR16;
;|***       typedef CHAR      * _Seg16 PCHAR16;
;|***    #endif
;|*** 
;|***    typedef unsigned char BYTE;     /* b   */
;|*** 
;|***    typedef unsigned char FAR  *PSZ;
;|***    typedef unsigned char NEAR *NPSZ;
;|*** 
;|***    typedef unsigned char FAR  *PCH;
;|***    typedef unsigned char NEAR *NPCH;
;|*** 
;|***    #ifdef __IBMC__
;|***       typedef int (* APIENTRY PFN)  ();
;|***       typedef int (* APIENTRY NPFN) ();
;|***    #else
;|***       typedef int   (PASCAL FAR  *PFN)();
;|***       typedef int   (PASCAL NEAR *NPFN)();
;|***    #endif
;|*** 
;|***    typedef BYTE   FAR  *PBYTE;
;|***    typedef BYTE   NEAR *NPBYTE;
;|*** 
;|***    typedef CHAR   FAR *PCHAR;
;|***    typedef SHORT  FAR *PSHORT;
;|***    typedef LONG   FAR *PLONG;
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       typedef INT    FAR *PINT;
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    typedef UCHAR  FAR *PUCHAR;
;|***    typedef USHORT FAR *PUSHORT;
;|***    typedef ULONG  FAR *PULONG;
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       typedef UINT FAR *PUINT;
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    typedef VOID   FAR *PVOID;
;|***    typedef PVOID  FAR *PPVOID;
;|*** 
;|***    typedef unsigned long BOOL;     /* f   */
;|***    typedef BOOL FAR *PBOOL;
;|*** 
;|***    typedef unsigned short  BOOL16;
;|***    #ifdef __IBMC__
;|***       typedef BOOL16     * _Seg16 PBOOL16;
;|***    #else
;|***       typedef BOOL16 FAR *PBOOL16;
;|***    #endif
;|*** 
;|***    /* NOINC */
;|***    #define BOOL32    BOOL
;|***    #define PBOOL32   PBOOL
;|***    /* INC */
;|*** 
;|***    /* NOINC */
;|***    /* Quad-word */
;|***    typedef struct _QWORD {        /* qword */
;|***       ULONG   ulLo;
;|***       ULONG   ulHi;
;|***    } QWORD;
;|***    typedef QWORD FAR *PQWORD;
;|***    /* INC */
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       typedef unsigned short SEL;     /* sel */
;|***       typedef SEL FAR *PSEL;
;|*** 
;|***       /*** Useful Helper Macros */
;|*** 
;|***       /* Create untyped far pointer from selector and offset */
;|***       #ifdef __IBMC__
;|***          #define MAKEP(sel,off) ((void * _Seg16)((((sel)&0xfff8)<<13)|(off)))
;|***       #else
;|***          #define MAKEP(sel, off)     ((PVOID)MAKEULONG(off, sel))
;|***       #endif
;|*** 
;|***       /* Extract selector or offset from far pointer */
;|***       #ifdef __IBMC__
;|***          #define SELECTOROF(ptr)     ((((ULONG)(ptr))>>13)|7)
;|***       #else
;|***          #define SELECTOROF(p)       (((PUSHORT)&(p))[1])
;|***       #endif
;|***       #define OFFSETOF(p)         (((PUSHORT)&(p))[0])
;|***    #endif  /* !INCL_SAADEFS */
;|*** 
;|***    /* Cast any variable to an instance of the specified type. */
;|***    #define MAKETYPE(v, type)   (*((type FAR *)&v))
;|*** 
;|***    /* Calculate the byte offset of a field in a structure of type type. */
;|***    #define FIELDOFFSET(type, field)    ((SHORT)&(((type *)0)->field))
;|*** 
;|***    /* Combine l & h to form a 32 bit quantity. */
;|***    #define MAKEULONG(l, h)  ((ULONG)(((USHORT)(l)) | ((ULONG)((USHORT)(h))) << 16))
;|***    #define MAKELONG(l, h)   ((LONG)MAKEULONG(l, h))
;|*** 
;|***    /* Combine l & h to form a 16 bit quantity. */
;|***    #define MAKEUSHORT(l, h) (((USHORT)(l)) | ((USHORT)(h)) << 8)
;|***    #define MAKESHORT(l, h)  ((SHORT)MAKEUSHORT(l, h))
;|*** 
;|***    /* Extract high and low order parts of 16 and 32 bit quantity */
;|***    #define LOBYTE(w)       LOUCHAR(w)
;|***    #define HIBYTE(w)       HIUCHAR(w)
;|***    #define LOUCHAR(w)      ((UCHAR)(w))
;|***    #define HIUCHAR(w)      ((UCHAR)(((USHORT)(w) >> 8) & 0xff))
;|***    #define LOUSHORT(l)     ((USHORT)((ULONG)l))
;|***    #define HIUSHORT(l)     ((USHORT)(((ULONG)(l) >> 16) & 0xffff))
;|*** 
;|***    /*** Common Error definitions ****/
;|*** 
;|***    typedef ULONG ERRORID;  /* errid */
;|***    typedef ERRORID FAR *PERRORID;
;|*** 
;|***    /* Combine severity and error code to produce ERRORID */
;|***    #define MAKEERRORID(sev, error) (ERRORID)(MAKEULONG((error), (sev)))
;|*** 
;|***    /* Extract error number from an errorid */
;|***    #define ERRORIDERROR(errid)            (LOUSHORT(errid))
;|*** 
;|***    /* Extract severity from an errorid */
;|***    #define ERRORIDSEV(errid)              (HIUSHORT(errid))
;|*** 
;|***    /* Severity codes */
;|***    #define SEVERITY_NOERROR                    0x0000
;|***    #define SEVERITY_WARNING                    0x0004
;|***    #define SEVERITY_ERROR                      0x0008
;|***    #define SEVERITY_SEVERE                     0x000C
;|***    #define SEVERITY_UNRECOVERABLE              0x0010
;|*** 
;|***    /* Base component error values */
;|*** 
;|***    #define WINERR_BASE     0x1000  /* Window Manager                  */
;|***    #define GPIERR_BASE     0x2000  /* Graphics Presentation Interface */
;|***    #define DEVERR_BASE     0x3000  /* Device Manager                  */
;|***    #define SPLERR_BASE     0x4000  /* Spooler                         */
;|*** 
;|***    /*** Common types used across components */
;|*** 
;|***    /*** Common DOS types */
;|*** 
;|***    typedef LHANDLE HMODULE;        /* hmod */
;|***    typedef LHANDLE PID;            /* pid  */
;|***    typedef LHANDLE TID;            /* tid  */
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       typedef USHORT  SGID;        /* sgid */
;|***    #endif  /* !INCL_SAADEFS */
;|*** 
;|***    typedef HMODULE FAR *PHMODULE;
;|***    typedef PID FAR *PPID;
;|***    typedef TID FAR *PTID;
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       typedef VOID FAR *HSEM;      /* hsem */
;|***       typedef HSEM FAR *PHSEM;
;|***    #endif  /* !INCL_SAADEFS */
;|*** 
;|***    /*** Common SUP types */
;|*** 
;|***    typedef LHANDLE   HAB;         /* hab  */
;|***    typedef HAB FAR *PHAB;
;|*** 
;|***    /*** Common GPI/DEV types */
;|*** 
;|***    typedef LHANDLE   HPS;         /* hps  */
;|***    typedef HPS FAR *PHPS;
;|*** 
;|***    typedef LHANDLE   HDC;         /* hdc  */
;|***    typedef HDC FAR *PHDC;
;|*** 
;|***    typedef LHANDLE   HRGN;        /* hrgn */
;|***    typedef HRGN FAR *PHRGN;
;|*** 
;|***    typedef LHANDLE   HBITMAP;     /* hbm  */
;|***    typedef HBITMAP FAR *PHBITMAP;
;|*** 
;|***    typedef LHANDLE   HMF;         /* hmf  */
;|***    typedef HMF FAR *PHMF;
;|*** 
;|***    typedef LHANDLE   HPAL;        /* hpal */
;|***    typedef HPAL FAR *PHPAL;
;|*** 
;|***    typedef LONG     COLOR;        /* clr  */
;|***    typedef COLOR FAR *PCOLOR;
;|*** 
;|***    typedef struct _POINTL  {      /* ptl  */
;|***       LONG  x;
;|***       LONG  y;
;|***    } POINTL;
;|***    typedef POINTL  FAR  *PPOINTL;
;|***    typedef POINTL  NEAR *NPPOINTL;
;|*** 
;|***    typedef struct _POINTS {       /* pts */
;|***       SHORT x;
;|***       SHORT y;
;|***    } POINTS;
;|***    typedef POINTS FAR *PPOINTS;
;|*** 
;|***    typedef struct _RECTL {        /* rcl */
;|***       LONG  xLeft;
;|***       LONG  yBottom;
;|***       LONG  xRight;
;|***       LONG  yTop;
;|***    } RECTL;
;|***    typedef RECTL FAR  *PRECTL;
;|***    typedef RECTL NEAR *NPRECTL;
;|*** 
;|***    typedef CHAR STR8[8];          /* str8 */
;|***    typedef STR8 FAR *PSTR8;
;|*** 
;|***    /*** common DEV/SPL types */
;|*** 
;|***    /* structure for Device Driver data */
;|*** 
;|***    typedef struct _DRIVDATA {     /* driv */
;|***       LONG    cb;
;|***       LONG    lVersion;
;|***       CHAR    szDeviceName[32];
;|***       CHAR    abGeneralData[1];
;|***    } DRIVDATA;
;|***    typedef DRIVDATA FAR *PDRIVDATA;
;|*** 
;|***    /* pointer data for DevOpenDC */
;|*** 
;|***    typedef PSZ FAR *PDEVOPENDATA;
;|*** 
;|***    /* array indices for array parameter for DevOpenDC, SplQmOpen or SplQpOpen */
;|*** 
;|***    #define ADDRESS          0
;|***    #ifndef INCL_SAADEFS
;|***       #define DRIVER_NAME      1
;|***       #define DRIVER_DATA      2
;|***       #define DATA_TYPE        3
;|***       #define COMMENT          4
;|***       #define PROC_NAME        5
;|***       #define PROC_PARAMS      6
;|***       #define SPL_PARAMS       7
;|***       #define NETWORK_PARAMS   8
;|*** 
;|***       /* structure definition as an alternative of the array parameter */
;|*** 
;|***       typedef struct _DEVOPENSTRUC {    /* dop */
;|***          PSZ        pszLogAddress;
;|***          PSZ        pszDriverName;
;|***          PDRIVDATA  pdriv;
;|***          PSZ        pszDataType;
;|***          PSZ        pszComment;
;|***          PSZ        pszQueueProcName;
;|***          PSZ        pszQueueProcParams;
;|***          PSZ        pszSpoolerParams;
;|***          PSZ        pszNetworkParams;
;|***       } DEVOPENSTRUC;
;|***       typedef DEVOPENSTRUC FAR *PDEVOPENSTRUC;
;|***    #endif  /* !INCL_SAADEFS */
;|*** 
;|***    /* common PMWP object and PMSTDDLG drag data */
;|*** 
;|***    typedef struct _PRINTDEST {   /* prntdst */
;|***       ULONG        cb;
;|***       LONG         lType;
;|***       PSZ          pszToken;
;|***       LONG         lCount;
;|***       PDEVOPENDATA pdopData;
;|***       ULONG        fl;
;|***       PSZ          pszPrinter;
;|***    } PRINTDEST;
;|***    typedef PRINTDEST FAR *PPRINTDEST;
;|*** 
;|***    #define PD_JOB_PROPERTY   0x0001      /* Flags for .fl field           */
;|*** 
;|***    /*** common AVIO/GPI types */
;|*** 
;|***    /* values of fsSelection field of FATTRS structure */
;|***    #define FATTR_SEL_ITALIC        0x0001
;|***    #define FATTR_SEL_UNDERSCORE    0x0002
;|***    #define FATTR_SEL_OUTLINE       0x0008
;|***    #define FATTR_SEL_STRIKEOUT     0x0010
;|***    #define FATTR_SEL_BOLD          0x0020
;|*** 
;|***    /* values of fsType field of FATTRS structure */
;|***    #define FATTR_TYPE_KERNING      0x0004
;|***    #define FATTR_TYPE_MBCS         0x0008
;|***    #define FATTR_TYPE_DBCS         0x0010
;|***    #define FATTR_TYPE_ANTIALIASED  0x0020
;|*** 
;|***    /* values of fsFontUse field of FATTRS structure */
;|***    #define FATTR_FONTUSE_NOMIX         0x0002
;|***    #define FATTR_FONTUSE_OUTLINE       0x0004
;|***    #define FATTR_FONTUSE_TRANSFORMABLE 0x0008
;|***    /* size for fields in the font structures */
;|*** 
;|***    #define FACESIZE 32
;|*** 
;|***    /* font struct for Vio/GpiCreateLogFont */
;|*** 
;|***    typedef struct _FATTRS {          /* fat */
;|***       USHORT  usRecordLength;
;|***       USHORT  fsSelection;
;|***       LONG    lMatch;
;|***       CHAR    szFacename[FACESIZE];
;|***       USHORT  idRegistry;
;|***       USHORT  usCodePage;
;|***       LONG    lMaxBaselineExt;
;|***       LONG    lAveCharWidth;
;|***       USHORT  fsType;
;|***       USHORT  fsFontUse;
;|***    } FATTRS;
;|***    typedef FATTRS FAR *PFATTRS;
;|*** 
;|***    /* values of fsType field of FONTMETRICS structure */
;|***    #define FM_TYPE_FIXED           0x0001
;|***    #define FM_TYPE_LICENSED        0x0002
;|***    #define FM_TYPE_KERNING         0x0004
;|***    #define FM_TYPE_DBCS            0x0010
;|***    #define FM_TYPE_MBCS            0x0018
;|***    #define FM_TYPE_64K             0x8000
;|***    #define FM_TYPE_ATOMS           0x4000
;|***    #define FM_TYPE_FAMTRUNC        0x2000
;|***    #define FM_TYPE_FACETRUNC       0x1000
;|*** 
;|***    /* values of fsDefn field of FONTMETRICS structure */
;|***    #define FM_DEFN_OUTLINE         0x0001
;|***    #define FM_DEFN_IFI             0x0002
;|***    #define FM_DEFN_WIN             0x0004
;|***    #define FM_DEFN_GENERIC         0x8000
;|*** 
;|***    /* values of fsSelection field of FONTMETRICS structure */
;|***    #define FM_SEL_ITALIC           0x0001
;|***    #define FM_SEL_UNDERSCORE       0x0002
;|***    #define FM_SEL_NEGATIVE         0x0004
;|***    #define FM_SEL_OUTLINE          0x0008          /* Hollow Outline Font */
;|***    #define FM_SEL_STRIKEOUT        0x0010
;|***    #define FM_SEL_BOLD             0x0020
;|***    #define FM_SEL_ISO9241_TESTED   0x0040
;|*** 
;|***    /* ISO 9241 is an international standard covering health and safety      */
;|***    /* in the work place for users of visual display terminals. Part 3 of    */
;|***    /* this standard covers clarity and legibility of text displayed on      */
;|***    /* computer screens, it places requirements on minimum sizes and         */
;|***    /* luminance contrast. The presence of FM_SEL_ISO9241_TESTED flag in the */
;|***    /* font metrics indicates that the font has been tested for compliance   */
;|***    /* to the standard. The FM_ISO_XXX flags indicate the results of the     */
;|***    /* test on the IBM 9515, 9517 and 9518 color displays at the supported   */
;|***    /* dimensions of 640x480 and 1024x768. To ensure compliance the          */
;|***    /* sXDeviceRes and sYDeviceRes must also match the target display        */
;|***    /* resolution.                                                           */
;|*** 
;|***    /* values of fbPassed/FailedISO field in the PANOSE structure */
;|***    #define FM_ISO_9518_640        0x01
;|***    #define FM_ISO_9515_640        0x02
;|***    #define FM_ISO_9515_1024       0x04
;|***    #define FM_ISO_9517_640        0x08
;|***    #define FM_ISO_9517_1024       0x10
;|*** 
;|***    /* values of fsCapabilities field of FONTMETRICS structure */
;|***    #define FM_CAP_NOMIX            0x0001
;|*** 
;|***    /* font metrics returned by GpiQueryFonts and others */
;|*** 
;|***    typedef struct _PANOSE { /* panose */
;|***       BYTE    bFamilyType;
;|***       BYTE    bSerifStyle;
;|***       BYTE    bWeight;
;|***       BYTE    bProportion;
;|***       BYTE    bContrast;
;|***       BYTE    bStrokeVariation;
;|***       BYTE    bArmStyle;
;|***       BYTE    bLetterform;
;|***       BYTE    bMidline;
;|***       BYTE    bXHeight;
;|***       BYTE    fbPassedISO;
;|***       BYTE    fbFailedISO;
;|***    } PANOSE;
;|*** 
;|***    typedef struct _FONTMETRICS {   /* fm */
;|***       CHAR    szFamilyname[FACESIZE];
;|***       CHAR    szFacename[FACESIZE];
;|***       USHORT  idRegistry;
;|***       USHORT  usCodePage;
;|***       LONG    lEmHeight;
;|***       LONG    lXHeight;
;|***       LONG    lMaxAscender;
;|***       LONG    lMaxDescender;
;|***       LONG    lLowerCaseAscent;
;|***       LONG    lLowerCaseDescent;
;|***       LONG    lInternalLeading;
;|***       LONG    lExternalLeading;
;|***       LONG    lAveCharWidth;
;|***       LONG    lMaxCharInc;
;|***       LONG    lEmInc;
;|***       LONG    lMaxBaselineExt;
;|***       SHORT   sCharSlope;
;|***       SHORT   sInlineDir;
;|***       SHORT   sCharRot;
;|***       USHORT  usWeightClass;
;|***       USHORT  usWidthClass;
;|***       SHORT   sXDeviceRes;
;|***       SHORT   sYDeviceRes;
;|***       SHORT   sFirstChar;
;|***       SHORT   sLastChar;
;|***       SHORT   sDefaultChar;
;|***       SHORT   sBreakChar;
;|***       SHORT   sNominalPointSize;
;|***       SHORT   sMinimumPointSize;
;|***       SHORT   sMaximumPointSize;
;|***       USHORT  fsType;
;|***       USHORT  fsDefn;
;|***       USHORT  fsSelection;
;|***       USHORT  fsCapabilities;
;|***       LONG    lSubscriptXSize;
;|***       LONG    lSubscriptYSize;
;|***       LONG    lSubscriptXOffset;
;|***       LONG    lSubscriptYOffset;
;|***       LONG    lSuperscriptXSize;
;|***       LONG    lSuperscriptYSize;
;|***       LONG    lSuperscriptXOffset;
;|***       LONG    lSuperscriptYOffset;
;|***       LONG    lUnderscoreSize;
;|***       LONG    lUnderscorePosition;
;|***       LONG    lStrikeoutSize;
;|***       LONG    lStrikeoutPosition;
;|***       SHORT   sKerningPairs;
;|***       SHORT   sFamilyClass;
;|***       LONG    lMatch;
;|***       LONG    FamilyNameAtom;
;|***       LONG    FaceNameAtom;
;|***       PANOSE  panose;
;|***    } FONTMETRICS;
;|***    typedef FONTMETRICS FAR *PFONTMETRICS;
;|*** 
;|***    /*** Common WIN types */
;|*** 
;|***    typedef LHANDLE HWND;      /* hwnd */
;|***    typedef HWND FAR *PHWND;
;|*** 
;|***    typedef LHANDLE HMQ;       /* hmq */
;|***    typedef LHANDLE FAR *PHMQ;
;|*** 
;|***    /* NOINC */
;|***    #define WRECT RECTL
;|***    #define PWRECT PRECTL
;|***    #define NPWRECT NPRECTL
;|*** 
;|***    #define WPOINT POINTL
;|***    #define PWPOINT PPOINTL
;|***    #define NPWPOINT NPPOINTL
;|***    /* INC */
;|*** 
;|***    typedef struct _ICONINFO {  /* icninf */
;|***       ULONG   cb;                  /* size of ICONINFO structure */
;|***       ULONG   fFormat;
;|***       PSZ     pszFileName;         /* use when fFormat = ICON_FILE */
;|***       HMODULE hmod;                /* use when fFormat = ICON_RESOURCE */
;|***       ULONG   resid;               /* use when fFormat = ICON_RESOURCE */
;|***       ULONG   cbIconData;          /* use when fFormat = ICON_DATA     */
;|***       PVOID   pIconData;           /* use when fFormat = ICON_DATA     */
;|***    } ICONINFO;
;|***    typedef ICONINFO FAR *PICONINFO;
;|*** 
;|***    #define ICON_FILE     1         /* flags for fFormat */
;|***    #define ICON_RESOURCE 2
;|***    #define ICON_DATA     3
;|***    #define ICON_CLEAR    4
;|*** 
;|*** #else /* not INCL_32 */
;|***    /* The previous #else/#endif corresponds to a #if near the top of this  */
;|***    /* file.  The next three lines include the 16-bit version of this file, */
;|***    /* hence these lines MUST be the last lines in this include file.       */
;|*** 
;|***    #ifdef INCL_16
;|***       #include <os2def16.h>
; Line 616
;|*** 
;|*** /* OS/2 Base Include File */
;|*** 
;|*** #ifndef INCL_NOBASEAPI
;|*** #include <bse.h>
; Line 47
;|*** /*DDK*************************************************************************/
;|*** /*                                                                           */
;|*** /* COPYRIGHT (C) Microsoft Corporation, 1989                                 */
;|*** /* COPYRIGHT    Copyright (C) 1995 IBM Corporation                           */
;|*** /*                                                                           */
;|*** /*    The following IBM OS/2 WARP source code is provided to you solely for  */
;|*** /*    the purpose of assisting you in your development of OS/2 WARP device   */
;|*** /*    drivers. You may use this code in accordance with the IBM License      */
;|*** /*    Agreement provided in the IBM Device Driver Source Kit for OS/2. This  */
;|*** /*    Copyright statement may not be removed.                                */
;|*** /*                                                                           */
;|*** /*****************************************************************************/
;|*** /*static char *SCCSID = "@(#)bse.h	6.2 91/02/12";*/
;|*** /*static char *SCCSID = "@(#)bse.h	6.2 91/02/12";*/
;|*** /****************************** Module Header ******************************\
;|*** *
;|*** * Module Name: BSE.H
;|*** *
;|*** * This file includes the definitions necessary for writing Base OS/2 applications.
;|*** *
;|*** *
;|*** *
;|*** *
;|*** * ===========================================================================
;|*** *
;|*** * The following symbols are used in this file for conditional sections.
;|*** *
;|*** *   INCL_BASE   -  ALL of OS/2 Base
;|*** *   INCL_DOS    -  OS/2 DOS Kernel
;|*** *   INCL_SUB    -  OS/2 VIO/KBD/MOU
;|*** *   INCL_DOSERRORS -  OS/2 Errors         - only included if symbol defined
;|*** *
;|*** \***************************************************************************/
;|*** 
;|*** #define INCL_BASEINCLUDED
;|*** 
;|*** /* if INCL_BASE defined then define all the symbols */
;|*** #ifdef INCL_BASE
;|***     #define INCL_DOS
;|***     #define INCL_SUB
;|***     #define INCL_DOSERRORS
;|*** #endif /* INCL_BASE */
;|*** 
;|*** #ifndef OS2_INCLUDED
;|*** #if !(defined(INCL_32) || defined(INCL_16))
;|*** #ifdef M_I386
;|***     #define INCL_32
;|*** #else /* not M_I386 */
;|***     #define INCL_16
;|*** #endif /* M_I386 */
;|*** #endif /* INCL_32 || INCL_16 */
;|*** #endif /* OS2_INCLUDED */
;|*** 
;|*** /* XLATOFF */
;|*** #ifdef INCL_32
;|*** #if defined(INCL_16)
;|*** #error message ("Illegal combination of API Flags - 32 && 16")
;|*** #endif /* || INCL_16 */
;|*** #endif /* INCL_32 */
;|*** /* XLATON */
;|*** 
;|*** #include <bsedos.h>       /* Base definitions */
; Line 62
;|*** /*DDK*************************************************************************/
;|*** /*                                                                           */
;|*** /* COPYRIGHT (C) Microsoft Corporation, 1989                                 */
;|*** /* COPYRIGHT    Copyright (C) 1995 IBM Corporation                           */
;|*** /*                                                                           */
;|*** /*    The following IBM OS/2 WARP source code is provided to you solely for  */
;|*** /*    the purpose of assisting you in your development of OS/2 WARP device   */
;|*** /*    drivers. You may use this code in accordance with the IBM License      */
;|*** /*    Agreement provided in the IBM Device Driver Source Kit for OS/2. This  */
;|*** /*    Copyright statement may not be removed.                                */
;|*** /*                                                                           */
;|*** /*****************************************************************************/
;|*** /*static char *SCCSID = "@(#)bsedos.h   6.29 92/03/10";*/
;|*** /***************************************************************************\
;|*** *
;|*** * Module Name: BSEDOS.H
;|*** *
;|*** * OS/2 Base Include File
;|*** *
;|*** *
;|*** *****************************************************************************
;|*** *
;|*** * Subcomponents marked with "+" are partially included by default
;|*** *
;|*** *   #define:                To include:
;|*** *
;|*** * + INCL_DOSPROCESS         Process and thread support
;|*** * + INCL_DOSFILEMGR         File Management
;|*** * + INCL_DOSMEMMGR          Memory Management
;|*** * + INCL_DOSSEMAPHORES      Semaphore support
;|*** * + INCL_DOSDATETIME        Date/Time and Timer support
;|*** *   INCL_DOSMODULEMGR       Module manager
;|*** * + INCL_DOSRESOURCES       Resource support
;|*** *   INCL_DOSNLS             National Language Support
;|*** *   INCL_DOSEXCEPTIONS      Exceptions
;|*** *   INCL_DOSMISC            Miscellaneous
;|*** *   INCL_DOSMONITORS        Monitors
;|*** *   INCL_DOSQUEUES          Queues
;|*** *   INCL_DOSSESMGR          Session Manager Support
;|*** *   INCL_DOSDEVICES         Device specific, ring 2 support
;|*** *   INCL_DOSNMPIPES         Named Pipes Support
;|*** *   INCL_DOSPROFILE         DosProfile API
;|*** *   INCL_DOSMVDM            MVDM support
;|*** *
;|*** \***************************************************************************/
;|*** 
;|*** #define INCL_DOSINCLUDED
;|*** 
;|*** #ifndef INCL_BASEINCLUDED
;|*** #if !(defined(INCL_32) || defined(INCL_16))
;|*** #ifdef M_I386
;|***     #define INCL_32
;|*** #else /* not M_I386 */
;|***     #define INCL_16
;|*** #endif /* M_I386 */
;|*** #endif /* INCL_32 || INCL_16 */
;|*** 
;|*** /* XLATOFF */
;|*** #if defined(INCL_16)
;|*** #pragma message ("32-bit Base API included when using 16-bit compiler")
;|*** #endif /* INCL_16 */
;|*** /* XLATON */
;|*** #endif /* INCL_BASEINCLUDED */
;|*** 
;|*** #ifdef INCL_32  /* This #ifdef brackets the rest of this entire */
;|***                         /* file.  It is used to include either the      */
;|***                         /* 32-bit or 16-bit base definitions.  No       */
;|***                         /* definitions (other than 16/32-bit            */
;|***                         /* determination) must be placed above this.    */
;|*** 
;|*** #ifdef INCL_DOS
;|*** 
;|*** #define INCL_DOSPROCESS
;|*** #define INCL_DOSFILEMGR
;|*** #define INCL_DOSMEMMGR
;|*** #define INCL_DOSSEMAPHORES
;|*** #define INCL_DOSDATETIME
;|*** #define INCL_DOSMODULEMGR
;|*** #define INCL_DOSRESOURCES
;|*** #define INCL_DOSNLS
;|*** #define INCL_DOSEXCEPTIONS
;|*** #define INCL_DOSMISC
;|*** #define INCL_DOSMONITORS
;|*** #define INCL_DOSQUEUES
;|*** #define INCL_DOSSESMGR
;|*** #define INCL_DOSDEVICES
;|*** #define INCL_DOSNMPIPES
;|*** #define INCL_DOSPROFILE
;|*** #define INCL_DOSMVDM
;|*** 
;|*** #endif /* INCL_DOS */
;|*** 
;|*** #ifdef INCL_ERRORS
;|*** #define INCL_DOSERRORS
;|*** #endif /* INCL_ERRORS */
;|*** 
;|*** #if (defined(INCL_DOSPROCESS) || !defined(INCL_NOCOMMON))
;|*** 
;|*** /*** General services */
;|*** 
;|*** APIRET  APIENTRY        DosBeep(ULONG freq, ULONG dur);
;|*** 
;|*** /*** Process and Thread support */
;|*** 
;|*** VOID    APIENTRY        DosExit(ULONG action, ULONG result);
;|*** 
;|*** /* DosExit codes */
;|*** 
;|*** #define EXIT_THREAD         0
;|*** #define EXIT_PROCESS        1
;|*** 
;|*** #endif /* common INCL_DOSPROCESS stuff */
;|*** 
;|*** #ifdef INCL_DOSPROCESS
;|*** 
;|*** /* XLATOFF */
;|*** #define DosCwait        DosWaitChild
;|*** #define DosSetPrty      DosSetPriority
;|*** /* XLATON */
;|*** 
;|*** #include <bsetib.h>
;|*** 
;|*** typedef VOID (*PFNTHREAD)(VOID);
;|*** 
;|*** APIRET  APIENTRY        DosCreateThread(PTID ptid, PFNTHREAD pfn, ULONG param, ULONG flag, ULONG cbStack);
;|*** 
;|*** APIRET  APIENTRY        DosResumeThread(TID tid);
;|*** 
;|*** APIRET  APIENTRY        DosSuspendThread(TID tid);
;|*** 
;|*** APIRET  APIENTRY        DosGetInfoBlocks(PTIB *pptib,PPIB *pppib);
;|*** 
;|*** APIRET  APIENTRY        DosKillThread(TID tid);
;|*** 
;|*** APIRET APIENTRY DosAllocThreadLocalMemory(ULONG cb, PULONG *p);
;|*** APIRET APIENTRY DosFreeThreadLocalMemory(ULONG *p);
;|*** 
;|*** /* Action code values */
;|*** 
;|*** #define DCWA_PROCESS        0
;|*** #define DCWA_PROCESSTREE    1
;|*** 
;|*** /* Wait option values */
;|*** 
;|*** #define DCWW_WAIT   0
;|*** #define DCWW_NOWAIT 1
;|*** 
;|*** /* Thread Flags for DosCreateThread options 59468 */
;|*** 
;|*** #define CREATE_READY        0
;|*** #define CREATE_SUSPENDED    1
;|*** #define STACK_SPARSE        0
;|*** #define STACK_COMMITTED     2
;|*** 
;|*** typedef struct _RESULTCODES {     /* resc */
;|***     ULONG codeTerminate;
;|***     ULONG codeResult;
;|*** } RESULTCODES;
;|*** typedef RESULTCODES     *PRESULTCODES;
;|*** 
;|*** APIRET  APIENTRY        DosWaitChild(ULONG action, ULONG option, PRESULTCODES pres, PPID ppid, PID pid);
;|*** 
;|*** APIRET  APIENTRY        DosWaitThread(PTID ptid, ULONG option);
;|*** 
;|*** APIRET  APIENTRY        DosSleep(ULONG msec);
;|*** 
;|*** APIRET  APIENTRY        DosDebug(PVOID pdbgbuf);
;|*** 
;|*** 
;|*** /* codeTerminate values (also passed to ExitList routines) */
;|*** 
;|*** #define TC_EXIT          0
;|*** #define TC_HARDERROR     1
;|*** #define TC_TRAP          2
;|*** #define TC_KILLPROCESS   3
;|*** #define TC_EXCEPTION     4
;|*** 
;|*** typedef VOID    (*PFNEXITLIST)(ULONG);
;|*** 
;|*** APIRET  APIENTRY        DosEnterCritSec(VOID);
;|*** 
;|*** APIRET  APIENTRY        DosExitCritSec(VOID);
;|*** 
;|*** APIRET  APIENTRY        DosExitList(ULONG ordercode, PFNEXITLIST pfn);
;|*** 
;|*** /* DosExitList functions */
;|*** 
;|*** #define EXLST_ADD       1
;|*** #define EXLST_REMOVE    2
;|*** #define EXLST_EXIT      3
;|*** 
;|*** APIRET  APIENTRY        DosExecPgm(PCHAR pObjname, LONG cbObjname, ULONG execFlag, PSZ pArg, PSZ pEnv, PRESULTCODES pRes, PSZ pName);
;|*** 
;|*** /* DosExecPgm functions */
;|*** 
;|*** #define EXEC_SYNC           0
;|*** #define EXEC_ASYNC          1
;|*** #define EXEC_ASYNCRESULT    2
;|*** #define EXEC_TRACE          3
;|*** #define EXEC_BACKGROUND     4
;|*** #define EXEC_LOAD           5
;|*** #define EXEC_ASYNCRESULTDB  6
;|*** 
;|*** 
;|*** APIRET  APIENTRY        DosSetPriority(ULONG scope, ULONG class, LONG delta, ULONG PorTid);
;|*** 
;|*** /* Priority scopes */
;|*** 
;|*** #define PRTYS_PROCESS       0
;|*** #define PRTYS_PROCESSTREE   1
;|*** #define PRTYS_THREAD        2
;|*** 
;|*** /* Priority classes */
;|*** 
;|*** #define PRTYC_NOCHANGE      0
;|*** #define PRTYC_IDLETIME      1
;|*** #define PRTYC_REGULAR       2
;|*** #define PRTYC_TIMECRITICAL  3
;|*** #define PRTYC_FOREGROUNDSERVER  4
;|*** 
;|*** /* Priority deltas */
;|*** 
;|*** #define PRTYD_MINIMUM      -31
;|*** #define PRTYD_MAXIMUM       31
;|*** 
;|*** APIRET  APIENTRY        DosKillProcess(ULONG action, PID pid);
;|*** 
;|*** #define DKP_PROCESSTREE     0
;|*** #define DKP_PROCESS         1
;|*** 
;|*** #endif /* INCL_DOSPROCESS */
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** 
;|*** /*
;|***  * CCHMAXPATH is the maximum fully qualified path name length including
;|***  * the drive letter, colon, backslashes and terminating NULL.
;|***  */
;|*** #define CCHMAXPATH      260
;|*** 
;|*** /*
;|***  * CCHMAXPATHCOMP is the maximum individual path component name length
;|***  * including a terminating NULL.
;|***  */
;|*** #define CCHMAXPATHCOMP  256
;|*** 
;|*** #endif  /* !INCL_SAADEFS */
;|*** 
;|*** #if (defined(INCL_DOSFILEMGR) || !defined(INCL_NOCOMMON))
;|*** 
;|*** /*** File manager */
;|*** 
;|*** /* DosSetFilePtr() file position codes */
;|*** 
;|*** #define FILE_BEGIN      0x0000  /* Move relative to beginning of file */
;|*** #define FILE_CURRENT    0x0001  /* Move relative to current fptr position */
;|*** #define FILE_END        0x0002  /* Move relative to end of file */
;|*** 
;|*** /* DosFindFirst/Next Directory handle types */
;|*** 
;|*** #define HDIR_SYSTEM     1       /* Use system handle (1) */
;|*** #define HDIR_CREATE     (-1)    /* Allocate a new, unused handle */
;|*** 
;|*** /* DosCopy control bits; may be or'ed together */
;|*** #define DCPY_EXISTING   0x00001         /* Copy even if target exists */
;|*** #define DCPY_APPEND     0x00002         /* Append to existing file, do not replace */
;|*** #define DCPY_FAILEAS    0x00004         /* Fail if EAs not supported on target*/
;|*** 
;|*** /* DosOpen/DosQFHandState/DosQueryFileInfo et al file attributes; also */
;|*** /* known as Dos File Mode bits... */
;|*** #define FILE_NORMAL     0x0000
;|*** #define FILE_READONLY   0x0001
;|*** #define FILE_HIDDEN     0x0002
;|*** #define FILE_SYSTEM     0x0004
;|*** #define FILE_DIRECTORY  0x0010
;|*** #define FILE_ARCHIVED   0x0020
;|*** 
;|*** 
;|*** #define MUST_HAVE_READONLY      ( (FILE_READONLY  << 8) | FILE_READONLY  )
;|*** #define MUST_HAVE_HIDDEN        ( (FILE_HIDDEN    << 8) | FILE_HIDDEN    )
;|*** #define MUST_HAVE_SYSTEM        ( (FILE_SYSTEM    << 8) | FILE_SYSTEM    )
;|*** #define MUST_HAVE_DIRECTORY     ( (FILE_DIRECTORY << 8) | FILE_DIRECTORY )
;|*** #define MUST_HAVE_ARCHIVED      ( (FILE_ARCHIVED  << 8) | FILE_ARCHIVED  )
;|*** 
;|*** /* DosOpen() actions */
;|*** 
;|*** #define FILE_EXISTED    0x0001
;|*** #define FILE_CREATED    0x0002
;|*** #define FILE_TRUNCATED  0x0003
;|*** 
;|*** /* DosOpen() open flags */
;|*** #define FILE_OPEN                  0x0001
;|*** #define FILE_TRUNCATE              0x0002
;|*** #define FILE_CREATE                0x0010
;|*** 
;|*** /*     this nibble applies if file already exists                xxxx */
;|*** 
;|*** #define OPEN_ACTION_FAIL_IF_EXISTS     0x0000  /* ---- ---- ---- 0000 */
;|*** #define OPEN_ACTION_OPEN_IF_EXISTS     0x0001  /* ---- ---- ---- 0001 */
;|*** #define OPEN_ACTION_REPLACE_IF_EXISTS  0x0002  /* ---- ---- ---- 0010 */
;|*** 
;|*** /*     this nibble applies if file does not exist           xxxx      */
;|*** 
;|*** #define OPEN_ACTION_FAIL_IF_NEW        0x0000  /* ---- ---- 0000 ---- */
;|*** #define OPEN_ACTION_CREATE_IF_NEW      0x0010  /* ---- ---- 0001 ---- */
;|*** 
;|*** /* DosOpen/DosSetFHandState flags */
;|*** 
;|*** #define OPEN_ACCESS_READONLY        0x0000  /* ---- ---- ---- -000 */
;|*** #define OPEN_ACCESS_WRITEONLY       0x0001  /* ---- ---- ---- -001 */
;|*** #define OPEN_ACCESS_READWRITE       0x0002  /* ---- ---- ---- -010 */
;|*** #define OPEN_SHARE_DENYREADWRITE    0x0010  /* ---- ---- -001 ---- */
;|*** #define OPEN_SHARE_DENYWRITE        0x0020  /* ---- ---- -010 ---- */
;|*** #define OPEN_SHARE_DENYREAD         0x0030  /* ---- ---- -011 ---- */
;|*** #define OPEN_SHARE_DENYNONE         0x0040  /* ---- ---- -100 ---- */
;|*** #define OPEN_FLAGS_NOINHERIT        0x0080  /* ---- ---- 1--- ---- */
;|*** #define OPEN_FLAGS_NO_LOCALITY      0x0000  /* ---- -000 ---- ---- */
;|*** #define OPEN_FLAGS_SEQUENTIAL       0x0100  /* ---- -001 ---- ---- */
;|*** #define OPEN_FLAGS_RANDOM           0x0200  /* ---- -010 ---- ---- */
;|*** #define OPEN_FLAGS_RANDOMSEQUENTIAL 0x0300  /* ---- -011 ---- ---- */
;|*** #define OPEN_FLAGS_NO_CACHE         0x1000  /* ---1 ---- ---- ---- */
;|*** #define OPEN_FLAGS_FAIL_ON_ERROR    0x2000  /* --1- ---- ---- ---- */
;|*** #define OPEN_FLAGS_WRITE_THROUGH    0x4000  /* -1-- ---- ---- ---- */
;|*** #define OPEN_FLAGS_DASD             0x8000  /* 1--- ---- ---- ---- */
;|*** #define OPEN_FLAGS_NONSPOOLED       0x00040000
;|*** #define OPEN_FLAGS_PROTECTED_HANDLE 0x40000000
;|*** 
;|*** 
;|*** /* DosSearchPath() constants */
;|*** 
;|*** #define SEARCH_PATH            0x0000
;|*** #define SEARCH_CUR_DIRECTORY   0x0001
;|*** #define SEARCH_ENVIRONMENT     0x0002
;|*** #define SEARCH_IGNORENETERRS   0x0004
;|*** 
;|*** 
;|*** /************************************************************
;|*** EA Info Levels & Find First/Next
;|*** =========================================
;|*** API's: DosFindFirst, DosQueryFileInfo, DosQueryPathInfo, DosSetFileInfo,
;|***        DosSetPathInfo
;|*** ************************************************************/
;|*** 
;|*** /* File info levels&gml All listed API's */
;|*** #define FIL_STANDARD            1       /* Info level 1, standard file info */
;|*** #define FIL_QUERYEASIZE         2       /* Level 2, return Full EA size */
;|*** #define FIL_QUERYEASFROMLIST    3       /* Level 3, return requested EA's */
;|*** 
;|*** /* File info levels: Dos...PathInfo only */
;|*** #define FIL_QUERYFULLNAME       5       /* Level 5, return fully qualified
;|***                                            name of file */
;|*** /* DosFsAttach() */
;|*** /* Attact or detach */
;|*** #define FS_ATTACH       0       /* Attach file server */
;|*** #define FS_DETACH       1       /* Detach file server */
;|*** #define FS_SPOOLATTACH  2       /* Register a spooler device */
;|*** #define FS_SPOOLDETACH  3       /* De-register a spooler device */
;|*** 
;|*** 
;|*** /* DosFsCtl() */
;|*** /* Routing type */
;|*** #define FSCTL_HANDLE    1       /* File Handle directs req routing */
;|*** #define FSCTL_PATHNAME  2       /* Path Name directs req routing */
;|*** #define FSCTL_FSDNAME   3       /* FSD Name directs req routing */
;|*** 
;|*** /* defined FSCTL functions */
;|*** #define FSCTL_ERROR_INFO        1       /* return error info from FSD */
;|*** #define FSCTL_MAX_EASIZE        2       /* Max ea size for the FSD */
;|*** 
;|*** typedef struct  _EASIZEBUF {    /* struct for FSCTL fn 2 - max ea size */
;|***         USHORT  cbMaxEASize;    /* max. size of one EA */
;|***         ULONG   cbMaxEAListSize;        /* max size of the full EA List */
;|*** } EASIZEBUF;
;|*** typedef EASIZEBUF FAR * PEASIZEBUF;
;|*** 
;|*** 
;|*** /* DosQueryFSAttach() */
;|*** /* Information level types (defines method of query) */
;|*** #define FSAIL_QUERYNAME 1       /* Return data for a Drive or Device */
;|*** #define FSAIL_DEVNUMBER 2       /* Return data for Ordinal Device # */
;|*** #define FSAIL_DRVNUMBER 3       /* Return data for Ordinal Drive # */
;|*** 
;|*** /* Item types (from data structure item "iType") */
;|*** #define FSAT_CHARDEV    1       /* Resident character device */
;|*** #define FSAT_PSEUDODEV  2       /* Pseudo-character device */
;|*** #define FSAT_LOCALDRV   3       /* Local drive */
;|*** #define FSAT_REMOTEDRV  4       /* Remote drive attached to FSD */
;|*** 
;|*** 
;|*** typedef struct  _FSQBUFFER {    /* fsqbuf Data structure for QFSAttach*/
;|***     USHORT      iType;          /* Item type */
;|***     USHORT      cbName;         /* Length of item name, sans NULL */
;|***     UCHAR       szName[1];      /* ASCIIZ item name */
;|***     USHORT      cbFSDName;      /* Length of FSD name, sans NULL */
;|***     UCHAR       szFSDName[1];   /* ASCIIZ FSD name */
;|***     USHORT      cbFSAData;      /* Length of FSD Attach data returned */
;|***     UCHAR       rgFSAData[1];   /* FSD Attach data from FSD */
;|*** } FSQBUFFER;
;|*** typedef FSQBUFFER FAR *PFSQBUFFER;
;|*** 
;|*** 
;|*** typedef struct _FSQBUFFER2 {    /* fsqbuf Data structure for QFSAttach*/
;|***     USHORT  iType;
;|***     USHORT  cbName;
;|***     USHORT  cbFSDName;
;|***     USHORT  cbFSAData;
;|***     UCHAR   szName[1];
;|***     UCHAR   szFSDName[1];
;|***     UCHAR   rgFSAData[1];
;|*** } FSQBUFFER2;
;|*** 
;|*** typedef FSQBUFFER2 FAR * PFSQBUFFER2;
;|*** 
;|*** typedef struct _SPOOLATTACH {   /* Data structure for spooler operations */
;|***     USHORT      hNmPipe;        /* Named pipe handle                     */
;|***     ULONG       ulKey;          /* Attached key                          */
;|*** } SPOOLATTACH;
;|*** typedef SPOOLATTACH FAR *PSPOOLATTACH;
;|*** 
;|*** /***********
;|*** File System Drive Information&gml DosQueryFSInfo DosSetFSInfo
;|*** ***********/
;|*** 
;|*** /* FS Drive Info Levels */
;|*** #define FSIL_ALLOC      1       /* Drive allocation info (Query only) */
;|*** #define FSIL_VOLSER     2       /* Drive Volum/Serial info */
;|*** 
;|*** /* DosQueryFHType() */
;|*** /* Handle classes (low 8 bits of Handle Type) */
;|*** #define FHT_DISKFILE    0x0000          /* Disk file handle */
;|*** #define FHT_CHRDEV      0x0001          /* Character device handle */
;|*** #define FHT_PIPE        0x0002          /* Pipe handle */
;|*** 
;|*** /* Handle bits (high 8 bits of Handle Type) */
;|*** #define FHB_DSKREMOTE           0x8000  /* Remote disk */
;|*** #define FHB_CHRDEVREMOTE        0x8000  /* Remote character device */
;|*** #define FHB_PIPEREMOTE          0x8000  /* Remote pipe */
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** 
;|*** /* File time and date types */
;|*** 
;|*** typedef struct _FTIME {         /* ftime */
;|***     USHORT twosecs : 5;
;|***     USHORT minutes : 6;
;|***     USHORT hours   : 5;
;|*** } FTIME;
;|*** typedef FTIME   *PFTIME;
;|*** 
;|*** typedef struct _FDATE {         /* fdate */
;|***     USHORT day     : 5;
;|***     USHORT month   : 4;
;|***     USHORT year    : 7;
;|*** } FDATE;
;|*** typedef FDATE   *PFDATE;
;|*** 
;|*** #endif /* INCL_SAADEFS */
;|*** 
;|*** typedef struct _VOLUMELABEL {    /* vol */
;|***     BYTE cch;
;|***     CHAR szVolLabel[12];
;|*** } VOLUMELABEL;
;|*** typedef VOLUMELABEL FAR *PVOLUMELABEL;
;|*** 
;|*** typedef struct _FSINFO {    /* fsinf */
;|***     ULONG ulVSN;
;|***     VOLUMELABEL vol;
;|*** } FSINFO;
;|*** typedef FSINFO FAR *PFSINFO;
;|*** 
;|*** /* HANDTYPE values */
;|*** 
;|*** #define HANDTYPE_FILE     0x0000
;|*** #define HANDTYPE_DEVICE   0x0001
;|*** #define HANDTYPE_PIPE     0x0002
;|*** #define HANDTYPE_PROTECTED 0x4000
;|*** #define HANDTYPE_NETWORK  0x8000
;|*** 
;|*** typedef struct _FILELOCK {    /* flock */
;|***     LONG lOffset;
;|***     LONG lRange;
;|*** } FILELOCK;
;|*** typedef FILELOCK FAR *PFILELOCK;
;|*** 
;|*** typedef SHANDLE HFILE;     /* hf */
;|*** typedef HFILE   *PHFILE;
;|*** 
;|*** typedef  ULONG    HEV;             /* hev */
;|*** typedef  HEV      *PHEV;
;|*** typedef  ULONG  FHLOCK;
;|*** typedef  PULONG  PFHLOCK;
;|*** 
;|*** APIRET  APIENTRY        DosSetFileLocks(HFILE hFile, PFILELOCK pflUnlock, PFILELOCK pflLock, ULONG timeout, ULONG flags);
;|*** APIRET  APIENTRY        DosProtectSetFileLocks(HFILE hFile,
;|***                                                PFILELOCK pflUnlock,
;|***                                                PFILELOCK pflLock,
;|***                                                ULONG timeout, ULONG flags,
;|***                                                FHLOCK fhFileHandleLockID);
;|*** 
;|*** APIRET  APIENTRY        DosCancelLockRequest(HFILE hFile, PFILELOCK pflLock);
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** 
;|*** typedef struct _FILEFINDBUF {   /* findbuf */
;|***     FDATE  fdateCreation;
;|***     FTIME  ftimeCreation;
;|***     FDATE  fdateLastAccess;
;|***     FTIME  ftimeLastAccess;
;|***     FDATE  fdateLastWrite;
;|***     FTIME  ftimeLastWrite;
;|***     ULONG  cbFile;
;|***     ULONG  cbFileAlloc;
;|***     USHORT attrFile;
;|***     UCHAR  cchName;
;|***     CHAR   achName[CCHMAXPATHCOMP];
;|*** } FILEFINDBUF;
;|*** typedef FILEFINDBUF     *PFILEFINDBUF;
;|*** 
;|*** /* XLATOFF */
;|*** #pragma pack(2)
;|*** /* XLATON */
;|*** 
;|*** typedef struct _FILEFINDBUF2 {  /* findbuf2 */
;|***     FDATE  fdateCreation;
;|***     FTIME  ftimeCreation;
;|***     FDATE  fdateLastAccess;
;|***     FTIME  ftimeLastAccess;
;|***     FDATE  fdateLastWrite;
;|***     FTIME  ftimeLastWrite;
;|***     ULONG  cbFile;
;|***     ULONG  cbFileAlloc;
;|***     USHORT attrFile;
;|***     ULONG  cbList;
;|***     UCHAR  cchName;
;|***     CHAR   achName[CCHMAXPATHCOMP];
;|*** } FILEFINDBUF2;
;|*** typedef FILEFINDBUF2    *PFILEFINDBUF2;
;|*** 
;|*** /* XLATOFF */
;|*** #pragma pack()
;|*** /* XLATON */
;|*** 
;|*** typedef struct _FILEFINDBUF3 {   /* findbuf3 */
;|***     ULONG   oNextEntryOffset;                   /* new field */
;|***     FDATE   fdateCreation;
;|***     FTIME   ftimeCreation;
;|***     FDATE   fdateLastAccess;
;|***     FTIME   ftimeLastAccess;
;|***     FDATE   fdateLastWrite;
;|***     FTIME   ftimeLastWrite;
;|***     ULONG   cbFile;
;|***     ULONG   cbFileAlloc;
;|***     ULONG   attrFile;                           /* widened field */
;|***     UCHAR   cchName;
;|***     CHAR    achName[CCHMAXPATHCOMP];
;|*** } FILEFINDBUF3;
;|*** typedef FILEFINDBUF3    *PFILEFINDBUF3;
;|*** 
;|*** typedef struct _FILEFINDBUF4 {   /* findbuf4 */
;|***     ULONG   oNextEntryOffset;                   /* new field */
;|***     FDATE   fdateCreation;
;|***     FTIME   ftimeCreation;
;|***     FDATE   fdateLastAccess;
;|***     FTIME   ftimeLastAccess;
;|***     FDATE   fdateLastWrite;
;|***     FTIME   ftimeLastWrite;
;|***     ULONG   cbFile;
;|***     ULONG   cbFileAlloc;
;|***     ULONG   attrFile;                           /* widened field */
;|***     ULONG   cbList;
;|***     UCHAR   cchName;
;|***     CHAR    achName[CCHMAXPATHCOMP];
;|*** } FILEFINDBUF4;
;|*** typedef FILEFINDBUF4    *PFILEFINDBUF4;
;|*** 
;|*** /* extended attribute structures */
;|*** 
;|*** typedef struct _GEA {       /* gea */
;|***     BYTE cbName;            /* name length not including NULL */
;|***     CHAR szName[1];         /* attribute name */
;|*** } GEA;
;|*** typedef GEA     *PGEA;
;|*** 
;|*** typedef struct _GEALIST {   /* geal */
;|***     ULONG cbList;           /* total bytes of structure including full list */
;|***     GEA list[1];            /* variable length GEA structures */
;|*** } GEALIST;
;|*** typedef GEALIST* PGEALIST;
;|*** 
;|*** typedef struct _FEA {       /* fea */
;|***     BYTE fEA;               /* flags                              */
;|***     BYTE cbName;            /* name length not including NULL */
;|***     USHORT cbValue;         /* value length */
;|*** } FEA;
;|*** typedef FEA     *PFEA;
;|*** 
;|*** /* flags for _FEA.fEA */
;|*** 
;|*** #define FEA_NEEDEA 0x80     /* need EA bit */
;|*** 
;|*** typedef struct _FEALIST {   /* feal */
;|***     ULONG cbList;           /* total bytes of structure including full list */
;|***     FEA list[1];            /* variable length FEA structures */
;|*** } FEALIST;
;|*** typedef FEALIST* PFEALIST;
;|*** 
;|*** typedef struct _EAOP {      /* eaop */
;|***     PGEALIST fpGEAList;     /* general EA list */
;|***     PFEALIST fpFEAList;     /* full EA list */
;|***     ULONG oError;
;|*** } EAOP;
;|*** typedef EAOP* PEAOP;
;|*** 
;|*** 
;|*** /* XLATOFF */
;|*** #pragma pack(1)
;|*** /* XLATON */
;|*** 
;|*** typedef struct _FEA2 {      /* fea2 */
;|***     ULONG   oNextEntryOffset;                   /* new field */
;|***     BYTE    fEA;
;|***     BYTE    cbName;
;|***     USHORT  cbValue;
;|***     CHAR    szName[1];                          /* new field */
;|*** } FEA2;
;|*** 
;|*** typedef FEA2 *PFEA2;
;|*** 
;|*** /* flags for _FEA.fEA */
;|*** 
;|*** #define FEA_NEEDEA 0x80     /* need EA bit */
;|*** 
;|*** typedef struct _FEA2LIST {    /* fea2l */
;|***     ULONG   cbList;
;|***     FEA2    list[1];
;|*** } FEA2LIST;
;|*** 
;|*** typedef FEA2LIST *PFEA2LIST;
;|*** 
;|*** typedef struct _GEA2 {        /* gea2 */
;|***     ULONG   oNextEntryOffset;                   /* new field */
;|***     BYTE    cbName;
;|***     CHAR    szName[1];                          /* new field */
;|*** } GEA2;
;|*** 
;|*** typedef GEA2 *PGEA2;
;|*** 
;|*** typedef struct _GEA2LIST {    /* gea2l */
;|***     ULONG   cbList;
;|***     GEA2    list[1];
;|*** } GEA2LIST;
;|*** 
;|*** typedef GEA2LIST *PGEA2LIST;
;|*** 
;|*** typedef struct _EAOP2 {      /* eaop2 */
;|***     PGEA2LIST   fpGEA2List;                     /* GEA set */
;|***     PFEA2LIST   fpFEA2List;                     /* FEA set */
;|***     ULONG       oError;                         /* offset of FEA error */
;|*** } EAOP2;
;|*** 
;|*** typedef EAOP2 *PEAOP2;
;|*** 
;|*** /* XLATOFF */
;|*** #pragma pack()
;|*** /* XLATON */
;|*** 
;|*** /*
;|***  * Equates for the types of EAs that follow the convention that we have
;|***  * established.
;|***  *
;|***  * Values 0xFFFE thru 0x8000 are reserved.
;|***  * Values 0x0000 thru 0x7fff are user definable.
;|***  * Value  0xFFFC is not used
;|***  */
;|*** 
;|*** #define EAT_BINARY      0xFFFE          /* length preceeded binary */
;|*** #define EAT_ASCII       0xFFFD          /* length preceeded ASCII */
;|*** #define EAT_BITMAP      0xFFFB          /* length preceeded bitmap */
;|*** #define EAT_METAFILE    0xFFFA          /* length preceeded metafile */
;|*** #define EAT_ICON        0xFFF9          /* length preceeded icon */
;|*** #define EAT_EA          0xFFEE          /* length preceeded ASCII */
;|***                                         /* name of associated data (#include) */
;|*** #define EAT_MVMT        0xFFDF          /* multi-valued, multi-typed field */
;|*** #define EAT_MVST        0xFFDE          /* multi-valued, single-typed field */
;|*** #define EAT_ASN1        0xFFDD          /* ASN.1 field */
;|*** 
;|*** /* XLATOFF */
;|*** #pragma pack(1)
;|*** /* XLATON */
;|*** 
;|*** typedef struct _CNPATH {      /* CHANGENOTIFYPATH */
;|***     ULONG   oNextEntryOffset;
;|***     ULONG   wFlags;
;|***     USHORT  cbName;
;|***     CHAR    szName[1];
;|*** } CNPATH;
;|*** 
;|*** typedef CNPATH *PCNPATH;
;|*** 
;|*** typedef struct _CNINFO {      /* CHANGENOTIFYINFO */
;|***     ULONG   oNextEntryOffset;
;|***     CHAR    bAction;
;|***     USHORT  cbName;
;|***     CHAR    szName[1];
;|*** } CNINFO;
;|*** 
;|*** typedef CNINFO *PCNINFO;
;|*** 
;|*** /* XLATOFF */
;|*** #pragma pack()
;|*** /* XLATON */
;|*** 
;|*** /*
;|***  *  Equates for ChangeNotifyInfo baction field
;|***  *
;|***  */
;|*** 
;|*** #define             RCNF_FILE_ADDED        0x0001
;|*** #define             RCNF_FILE_DELETED      0x0002
;|*** #define             RCNF_DIR_ADDED         0x0003
;|*** #define             RCNF_DIR_DELETED       0x0004
;|*** #define             RCNF_MOVED_IN          0x0005
;|*** #define             RCNF_MOVED_OUT         0x0006
;|*** #define             RCNF_CHANGED           0x0007
;|*** #define             RCNF_OLDNAME           0x0008
;|*** #define             RCNF_NEWNAME           0x0009
;|*** #define             RCNF_DEVICE_ATTACHED   0x000A
;|*** #define             RCNF_DEVICE_DETACHED   0x000B
;|*** 
;|*** #endif  /* !INCL_SAADEFS */
;|*** 
;|*** APIRET  APIENTRY        DosOpen(PSZ pszFileName, PHFILE phf, PULONG pulAction, ULONG cbFile, ULONG ulAttribute, ULONG fsOpenFlags, ULONG fsOpenMode, PEAOP2 peaop2 );
;|*** APIRET  APIENTRY        DosProtectOpen(PSZ pszFileName, PHFILE phf,
;|***                                        PULONG pulAction, ULONG cbFile,
;|***                                        ULONG ulAttribute, ULONG fsOpenFlags,
;|***                                        ULONG fsOpenMode, PEAOP2 peaop2,
;|***                                        PFHLOCK pfhFileHandleLockID);
;|*** 
;|*** APIRET  APIENTRY        DosClose(HFILE hFile);
;|*** APIRET  APIENTRY        DosProtectClose(HFILE hFile, FHLOCK fhFileHandleLockID);
;|*** 
;|*** APIRET  APIENTRY        DosRead(HFILE hFile, PVOID pBuffer, ULONG cbRead, PULONG pcbActual);
;|*** APIRET  APIENTRY        DosProtectRead(HFILE hFile, PVOID pBuffer,
;|***                                        ULONG cbRead, PULONG pcbActual,
;|***                                        FHLOCK fhFileHandleLockID);
;|*** 
;|*** APIRET  APIENTRY        DosWrite(HFILE hFile, PVOID pBuffer, ULONG cbWrite, PULONG pcbActual);
;|*** APIRET  APIENTRY        DosProtectWrite(HFILE hFile, PVOID pBuffer,
;|***                                         ULONG cbWrite, PULONG pcbActual,
;|***                                         FHLOCK fhFileHandleLockID);
;|*** 
;|*** /* File time and date types */
;|*** 
;|*** typedef struct _FILESTATUS {    /* fsts */
;|***     FDATE  fdateCreation;
;|***     FTIME  ftimeCreation;
;|***     FDATE  fdateLastAccess;
;|***     FTIME  ftimeLastAccess;
;|***     FDATE  fdateLastWrite;
;|***     FTIME  ftimeLastWrite;
;|***     ULONG  cbFile;
;|***     ULONG  cbFileAlloc;
;|***     USHORT attrFile;
;|*** } FILESTATUS;
;|*** typedef FILESTATUS      *PFILESTATUS;
;|*** 
;|*** typedef struct _FILESTATUS2 {   /* fsts2 */
;|***     FDATE  fdateCreation;
;|***     FTIME  ftimeCreation;
;|***     FDATE  fdateLastAccess;
;|***     FTIME  ftimeLastAccess;
;|***     FDATE  fdateLastWrite;
;|***     FTIME  ftimeLastWrite;
;|***     ULONG  cbFile;
;|***     ULONG  cbFileAlloc;
;|***     USHORT attrFile;
;|***     ULONG  cbList;
;|*** } FILESTATUS2;
;|*** typedef FILESTATUS2     *PFILESTATUS2;
;|*** 
;|*** 
;|*** typedef struct _FILESTATUS3 {   /* fsts3 */
;|***     FDATE  fdateCreation;
;|***     FTIME  ftimeCreation;
;|***     FDATE  fdateLastAccess;
;|***     FTIME  ftimeLastAccess;
;|***     FDATE  fdateLastWrite;
;|***     FTIME  ftimeLastWrite;
;|***     ULONG  cbFile;
;|***     ULONG  cbFileAlloc;
;|***     ULONG  attrFile;
;|*** } FILESTATUS3;
;|*** typedef FILESTATUS3     *PFILESTATUS3;
;|*** 
;|*** typedef struct _FILESTATUS4 {    /* fsts4 */
;|***     FDATE  fdateCreation;
;|***     FTIME  ftimeCreation;
;|***     FDATE  fdateLastAccess;
;|***     FTIME  ftimeLastAccess;
;|***     FDATE  fdateLastWrite;
;|***     FTIME  ftimeLastWrite;
;|***     ULONG  cbFile;
;|***     ULONG  cbFileAlloc;
;|***     ULONG  attrFile;
;|***     ULONG  cbList;
;|*** } FILESTATUS4;
;|*** typedef FILESTATUS4     *PFILESTATUS4;
;|*** 
;|*** 
;|*** typedef struct _FSALLOCATE {    /* fsalloc */
;|***     ULONG  idFileSystem;
;|***     ULONG  cSectorUnit;
;|***     ULONG  cUnit;
;|***     ULONG  cUnitAvail;
;|***     USHORT cbSector;
;|*** } FSALLOCATE;
;|*** typedef FSALLOCATE      *PFSALLOCATE;
;|*** 
;|*** typedef SHANDLE HDIR;        /* hdir */
;|*** typedef HDIR    *PHDIR;
;|*** 
;|*** /* XLATOFF */
;|*** #define DosOpen2        DosOpen
;|*** #define DosFindFirst2   DosFindFirst
;|*** #define DosQFHandState  DosQueryFHState
;|*** #define DosProtectQFHandState  DosProtectQueryFHState
;|*** #define DosSetFHandState        DosSetFHState
;|*** #define DosProtectSetFHandState        DosProtectSetFHState
;|*** #define DosQHandType    DosQueryHType
;|*** #define DosQFSAttach    DosQueryFSAttach
;|*** #define DosNewSize      DosSetFileSize
;|*** #define DosProtectNewSize      DosProtectSetFileSize
;|*** #define DosBufReset     DosResetBuffer
;|*** #define DosChgFilePtr   DosSetFilePtr
;|*** #define DosProtectChgFilePtr   DosProtectSetFilePtr
;|*** #define DosMkDir        DosCreateDir
;|*** #define DosMkDir2       DosCreateDir
;|*** #define DosRmDir        DosDeleteDir
;|*** #define DosSelectDisk   DosSetDefaultDisk
;|*** #define DosQCurDisk     DosQueryCurrentDisk
;|*** #define DosChDir        DosSetCurrentDir
;|*** #define DosQCurDir      DosQueryCurrentDir
;|*** #define DosQFSInfo      DosQueryFSInfo
;|*** #define DosQVerify      DosQueryVerify
;|*** #define DosQFileInfo    DosQueryFileInfo
;|*** #define DosProtectQFileInfo    DosProtectQueryFileInfo
;|*** #define DosQPathInfo    DosQueryPathInfo
;|*** /* XLATON */
;|*** 
;|*** APIRET  APIENTRY DosOpenChangeNotify(PCNPATH PathBuf, ULONG LogSize, PHDIR hdir,
;|***                                      ULONG ulReserved);
;|*** APIRET  APIENTRY DosResetChangeNotify(PCNINFO LogBuf, ULONG BufferSize,
;|***                                       PULONG LogCount, HDIR hdir);
;|*** APIRET  APIENTRY DosCloseChangeNotify(HDIR hdir);
;|*** 
;|*** APIRET  APIENTRY        DosDelete(PSZ pszFile);
;|*** 
;|*** APIRET  APIENTRY        DosForceDelete(PSZ pszFile);
;|*** 
;|*** APIRET  APIENTRY        DosDupHandle(HFILE hFile, PHFILE pHfile);
;|*** 
;|*** APIRET  APIENTRY        DosQueryFHState(HFILE hFile, PULONG pMode);
;|*** APIRET  APIENTRY        DosProtectQueryFHState(HFILE hFile, PULONG pMode,
;|***                                                FHLOCK fhFileHandleLockID);
;|*** 
;|*** APIRET  APIENTRY        DosSetFHState(HFILE hFile, ULONG mode);
;|*** APIRET  APIENTRY        DosProtectSetFHState(HFILE hFile, ULONG mode,
;|***                                              FHLOCK fhFileHandleLockID);
;|*** 
;|*** APIRET  APIENTRY        DosQueryHType(HFILE hFile, PULONG pType, PULONG pAttr);
;|*** 
;|*** APIRET  APIENTRY        DosFindFirst(PSZ pszFileSpec, PHDIR phdir, ULONG flAttribute, PVOID pfindbuf, ULONG cbBuf, PULONG pcFileNames, ULONG ulInfoLevel );
;|*** 
;|*** APIRET  APIENTRY        DosFindNext(HDIR hdir, PVOID pfindbuf, ULONG cbfindbuf, PULONG pcFilenames );
;|*** 
;|*** APIRET  APIENTRY        DosFindClose(HDIR hDir);
;|*** 
;|*** APIRET  APIENTRY        DosFSAttach(PSZ pszDevice, PSZ pszFilesystem, PVOID pData, ULONG cbData, ULONG flag);
;|*** 
;|*** APIRET  APIENTRY        DosQueryFSAttach(PSZ pszDeviceName, ULONG ulOrdinal, ULONG ulFSAInfoLevel, PFSQBUFFER2 pfsqb, PULONG pcbBuffLength );
;|*** 
;|*** APIRET  APIENTRY        DosFSCtl(PVOID pData, ULONG cbData, PULONG pcbData, PVOID pParms, ULONG cbParms, PULONG pcbParms, ULONG function, PSZ pszRoute, HFILE hFile, ULONG method);
;|*** 
;|*** APIRET  APIENTRY        DosSetFileSize(HFILE hFile, ULONG cbSize);
;|*** APIRET  APIENTRY        DosProtectSetFileSize(HFILE hFile, ULONG cbSize,
;|***                                               FHLOCK fhFileHandleLockID);
;|*** 
;|*** APIRET  APIENTRY        DosResetBuffer(HFILE hFile);
;|*** 
;|*** APIRET  APIENTRY        DosSetFilePtr(HFILE hFile, LONG ib, ULONG method, PULONG ibActual);
;|*** APIRET  APIENTRY        DosProtectSetFilePtr(HFILE hFile, LONG ib,
;|***                                              ULONG method, PULONG ibActual,
;|***                                              FHLOCK fhFileHandleLockID);
;|*** 
;|*** APIRET  APIENTRY        DosMove(PSZ pszOld, PSZ pszNew);
;|*** 
;|*** APIRET  APIENTRY        DosCopy(PSZ pszOld, PSZ pszNew, ULONG option);
;|*** 
;|*** APIRET  APIENTRY        DosEditName(ULONG metalevel, PSZ pszSource, PSZ pszEdit, PBYTE pszTarget, ULONG cbTarget);
;|*** 
;|*** APIRET  APIENTRY        DosCreateDir(PSZ pszDirName, PEAOP2 peaop2 );
;|*** 
;|*** APIRET  APIENTRY        DosDeleteDir(PSZ pszDir);
;|*** 
;|*** APIRET  APIENTRY        DosSetDefaultDisk(ULONG disknum);
;|*** 
;|*** APIRET  APIENTRY        DosQueryCurrentDisk(PULONG pdisknum, PULONG plogical);
;|*** 
;|*** APIRET  APIENTRY        DosSetCurrentDir(PSZ pszDir);
;|*** 
;|*** APIRET  APIENTRY        DosQueryCurrentDir(ULONG disknum, PBYTE pBuf, PULONG pcbBuf);
;|*** 
;|*** APIRET  APIENTRY        DosQueryFSInfo(ULONG disknum, ULONG infolevel, PVOID pBuf, ULONG cbBuf);
;|*** 
;|*** APIRET  APIENTRY        DosSetFSInfo(ULONG disknum, ULONG infolevel, PVOID pBuf, ULONG cbBuf);
;|*** 
;|*** APIRET  APIENTRY        DosQueryVerify(PBOOL32 pBool);
;|*** 
;|*** APIRET  APIENTRY        DosSetVerify(BOOL32);
;|*** 
;|*** APIRET  APIENTRY        DosSetMaxFH(ULONG cFH);
;|*** 
;|*** APIRET  APIENTRY        DosSetRelMaxFH(PLONG pcbReqCount, PULONG pcbCurMaxFH);
;|*** 
;|*** APIRET  APIENTRY        DosQueryFileInfo(HFILE hf, ULONG ulInfoLevel, PVOID pInfo,  ULONG cbInfoBuf );
;|*** APIRET  APIENTRY        DosProtectQueryFileInfo(HFILE hf, ULONG ulInfoLevel,
;|***                                                 PVOID pInfo, ULONG cbInfoBuf,
;|***                                                 FHLOCK fhFileHandleLockID);
;|*** 
;|*** APIRET  APIENTRY        DosSetFileInfo(HFILE hf, ULONG ulInfoLevel, PVOID pInfoBuf, ULONG cbInfoBuf );
;|*** APIRET  APIENTRY        DosProtectSetFileInfo(HFILE hf, ULONG ulInfoLevel,
;|***                                               PVOID pInfoBuf, ULONG cbInfoBuf,
;|***                                               FHLOCK fhFileHandleLockID);
;|*** 
;|*** APIRET  APIENTRY        DosQueryPathInfo(PSZ pszPathName, ULONG ulInfoLevel, PVOID pInfoBuf, ULONG cbInfoBuf );
;|*** 
;|*** APIRET  APIENTRY        DosSetPathInfo(PSZ pszPathName, ULONG ulInfoLevel, PVOID pInfoBuf, ULONG cbInfoBuf, ULONG flOptions );
;|*** 
;|*** /* defines for DosSetPathInfo -pathinfo flag */
;|*** #define DSPI_WRTTHRU    0x10    /* write through */
;|*** 
;|*** APIRET  APIENTRY        DosShutdown(ULONG ulReserved);
;|*** 
;|*** APIRET  APIENTRY        DosEnumAttribute(ULONG ulRefType, PVOID pvFile, ULONG ulEntry, PVOID pvBuf, ULONG cbBuf, PULONG pulCount, ULONG ulInfoLevel );
;|*** 
;|*** APIRET  APIENTRY        DosProtectEnumAttribute(ULONG ulRefType, PVOID pvFile, ULONG ulEntry, PVOID pvBuf, ULONG cbBuf, PULONG pulCount, ULONG ulInfoLevel, FHLOCK fhFileHandleLockID );
;|*** 
;|*** /* XLATOFF */
;|*** #pragma pack(1)
;|*** /* XLATON */
;|*** 
;|*** typedef struct _DENA1 { /* _dena1 level 1 info returned from DosEnumAttribute */
;|***     UCHAR       reserved;       /* 0 */
;|***     UCHAR       cbName;         /* length of name exculding NULL */
;|***     USHORT      cbValue;        /* length of value */
;|***     UCHAR       szName[1];      /* variable length asciiz name */
;|*** } DENA1;
;|*** typedef DENA1 FAR *PDENA1;
;|*** 
;|*** /* XLATOFF */
;|*** #pragma pack()
;|*** /* XLATON */
;|*** 
;|*** typedef FEA2 DENA2;
;|*** typedef PFEA2 PDENA2;
;|*** 
;|*** /* Infolevels for DosEnumAttribute  */
;|*** #define ENUMEA_LEVEL_NO_VALUE   1L      /* FEA without value */
;|*** /* Reference types for DosEnumAttribute */
;|*** #define ENUMEA_REFTYPE_FHANDLE  0       /* file handle */
;|*** #define ENUMEA_REFTYPE_PATH     1       /* path name */
;|*** #define ENUMEA_REFTYPE_MAX      ENUMEA_REFTYPE_PATH
;|*** 
;|*** #endif /* common INCL_DOSFILEMGR */
;|*** 
;|*** #if (defined(INCL_DOSMEMMGR) || !defined(INCL_NOCOMMON))
;|*** /*** Memory management */
;|*** 
;|*** APIRET  APIENTRY        DosAllocMem(PPVOID ppb, ULONG cb, ULONG flag);
;|*** 
;|*** APIRET  APIENTRY        DosFreeMem(PVOID pb);
;|*** 
;|*** APIRET  APIENTRY        DosSetMem(PVOID pb, ULONG cb, ULONG flag);
;|*** 
;|*** APIRET  APIENTRY        DosGiveSharedMem(PVOID pb, PID pid, ULONG flag);
;|*** 
;|*** APIRET  APIENTRY        DosGetSharedMem(PVOID pb, ULONG flag);
;|*** 
;|*** APIRET  APIENTRY        DosGetNamedSharedMem(PPVOID ppb, PSZ pszName, ULONG flag);
;|*** 
;|*** APIRET  APIENTRY        DosAllocSharedMem(PPVOID ppb, PSZ pszName, ULONG cb, ULONG flag);
;|*** 
;|*** APIRET  APIENTRY        DosQueryMem(PVOID pb, PULONG pcb, PULONG pFlag);
;|*** 
;|*** #define DosSubAlloc     DosSubAllocMem
;|*** #define DOSSUBALLOC     DosSubAllocMem
;|*** APIRET  APIENTRY        DosSubAllocMem(PVOID pbBase, PPVOID ppb, ULONG cb);
;|*** 
;|*** #define DosSubFree      DosSubFreeMem
;|*** #define DOSSUBFREE      DosSubFreeMem
;|*** APIRET  APIENTRY        DosSubFreeMem(PVOID pbBase, PVOID pb, ULONG cb);
;|*** 
;|*** #define DosSubSet       DosSubSetMem
;|*** #define DOSSUBSET       DosSubSetMem
;|*** APIRET  APIENTRY        DosSubSetMem(PVOID pbBase, ULONG flag, ULONG cb);
;|*** 
;|*** #define DosSubUnset     DosSubUnsetMem
;|*** #define DOSSUBUNSET     DosSubUnsetMem
;|*** APIRET  APIENTRY        DosSubUnsetMem(PVOID pbBase);
;|*** 
;|*** #include <bsememf.h>    /* get flags for API                            */
;|*** 
;|*** #endif /* INCL_DOSMEMMGR */
;|*** 
;|*** #if (defined(INCL_DOSSEMAPHORES) || !defined(INCL_NOCOMMON))
;|*** 
;|*** /*
;|***  *     32-bit Semaphore Support
;|***  */
;|*** 
;|*** /* Semaphore Attributes */
;|*** 
;|*** #define DC_SEM_SHARED   0x01      /* DosCreateMutex, DosCreateEvent, and     */
;|***                                   /*   DosCreateMuxWait use it to indicate   */
;|***                                   /*   whether the semaphore is shared or    */
;|***                                   /*   private when the PSZ is null          */
;|*** #define DCMW_WAIT_ANY   0x02      /* DosCreateMuxWait option for wait on any */
;|***                                   /*   event/mutex to occur                  */
;|*** #define DCMW_WAIT_ALL   0x04      /* DosCreateMuxWait option for wait on all */
;|***                                   /*   events/mutexs to occur                */
;|*** 
;|*** /* PMxxxxxx */
;|*** #define DC_SEM_PM       0x40      /* PM Shared Event Semaphore.              */
;|*** 
;|*** #define PM_EVENT_POSTED 3000      /* PM Shared Event Posted                  */
;|*** 
;|*** #define SEM_INDEFINITE_WAIT      0xFFFFFFFF
;|*** #define SEM_IMMEDIATE_RETURN     0L
;|*** 
;|*** typedef struct _PSEMRECORD {    /* psr */
;|***     HSEM        hsemCur;
;|***     ULONG       ulUser;
;|*** } SEMRECORD;
;|*** typedef SEMRECORD       *PSEMRECORD;
;|*** 
;|*** #endif /* common INCL_DOSSEMAPHORES */
;|*** 
;|*** #ifdef INCL_DOSSEMAPHORES
;|*** 
;|*** typedef  ULONG    HEV;             /* hev */
;|*** typedef  HEV      *PHEV;
;|*** typedef  ULONG    HMTX;            /* hmtx */
;|*** typedef  HMTX     *PHMTX;
;|*** typedef  ULONG    HMUX;            /* hmux */
;|*** typedef  HMUX     *PHMUX;
;|*** 
;|*** APIRET  APIENTRY        DosCreateEventSem (PSZ pszName, PHEV phev, ULONG flAttr, BOOL32 fState);
;|*** APIRET  APIENTRY        DosOpenEventSem (PSZ pszName, PHEV phev);
;|*** APIRET  APIENTRY        DosCloseEventSem (HEV hev);
;|*** APIRET  APIENTRY        DosResetEventSem (HEV hev, PULONG pulPostCt);
;|*** APIRET  APIENTRY        DosPostEventSem (HEV hev);
;|*** APIRET  APIENTRY        DosWaitEventSem (HEV hev, ULONG ulTimeout);
;|*** APIRET  APIENTRY        DosQueryEventSem (HEV hev, PULONG pulPostCt);
;|*** 
;|*** APIRET  APIENTRY        DosCreateMutexSem (PSZ pszName, PHMTX phmtx, ULONG flAttr, BOOL32 fState);
;|*** APIRET  APIENTRY        DosOpenMutexSem (PSZ pszName, PHMTX phmtx);
;|*** APIRET  APIENTRY        DosCloseMutexSem (HMTX hmtx);
;|*** APIRET  APIENTRY        DosRequestMutexSem (HMTX hmtx, ULONG ulTimeout);
;|*** APIRET  APIENTRY        DosReleaseMutexSem (HMTX hmtx);
;|*** APIRET  APIENTRY        DosQueryMutexSem (HMTX hmtx, PPID ppid, PTID ptid, PULONG pulCount);
;|*** 
;|*** APIRET  APIENTRY        DosCreateMuxWaitSem (PSZ pszName, PHMUX phmux, ULONG cSemRec, PSEMRECORD pSemRec, ULONG flAttr);
;|*** APIRET  APIENTRY        DosOpenMuxWaitSem (PSZ pszName, PHMUX phmux);
;|*** APIRET  APIENTRY        DosCloseMuxWaitSem (HMUX hmux);
;|*** APIRET  APIENTRY        DosWaitMuxWaitSem (HMUX hmux, ULONG ulTimeout, PULONG pulUser);
;|*** APIRET  APIENTRY        DosAddMuxWaitSem (HMUX hmux, PSEMRECORD pSemRec);
;|*** APIRET  APIENTRY        DosDeleteMuxWaitSem (HMUX hmux, HSEM hSem);
;|*** APIRET  APIENTRY        DosQueryMuxWaitSem (HMUX hmux, PULONG pcSemRec, PSEMRECORD pSemRec, PULONG pflAttr);
;|*** 
;|*** APIRET  APIENTRY        DosPMPostEventSem (HEV hev);
;|*** APIRET  APIENTRY        DosPMWaitEventSem (HEV pmhev, HEV hev, ULONG ulTimeout);
;|*** APIRET  APIENTRY        DosPMRequestMutexSem (HEV hev, HMTX hmtx, ULONG ulTimeout);
;|*** APIRET  APIENTRY        DosPMWaitMuxWaitSem (HEV hev, HMUX hmux, ULONG ulTimeout, PULONG pulUser);
;|*** 
;|*** #endif /* INCL_DOSSEMAPHORES */
;|*** 
;|*** #if (defined(INCL_DOSDATETIME) || !defined(INCL_NOCOMMON))
;|*** 
;|*** /*** Time support */
;|*** 
;|*** typedef struct _DATETIME {    /* date */
;|***     UCHAR   hours;
;|***     UCHAR   minutes;
;|***     UCHAR   seconds;
;|***     UCHAR   hundredths;
;|***     UCHAR   day;
;|***     UCHAR   month;
;|***     USHORT  year;
;|***     SHORT   timezone;
;|***     UCHAR   weekday;
;|*** } DATETIME;
;|*** typedef DATETIME        *PDATETIME;
;|*** 
;|*** APIRET  APIENTRY        DosGetDateTime(PDATETIME pdt);
;|*** 
;|*** APIRET  APIENTRY        DosSetDateTime(PDATETIME pdt);
;|*** 
;|*** #endif /* common INCL_DOSDATETIME */
;|*** 
;|*** #ifdef INCL_DOSDATETIME
;|*** 
;|*** /* XLATOFF */
;|*** #define DosTimerAsync   DosAsyncTimer
;|*** #define DosTimerStart   DosStartTimer
;|*** #define DosTimerStop    DosStopTimer
;|*** /* XLATON */
;|*** 
;|*** typedef SHANDLE HTIMER;
;|*** typedef HTIMER  *PHTIMER;
;|*** 
;|*** APIRET  APIENTRY        DosAsyncTimer(ULONG msec, HSEM hsem, PHTIMER phtimer);
;|*** 
;|*** APIRET  APIENTRY        DosStartTimer(ULONG msec, HSEM hsem, PHTIMER phtimer);
;|*** 
;|*** APIRET  APIENTRY        DosStopTimer(HTIMER htimer);
;|*** 
;|*** #endif /* INCL_DOSDATETIME */
;|*** 
;|*** 
;|*** /*** Module manager */
;|*** 
;|*** #ifdef INCL_DOSMODULEMGR
;|*** 
;|*** /* XLATOFF */
;|*** #define DosGetProcAddr          DosQueryProcAddr
;|*** #define DosGetModHandle         DosQueryModuleHandle
;|*** #define DosGetModName           DosQueryModuleName
;|*** /* XLATON */
;|*** 
;|*** APIRET  APIENTRY  DosLoadModule(PSZ pszName, ULONG cbName, PSZ pszModname, PHMODULE phmod);
;|*** 
;|*** APIRET  APIENTRY  DosFreeModule(HMODULE hmod);
;|*** 
;|*** APIRET  APIENTRY  DosQueryProcAddr(HMODULE hmod, ULONG ordinal, PSZ pszName,PFN* ppfn);
;|*** 
;|*** APIRET  APIENTRY  DosQueryModuleHandle(PSZ pszModname, PHMODULE phmod);
;|*** 
;|*** APIRET  APIENTRY  DosQueryModuleName(HMODULE hmod, ULONG cbName, PCHAR pch);
;|*** 
;|*** #define PT_16BIT  0
;|*** #define PT_32BIT  1
;|*** 
;|*** APIRET  APIENTRY  DosQueryProcType(HMODULE hmod, ULONG ordinal, PSZ pszName, PULONG pulproctype);
;|*** 
;|*** APIRET  APIENTRY  DosQueryModFromEIP(HMODULE *phMod, ULONG *pObjNum, ULONG BuffLen, PCHAR pBuff, ULONG *pOffset, ULONG Address);
;|*** 
;|*** #define HW_CFG_MCA              0x00000001
;|*** #define HW_CFG_EISA             0x00000002
;|*** #define HW_CFG_ABIOS_SUPPORTED  0x00000004
;|*** #define HW_CFG_ABIOS_PRESENT    0x00000008
;|*** 
;|*** APIRET  APIENTRY DosQueryABIOSSupport(ULONG reserved);
;|*** 
;|*** #endif /* INCL_DOSMODULEMGR */
;|*** 
;|*** #if (defined(INCL_DOSRESOURCES) || !defined(INCL_NOCOMMON))
;|*** 
;|*** /*** Resource support */
;|*** 
;|*** /* Predefined resource types */
;|*** 
;|*** #define RT_POINTER      1   /* mouse pointer shape */
;|*** #define RT_BITMAP       2   /* bitmap */
;|*** #define RT_MENU         3   /* menu template */
;|*** #define RT_DIALOG       4   /* dialog template */
;|*** #define RT_STRING       5   /* string tables */
;|*** #define RT_FONTDIR      6   /* font directory */
;|*** #define RT_FONT         7   /* font */
;|*** #define RT_ACCELTABLE   8   /* accelerator tables */
;|*** #define RT_RCDATA       9   /* binary data */
;|*** #define RT_MESSAGE      10  /* error msg     tables */
;|*** #define RT_DLGINCLUDE   11  /* dialog include file name */
;|*** #define RT_VKEYTBL      12  /* key to vkey tables */
;|*** #define RT_KEYTBL       13  /* key to UGL tables */
;|*** #define RT_CHARTBL      14  /* glyph to character tables */
;|*** #define RT_DISPLAYINFO  15  /* screen display information */
;|*** 
;|*** #define RT_FKASHORT     16  /* function key area short form */
;|*** #define RT_FKALONG      17  /* function key area long form */
;|*** 
;|*** #define RT_HELPTABLE    18  /* Help table for Cary Help manager */
;|*** #define RT_HELPSUBTABLE 19  /* Help subtable for Cary Help manager */
;|*** 
;|*** #define RT_FDDIR        20  /* DBCS uniq/font driver directory */
;|*** #define RT_FD           21  /* DBCS uniq/font driver */
;|*** 
;|*** #define RT_MAX          22  /* 1st unused Resource Type */
;|*** 
;|*** 
;|*** #define RF_ORDINALID    0x80000000L     /* ordinal id flag in resource table */
;|*** 
;|*** #endif /* common INCL_DOSRESOURCES */
;|*** 
;|*** #ifdef INCL_DOSRESOURCES
;|*** 
;|*** /* XLATOFF */
;|*** #define DosGetResource2 DosGetResource
;|*** /* XLATON */
;|*** 
;|*** APIRET  APIENTRY        DosGetResource(HMODULE hmod, ULONG idType, ULONG idName, PPVOID ppb);
;|*** 
;|*** APIRET  APIENTRY        DosFreeResource(PVOID pb);
;|*** 
;|*** APIRET  APIENTRY        DosQueryResourceSize(HMODULE hmod, ULONG idt, ULONG idn, PULONG pulsize);
;|*** 
;|*** #endif /* INCL_DOSRESOURCES */
;|*** 
;|*** 
;|*** /*** NLS Support */
;|*** 
;|*** #ifdef INCL_DOSNLS
;|*** 
;|*** typedef struct _COUNTRYCODE { /* ctryc */
;|***     ULONG       country;
;|***     ULONG       codepage;
;|*** } COUNTRYCODE;
;|*** typedef COUNTRYCODE     *PCOUNTRYCODE;
;|*** 
;|*** typedef struct _COUNTRYINFO { /* ctryi */
;|***     ULONG       country;
;|***     ULONG       codepage;
;|***     ULONG       fsDateFmt;
;|***     CHAR        szCurrency[5];
;|***     CHAR        szThousandsSeparator[2];
;|***     CHAR        szDecimal[2];
;|***     CHAR        szDateSeparator[2];
;|***     CHAR        szTimeSeparator[2];
;|***     UCHAR       fsCurrencyFmt;
;|***     UCHAR       cDecimalPlace;
;|***     UCHAR       fsTimeFmt;
;|***     USHORT      abReserved1[2];
;|***     CHAR        szDataSeparator[2];
;|***     USHORT      abReserved2[5];
;|*** } COUNTRYINFO;
;|*** typedef COUNTRYINFO     *PCOUNTRYINFO;
;|*** 
;|*** /* XLATOFF */
;|*** #define DosGetCtryInfo  DosQueryCtryInfo
;|*** #define DosGetDBCSEv    DosQueryDBCSEnv
;|*** #define DosCaseMap      DosMapCase
;|*** #define DosGetCollate   DosQueryCollate
;|*** #define DosGetCp        DosQueryCp
;|*** #define DosSetProcCp    DosSetProcessCp
;|*** /* XLATON */
;|*** 
;|*** APIRET  APIENTRY        DosQueryCtryInfo(ULONG cb, PCOUNTRYCODE pcc, PCOUNTRYINFO pci, PULONG pcbActual);
;|*** 
;|*** APIRET  APIENTRY        DosQueryDBCSEnv(ULONG cb, PCOUNTRYCODE pcc, PCHAR pBuf);
;|*** 
;|*** APIRET  APIENTRY        DosMapCase(ULONG cb, PCOUNTRYCODE pcc, PCHAR pch);
;|*** 
;|*** APIRET  APIENTRY        DosQueryCollate(ULONG cb, PCOUNTRYCODE pcc, PCHAR pch, PULONG pcch);
;|*** 
;|*** APIRET  APIENTRY        DosQueryCp(ULONG cb, PULONG arCP, PULONG pcCP);
;|*** 
;|*** APIRET  APIENTRY        DosSetProcessCp(ULONG cp);
;|*** 
;|*** #endif /* INCL_DOSNLS */
;|*** 
;|*** 
;|*** /*** Signal support */
;|*** 
;|*** #ifdef INCL_DOSEXCEPTIONS
;|*** 
;|*** /* DosSetSigExceptionFocus codes */
;|*** 
;|*** #define SIG_UNSETFOCUS 0
;|*** #define SIG_SETFOCUS 1
;|*** 
;|*** #include <bsexcpt.h>
;|*** 
;|*** APIRET  APIENTRY        DosSetExceptionHandler(PEXCEPTIONREGISTRATIONRECORD pERegRec);
;|*** 
;|*** APIRET  APIENTRY        DosUnsetExceptionHandler(PEXCEPTIONREGISTRATIONRECORD pERegRec);
;|*** 
;|*** APIRET  APIENTRY        DosRaiseException(PEXCEPTIONREPORTRECORD pexcept);
;|*** 
;|*** APIRET  APIENTRY        DosSendSignalException(PID pid, ULONG exception);
;|*** 
;|*** APIRET  APIENTRY        DosUnwindException(PEXCEPTIONREGISTRATIONRECORD phandler, PVOID pTargetIP, PEXCEPTIONREPORTRECORD pERepRec);
;|*** 
;|*** APIRET  APIENTRY        DosSetSignalExceptionFocus(BOOL32 flag, PULONG pulTimes);
;|*** 
;|*** APIRET  APIENTRY        DosEnterMustComplete(PULONG pulNesting);
;|*** 
;|*** APIRET  APIENTRY        DosExitMustComplete(PULONG pulNesting);
;|*** 
;|*** APIRET  APIENTRY        DosAcknowledgeSignalException(ULONG ulSignalNum);
;|*** 
;|*** #endif /* INCL_DOSEXCEPTIONS */
;|*** 
;|*** 
;|*** /*** Pipe and queue support */
;|*** 
;|*** #ifdef INCL_DOSQUEUES
;|*** #if (defined(INCL_DOSFILEMGR) || !defined(INCL_NOCOMMON))
;|*** 
;|*** typedef SHANDLE HQUEUE;  /* hq */
;|*** typedef HQUEUE  *PHQUEUE;
;|*** typedef struct _REQUESTDATA {   /* reqqdata */
;|***     PID         pid;
;|***     ULONG       ulData;
;|*** } REQUESTDATA;
;|*** typedef REQUESTDATA     *PREQUESTDATA;
;|*** 
;|*** #define QUE_FIFO              0L
;|*** #define QUE_LIFO              1L
;|*** #define QUE_PRIORITY          2L
;|*** #define QUE_NOCONVERT_ADDRESS 0L
;|*** #define QUE_CONVERT_ADDRESS   4L
;|*** 
;|*** /* XLATOFF */
;|*** #define DosMakePipe     DosCreatePipe
;|*** /* XLATON */
;|*** 
;|*** APIRET  APIENTRY        DosCreatePipe(PHFILE phfRead, PHFILE phfWrite, ULONG cb);
;|*** 
;|*** APIRET  APIENTRY        DosCloseQueue(HQUEUE hq);
;|*** 
;|*** APIRET  APIENTRY        DosCreateQueue(PHQUEUE phq, ULONG priority, PSZ pszName);
;|*** 
;|*** APIRET  APIENTRY        DosOpenQueue(PPID ppid, PHQUEUE phq, PSZ pszName);
;|*** 
;|*** APIRET  APIENTRY        DosPeekQueue(HQUEUE hq, PREQUESTDATA pRequest, PULONG pcbData, PPVOID ppbuf, PULONG element, BOOL32 nowait, PBYTE ppriority, HEV hsem);
;|*** 
;|*** APIRET  APIENTRY        DosPurgeQueue(HQUEUE hq);
;|*** 
;|*** APIRET  APIENTRY        DosQueryQueue(HQUEUE hq, PULONG pcbEntries);
;|*** 
;|*** APIRET  APIENTRY        DosReadQueue(HQUEUE hq, PREQUESTDATA pRequest, PULONG pcbData, PPVOID ppbuf, ULONG element, BOOL32 wait, PBYTE ppriority, HEV hsem);
;|*** 
;|*** APIRET  APIENTRY        DosWriteQueue(HQUEUE hq, ULONG request, ULONG cbData, PVOID pbData, ULONG priority);
;|*** 
;|*** #else /* INCL_DOSFILEMGR || !INCL_NOCOMMON */
;|*** #error PHFILE not defined - define INCL_DOSFILEMGR or undefine INCL_NOCOMMON
;|*** #endif /* INCL_DOSFILEMGR || !INCL_NOCOMMON */
;|*** #endif /* INCL_DOSQUEUES */
;|*** 
;|*** #ifdef INCL_DOSMISC
;|*** 
;|*** /* definitions for DosSearchPath control word */
;|*** #define DSP_IMPLIEDCUR          1 /* current dir will be searched first */
;|*** #define DSP_PATHREF             2 /* from env.variable */
;|*** #define DSP_IGNORENETERR        4 /* ignore net errs & continue search */
;|*** 
;|*** /* indices for DosQuerySysInfo */
;|*** #define QSV_MAX_PATH_LENGTH     1
;|*** #define Q_MAX_PATH_LENGTH       QSV_MAX_PATH_LENGTH
;|*** #define QSV_MAX_TEXT_SESSIONS   2
;|*** #define QSV_MAX_PM_SESSIONS     3
;|*** #define QSV_MAX_VDM_SESSIONS    4
;|*** #define QSV_BOOT_DRIVE          5       /* 1=A, 2=B, etc. */
;|*** #define QSV_DYN_PRI_VARIATION   6       /* 0=Absolute, 1=Dynamic */
;|*** #define QSV_MAX_WAIT            7       /* seconds */
;|*** #define QSV_MIN_SLICE           8       /* milli seconds */
;|*** #define QSV_MAX_SLICE           9       /* milli seconds */
;|*** #define QSV_PAGE_SIZE           10
;|*** #define QSV_VERSION_MAJOR       11
;|*** #define QSV_VERSION_MINOR       12
;|*** #define QSV_VERSION_REVISION    13      /* Revision letter */
;|*** #define QSV_MS_COUNT            14      /* Free running millisecond counter */
;|*** #define QSV_TIME_LOW            15      /* Low dword of time in seconds */
;|*** #define QSV_TIME_HIGH           16      /* High dword of time in seconds */
;|*** #define QSV_TOTPHYSMEM          17      /* Physical memory on system */
;|*** #define QSV_TOTRESMEM           18      /* Resident memory on system */
;|*** #define QSV_TOTAVAILMEM         19      /* Available memory for all processes */
;|*** #define QSV_MAXPRMEM            20      /* Avail private mem for calling proc */
;|*** #define QSV_MAXSHMEM            21      /* Avail shared mem for calling proc */
;|*** #define QSV_TIMER_INTERVAL      22      /* Timer interval in tenths of ms */
;|*** #define QSV_MAX_COMP_LENGTH     23      /* max len of one component in a name */
;|*** #define QSV_FGND_SG_ID          24      /* Foreground Screen Group ID 26215   */
;|*** #define QSV_FGND_PID            25      /* Foreground Process ID      26215   */
;|*** #define QSV_MAX                 QSV_MAX_COMP_LENGTH
;|*** 
;|*** /* definitions for DosError - combine with | */
;|*** #define FERR_DISABLEHARDERR     0x00000000L     /* disable hard error popups */
;|*** #define FERR_ENABLEHARDERR      0x00000001L     /* enable hard error popups */
;|*** #define FERR_ENABLEEXCEPTION    0x00000000L     /* enable exception popups */
;|*** #define FERR_DISABLEEXCEPTION   0x00000002L     /* disable exception popups */
;|*** 
;|*** /* definitions for DosDumpProcess */
;|*** #define DDP_DISABLEPROCDUMP     0x00000000L     /* disable process dumps */
;|*** #define DDP_ENABLEPROCDUMP      0x00000001L     /* enable process dumps */
;|*** #define DDP_PERFORMPROCDUMP     0x00000002L     /* perform process dump */
;|*** 
;|*** /* definitions for DosSuppressPopUps */
;|*** #define SPU_DISABLESUPPRESSION  0x00000000L     /* disable popup suppression */
;|*** #define SPU_ENABLESUPPRESSION   0x00000001L     /* enable popup suppression */
;|*** 
;|*** /* definitions for DosQueryRASInfo Index */
;|*** #define SIS_MMIOADDR            0
;|*** #define SIS_MEC_TABLE           1
;|*** #define SIS_SYS_LOG             2
;|*** 
;|*** /* definitions for DosQueryExtLIBPATH and DosSetExtLIBPATH flags parameter */
;|*** #define BEGIN_LIBPATH   1
;|*** #define END_LIBPATH     2
;|*** 
;|*** /* XLATOFF */
;|*** #define DosInsMessage   DosInsertMessage
;|*** #define DosQSysInfo     DosQuerySysInfo
;|*** /* XLATON */
;|*** 
;|*** APIRET  APIENTRY        DosError(ULONG error);
;|*** 
;|*** APIRET  APIENTRY        DosGetMessage(PCHAR* pTable, ULONG cTable, PCHAR pBuf, ULONG cbBuf, ULONG msgnumber, PSZ pszFile, PULONG pcbMsg);
;|*** 
;|*** APIRET  APIENTRY        DosErrClass(ULONG code, PULONG pClass, PULONG pAction, PULONG pLocus);
;|*** 
;|*** APIRET  APIENTRY        DosInsertMessage(PCHAR* pTable, ULONG cTable, PSZ pszMsg, ULONG cbMsg, PCHAR pBuf, ULONG cbBuf, PULONG pcbMsg);
;|*** 
;|*** APIRET  APIENTRY        DosPutMessage(HFILE hfile, ULONG cbMsg, PCHAR pBuf);
;|*** 
;|*** APIRET  APIENTRY        DosQuerySysInfo(ULONG iStart, ULONG iLast, PVOID pBuf, ULONG cbBuf);
;|*** 
;|*** APIRET  APIENTRY        DosScanEnv(PSZ pszName, PSZ *ppszValue);
;|*** 
;|*** APIRET  APIENTRY        DosSearchPath(ULONG flag, PSZ pszPathOrName, PSZ pszFilename, PBYTE pBuf, ULONG cbBuf);
;|*** 
;|*** APIRET  APIENTRY        DosQueryMessageCP(PCHAR pb, ULONG cb, PSZ pszFilename, PULONG cbBuf);
;|*** 
;|*** APIRET  APIENTRY        DosQueryRASInfo(ULONG Index, PPVOID Addr);
;|*** 
;|*** APIRET  APIENTRY        DosForceSystemDump(ULONG reserved);
;|*** 
;|*** APIRET  APIENTRY        DosDumpProcess(ULONG Flag, ULONG Drive, PID Pid);
;|*** 
;|*** APIRET  APIENTRY        DosSuppressPopUps(ULONG Flag, ULONG Drive);
;|*** 
;|*** APIRET  APIENTRY        DosSetExtLIBPATH( PSZ pszExtLIBPATH, ULONG flags);
;|*** 
;|*** APIRET  APIENTRY        DosQueryExtLIBPATH( PSZ pszExtLIBPATH, ULONG flags);
;|*** 
;|*** APIRET  APIENTRY        DosVerifyPidTid(PID Pid, TID Tid);   /* 88344 */
;|*** 
;|*** #endif /* INCL_DOSMISC */
;|*** 
;|*** 
;|*** /*** Session manager support */
;|*** 
;|*** #ifdef INCL_DOSSESMGR
;|*** 
;|*** typedef struct _STARTDATA {   /* stdata */
;|***     USHORT  Length;
;|***     USHORT  Related;
;|***     USHORT  FgBg;
;|***     USHORT  TraceOpt;
;|***     PSZ     PgmTitle;
;|***     PSZ     PgmName;
;|***     PBYTE   PgmInputs;
;|***     PBYTE   TermQ;
;|***     PBYTE   Environment;
;|***     USHORT  InheritOpt;
;|***     USHORT  SessionType;
;|***     PSZ     IconFile;
;|***     ULONG   PgmHandle;
;|***     USHORT  PgmControl;
;|***     USHORT  InitXPos;
;|***     USHORT  InitYPos;
;|***     USHORT  InitXSize;
;|***     USHORT  InitYSize;
;|***     USHORT  Reserved;
;|***     PSZ     ObjectBuffer;
;|***     ULONG   ObjectBuffLen;
;|*** } STARTDATA;
;|*** typedef STARTDATA       *PSTARTDATA;
;|*** 
;|*** #define SSF_RELATED_INDEPENDENT 0
;|*** #define SSF_RELATED_CHILD       1
;|*** 
;|*** #define SSF_FGBG_FORE           0
;|*** #define SSF_FGBG_BACK           1
;|*** 
;|*** #define SSF_TRACEOPT_NONE       0
;|*** #define SSF_TRACEOPT_TRACE      1
;|*** #define SSF_TRACEOPT_TRACEALL   2
;|*** 
;|*** #define SSF_INHERTOPT_SHELL     0
;|*** #define SSF_INHERTOPT_PARENT    1
;|*** 
;|*** /* note that these types are identical to those in pmshl.h for PROG_* */
;|*** #define SSF_TYPE_DEFAULT        0
;|*** #define SSF_TYPE_FULLSCREEN     1
;|*** #define SSF_TYPE_WINDOWABLEVIO  2
;|*** #define SSF_TYPE_PM             3
;|*** #define SSF_TYPE_VDM            4
;|*** #define SSF_TYPE_GROUP          5
;|*** #define SSF_TYPE_DLL            6
;|*** #define SSF_TYPE_WINDOWEDVDM    7
;|*** #define SSF_TYPE_PDD            8
;|*** #define SSF_TYPE_VDD            9
;|*** 
;|*** /* note that these flags are identical to those in pmshl.h for SHE_* */
;|*** #define SSF_CONTROL_VISIBLE     0x0000
;|*** #define SSF_CONTROL_INVISIBLE   0x0001
;|*** #define SSF_CONTROL_MAXIMIZE    0x0002
;|*** #define SSF_CONTROL_MINIMIZE    0x0004
;|*** #define SSF_CONTROL_NOAUTOCLOSE 0x0008
;|*** #define SSF_CONTROL_SETPOS      0x8000
;|*** 
;|*** typedef struct _STATUSDATA { /* stsdata */
;|***     USHORT Length;
;|***     USHORT SelectInd;
;|***     USHORT BondInd;
;|*** } STATUSDATA;
;|*** typedef STATUSDATA      *PSTATUSDATA;
;|*** 
;|*** /* SelectInd and BondInd paramater values for DosSetSession */
;|*** #define SET_SESSION_UNCHANGED      0
;|*** #define SET_SESSION_SELECTABLE     1
;|*** #define SET_SESSION_NON_SELECTABLE 2
;|*** #define SET_SESSION_BOND           1
;|*** #define SET_SESSION_NO_BOND        2
;|*** 
;|*** /* TargetOption (scope) parameter values for DosStopSession */
;|*** #define STOP_SESSION_SPECIFIED     0
;|*** #define STOP_SESSION_ALL           1
;|*** 
;|*** /* XLATOFF */
;|*** #define DosQAppType     DosQueryAppType
;|*** /* XLATON */
;|*** 
;|*** APIRET  APIENTRY        DosStartSession(PSTARTDATA psd, PULONG pidSession, PPID ppid);
;|*** 
;|*** APIRET  APIENTRY        DosSetSession(ULONG idSession, PSTATUSDATA psd);
;|*** 
;|*** APIRET  APIENTRY        DosSelectSession(ULONG idSession);
;|*** 
;|*** APIRET  APIENTRY        DosStopSession(ULONG scope, ULONG idSession);
;|*** 
;|*** APIRET  APIENTRY        DosQueryAppType(PSZ pszName, PULONG pFlags);
;|*** 
;|*** #endif /* INCL_DOSSESMGR */
;|*** 
;|*** #if (defined(INCL_DOSSESMGR) || defined(INCL_DOSFILEMGR))
;|*** 
;|*** /* AppType returned in by DosQueryAppType in pFlags as follows          */
;|*** #define FAPPTYP_NOTSPEC         0x00000000
;|*** #define FAPPTYP_NOTWINDOWCOMPAT 0x00000001
;|*** #define FAPPTYP_WINDOWCOMPAT    0x00000002
;|*** #define FAPPTYP_WINDOWAPI       0x00000003
;|*** #define FAPPTYP_BOUND           0x00000008
;|*** #define FAPPTYP_DLL             0x00000010
;|*** #define FAPPTYP_DOS             0x00000020
;|*** #define FAPPTYP_PHYSDRV         0x00000040 /* physical device driver       */
;|*** #define FAPPTYP_VIRTDRV         0x00000080 /* virtual device driver        */
;|*** #define FAPPTYP_PROTDLL         0x00000100 /* 'protected memory' dll       */
;|*** #define FAPPTYP_WINDOWSREAL     0x00000200 /*         real mode app        */
;|*** #define FAPPTYP_WINDOWSPROT     0x00000400 /*         protect mode app     */
;|*** #define FAPPTYP_WINDOWSPROT31   0x00001000 /*         3.1 protect mode app */
;|*** #define FAPPTYP_32BIT           0x00004000
;|*** #define FAPPTYP_EXETYPE         FAPPTYP_WINDOWAPI
;|*** 
;|*** #define FAPPTYP_RESERVED        ~(FAPPTYP_WINDOWAPI | FAPPTYP_BOUND | FAPPTYP_DLL | FAPPTYP_DOS | FAPPTYP_PHYSDRV | FAPPTYP_VIRTDRV | FAPPTYP_PROTDLL | FAPPTYP_32BIT)
;|*** 
;|*** #ifdef INCL_DOSFILEMGR
;|*** 
;|*** #define EAT_APPTYP_PMAPI        0x00            /* Uses PM API */
;|*** #define EAT_APPTYP_DOS          0x01            /* DOS APP */
;|*** #define EAT_APPTYP_PMW          0x02            /* Window compatible */
;|*** #define EAT_APPTYP_NOPMW        0x03            /* Not Window compatible */
;|*** #define EAT_APPTYP_EXETYPE      0x03            /* EXE type mask */
;|*** #define EAT_APPTYP_RESERVED     ~(EAT_APPTYP_EXETYPE)
;|*** 
;|*** #endif /* INCL_DOSFILEMGR */
;|*** 
;|*** #endif /* INCL_DOSSESMGR || INCL_DOSFILEMGR */
;|*** 
;|*** 
;|*** /*** Device support */
;|*** 
;|*** #ifdef INCL_DOSDEVICES
;|*** 
;|*** /* XLATOFF */
;|*** #define DosDevIOCtl2    DosDevIOCtl
;|*** /* XLATON */
;|*** 
;|*** APIRET  APIENTRY        DosDevConfig(PVOID pdevinfo, ULONG item);
;|*** #define DEVINFO_PRINTER         0       /* Number of printers attached */
;|*** #define DEVINFO_RS232           1       /* Number of RS232 ports */
;|*** #define DEVINFO_FLOPPY          2       /* Number of diskette drives */
;|*** #define DEVINFO_COPROCESSOR     3       /* Presence of math coprocessor */
;|*** #define DEVINFO_SUBMODEL        4       /* PC Submodel Type */
;|*** #define DEVINFO_MODEL           5       /* PC Model Type */
;|*** #define DEVINFO_ADAPTER         6       /* Primary display adapter type */
;|*** 
;|*** APIRET  APIENTRY        DosDevIOCtl(HFILE hDevice, ULONG category, ULONG function, PVOID pParams, ULONG cbParmLenMax, PULONG pcbParmLen, PVOID pData, ULONG cbDataLenMax, PULONG pcbDataLen);
;|*** 
;|*** 
;|*** APIRET  APIENTRY        DosPhysicalDisk(ULONG function, PVOID pBuf, ULONG cbBuf, PVOID pParams, ULONG cbParams);
;|*** #define INFO_COUNT_PARTITIONABLE_DISKS  1       /* # of partitionable disks */
;|*** #define INFO_GETIOCTLHANDLE             2       /* Obtain handle            */
;|*** #define INFO_FREEIOCTLHANDLE            3       /* Release handle           */
;|*** 
;|*** #endif /* INCL_DOSDEVICES */
;|*** 
;|*** 
;|*** /*** DosNamedPipes API Support */
;|*** 
;|*** #ifdef INCL_DOSNMPIPES
;|*** 
;|*** /*** Data structures used with named pipes ***/
;|*** 
;|*** typedef SHANDLE HPIPE;     /* hp */
;|*** typedef HPIPE   *PHPIPE;
;|*** 
;|*** typedef struct _AVAILDATA {             /* AVAILDATA */
;|***     USHORT      cbpipe;                 /* bytes left in the pipe */
;|***     USHORT      cbmessage;              /* bytes left in the current message */
;|*** } AVAILDATA;
;|*** typedef AVAILDATA FAR *PAVAILDATA;
;|*** 
;|*** typedef struct _PIPEINFO {              /* nmpinf */
;|***     USHORT cbOut;                       /* length of outgoing I/O buffer */
;|***     USHORT cbIn;                        /* length of incoming I/O buffer */
;|***     BYTE   cbMaxInst;                   /* maximum number of instances   */
;|***     BYTE   cbCurInst;                   /* current number of instances   */
;|***     BYTE   cbName;                      /* length of pipe name           */
;|***     CHAR   szName[1];                   /* start of name                 */
;|*** } PIPEINFO;
;|*** typedef PIPEINFO FAR *PPIPEINFO;
;|*** 
;|*** typedef struct _PIPESEMSTATE {  /* nmpsmst */
;|***     BYTE   fStatus;             /* type of record, 0 = EOI, 1 = read ok, */
;|***                                 /* 2 = write ok, 3 = pipe closed         */
;|***     BYTE   fFlag;               /* additional info, 01 = waiting thread  */
;|***     USHORT usKey;               /* user's key value                      */
;|***     USHORT usAvail;             /* available data/space if status = 1/2  */
;|*** } PIPESEMSTATE;
;|*** typedef PIPESEMSTATE FAR *PPIPESEMSTATE;
;|*** 
;|*** #define NP_INDEFINITE_WAIT      -1
;|*** #define NP_DEFAULT_WAIT         0L
;|*** 
;|*** /* DosPeekNmPipe() pipe states */
;|*** 
;|*** #define NP_STATE_DISCONNECTED   0x0001
;|*** #define NP_STATE_LISTENING      0x0002
;|*** #define NP_STATE_CONNECTED      0x0003
;|*** #define NP_STATE_CLOSING        0x0004
;|*** 
;|*** /* DosCreateNPipe open modes */
;|*** 
;|*** #define NP_ACCESS_INBOUND       0x0000
;|*** #define NP_ACCESS_OUTBOUND      0x0001
;|*** #define NP_ACCESS_DUPLEX        0x0002
;|*** #define NP_INHERIT              0x0000
;|*** #define NP_NOINHERIT            0x0080
;|*** #define NP_WRITEBEHIND          0x0000
;|*** #define NP_NOWRITEBEHIND        0x4000
;|*** 
;|*** /* DosCreateNPipe and DosQueryNPHState state */
;|*** 
;|*** #define NP_READMODE_BYTE        0x0000
;|*** #define NP_READMODE_MESSAGE     0x0100
;|*** #define NP_TYPE_BYTE            0x0000
;|*** #define NP_TYPE_MESSAGE         0x0400
;|*** #define NP_END_CLIENT           0x0000
;|*** #define NP_END_SERVER           0x4000
;|*** #define NP_WAIT                 0x0000
;|*** #define NP_NOWAIT               0x8000
;|*** #define NP_UNLIMITED_INSTANCES  0x00FF
;|*** 
;|*** /* XLATOFF */
;|*** #define DosCallNmPipe   DosCallNPipe
;|*** #define DosConnectNmPipe        DosConnectNPipe
;|*** #define DosDisConnectNmPipe     DosDisConnectNPipe
;|*** #define DosMakeNmPipe   DosCreateNPipe
;|*** #define DosPeekNmPipe   DosPeekNPipe
;|*** #define DosQNmPHandState        DosQueryNPHState
;|*** #define DosQNmPipeInfo  DosQueryNPipeInfo
;|*** #define DosQNmPipeSemState      DosQueryNPipeSemState
;|*** #define DosRawReadNmPipe        DosRawReadNPipe
;|*** #define DosRawWriteNmPipe       DosRawWriteNPipe
;|*** #define DosSetNmPHandState      DosSetNPHState
;|*** #define DosSetNmPipeSem DosSetNPipeSem
;|*** #define DosTransactNmPipe       DosTransactNPipe
;|*** #define DosWaitNmPipe   DosWaitNPipe
;|*** /* XLATON */
;|*** 
;|*** APIRET  APIENTRY        DosCallNPipe(PSZ pszName, PVOID pInbuf, ULONG cbIn, PVOID pOutbuf, ULONG cbOut, PULONG pcbActual, ULONG msec);
;|*** 
;|*** APIRET  APIENTRY        DosConnectNPipe(HPIPE hpipe);
;|*** 
;|*** APIRET  APIENTRY        DosDisConnectNPipe(HPIPE hpipe);
;|*** 
;|*** APIRET  APIENTRY        DosCreateNPipe(PSZ pszName, PHPIPE pHpipe, ULONG openmode, ULONG pipemode, ULONG cbInbuf, ULONG cbOutbuf, ULONG msec);
;|*** 
;|*** APIRET  APIENTRY        DosPeekNPipe(HPIPE hpipe, PVOID pBuf, ULONG cbBuf, PULONG pcbActual, PAVAILDATA pAvail, PULONG pState);
;|*** 
;|*** APIRET  APIENTRY        DosQueryNPHState(HPIPE hpipe, PULONG pState);
;|*** 
;|*** APIRET  APIENTRY        DosQueryNPipeInfo(HPIPE hpipe, ULONG infolevel, PVOID pBuf, ULONG cbBuf);
;|*** 
;|*** APIRET  APIENTRY        DosQueryNPipeSemState(HSEM hsem, PPIPESEMSTATE pnpss, ULONG cbBuf);
;|*** 
;|*** APIRET  APIENTRY        DosSetNPHState(HPIPE hpipe, ULONG state);
;|*** 
;|*** APIRET  APIENTRY        DosSetNPipeSem(HPIPE hpipe, HSEM hsem, ULONG key);
;|*** 
;|*** APIRET  APIENTRY        DosTransactNPipe(HPIPE hpipe, PVOID pOutbuf, ULONG cbOut, PVOID pInbuf, ULONG cbIn, PULONG pcbRead);
;|*** 
;|*** APIRET  APIENTRY        DosWaitNPipe(PSZ pszName, ULONG msec);
;|*** 
;|*** /* values in fStatus */
;|*** #define NPSS_EOI                   0     /* End Of Information    */
;|*** #define NPSS_RDATA                 1     /* read data available   */
;|*** #define NPSS_WSPACE                2     /* write space available */
;|*** #define NPSS_CLOSE                 3     /* pipe in CLOSING state */
;|*** 
;|*** /* values in npss_flag */
;|*** #define NPSS_WAIT                  0x01  /* waiting thread on end of pipe */
;|*** 
;|*** /* defined bits in pipe mode */
;|*** #define NP_NBLK                    0x8000 /* non-blocking read/write */
;|*** #define NP_SERVER                  0x4000 /* set if server end       */
;|*** #define NP_WMESG                   0x0400 /* write messages          */
;|*** #define NP_RMESG                   0x0100 /* read as messages        */
;|*** #define NP_ICOUNT                  0x00FF /* instance count field    */
;|*** 
;|*** 
;|*** /*      Named pipes may be in one of several states depending on the actions
;|***  *      that have been taken on it by the server end and client end.  The
;|***  *      following state/action table summarizes the valid state transitions:
;|***  *
;|***  *      Current state           Action                  Next state
;|***  *
;|***  *       <none>             server DosMakeNmPipe        DISCONNECTED
;|***  *       DISCONNECTED       server connect              LISTENING
;|***  *       LISTENING          client open                 CONNECTED
;|***  *       CONNECTED          server disconn              DISCONNECTED
;|***  *       CONNECTED          client close                CLOSING
;|***  *       CLOSING            server disconn              DISCONNECTED
;|***  *       CONNECTED          server close                CLOSING
;|***  *       <any other>        server close                <pipe deallocated>
;|***  *
;|***  *      If a server disconnects his end of the pipe, the client end will enter a
;|***  *      special state in which any future operations (except close) on the file
;|***  *      descriptor associated with the pipe will return an error.
;|***  */
;|*** 
;|*** /*
;|***  *      Values for named pipe state
;|***  */
;|*** 
;|*** #define NP_DISCONNECTED            1    /* after pipe creation or Disconnect */
;|*** #define NP_LISTENING               2    /* after DosNmPipeConnect            */
;|*** #define NP_CONNECTED               3    /* after Client open                 */
;|*** #define NP_CLOSING                 4    /* after Client or Server close      */
;|*** 
;|*** 
;|*** #endif /* INCL_DOSNMPIPES */
;|*** 
;|*** 
;|*** /*** DosProfile API support */
;|*** 
;|*** #ifdef INCL_DOSPROFILE
;|*** 
;|*** /*** Perfview API support */
;|*** 
;|*** APIRET  APIENTRY        DosTmrQueryFreq(PULONG pulTmrFreq);
;|*** APIRET  APIENTRY        DosTmrQueryTime(PQWORD pqwTmrTime);
;|*** APIRET  APIENTRY        DosRegisterPerfCtrs(PBYTE pbDataBlk, PBYTE pbTextBlk, ULONG flFlags);
;|*** 
;|*** /* DosProfile ordinal number */
;|*** 
;|*** #define PROF_ORDINAL     133
;|*** 
;|*** /* DosProfile usType */
;|*** 
;|*** #define PROF_SYSTEM      0
;|*** #define PROF_USER        1
;|*** #define PROF_USEDD       2
;|*** #define PROF_KERNEL      4
;|*** #define PROF_VERBOSE     8
;|*** #define PROF_ENABLE     16
;|*** 
;|*** /* DosProfile usFunc */
;|*** 
;|*** #define PROF_ALLOC       0
;|*** #define PROF_CLEAR       1
;|*** #define PROF_ON          2
;|*** #define PROF_OFF         3
;|*** #define PROF_DUMP        4
;|*** #define PROF_FREE        5
;|*** 
;|*** /* DosProfile tic count granularity (DWORD) */
;|*** 
;|*** #define PROF_SHIFT       2
;|*** 
;|*** /* DosProfile module name string length */
;|*** 
;|*** #define PROF_MOD_NAME_SIZE   10
;|*** 
;|*** /* DosProfile error code for end of data */
;|*** 
;|*** #define PROF_END_OF_DATA     13
;|*** 
;|*** #endif /* INCL_DOSPROFILE */
;|*** 
;|*** 
;|*** /*** Virtual DOS Machine API support */
;|*** 
;|*** #ifdef INCL_DOSMVDM
;|*** 
;|*** typedef LHANDLE   HVDD;     /* hvdd */
;|*** typedef HVDD FAR *PHVDD;    /* phvdd */
;|*** 
;|*** APIRET  APIENTRY DosOpenVDD(PSZ pszVDD, PHVDD phvdd);
;|*** 
;|*** APIRET  APIENTRY DosRequestVDD(HVDD hvdd, SGID sgid, ULONG cmd,
;|***                                ULONG cbInput, PVOID pInput,
;|***                                ULONG cbOutput, PVOID pOutput);
;|*** 
;|*** APIRET  APIENTRY DosCloseVDD(HVDD hvdd);
;|*** 
;|*** APIRET  APIENTRY DosQueryDOSProperty(SGID sgid, PSZ pszName,
;|***                                      ULONG cb, PSZ pch);
;|*** 
;|*** APIRET  APIENTRY DosSetDOSProperty(SGID sgid, PSZ pszName,
;|***                                    ULONG cb, PSZ pch);
;|*** #endif /* INCL_DOSMVDM */
;|*** 
;|*** 
;|*** /* The following #else/#endif corresponds to a #if near the top of this */
;|*** /* file.  The next three lines include the 16-bit version of this file, */
;|*** /* hence these lines MUST be the last lines in this include file.       */
;|*** #else /* not INCL_32 */
;|*** 
;|*** #ifdef INCL_16
;|*** #include <bsedos16.h>
; Line 1841
;|*** 
;|*** #ifdef INCL_DOSDEVIOCTL
;|*** #include <bsedev.h>       /* Structures and constants for DosDevIOCtl */
;|*** #endif /* INCL_DOSDEVIOCTL */
;|*** 
;|*** #ifndef INCL_32
;|*** #include <bsesub.h>       /* VIO/KBD/MOU definitions */
; Line 69
;|*** #endif /* INCL_32 */
;|*** #include <bseerr.h>       /* Base error code definitions */
; Line 71
;|*** //#include <string.h>
;|*** 
;|*** #ifndef FAR
;|*** #define FAR far
;|*** #endif
;|*** 
;|*** #define building_DD
;|*** 
;|*** #define RM_DATE_STRING 1996,4,1
;|*** 
;|*** #include "rmcalls.h"
; Line 60
;|*** /**************************************************************************
;|***  *
;|***  * SOURCE FILE NAME =  RMCALLS.H
;|***  *
;|***  * DESCRIPTIVE NAME =  RM function prototypes exported to drivers
;|***  *
;|***  *
;|***  * Copyright : COPYRIGHT IBM CORPORATION, 1994, 1995
;|***  *             LICENSED MATERIAL - PROGRAM PROPERTY OF IBM
;|***  *             REFER TO COPYRIGHT INSTRUCTION FORM#G120-2083
;|***  *             RESTRICTED MATERIALS OF IBM
;|***  *             IBM CONFIDENTIAL
;|***  *
;|***  * VERSION = V1.01
;|***  *
;|***  * DATE
;|***  *
;|***  * DESCRIPTION :
;|***  *
;|***  * Purpose:
;|***  *
;|***  *
;|***  *
;|***  * FUNCTIONS  :
;|***  *
;|***  * NOTES
;|***  *
;|***  *
;|***  * STRUCTURES
;|***  *
;|***  * EXTERNAL REFERENCES
;|***  *
;|***  *
;|***  *
;|***  * EXTERNAL FUNCTIONS
;|***  *
;|***  * CHANGE ACTIVITY =
;|***  *   DATE      FLAG        APAR   CHANGE DESCRIPTION
;|***  *   --------  ----------  -----  --------------------------------------
;|***  *
;|***  ****************************************************************************/
;|*** 
;|*** 
;|*** /****************************************************************************/
;|*** /*                                                                          */
;|*** /* Function Prototypes                                                      */
;|*** /*                                                                          */
;|*** /****************************************************************************/
;|*** 
;|*** 
;|*** 
;|*** #ifndef __RM_CALLS__
;|*** #define __RM_CALLS__
;|*** 
;|*** #include <rmbase.h>
; Line 55
;|*** #include <rmioctl.h>
; Line 56
;|*** #include "COMDD.H"
; Line 61
;|*** #include "COMDCB.H"
; Line 62
;|*** #include "CUTIL.H"
; Line 63
;|*** #include "rmhelp.h"
; Line 64
;|*** /*DDK*************************************************************************/
;|*** /*                                                                           */
;|*** /* COPYRIGHT    Copyright (C) 1995 IBM Corporation                           */
;|*** /*                                                                           */
;|*** /*    The following IBM OS/2 WARP source code is provided to you solely for  */
;|*** /*    the purpose of assisting you in your development of OS/2 WARP device   */
;|*** /*    drivers. You may use this code in accordance with the IBM License      */
;|*** /*    Agreement provided in the IBM Device Driver Source Kit for OS/2. This  */
;|*** /*    Copyright statement may not be removed.                                */
;|*** /*                                                                           */
;|*** /*****************************************************************************/
;|*** /**************************************************************************
;|***  *
;|***  * SOURCE FILE NAME =  RMHELP.H
;|***  *
;|***  * DESCRIPTIVE NAME =  Header file for rmhelp.c
;|***  *
;|***  *
;|***  *
;|***  * VERSION = V0.1
;|***  *
;|***  * DATE  09/02/94
;|***  *
;|***  * DESCRIPTION : (see above)
;|***  *
;|***  * Purpose: (see above)
;|***  *
;|***  *
;|***  *
;|***  * FUNCTIONS  :
;|***  *
;|***  * NOTES
;|***  *
;|***  *
;|***  * STRUCTURES
;|***  *
;|***  * EXTERNAL REFERENCES
;|***  *
;|***  *
;|***  *
;|***  * EXTERNAL FUNCTIONS
;|***  *
;|*** */
;|*** 
;|*** #ifndef  __RMHELP_H__
;|*** #define  __RMHELP_H__
;|*** 
;|*** #include "rmcalls.h"
; Line 48
;|*** 
;|*** #define USESIRQ     1         //Driver does indeed use IRQs....
;|*** 
;|*** #define DHGETDOSV_SYSINFOSEG 1
;|*** 
;|*** WORD _far DevHelp_GetDOSVar( WORD iIndex ,PSEL *pSegment );
;|*** 
;|*** /*--------------------------------------------------------*/
;|*** /* # D E F I N E S                                        */
;|*** /*--------------------------------------------------------*/
;|*** #ifndef MAXADN                          //Maximum number of adapters
;|*** #define MAXADN 16
;|*** #endif
;|*** #ifndef MAXPORT                         //Maximum number of I/O ranges
;|*** #define MAXPORT 16
;|*** #endif
;|*** #ifndef MAXIRQ                          //Maximum number of IRQs
;|*** #define MAXIRQ  15
;|*** #endif
;|*** #define MAXRESOURCE (MAXPORT+MAXIRQ)
;|*** 
;|*** 
;|*** /*--------------------------------------------------------*/
;|*** /* Set the DRIVERSTRUCT and ADAPTERSTRUCT data areas      */
;|*** /*--------------------------------------------------------*/
;|*** 
;|*** char szAdapterDescription[80] = "SERIAL_# Serial Adapter";
;|*** char *pszUART = 0;
;|*** char sz16650UART[] = "16650";
;|*** char sz16750UART[] = "16750";
;|*** char sz16654UART[] = "16654";
;|*** char sz16550UART[] = "16550";
;|*** char sz16950UART[] = "16950";
;|*** char szUART[] = "16450";
;|*** /*----------------------------------------------*/
;|*** /* Driver Description                           */
;|*** /*----------------------------------------------*/
;|*** DRIVERSTRUCT DriverStruct =
;|*** {
;|***    "COMDD.SYS",                              /* DrvrName                */
;|***    "COMi Asynchronous Communications Driver",/* DrvrDescript            */
;|***    "OS/tools Inc.",                          /* VendorName              */
;|***    CMVERSION_MAJOR,                          /* MajorVer                */
;|***    CMVERSION_MINOR,                          /* MinorVer                */
;|***    RM_DATE_STRING,                           /* Date                    */
;|***    DRF_STATIC,                               /* DrvrFlags               */
;|***    DRT_OS2,                                  /* DrvrType                */
;|***    DRS_CHAR,                                 /* DrvrSubType             */
;|***    NULL                                      /* DrvrCallback            */
;|*** };
;|*** 
;|*** /*----------------------------------------------*/
;|*** /* Adapter Description 0                        */
;|*** /*----------------------------------------------*/
;|*** ADAPTERSTRUCT AdapterStruct=
;|*** {
;|***   szAdapterDescription,              /* AdaptDescriptName; */
;|***   AS_NO16MB_ADDRESS_LIMIT,           /* AdaptFlags;        */
;|***   AS_BASE_COMM,                      /* BaseType;          */
;|***   AS_SUB_SERIAL,                     /* SubType;           */
;|***   AS_INTF_16550,                     /* InterfaceType;     */
;|***   AS_HOSTBUS_OTHER,                  /* HostBusType;       */
;|***   AS_BUSWIDTH_16BIT,                 /* HostBusWidth;      */
;|***   NULL                               /* pAdjunctList;      */
;|*** };
;|*** 
;|*** UCHAR LComName[] = KEY_COMM;
;|*** 
;|*** UCHAR aszFSComName[MAXADN][10] = {"COM0","COM1"};
;|*** 
;|*** char szErrMsg[100] = "Just init";
;|*** USHORT usIDregIndex = 0xffff;
;|*** 
;|*** /*----------------------------------------------*/
;|*** /* GLOBAL VARS FOR RM                           */
;|*** /*                                              */
;|*** /* RM.LIB needs these declared                  */
;|*** /*----------------------------------------------*/
;|*** PFN             RM_Help               = 0L;
;|*** ULONG           RMFlags               = 0L;
;|*** ULONG           Device_Help           = 0L;
;|*** PFN             RM_Help0              = 0L;
;|*** PFN             RM_Help3              = 0L;
;|*** 
;|*** /*----------------------------------------------*/
;|*** /* GLOBAL HANDLE VARIABLES                      */
;|*** /*                                              */
;|*** /* These variables get the handles for          */
;|*** /* drivers, adapter (only 1), and resources.    */
;|*** /* The RMHELP wrappers are written so that most */
;|*** /* drivers using RMHELP as a template will not  */
;|*** /* have to reference these directly.            */
;|*** /*                                              */
;|*** /*----------------------------------------------*/
;|*** 
;|*** USHORT    cSerialNodes = 0;   /* Number of other COMi_# Nodes   */
;|*** HDRIVER   hDriver = 0;        /* global handle to driver          */
;|*** HADAPTER  hAdapter[MAXADN + 1] = {0,0};   /* global handle to adapter         */
;|*** HRESOURCE hResPorts[MAXPORT + 1] = {0,0}; /* global handles to ports resource */
;|*** HRESOURCE hResIRQs[MAXIRQ] = {0,0};   /* global handles to IRQs resource  */
;|*** 
;|*** extern WORD _far _wIntIDregister;
;|*** extern WORD _far _wMiscControl;
;|*** extern WORD _far _wBusType;
;|*** extern DEVDEF _far _stDeviceParms[];
;|*** extern COMDCB stConfigParms[];
;|*** extern WORD bSeparteIDreg;
;|*** extern RMDEF stRMparms[];
;|*** extern WORD wLoadCount;
;|*** extern WORD wLoadNumber;
;|*** extern WORD bUsesSixteenAddrLines;
;|*** extern bPnPcapable;
;|*** 
;|*** VOID FAR RMHELP_SetDevHelp(ULONG dhaddr)
;|***   {
; Line 179
	PUBLIC	_RMHELP_SetDevHelp
_RMHELP_SetDevHelp	PROC FAR
	*** 000000	c8 00 00 00 		enter	0,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	dhaddr = 6
;|***   Device_Help = dhaddr;
; Line 180
	*** 000006	8b 46 06 		mov	ax,WORD PTR [bp+6]	;dhaddr
	*** 000009	8b 56 08 		mov	dx,WORD PTR [bp+8]
	*** 00000c	a3 08 02 		mov	WORD PTR _Device_Help,ax
	*** 00000f	89 16 0a 02 		mov	WORD PTR _Device_Help+2,dx
;|***   }
; Line 181
					$EX1873:
	*** 000013	5e 			pop	si
	*** 000014	5f 			pop	di
	*** 000015	c9 			leave	
	*** 000016	cb 			ret	

_RMHELP_SetDevHelp	ENDP
;|*** 
;|*** /*--------------------------------------------------------*/
;|*** /* RMHELP_CreateDriver - registers to RM susbsystem       */
;|*** /*                       (which initializes the DD to     */
;|*** /*                        RM connection)                  */
;|*** /*                                                        */
;|*** /*--------------------------------------------------------*/
;|*** 
;|*** USHORT FAR RMHELP_CreateDriver()
;|***   {
; Line 191
	PUBLIC	_RMHELP_CreateDriver
_RMHELP_CreateDriver	PROC FAR
	*** 000017	c8 0a 00 00 		enter	10,0
	*** 00001b	57 			push	di
	*** 00001c	56 			push	si
;	rc = -2
;	HandleList = -10
;|***   USHORT     rc;
;|***   HANDLELIST HandleList;
;|*** 
;|***   memset(hResPorts,0,((MAXPORT + 1) * sizeof(HRESOURCE)));
; Line 195
	*** 00001d	6a 44 			push	68
	*** 00001f	6a 00 			push	0
	*** 000021	1e 			push	ds
	*** 000022	68 5e 02 		push	OFFSET DGROUP:_hResPorts
	*** 000025	9a 00 00 00 00 		call	FAR PTR _memset
	*** 00002a	83 c4 08 		add	sp,8
;|***   memset(hResIRQs,0,(MAXIRQ * sizeof(HRESOURCE)));
; Line 196
	*** 00002d	6a 3c 			push	60
	*** 00002f	6a 00 			push	0
	*** 000031	1e 			push	ds
	*** 000032	68 a2 02 		push	OFFSET DGROUP:_hResIRQs
	*** 000035	9a 00 00 00 00 		call	FAR PTR _memset
	*** 00003a	83 c4 08 		add	sp,8
;|*** 
;|***   if ((rc = RMCreateDriver(&DriverStruct,&hDriver)) != 0)
; Line 198
	*** 00003d	1e 			push	ds
	*** 00003e	68 16 02 		push	OFFSET DGROUP:_hDriver
	*** 000041	1e 			push	ds
	*** 000042	68 b8 00 		push	OFFSET DGROUP:_DriverStruct
	*** 000045	9a 00 00 00 00 		call	FAR PTR _RMCreateDriver
	*** 00004a	83 c4 08 		add	sp,8
	*** 00004d	89 46 fe 		mov	WORD PTR [bp-2],ax	;rc
	*** 000050	3d 00 00 		cmp	ax,0
	*** 000053	75 03 			jne	$JCC83
	*** 000055	e9 06 00 		jmp	$I1878
					$JCC83:
;|***     return(rc);
; Line 199
	*** 000058	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;rc
	*** 00005b	e9 2f 00 		jmp	$EX1874
;|*** 
;|***   HandleList.cMaxHandles = 1;
; Line 201
					$I1878:
	*** 00005e	c7 46 f6 01 00 		mov	WORD PTR [bp-10],1	;HandleList
;|*** 
;|***   if (!(RMKeyToHandleList(HANDLE_PHYS_TREE,"SERIAL*",&HandleList)))
; Line 203
	*** 000063	8d 46 f6 		lea	ax,WORD PTR [bp-10]	;HandleList
	*** 000066	16 			push	ss
	*** 000067	50 			push	ax
	*** 000068	1e 			push	ds
	*** 000069	68 de 02 		push	OFFSET DGROUP:$SG1880
	*** 00006c	6a ff 			push	-1
	*** 00006e	68 00 80 		push	-32768
	*** 000071	9a 00 00 00 00 		call	FAR PTR _RMKeyToHandleList
	*** 000076	83 c4 0c 		add	sp,12
	*** 000079	3d 00 00 		cmp	ax,0
	*** 00007c	74 03 			je	$JCC124
	*** 00007e	e9 06 00 		jmp	$I1879
					$JCC124:
;|***     {
; Line 204
;|***     cSerialNodes = HandleList.cHandles;
; Line 205
	*** 000081	8b 46 f8 		mov	ax,WORD PTR [bp-8]
	*** 000084	a3 14 02 		mov	WORD PTR _cSerialNodes,ax
;|***     }
; Line 206
;|***   return(rc);
; Line 207
					$I1879:
	*** 000087	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;rc
	*** 00008a	e9 00 00 		jmp	$EX1874
;|***   }
; Line 208
					$EX1874:
	*** 00008d	5e 			pop	si
	*** 00008e	5f 			pop	di
	*** 00008f	c9 			leave	
	*** 000090	cb 			ret	

_RMHELP_CreateDriver	ENDP
;|*** 
;|*** /*--------------------------------------------------------*/
;|*** /* RMHELP_DestroyDriver - deregisters the driver from     */
;|*** /*                        RM sub-system and releases all  */
;|*** /*                        claimed resources               */
;|*** /*                                                        */
;|*** /*--------------------------------------------------------*/
;|*** 
;|*** VOID FAR RMHELP_DestroyDriver(void)
;|***   {
; Line 218
	PUBLIC	_RMHELP_DestroyDriver
_RMHELP_DestroyDriver	PROC FAR
	*** 000091	c8 00 00 00 		enter	0,0
	*** 000095	57 			push	di
	*** 000096	56 			push	si
;|***   RMDestroyDriver(hDriver);
; Line 219
	*** 000097	ff 36 18 02 		push	WORD PTR _hDriver+2
	*** 00009b	ff 36 16 02 		push	WORD PTR _hDriver
	*** 00009f	9a 00 00 00 00 		call	FAR PTR _RMDestroyDriver
	*** 0000a4	83 c4 04 		add	sp,4
;|***   /*-------------------------*/
;|***   /* Null out global handles */
;|***   /*-------------------------*/
;|*** 
;|***   hDriver = 0;
; Line 224
	*** 0000a7	2b c0 			sub	ax,ax
	*** 0000a9	a3 18 02 		mov	WORD PTR _hDriver+2,ax
	*** 0000ac	a3 16 02 		mov	WORD PTR _hDriver,ax
;|***   memset(hAdapter,0,((MAX_DEVICE + 1) * sizeof(HRESOURCE)));
; Line 225
	*** 0000af	6a 24 			push	36
	*** 0000b1	6a 00 			push	0
	*** 0000b3	1e 			push	ds
	*** 0000b4	68 1a 02 		push	OFFSET DGROUP:_hAdapter
	*** 0000b7	9a 00 00 00 00 		call	FAR PTR _memset
	*** 0000bc	83 c4 08 		add	sp,8
;|***   memset(hResPorts,0,((MAX_DEVICE + 1) * sizeof(HRESOURCE)));
; Line 226
	*** 0000bf	6a 24 			push	36
	*** 0000c1	6a 00 			push	0
	*** 0000c3	1e 			push	ds
	*** 0000c4	68 5e 02 		push	OFFSET DGROUP:_hResPorts
	*** 0000c7	9a 00 00 00 00 		call	FAR PTR _memset
	*** 0000cc	83 c4 08 		add	sp,8
;|***   memset(hResIRQs,0,(MAX_DEVICE * sizeof(HRESOURCE)));
; Line 227
	*** 0000cf	6a 20 			push	32
	*** 0000d1	6a 00 			push	0
	*** 0000d3	1e 			push	ds
	*** 0000d4	68 a2 02 		push	OFFSET DGROUP:_hResIRQs
	*** 0000d7	9a 00 00 00 00 		call	FAR PTR _memset
	*** 0000dc	83 c4 08 		add	sp,8
;|***   }
; Line 228
					$EX1881:
	*** 0000df	5e 			pop	si
	*** 0000e0	5f 			pop	di
	*** 0000e1	c9 			leave	
	*** 0000e2	cb 			ret	

_RMHELP_DestroyDriver	ENDP
;|*** 
;|*** /*--------------------------------------------------------*/
;|*** /* RMHELP_CreateAdapter - tells RM to associate adapter   */
;|*** /*                        to driver and resources to      */
;|*** /*                        adapater                        */
;|*** /*                                                        */
;|*** /*--------------------------------------------------------*/
;|*** 
;|*** USHORT FAR RMHELP_CreateAdapter(USHORT adn)
;|***   {
; Line 238
	PUBLIC	_RMHELP_CreateAdapter
_RMHELP_CreateAdapter	PROC FAR
	*** 0000e3	c8 a0 00 00 		enter	160,0
	*** 0000e7	57 			push	di
	*** 0000e8	56 			push	si
;	pComInfo = -132
;	ResourceBuf = -128
;	pResourceList = -4
;	adj = -160
;	rescnt = -134
;	adn = 6
;|***   DEVDEF _far *pComInfo;
;|***   UCHAR       ResourceBuf[ sizeof(HRESOURCE) * MAXRESOURCE ];
;|***   PAHRESOURCE pResourceList = (PAHRESOURCE)ResourceBuf;
; Line 241
	*** 0000e9	8d 46 80 		lea	ax,WORD PTR [bp-128]	;ResourceBuf
	*** 0000ec	89 46 fc 		mov	WORD PTR [bp-4],ax	;pResourceList
	*** 0000ef	8c 56 fe 		mov	WORD PTR [bp-2],ss
;|***   ADJUNCT     adj;
;|***   USHORT      rescnt;
;|*** //  int iLen;
;|*** 
;|***   adj.pNextAdj=NULL;
; Line 246
	*** 0000f2	2b c0 			sub	ax,ax
	*** 0000f4	89 86 62 ff 		mov	WORD PTR [bp-158],ax
	*** 0000f8	89 86 60 ff 		mov	WORD PTR [bp-160],ax	;adj
;|***   adj.AdjLength=sizeof(ADJUNCT);
; Line 247
	*** 0000fc	c7 86 64 ff 19 00 	mov	WORD PTR [bp-156],25
;|***   adj.AdjType=ADJ_ADAPTER_NUMBER;
; Line 248
	*** 000102	c7 86 66 ff 02 00 	mov	WORD PTR [bp-154],2
;|***   adj.Adapter_Number = (adn + cSerialNodes);
; Line 249
	*** 000108	a1 14 02 		mov	ax,WORD PTR _cSerialNodes
	*** 00010b	03 46 06 		add	ax,WORD PTR [bp+6]	;adn
	*** 00010e	89 86 68 ff 		mov	WORD PTR [bp-152],ax
;|*** 
;|***   rescnt=0;                          //no resources to begin with
; Line 251
	*** 000112	c7 86 7a ff 00 00 	mov	WORD PTR [bp-134],0	;rescnt
;|*** 
;|***   pComInfo = &_stDeviceParms[adn];
; Line 253
	*** 000118	69 46 06 be 00 		imul	ax,WORD PTR [bp+6],190	;adn
	*** 00011d	05 00 00 		add	ax,OFFSET __stDeviceParms
	*** 000120	89 86 7c ff 		mov	WORD PTR [bp-132],ax	;pComInfo
	*** 000124	c7 86 7e ff 00 00 	mov	WORD PTR [bp-130],SEG __stDeviceParms
;|***   if ((pComInfo->usDeviceFlag2 & DEV_FLAG2_FIFO_AVAILABLE) == 0)
; Line 254
	*** 00012a	c4 9e 7c ff 		les	bx,DWORD PTR [bp-132]	;pComInfo
	*** 00012e	26 f6 47 05 08 		test	BYTE PTR es:[bx+5],8
	*** 000133	74 03 			je	$JCC307
	*** 000135	e9 0d 00 		jmp	$I1890
					$JCC307:
;|***     pszUART = szUART;
; Line 255
	*** 000138	c7 06 90 00 b2 00 	mov	WORD PTR _pszUART,OFFSET DGROUP:_szUART
	*** 00013e	8c 1e 92 00 		mov	WORD PTR _pszUART+2,ds
;|***   else
; Line 256
	*** 000142	e9 5b 00 		jmp	$I1891
					$I1890:
;|***     if (pComInfo->usDeviceFlag2 & DEV_FLAG2_16650_UART)
; Line 257
	*** 000145	c4 9e 7c ff 		les	bx,DWORD PTR [bp-132]	;pComInfo
	*** 000149	26 f6 47 04 01 		test	BYTE PTR es:[bx+4],1
	*** 00014e	75 03 			jne	$JCC334
	*** 000150	e9 0d 00 		jmp	$I1892
					$JCC334:
;|***       pszUART = sz16650UART;
; Line 258
	*** 000153	c7 06 90 00 94 00 	mov	WORD PTR _pszUART,OFFSET DGROUP:_sz16650UART
	*** 000159	8c 1e 92 00 		mov	WORD PTR _pszUART+2,ds
;|***     else
; Line 259
	*** 00015d	e9 40 00 		jmp	$I1893
					$I1892:
;|***       if (pComInfo->usDeviceFlag2 & DEV_FLAG2_16750_UART)
; Line 260
	*** 000160	c4 9e 7c ff 		les	bx,DWORD PTR [bp-132]	;pComInfo
	*** 000164	26 f6 47 04 02 		test	BYTE PTR es:[bx+4],2
	*** 000169	75 03 			jne	$JCC361
	*** 00016b	e9 0d 00 		jmp	$I1894
					$JCC361:
;|***         pszUART = sz16750UART;
; Line 261
	*** 00016e	c7 06 90 00 9a 00 	mov	WORD PTR _pszUART,OFFSET DGROUP:_sz16750UART
	*** 000174	8c 1e 92 00 		mov	WORD PTR _pszUART+2,ds
;|***       else
; Line 262
	*** 000178	e9 25 00 		jmp	$I1895
					$I1894:
;|***         if (pComInfo->usDeviceFlag2 & DEV_FLAG2_16654_UART)
; Line 263
	*** 00017b	c4 9e 7c ff 		les	bx,DWORD PTR [bp-132]	;pComInfo
	*** 00017f	26 f6 47 04 04 		test	BYTE PTR es:[bx+4],4
	*** 000184	75 03 			jne	$JCC388
	*** 000186	e9 0d 00 		jmp	$I1896
					$JCC388:
;|***           pszUART = sz16654UART;
; Line 264
	*** 000189	c7 06 90 00 a0 00 	mov	WORD PTR _pszUART,OFFSET DGROUP:_sz16654UART
	*** 00018f	8c 1e 92 00 		mov	WORD PTR _pszUART+2,ds
;|***         else
; Line 265
	*** 000193	e9 0a 00 		jmp	$I1897
					$I1896:
;|***           pszUART = sz16550UART;
; Line 266
	*** 000196	c7 06 90 00 a6 00 	mov	WORD PTR _pszUART,OFFSET DGROUP:_sz16550UART
	*** 00019c	8c 1e 92 00 		mov	WORD PTR _pszUART+2,ds
					$I1897:
					$I1895:
					$I1893:
					$I1891:
;|*** 
;|***   if (adj.Adapter_Number < 10)
; Line 268
	*** 0001a0	83 be 68 ff 0a 		cmp	WORD PTR [bp-152],10
	*** 0001a5	72 03 			jb	$JCC421
	*** 0001a7	e9 1d 00 		jmp	$I1898
					$JCC421:
;|***     sprintf(szAdapterDescription,0,"SERIAL_# %s Serial Controller",pszUART);
; Line 269
	*** 0001aa	ff 36 92 00 		push	WORD PTR _pszUART+2
	*** 0001ae	ff 36 90 00 		push	WORD PTR _pszUART
	*** 0001b2	1e 			push	ds
	*** 0001b3	68 e6 02 		push	OFFSET DGROUP:$SG1899
	*** 0001b6	6a 00 			push	0
	*** 0001b8	1e 			push	ds
	*** 0001b9	68 40 00 		push	OFFSET DGROUP:_szAdapterDescription
	*** 0001bc	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 0001c1	83 c4 0e 		add	sp,14
;|***   else
; Line 270
	*** 0001c4	e9 1a 00 		jmp	$I1900
					$I1898:
;|***     sprintf(szAdapterDescription,0,"SERIAL_#  %s Serial Controller",pszUART);
; Line 271
	*** 0001c7	ff 36 92 00 		push	WORD PTR _pszUART+2
	*** 0001cb	ff 36 90 00 		push	WORD PTR _pszUART
	*** 0001cf	1e 			push	ds
	*** 0001d0	68 04 03 		push	OFFSET DGROUP:$SG1901
	*** 0001d3	6a 00 			push	0
	*** 0001d5	1e 			push	ds
	*** 0001d6	68 40 00 		push	OFFSET DGROUP:_szAdapterDescription
	*** 0001d9	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 0001de	83 c4 0e 		add	sp,14
					$I1900:
;|*** 
;|***   if (hResPorts[adn] != 0)
; Line 273
	*** 0001e1	8b 5e 06 		mov	bx,WORD PTR [bp+6]	;adn
	*** 0001e4	c1 e3 02 		shl	bx,2
	*** 0001e7	8b 87 60 02 		mov	ax,WORD PTR _hResPorts[bx+2]
	*** 0001eb	0b 87 5e 02 		or	ax,WORD PTR _hResPorts[bx]
	*** 0001ef	75 03 			jne	$JCC495
	*** 0001f1	e9 24 00 		jmp	$I1902
					$JCC495:
;|***     pResourceList->hResource[rescnt++] = hResPorts[adn];
; Line 274
	*** 0001f4	8b 5e 06 		mov	bx,WORD PTR [bp+6]	;adn
	*** 0001f7	c1 e3 02 		shl	bx,2
	*** 0001fa	8b 87 5e 02 		mov	ax,WORD PTR _hResPorts[bx]
	*** 0001fe	8b 97 60 02 		mov	dx,WORD PTR _hResPorts[bx+2]
	*** 000202	8b b6 7a ff 		mov	si,WORD PTR [bp-134]	;rescnt
	*** 000206	c1 e6 02 		shl	si,2
	*** 000209	c4 5e fc 		les	bx,DWORD PTR [bp-4]	;pResourceList
	*** 00020c	26 89 40 04 		mov	WORD PTR es:[bx+4][si],ax
	*** 000210	26 89 50 06 		mov	WORD PTR es:[bx+6][si],dx
	*** 000214	ff 86 7a ff 		inc	WORD PTR [bp-134]	;rescnt
;|*** 
;|***   if (hResIRQs[adn] != 0)
; Line 276
					$I1902:
	*** 000218	8b 5e 06 		mov	bx,WORD PTR [bp+6]	;adn
	*** 00021b	c1 e3 02 		shl	bx,2
	*** 00021e	8b 87 a4 02 		mov	ax,WORD PTR _hResIRQs[bx+2]
	*** 000222	0b 87 a2 02 		or	ax,WORD PTR _hResIRQs[bx]
	*** 000226	75 03 			jne	$JCC550
	*** 000228	e9 24 00 		jmp	$I1903
					$JCC550:
;|***     pResourceList->hResource[rescnt++] = hResIRQs[adn];
; Line 277
	*** 00022b	8b 5e 06 		mov	bx,WORD PTR [bp+6]	;adn
	*** 00022e	c1 e3 02 		shl	bx,2
	*** 000231	8b 87 a2 02 		mov	ax,WORD PTR _hResIRQs[bx]
	*** 000235	8b 97 a4 02 		mov	dx,WORD PTR _hResIRQs[bx+2]
	*** 000239	8b b6 7a ff 		mov	si,WORD PTR [bp-134]	;rescnt
	*** 00023d	c1 e6 02 		shl	si,2
	*** 000240	c4 5e fc 		les	bx,DWORD PTR [bp-4]	;pResourceList
	*** 000243	26 89 40 04 		mov	WORD PTR es:[bx+4][si],ax
	*** 000247	26 89 50 06 		mov	WORD PTR es:[bx+6][si],dx
	*** 00024b	ff 86 7a ff 		inc	WORD PTR [bp-134]	;rescnt
;|*** 
;|***   pResourceList->NumResource=rescnt;
; Line 279
					$I1903:
	*** 00024f	8b 86 7a ff 		mov	ax,WORD PTR [bp-134]	;rescnt
	*** 000253	c4 5e fc 		les	bx,DWORD PTR [bp-4]	;pResourceList
	*** 000256	26 89 07 		mov	WORD PTR es:[bx],ax
	*** 000259	26 c7 47 02 00 00 	mov	WORD PTR es:[bx+2],0
;|***   AdapterStruct.pAdjunctList=&adj;
; Line 280
	*** 00025f	8d 86 60 ff 		lea	ax,WORD PTR [bp-160]	;adj
	*** 000263	a3 e4 00 		mov	WORD PTR _AdapterStruct+16,ax
	*** 000266	8c 16 e6 00 		mov	WORD PTR _AdapterStruct+18,ss
;|*** 
;|***   RMCreateAdapter(hDriver,
;|***                   &hAdapter[adn],
;|***                   &AdapterStruct,
;|***                   0,
;|***                   pResourceList);
; Line 286
	*** 00026a	ff 76 fe 		push	WORD PTR [bp-2]
	*** 00026d	ff 76 fc 		push	WORD PTR [bp-4]	;pResourceList
	*** 000270	6a 00 			push	0
	*** 000272	6a 00 			push	0
	*** 000274	1e 			push	ds
	*** 000275	68 d4 00 		push	OFFSET DGROUP:_AdapterStruct
	*** 000278	8b 46 06 		mov	ax,WORD PTR [bp+6]	;adn
	*** 00027b	c1 e0 02 		shl	ax,2
	*** 00027e	05 1a 02 		add	ax,OFFSET DGROUP:_hAdapter
	*** 000281	1e 			push	ds
	*** 000282	50 			push	ax
	*** 000283	ff 36 18 02 		push	WORD PTR _hDriver+2
	*** 000287	ff 36 16 02 		push	WORD PTR _hDriver
	*** 00028b	9a 00 00 00 00 		call	FAR PTR _RMCreateAdapter
	*** 000290	83 c4 14 		add	sp,20
;|***   return(0);
; Line 287
	*** 000293	b8 00 00 		mov	ax,0
	*** 000296	e9 00 00 		jmp	$EX1884
;|***   }
; Line 288
					$EX1884:
	*** 000299	5e 			pop	si
	*** 00029a	5f 			pop	di
	*** 00029b	c9 			leave	
	*** 00029c	cb 			ret	

_RMHELP_CreateAdapter	ENDP
;|*** 
;|*** /*--------------------------------------------------------
;|*** ** RMHELP_CreateStatusPort - tells RM to associate status port
;|*** **                           to driver and resources to
;|*** **                           adapater
;|*** **
;|*** --------------------------------------------------------*/
;|*** 
;|*** USHORT FAR RMHELP_CreateStatusPort()
;|***   {
; Line 298
	PUBLIC	_RMHELP_CreateStatusPort
_RMHELP_CreateStatusPort	PROC FAR
	*** 00029d	c8 9c 00 00 		enter	156,0
	*** 0002a1	57 			push	di
	*** 0002a2	56 			push	si
;	ResourceBuf = -128
;	pResourceList = -4
;	adj = -156
;	rescnt = -130
;|***   UCHAR       ResourceBuf[ sizeof(HRESOURCE) * MAXRESOURCE ];
;|***   PAHRESOURCE pResourceList = (PAHRESOURCE)ResourceBuf;
; Line 300
	*** 0002a3	8d 46 80 		lea	ax,WORD PTR [bp-128]	;ResourceBuf
	*** 0002a6	89 46 fc 		mov	WORD PTR [bp-4],ax	;pResourceList
	*** 0002a9	8c 56 fe 		mov	WORD PTR [bp-2],ss
;|***   ADJUNCT     adj;
;|***   USHORT      rescnt;
;|*** 
;|***   adj.pNextAdj=NULL;
; Line 304
	*** 0002ac	2b c0 			sub	ax,ax
	*** 0002ae	89 86 66 ff 		mov	WORD PTR [bp-154],ax
	*** 0002b2	89 86 64 ff 		mov	WORD PTR [bp-156],ax	;adj
;|***   adj.AdjLength=sizeof(ADJUNCT);
; Line 305
	*** 0002b6	c7 86 68 ff 19 00 	mov	WORD PTR [bp-152],25
;|***   adj.AdjType=ADJ_ADAPTER_NUMBER;
; Line 306
	*** 0002bc	c7 86 6a ff 02 00 	mov	WORD PTR [bp-150],2
;|***   adj.Adapter_Number = (wLoadCount + 1);
; Line 307
_TEXT      ENDS
CONST      SEGMENT
$T20000	DW SEG _wLoadCount 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 0002c2	8e 06 00 00 		mov	es,WORD PTR $T20000
	*** 0002c6	26 a1 00 00 		mov	ax,WORD PTR es:_wLoadCount
	*** 0002ca	40 			inc	ax
	*** 0002cb	89 86 6c ff 		mov	WORD PTR [bp-148],ax
;|*** 
;|***   rescnt=0;                          //no resources to begin with
; Line 309
	*** 0002cf	c7 86 7e ff 00 00 	mov	WORD PTR [bp-130],0	;rescnt
;|*** 
;|***   sprintf(szAdapterDescription,0,"Serial Controller interrupt status register");
; Line 311
	*** 0002d5	1e 			push	ds
	*** 0002d6	68 23 03 		push	OFFSET DGROUP:$SG1910
	*** 0002d9	6a 00 			push	0
	*** 0002db	1e 			push	ds
	*** 0002dc	68 40 00 		push	OFFSET DGROUP:_szAdapterDescription
	*** 0002df	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 0002e4	83 c4 0a 		add	sp,10
;|*** 
;|***   if (hResPorts[wLoadCount] != 0)
; Line 313
	*** 0002e7	8e 06 00 00 		mov	es,WORD PTR $T20000
	*** 0002eb	26 8b 1e 00 00 		mov	bx,WORD PTR es:_wLoadCount
	*** 0002f0	c1 e3 02 		shl	bx,2
	*** 0002f3	8b 87 60 02 		mov	ax,WORD PTR _hResPorts[bx+2]
	*** 0002f7	0b 87 5e 02 		or	ax,WORD PTR _hResPorts[bx]
	*** 0002fb	75 03 			jne	$JCC763
	*** 0002fd	e9 26 00 		jmp	$I1911
					$JCC763:
;|***     pResourceList->hResource[rescnt++] = hResPorts[wLoadCount];
; Line 314
	*** 000300	26 8b 1e 00 00 		mov	bx,WORD PTR es:_wLoadCount
	*** 000305	c1 e3 02 		shl	bx,2
	*** 000308	8b 87 5e 02 		mov	ax,WORD PTR _hResPorts[bx]
	*** 00030c	8b 97 60 02 		mov	dx,WORD PTR _hResPorts[bx+2]
	*** 000310	8b b6 7e ff 		mov	si,WORD PTR [bp-130]	;rescnt
	*** 000314	c1 e6 02 		shl	si,2
	*** 000317	c4 5e fc 		les	bx,DWORD PTR [bp-4]	;pResourceList
	*** 00031a	26 89 40 04 		mov	WORD PTR es:[bx+4][si],ax
	*** 00031e	26 89 50 06 		mov	WORD PTR es:[bx+6][si],dx
	*** 000322	ff 86 7e ff 		inc	WORD PTR [bp-130]	;rescnt
;|*** 
;|***   pResourceList->NumResource=rescnt;
; Line 316
					$I1911:
	*** 000326	8b 86 7e ff 		mov	ax,WORD PTR [bp-130]	;rescnt
	*** 00032a	c4 5e fc 		les	bx,DWORD PTR [bp-4]	;pResourceList
	*** 00032d	26 89 07 		mov	WORD PTR es:[bx],ax
	*** 000330	26 c7 47 02 00 00 	mov	WORD PTR es:[bx+2],0
;|***   AdapterStruct.pAdjunctList=&adj;
; Line 317
	*** 000336	8d 86 64 ff 		lea	ax,WORD PTR [bp-156]	;adj
	*** 00033a	a3 e4 00 		mov	WORD PTR _AdapterStruct+16,ax
	*** 00033d	8c 16 e6 00 		mov	WORD PTR _AdapterStruct+18,ss
;|*** 
;|***   RMCreateAdapter(hDriver,
;|***                   &hAdapter[wLoadCount],
;|***                   &AdapterStruct,
;|***                   0,
;|***                   pResourceList);
; Line 323
	*** 000341	ff 76 fe 		push	WORD PTR [bp-2]
	*** 000344	ff 76 fc 		push	WORD PTR [bp-4]	;pResourceList
	*** 000347	6a 00 			push	0
	*** 000349	6a 00 			push	0
	*** 00034b	1e 			push	ds
	*** 00034c	68 d4 00 		push	OFFSET DGROUP:_AdapterStruct
	*** 00034f	8e 06 00 00 		mov	es,WORD PTR $T20000
	*** 000353	26 a1 00 00 		mov	ax,WORD PTR es:_wLoadCount
	*** 000357	c1 e0 02 		shl	ax,2
	*** 00035a	05 1a 02 		add	ax,OFFSET DGROUP:_hAdapter
	*** 00035d	1e 			push	ds
	*** 00035e	50 			push	ax
	*** 00035f	ff 36 18 02 		push	WORD PTR _hDriver+2
	*** 000363	ff 36 16 02 		push	WORD PTR _hDriver
	*** 000367	9a 00 00 00 00 		call	FAR PTR _RMCreateAdapter
	*** 00036c	83 c4 14 		add	sp,20
;|***   return(0);
; Line 324
	*** 00036f	b8 00 00 		mov	ax,0
	*** 000372	e9 00 00 		jmp	$EX1905
;|***   }
; Line 325
					$EX1905:
	*** 000375	5e 			pop	si
	*** 000376	5f 			pop	di
	*** 000377	c9 			leave	
	*** 000378	cb 			ret	

_RMHELP_CreateStatusPort	ENDP
;|*** 
;|*** /*--------------------------------------------------------*/
;|*** /* RMHELP_FreeAdapter -   tells RM to free adapter and    */
;|*** /*                        resources allocated to adapter  */
;|*** /*                                                        */
;|*** /*--------------------------------------------------------*/
;|*** 
;|*** VOID FAR RMHELP_FreeAdapter(USHORT adn)
;|***   {
; Line 334
	PUBLIC	_RMHELP_FreeAdapter
_RMHELP_FreeAdapter	PROC FAR
	*** 000379	c8 00 00 00 		enter	0,0
	*** 00037d	57 			push	di
	*** 00037e	56 			push	si
;	adn = 6
;|*** 
;|***   if (hResPorts[adn] != 0)
; Line 336
	*** 00037f	8b 5e 06 		mov	bx,WORD PTR [bp+6]	;adn
	*** 000382	c1 e3 02 		shl	bx,2
	*** 000385	8b 87 60 02 		mov	ax,WORD PTR _hResPorts[bx+2]
	*** 000389	0b 87 5e 02 		or	ax,WORD PTR _hResPorts[bx]
	*** 00038d	75 03 			jne	$JCC909
	*** 00038f	e9 1e 00 		jmp	$I1915
					$JCC909:
;|***     RMDeallocResource(hDriver,hResPorts[adn]);
; Line 337
	*** 000392	8b 5e 06 		mov	bx,WORD PTR [bp+6]	;adn
	*** 000395	c1 e3 02 		shl	bx,2
	*** 000398	ff b7 60 02 		push	WORD PTR _hResPorts[bx+2]
	*** 00039c	ff b7 5e 02 		push	WORD PTR _hResPorts[bx]
	*** 0003a0	ff 36 18 02 		push	WORD PTR _hDriver+2
	*** 0003a4	ff 36 16 02 		push	WORD PTR _hDriver
	*** 0003a8	9a 00 00 00 00 		call	FAR PTR _RMDeallocResource
	*** 0003ad	83 c4 08 		add	sp,8
;|*** 
;|***   if (hResIRQs[adn] != 0)
; Line 339
					$I1915:
	*** 0003b0	8b 5e 06 		mov	bx,WORD PTR [bp+6]	;adn
	*** 0003b3	c1 e3 02 		shl	bx,2
	*** 0003b6	8b 87 a4 02 		mov	ax,WORD PTR _hResIRQs[bx+2]
	*** 0003ba	0b 87 a2 02 		or	ax,WORD PTR _hResIRQs[bx]
	*** 0003be	75 03 			jne	$JCC958
	*** 0003c0	e9 1e 00 		jmp	$I1916
					$JCC958:
;|***     RMDeallocResource(hDriver,hResIRQs[adn]);
; Line 340
	*** 0003c3	8b 5e 06 		mov	bx,WORD PTR [bp+6]	;adn
	*** 0003c6	c1 e3 02 		shl	bx,2
	*** 0003c9	ff b7 a4 02 		push	WORD PTR _hResIRQs[bx+2]
	*** 0003cd	ff b7 a2 02 		push	WORD PTR _hResIRQs[bx]
	*** 0003d1	ff 36 18 02 		push	WORD PTR _hDriver+2
	*** 0003d5	ff 36 16 02 		push	WORD PTR _hDriver
	*** 0003d9	9a 00 00 00 00 		call	FAR PTR _RMDeallocResource
	*** 0003de	83 c4 08 		add	sp,8
;|*** 
;|***   if (hAdapter[adn] != 0)
; Line 342
					$I1916:
	*** 0003e1	8b 5e 06 		mov	bx,WORD PTR [bp+6]	;adn
	*** 0003e4	c1 e3 02 		shl	bx,2
	*** 0003e7	8b 87 1c 02 		mov	ax,WORD PTR _hAdapter[bx+2]
	*** 0003eb	0b 87 1a 02 		or	ax,WORD PTR _hAdapter[bx]
	*** 0003ef	75 03 			jne	$JCC1007
	*** 0003f1	e9 1e 00 		jmp	$I1917
					$JCC1007:
;|***     RMDestroyAdapter(hDriver,hAdapter[adn]);
; Line 343
	*** 0003f4	8b 5e 06 		mov	bx,WORD PTR [bp+6]	;adn
	*** 0003f7	c1 e3 02 		shl	bx,2
	*** 0003fa	ff b7 1c 02 		push	WORD PTR _hAdapter[bx+2]
	*** 0003fe	ff b7 1a 02 		push	WORD PTR _hAdapter[bx]
	*** 000402	ff 36 18 02 		push	WORD PTR _hDriver+2
	*** 000406	ff 36 16 02 		push	WORD PTR _hDriver
	*** 00040a	9a 00 00 00 00 		call	FAR PTR _RMDestroyAdapter
	*** 00040f	83 c4 08 		add	sp,8
;|***   }
; Line 344
					$I1917:
					$EX1914:
	*** 000412	5e 			pop	si
	*** 000413	5f 			pop	di
	*** 000414	c9 			leave	
	*** 000415	cb 			ret	

_RMHELP_FreeAdapter	ENDP
;|*** 
;|*** /*--------------------------------------------------------*/
;|*** /* RMHELP_AllocPorts - attempts to claim a port resource */
;|*** /*                       from RM subsystem                */
;|*** /*                                                        */
;|*** /* ARGS:                                                  */
;|*** /*                                                        */
;|*** /* USHORT baseport - base IO port.                        */
;|*** /* USHORT nPorts   - number of prts inclusive of base port*/
;|*** /*                                                        */
;|*** /*--------------------------------------------------------*/
;|*** USHORT FAR RMHELP_AllocPorts(USHORT baseport,USHORT nPorts, USHORT usDevNum)
;|***   {
; Line 357
	PUBLIC	_RMHELP_AllocPorts
_RMHELP_AllocPorts	PROC FAR
	*** 000416	c8 18 00 00 		enter	24,0
	*** 00041a	57 			push	di
	*** 00041b	56 			push	si
;	Resource = -24
;	rc = -4
;	usDevNum = 10
;	nPorts = 8
;	baseport = 6
;|***   RESOURCESTRUCT Resource;
;|***   ULONG rc;
;|*** 
;|***   if (hResPorts[usDevNum] == 0)
; Line 361
	*** 00041c	8b 5e 0a 		mov	bx,WORD PTR [bp+10]	;usDevNum
	*** 00041f	c1 e3 02 		shl	bx,2
	*** 000422	8b 87 60 02 		mov	ax,WORD PTR _hResPorts[bx+2]
	*** 000426	0b 87 5e 02 		or	ax,WORD PTR _hResPorts[bx]
	*** 00042a	74 03 			je	$JCC1066
	*** 00042c	e9 7e 00 		jmp	$I1924
					$JCC1066:
;|***     {
; Line 362
;|***     Resource.ResourceType             = RS_TYPE_IO;
; Line 363
	*** 00042f	c7 46 e8 01 00 		mov	WORD PTR [bp-24],1	;Resource
	*** 000434	c7 46 ea 00 00 		mov	WORD PTR [bp-22],0
;|***     Resource.IOResource.BaseIOPort    = baseport;
; Line 364
	*** 000439	8b 46 06 		mov	ax,WORD PTR [bp+6]	;baseport
	*** 00043c	89 46 ec 		mov	WORD PTR [bp-20],ax
;|***     Resource.IOResource.NumIOPorts    = nPorts;
; Line 365
	*** 00043f	8b 46 08 		mov	ax,WORD PTR [bp+8]	;nPorts
	*** 000442	89 46 ee 		mov	WORD PTR [bp-18],ax
;|*** 
;|***     Resource.IOResource.IOAddressLines=16;
; Line 367
	*** 000445	c7 46 f2 10 00 		mov	WORD PTR [bp-14],16
;|*** #ifdef SHARE
;|***     Resource.IOResource.IOFlags = RS_IO_EXCLUSIVE;
; Line 369
	*** 00044a	c7 46 f0 01 00 		mov	WORD PTR [bp-16],1
;|*** #else
;|***     Resource.IOResource.IOFlags = RS_IO_MULTIPLEXED;
;|*** #endif
;|***     if ((rc = RMAllocResource(hDriver,&hResPorts[usDevNum],&Resource)) != RMRC_SUCCESS)
; Line 373
	*** 00044f	8d 46 e8 		lea	ax,WORD PTR [bp-24]	;Resource
	*** 000452	16 			push	ss
	*** 000453	50 			push	ax
	*** 000454	8b 4e 0a 		mov	cx,WORD PTR [bp+10]	;usDevNum
	*** 000457	c1 e1 02 		shl	cx,2
	*** 00045a	81 c1 5e 02 		add	cx,OFFSET DGROUP:_hResPorts
	*** 00045e	1e 			push	ds
	*** 00045f	51 			push	cx
	*** 000460	ff 36 18 02 		push	WORD PTR _hDriver+2
	*** 000464	ff 36 16 02 		push	WORD PTR _hDriver
	*** 000468	9a 00 00 00 00 		call	FAR PTR _RMAllocResource
	*** 00046d	83 c4 0c 		add	sp,12
	*** 000470	2b d2 			sub	dx,dx
	*** 000472	89 46 fc 		mov	WORD PTR [bp-4],ax	;rc
	*** 000475	89 56 fe 		mov	WORD PTR [bp-2],dx
	*** 000478	0b d0 			or	dx,ax
	*** 00047a	75 03 			jne	$JCC1146
	*** 00047c	e9 28 00 		jmp	$I1925
					$JCC1146:
;|***       {
; Line 374
;|***       Resource.IOResource.IOAddressLines = 10;
; Line 375
	*** 00047f	c7 46 f2 0a 00 		mov	WORD PTR [bp-14],10
;|***       return(RMAllocResource(hDriver,&hResPorts[usDevNum],&Resource));
; Line 376
	*** 000484	8d 46 e8 		lea	ax,WORD PTR [bp-24]	;Resource
	*** 000487	16 			push	ss
	*** 000488	50 			push	ax
	*** 000489	8b 46 0a 		mov	ax,WORD PTR [bp+10]	;usDevNum
	*** 00048c	c1 e0 02 		shl	ax,2
	*** 00048f	05 5e 02 		add	ax,OFFSET DGROUP:_hResPorts
	*** 000492	1e 			push	ds
	*** 000493	50 			push	ax
	*** 000494	ff 36 18 02 		push	WORD PTR _hDriver+2
	*** 000498	ff 36 16 02 		push	WORD PTR _hDriver
	*** 00049c	9a 00 00 00 00 		call	FAR PTR _RMAllocResource
	*** 0004a1	83 c4 0c 		add	sp,12
	*** 0004a4	e9 0c 00 		jmp	$EX1921
;|***       }
; Line 377
;|***     return(RMRC_SUCCESS);
; Line 378
					$I1925:
	*** 0004a7	b8 00 00 		mov	ax,0
	*** 0004aa	e9 06 00 		jmp	$EX1921
;|***     }
; Line 379
;|***   return(RMHELP_ERR_RESOURCECLAIMED);
; Line 380
					$I1924:
	*** 0004ad	b8 ff ff 		mov	ax,-1
	*** 0004b0	e9 00 00 		jmp	$EX1921
;|***   }
; Line 381
					$EX1921:
	*** 0004b3	5e 			pop	si
	*** 0004b4	5f 			pop	di
	*** 0004b5	c9 			leave	
	*** 0004b6	cb 			ret	

_RMHELP_AllocPorts	ENDP
;|*** 
;|*** /*--------------------------------------------------------*/
;|*** /* RMHELP_AllocPort - attempts to claim a port resource   */
;|*** /*                       from RM subsystem                */
;|*** /*                                                        */
;|*** /* ARGS:                                                  */
;|*** /*                                                        */
;|*** /* USHORT baseport - base IO port.                        */
;|*** /*                                                        */
;|*** /*--------------------------------------------------------*/
;|*** USHORT FAR RMHELP_AllocStatusPort(void)
;|***   {
; Line 393
	PUBLIC	_RMHELP_AllocStatusPort
_RMHELP_AllocStatusPort	PROC FAR
	*** 0004b7	c8 18 00 00 		enter	24,0
	*** 0004bb	57 			push	di
	*** 0004bc	56 			push	si
;	Resource = -24
;	rc = -4
;|***   RESOURCESTRUCT Resource;
;|***   ULONG rc;
;|*** 
;|***   if (hResPorts[wLoadCount] == 0)
; Line 397
	*** 0004bd	8e 06 00 00 		mov	es,WORD PTR $T20000
	*** 0004c1	26 8b 1e 00 00 		mov	bx,WORD PTR es:_wLoadCount
	*** 0004c6	c1 e3 02 		shl	bx,2
	*** 0004c9	8b 87 60 02 		mov	ax,WORD PTR _hResPorts[bx+2]
	*** 0004cd	0b 87 5e 02 		or	ax,WORD PTR _hResPorts[bx]
	*** 0004d1	74 03 			je	$JCC1233
	*** 0004d3	e9 8d 00 		jmp	$I1930
					$JCC1233:
;|***     {
; Line 398
;|***     Resource.ResourceType              = RS_TYPE_IO;
; Line 399
	*** 0004d6	c7 46 e8 01 00 		mov	WORD PTR [bp-24],1	;Resource
	*** 0004db	c7 46 ea 00 00 		mov	WORD PTR [bp-22],0
;|***     Resource.IOResource.BaseIOPort     = _wIntIDregister;
; Line 400
_TEXT      ENDS
CONST      SEGMENT
$T20001	DW SEG __wIntIDregister 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 0004e0	8e 06 02 00 		mov	es,WORD PTR $T20001
	*** 0004e4	26 a1 00 00 		mov	ax,WORD PTR es:__wIntIDregister
	*** 0004e8	89 46 ec 		mov	WORD PTR [bp-20],ax
;|***     Resource.IOResource.NumIOPorts     = 1;
; Line 401
	*** 0004eb	c7 46 ee 01 00 		mov	WORD PTR [bp-18],1
;|***     Resource.IOResource.IOAddressLines = 16;
; Line 402
	*** 0004f0	c7 46 f2 10 00 		mov	WORD PTR [bp-14],16
;|***     Resource.IOResource.IOFlags = RS_IO_EXCLUSIVE;
; Line 403
	*** 0004f5	c7 46 f0 01 00 		mov	WORD PTR [bp-16],1
;|***     if ((rc = RMAllocResource(hDriver,&hResPorts[wLoadCount],&Resource)) != RMRC_SUCCESS)
; Line 404
	*** 0004fa	8d 46 e8 		lea	ax,WORD PTR [bp-24]	;Resource
	*** 0004fd	16 			push	ss
	*** 0004fe	50 			push	ax
	*** 0004ff	8e 06 00 00 		mov	es,WORD PTR $T20000
	*** 000503	26 8b 0e 00 00 		mov	cx,WORD PTR es:_wLoadCount
	*** 000508	c1 e1 02 		shl	cx,2
	*** 00050b	81 c1 5e 02 		add	cx,OFFSET DGROUP:_hResPorts
	*** 00050f	1e 			push	ds
	*** 000510	51 			push	cx
	*** 000511	ff 36 18 02 		push	WORD PTR _hDriver+2
	*** 000515	ff 36 16 02 		push	WORD PTR _hDriver
	*** 000519	9a 00 00 00 00 		call	FAR PTR _RMAllocResource
	*** 00051e	83 c4 0c 		add	sp,12
	*** 000521	2b d2 			sub	dx,dx
	*** 000523	89 46 fc 		mov	WORD PTR [bp-4],ax	;rc
	*** 000526	89 56 fe 		mov	WORD PTR [bp-2],dx
	*** 000529	0b d0 			or	dx,ax
	*** 00052b	75 03 			jne	$JCC1323
	*** 00052d	e9 2d 00 		jmp	$I1931
					$JCC1323:
;|***       {
; Line 405
;|***       Resource.IOResource.IOAddressLines = 10;
; Line 406
	*** 000530	c7 46 f2 0a 00 		mov	WORD PTR [bp-14],10
;|***       return(RMAllocResource(hDriver,&hResPorts[wLoadCount],&Resource));
; Line 407
	*** 000535	8d 46 e8 		lea	ax,WORD PTR [bp-24]	;Resource
	*** 000538	16 			push	ss
	*** 000539	50 			push	ax
	*** 00053a	8e 06 00 00 		mov	es,WORD PTR $T20000
	*** 00053e	26 a1 00 00 		mov	ax,WORD PTR es:_wLoadCount
	*** 000542	c1 e0 02 		shl	ax,2
	*** 000545	05 5e 02 		add	ax,OFFSET DGROUP:_hResPorts
	*** 000548	1e 			push	ds
	*** 000549	50 			push	ax
	*** 00054a	ff 36 18 02 		push	WORD PTR _hDriver+2
	*** 00054e	ff 36 16 02 		push	WORD PTR _hDriver
	*** 000552	9a 00 00 00 00 		call	FAR PTR _RMAllocResource
	*** 000557	83 c4 0c 		add	sp,12
	*** 00055a	e9 0c 00 		jmp	$EX1927
;|***       }
; Line 408
;|***     return(RMRC_SUCCESS);
; Line 409
					$I1931:
	*** 00055d	b8 00 00 		mov	ax,0
	*** 000560	e9 06 00 		jmp	$EX1927
;|***     }
; Line 410
;|***   return(RMHELP_ERR_RESOURCECLAIMED);
; Line 411
					$I1930:
	*** 000563	b8 ff ff 		mov	ax,-1
	*** 000566	e9 00 00 		jmp	$EX1927
;|***   }
; Line 412
					$EX1927:
	*** 000569	5e 			pop	si
	*** 00056a	5f 			pop	di
	*** 00056b	c9 			leave	
	*** 00056c	cb 			ret	

_RMHELP_AllocStatusPort	ENDP
;|*** 
;|*** /*--------------------------------------------------------*/
;|*** /* RMHELP_AllocIRQ   - attempts to claim a IRQ resource   */
;|*** /*                       from RM subsystem                */
;|*** /*                                                        */
;|*** /* ARGS:                                                  */
;|*** /*                                                        */
;|*** /* USHORT IRQlevel - IRQ level to claim                   */
;|*** /*                                                        */
;|*** /*--------------------------------------------------------*/
;|*** USHORT FAR RMHELP_AllocIRQ(USHORT IRQlevel, USHORT usDevNum)
;|***   {
; Line 424
	PUBLIC	_RMHELP_AllocIRQ
_RMHELP_AllocIRQ	PROC FAR
	*** 00056d	c8 14 00 00 		enter	20,0
	*** 000571	57 			push	di
	*** 000572	56 			push	si
;	Resource = -20
;	usDevNum = 8
;	IRQlevel = 6
;|***   RESOURCESTRUCT Resource;
;|*** 
;|***   if (hResIRQs[usDevNum] == 0)
; Line 427
	*** 000573	8b 5e 08 		mov	bx,WORD PTR [bp+8]	;usDevNum
	*** 000576	c1 e3 02 		shl	bx,2
	*** 000579	8b 87 a4 02 		mov	ax,WORD PTR _hResIRQs[bx+2]
	*** 00057d	0b 87 a2 02 		or	ax,WORD PTR _hResIRQs[bx]
	*** 000581	74 03 			je	$JCC1409
	*** 000583	e9 5f 00 		jmp	$I1936
					$JCC1409:
;|***     {
; Line 428
;|***     Resource.ResourceType          = RS_TYPE_IRQ;
; Line 429
	*** 000586	c7 46 ec 02 00 		mov	WORD PTR [bp-20],2	;Resource
	*** 00058b	c7 46 ee 00 00 		mov	WORD PTR [bp-18],0
;|***     Resource.IRQResource.PCIIrqPin = RS_PCI_INT_NONE;
; Line 430
	*** 000590	c7 46 f2 00 00 		mov	WORD PTR [bp-14],0
;|***     if ((_wBusType == MACH_UCHNL) || (_wBusType == MACH_PCI)) // || (wIntIDregister != 0))
; Line 431
_TEXT      ENDS
CONST      SEGMENT
$T20002	DW SEG __wBusType 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 000595	8e 06 04 00 		mov	es,WORD PTR $T20002
	*** 000599	26 83 3e 00 00 02 	cmp	WORD PTR es:__wBusType,2
	*** 00059f	75 03 			jne	$JCC1439
	*** 0005a1	e9 0b 00 		jmp	$I1938
					$JCC1439:
	*** 0005a4	26 83 3e 00 00 05 	cmp	WORD PTR es:__wBusType,5
	*** 0005aa	74 03 			je	$JCC1450
	*** 0005ac	e9 08 00 		jmp	$I1937
					$JCC1450:
					$I1938:
;|***       Resource.IRQResource.IRQFlags  = RS_IRQ_SHARED;
; Line 432
	*** 0005af	c7 46 f4 04 00 		mov	WORD PTR [bp-12],4
;|***     else
; Line 433
	*** 0005b4	e9 05 00 		jmp	$I1939
					$I1937:
;|***       Resource.IRQResource.IRQFlags  = RS_IRQ_MULTIPLEXED;
; Line 434
	*** 0005b7	c7 46 f4 02 00 		mov	WORD PTR [bp-12],2
					$I1939:
;|***     Resource.IRQResource.IRQLevel  = IRQlevel;
; Line 435
	*** 0005bc	8b 46 06 		mov	ax,WORD PTR [bp+6]	;IRQlevel
	*** 0005bf	89 46 f0 		mov	WORD PTR [bp-16],ax
;|***     return(RMAllocResource(hDriver,&(hResIRQs[usDevNum]),&Resource));
; Line 436
	*** 0005c2	8d 46 ec 		lea	ax,WORD PTR [bp-20]	;Resource
	*** 0005c5	16 			push	ss
	*** 0005c6	50 			push	ax
	*** 0005c7	8b 46 08 		mov	ax,WORD PTR [bp+8]	;usDevNum
	*** 0005ca	c1 e0 02 		shl	ax,2
	*** 0005cd	05 a2 02 		add	ax,OFFSET DGROUP:_hResIRQs
	*** 0005d0	1e 			push	ds
	*** 0005d1	50 			push	ax
	*** 0005d2	ff 36 18 02 		push	WORD PTR _hDriver+2
	*** 0005d6	ff 36 16 02 		push	WORD PTR _hDriver
	*** 0005da	9a 00 00 00 00 		call	FAR PTR _RMAllocResource
	*** 0005df	83 c4 0c 		add	sp,12
	*** 0005e2	e9 06 00 		jmp	$EX1934
;|***     }
; Line 437
;|***   return(RMHELP_ERR_RESOURCECLAIMED);
; Line 438
					$I1936:
	*** 0005e5	b8 ff ff 		mov	ax,-1
	*** 0005e8	e9 00 00 		jmp	$EX1934
;|***   }
; Line 439
					$EX1934:
	*** 0005eb	5e 			pop	si
	*** 0005ec	5f 			pop	di
	*** 0005ed	c9 			leave	
	*** 0005ee	cb 			ret	

_RMHELP_AllocIRQ	ENDP
;|*** 
;|*** /*****************************************************************************/
;|*** /*****************************************************************************/
;|*** /********                                               **********************/
;|*** /********  All COM specific code appears below this     **********************/
;|*** /********                divider!!!                     **********************/
;|*** /********                                               **********************/
;|*** /********                                               **********************/
;|*** /*****************************************************************************/
;|*** /*****************************************************************************/
;|*** 
;|*** /*--------------------------------------------------------*/
;|*** /* RMHELP_GetPorts   - attempts to claim resources for a  */
;|*** /*                     COM port                           */
;|*** /*                                                        */
;|*** /* ARGS:  ptr = COM driver ComInfo structure              */
;|*** /*                                                        */
;|*** /*--------------------------------------------------------*/
;|*** USHORT FAR RMHELP_GetPorts(DCBHEAD *pComInfo,USHORT usPortNumber)
;|***   {
; Line 459
	PUBLIC	_RMHELP_GetPorts
_RMHELP_GetPorts	PROC FAR
	*** 0005ef	c8 0e 00 00 		enter	14,0
	*** 0005f3	57 			push	di
	*** 0005f4	56 			push	si
;	usBase = -4
;	usLimit = -8
;	rc = -6
;	iIndex = -2
;	pszName = -14
;	iLen = -10
;	usPortNumber = 10
;	pComInfo = 6
;|*** //  COMDCB _far *pConfig;
;|*** //  DEVDEF _far *pComInfo;
;|***   USHORT usBase;
;|***   USHORT usLimit;
;|***   USHORT rc = 0;
; Line 464
	*** 0005f5	c7 46 fa 00 00 		mov	WORD PTR [bp-6],0	;rc
;|***   int iIndex;
;|***   char *pszName;
;|***   int iLen;
;|*** 
;|*** //  pComInfo = &_stDeviceParms[usPortNumber];
;|***   pszName = aszFSComName[usPortNumber];
; Line 470
	*** 0005fa	8b 46 0a 		mov	ax,WORD PTR [bp+10]	;usPortNumber
	*** 0005fd	8b c8 			mov	cx,ax
	*** 0005ff	c1 e0 02 		shl	ax,2
	*** 000602	03 c1 			add	ax,cx
	*** 000604	d1 e0 			shl	ax,1
	*** 000606	05 fa 00 		add	ax,OFFSET DGROUP:_aszFSComName
	*** 000609	89 46 f2 		mov	WORD PTR [bp-14],ax	;pszName
	*** 00060c	8c 5e f4 		mov	WORD PTR [bp-12],ds
;|***   for (iIndex = 0;iIndex < 8;iIndex++)
; Line 471
	*** 00060f	c7 46 fe 00 00 		mov	WORD PTR [bp-2],0	;iIndex
	*** 000614	e9 03 00 		jmp	$F1950
					$FC1951:
	*** 000617	ff 46 fe 		inc	WORD PTR [bp-2]	;iIndex
					$F1950:
	*** 00061a	83 7e fe 08 		cmp	WORD PTR [bp-2],8	;iIndex
	*** 00061e	7c 03 			jl	$JCC1566
	*** 000620	e9 1f 00 		jmp	$FB1952
					$JCC1566:
;|***     if ((pszName[iIndex] = pComInfo->abyPortName[iIndex]) == ' ')
; Line 472
	*** 000623	c4 5e 06 		les	bx,DWORD PTR [bp+6]	;pComInfo
	*** 000626	8b 76 fe 		mov	si,WORD PTR [bp-2]	;iIndex
	*** 000629	26 8a 00 		mov	al,BYTE PTR es:[bx][si]
	*** 00062c	c4 5e f2 		les	bx,DWORD PTR [bp-14]	;pszName
	*** 00062f	8b 76 fe 		mov	si,WORD PTR [bp-2]	;iIndex
	*** 000632	26 88 00 		mov	BYTE PTR es:[bx][si],al
	*** 000635	3c 20 			cmp	al,32
	*** 000637	74 03 			je	$JCC1591
	*** 000639	e9 03 00 		jmp	$I1953
					$JCC1591:
;|***       break;
; Line 473
	*** 00063c	e9 03 00 		jmp	$FB1952
;|***   pszName[iIndex] = 0;
; Line 474
					$I1953:
	*** 00063f	e9 d5 ff 		jmp	$FC1951
					$FB1952:
	*** 000642	c4 5e f2 		les	bx,DWORD PTR [bp-14]	;pszName
	*** 000645	8b 76 fe 		mov	si,WORD PTR [bp-2]	;iIndex
	*** 000648	26 c6 00 00 		mov	BYTE PTR es:[bx][si],0
;|*** //  pConfig = &stConfigParms[usPortNumber];
;|***   if ((usBase = pComInfo->stComDCB.wIObaseAddress) == 0)
; Line 476
	*** 00064c	c4 5e 06 		les	bx,DWORD PTR [bp+6]	;pComInfo
	*** 00064f	26 8b 47 16 		mov	ax,WORD PTR es:[bx+22]
	*** 000653	89 46 fc 		mov	WORD PTR [bp-4],ax	;usBase
	*** 000656	3d 00 00 		cmp	ax,0
	*** 000659	74 03 			je	$JCC1625
	*** 00065b	e9 06 00 		jmp	$I1954
					$JCC1625:
;|***     return(0xffff);
; Line 477
	*** 00065e	b8 ff ff 		mov	ax,-1
	*** 000661	e9 dc 00 		jmp	$EX1943
;|***   if ((rc = RMHELP_AllocPorts(usBase,8,usPortNumber)) != 0)
; Line 478
					$I1954:
	*** 000664	ff 76 0a 		push	WORD PTR [bp+10]	;usPortNumber
	*** 000667	6a 08 			push	8
	*** 000669	ff 76 fc 		push	WORD PTR [bp-4]	;usBase
	*** 00066c	9a 00 00 00 00 		call	FAR PTR _RMHELP_AllocPorts
	*** 000671	83 c4 06 		add	sp,6
	*** 000674	89 46 fa 		mov	WORD PTR [bp-6],ax	;rc
	*** 000677	3d 00 00 		cmp	ax,0
	*** 00067a	75 03 			jne	$JCC1658
	*** 00067c	e9 3e 00 		jmp	$I1955
					$JCC1658:
;|***     {
; Line 479
;|***     usLimit = usBase + 7;
; Line 480
	*** 00067f	8b 46 fc 		mov	ax,WORD PTR [bp-4]	;usBase
	*** 000682	05 07 00 		add	ax,7
	*** 000685	89 46 f8 		mov	WORD PTR [bp-8],ax	;usLimit
;|***     iLen = sprintf(szErrMsg,0,"[1m%s was not installed, RM I/O address range 0x%X-0x%X is not available.[0m\r\n",pszName,usBase,usLimit);
; Line 481
	*** 000688	ff 76 f8 		push	WORD PTR [bp-8]	;usLimit
	*** 00068b	ff 76 fc 		push	WORD PTR [bp-4]	;usBase
	*** 00068e	ff 76 f4 		push	WORD PTR [bp-12]
	*** 000691	ff 76 f2 		push	WORD PTR [bp-14]	;pszName
	*** 000694	1e 			push	ds
	*** 000695	68 4f 03 		push	OFFSET DGROUP:$SG1956
	*** 000698	6a 00 			push	0
	*** 00069a	1e 			push	ds
	*** 00069b	68 9a 01 		push	OFFSET DGROUP:_szErrMsg
	*** 00069e	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 0006a3	83 c4 12 		add	sp,18
	*** 0006a6	89 46 f6 		mov	WORD PTR [bp-10],ax	;iLen
;|***     VioWrtTTY(szErrMsg,iLen,0);
; Line 482
	*** 0006a9	1e 			push	ds
	*** 0006aa	68 9a 01 		push	OFFSET DGROUP:_szErrMsg
	*** 0006ad	ff 76 f6 		push	WORD PTR [bp-10]	;iLen
	*** 0006b0	6a 00 			push	0
	*** 0006b2	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***     return(rc);
; Line 483
	*** 0006b7	8b 46 fa 		mov	ax,WORD PTR [bp-6]	;rc
	*** 0006ba	e9 83 00 		jmp	$EX1943
;|***     }
; Line 484
;|*** 
;|***   if (pComInfo->stComDCB.byInterruptLevel != 0)
; Line 486
					$I1955:
	*** 0006bd	c4 5e 06 		les	bx,DWORD PTR [bp+6]	;pComInfo
	*** 0006c0	26 80 7f 30 00 		cmp	BYTE PTR es:[bx+48],0
	*** 0006c5	75 03 			jne	$JCC1733
	*** 0006c7	e9 59 00 		jmp	$I1957
					$JCC1733:
;|***     if ((rc = RMHELP_AllocIRQ(pComInfo->stComDCB.byInterruptLevel,usPortNumber)) != 0 )
; Line 487
	*** 0006ca	ff 76 0a 		push	WORD PTR [bp+10]	;usPortNumber
	*** 0006cd	c4 5e 06 		les	bx,DWORD PTR [bp+6]	;pComInfo
	*** 0006d0	26 8a 47 30 		mov	al,BYTE PTR es:[bx+48]
	*** 0006d4	2a e4 			sub	ah,ah
	*** 0006d6	50 			push	ax
	*** 0006d7	9a 00 00 00 00 		call	FAR PTR _RMHELP_AllocIRQ
	*** 0006dc	83 c4 04 		add	sp,4
	*** 0006df	89 46 fa 		mov	WORD PTR [bp-6],ax	;rc
	*** 0006e2	3d 00 00 		cmp	ax,0
	*** 0006e5	75 03 			jne	$JCC1765
	*** 0006e7	e9 39 00 		jmp	$I1958
					$JCC1765:
;|***       {
; Line 488
;|***       iLen = sprintf(szErrMsg,0,"[1m%s was not installed, RM interrupt level %u is not available.[0m\r\n",pszName,pComInfo->stComDCB.byInterruptLevel);
; Line 489
	*** 0006ea	c4 5e 06 		les	bx,DWORD PTR [bp+6]	;pComInfo
	*** 0006ed	26 8a 47 30 		mov	al,BYTE PTR es:[bx+48]
	*** 0006f1	2a e4 			sub	ah,ah
	*** 0006f3	50 			push	ax
	*** 0006f4	ff 76 f4 		push	WORD PTR [bp-12]
	*** 0006f7	ff 76 f2 		push	WORD PTR [bp-14]	;pszName
	*** 0006fa	1e 			push	ds
	*** 0006fb	68 a1 03 		push	OFFSET DGROUP:$SG1959
	*** 0006fe	6a 00 			push	0
	*** 000700	1e 			push	ds
	*** 000701	68 9a 01 		push	OFFSET DGROUP:_szErrMsg
	*** 000704	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 000709	83 c4 10 		add	sp,16
	*** 00070c	89 46 f6 		mov	WORD PTR [bp-10],ax	;iLen
;|***       VioWrtTTY(szErrMsg,iLen,0);
; Line 490
	*** 00070f	1e 			push	ds
	*** 000710	68 9a 01 		push	OFFSET DGROUP:_szErrMsg
	*** 000713	ff 76 f6 		push	WORD PTR [bp-10]	;iLen
	*** 000716	6a 00 			push	0
	*** 000718	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***       return(rc);
; Line 491
	*** 00071d	8b 46 fa 		mov	ax,WORD PTR [bp-6]	;rc
	*** 000720	e9 1d 00 		jmp	$EX1943
;|***       }
; Line 492
;|*** 
;|***   pszName[iIndex++] = ':';
; Line 494
					$I1958:
					$I1957:
	*** 000723	c4 5e f2 		les	bx,DWORD PTR [bp-14]	;pszName
	*** 000726	8b 76 fe 		mov	si,WORD PTR [bp-2]	;iIndex
	*** 000729	26 c6 00 3a 		mov	BYTE PTR es:[bx][si],58
	*** 00072d	ff 46 fe 		inc	WORD PTR [bp-2]	;iIndex
;|***   pszName[iIndex] = 0;
; Line 495
	*** 000730	c4 5e f2 		les	bx,DWORD PTR [bp-14]	;pszName
	*** 000733	8b 76 fe 		mov	si,WORD PTR [bp-2]	;iIndex
	*** 000736	26 c6 00 00 		mov	BYTE PTR es:[bx][si],0
;|***   return(rc);
; Line 496
	*** 00073a	8b 46 fa 		mov	ax,WORD PTR [bp-6]	;rc
	*** 00073d	e9 00 00 		jmp	$EX1943
;|***   }
; Line 497
					$EX1943:
	*** 000740	5e 			pop	si
	*** 000741	5f 			pop	di
	*** 000742	c9 			leave	
	*** 000743	cb 			ret	

_RMHELP_GetPorts	ENDP
;|*** 
;|*** /*--------------------------------------------------------
;|*** ** RMHELP_GetStatusPort - attempts to claim status port
;|*** **                        resource for a COMi load.
;|*** **
;|*** ----------------------------------------------------------*/
;|*** USHORT FAR RMHELP_GetStatusPort(void)
;|***   {
; Line 505
	PUBLIC	_RMHELP_GetStatusPort
_RMHELP_GetStatusPort	PROC FAR
	*** 000744	c8 04 00 00 		enter	4,0
	*** 000748	57 			push	di
	*** 000749	56 			push	si
;	iLen = -4
;	rc = -2
;|***   int iLen;
;|***   APIRET rc;
;|*** 
;|***   if ((rc = RMHELP_AllocStatusPort()) != 0)
; Line 509
	*** 00074a	9a 00 00 00 00 		call	FAR PTR _RMHELP_AllocStatusPort
	*** 00074f	89 46 fe 		mov	WORD PTR [bp-2],ax	;rc
	*** 000752	3d 00 00 		cmp	ax,0
	*** 000755	75 03 			jne	$JCC1877
	*** 000757	e9 3f 00 		jmp	$I1964
					$JCC1877:
;|***     {
; Line 510
;|***     iLen = sprintf(szErrMsg,0,"Load Number %u\r\n[1mRM I/O address 0x%04X is not available for interrupt status port. This load\r\nwill NOT be initialized (0x04x)[0m\r\n",(wLoadNumber + 1),_wIntIDregister,rc);
; Line 511
	*** 00075a	ff 76 fe 		push	WORD PTR [bp-2]	;rc
	*** 00075d	8e 06 02 00 		mov	es,WORD PTR $T20001
	*** 000761	26 ff 36 00 00 		push	WORD PTR es:__wIntIDregister
_TEXT      ENDS
CONST      SEGMENT
$T20003	DW SEG _wLoadNumber 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 000766	8e 06 06 00 		mov	es,WORD PTR $T20003
	*** 00076a	26 a1 00 00 		mov	ax,WORD PTR es:_wLoadNumber
	*** 00076e	40 			inc	ax
	*** 00076f	50 			push	ax
	*** 000770	1e 			push	ds
	*** 000771	68 ea 03 		push	OFFSET DGROUP:$SG1965
	*** 000774	6a 00 			push	0
	*** 000776	1e 			push	ds
	*** 000777	68 9a 01 		push	OFFSET DGROUP:_szErrMsg
	*** 00077a	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 00077f	83 c4 10 		add	sp,16
	*** 000782	89 46 fc 		mov	WORD PTR [bp-4],ax	;iLen
;|***     VioWrtTTY(szErrMsg,iLen,0);
; Line 512
	*** 000785	1e 			push	ds
	*** 000786	68 9a 01 		push	OFFSET DGROUP:_szErrMsg
	*** 000789	ff 76 fc 		push	WORD PTR [bp-4]	;iLen
	*** 00078c	6a 00 			push	0
	*** 00078e	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***     return(rc);
; Line 513
	*** 000793	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;rc
	*** 000796	e9 06 00 		jmp	$EX1961
;|***     }
; Line 514
;|***   return(0);
; Line 515
					$I1964:
	*** 000799	b8 00 00 		mov	ax,0
	*** 00079c	e9 00 00 		jmp	$EX1961
;|***   }
; Line 516
					$EX1961:
	*** 00079f	5e 			pop	si
	*** 0007a0	5f 			pop	di
	*** 0007a1	c9 			leave	
	*** 0007a2	cb 			ret	

_RMHELP_GetStatusPort	ENDP
;|*** 
;|*** /*----------------------------------------------------------*/
;|*** /* RMHELP_PortInitComplete - Bind resources to the port     */
;|*** /*                                                          */
;|*** /*      We also examine the ComInfo structure for the       */
;|*** /*      hardware type and update our structures accordingly */
;|*** /*                                                          */
;|*** /* ARGS:  pComInfo = COM driver ComInfo structure           */
;|*** /*                                                          */
;|*** /*----------------------------------------------------------*/
;|*** 
;|*** USHORT FAR RMHELP_PortInitComplete(USHORT usPortNumber, USHORT BusType)
;|***   {
; Line 529
	PUBLIC	_RMHELP_PortInitComplete
_RMHELP_PortInitComplete	PROC FAR
	*** 0007a3	c8 0a 00 00 		enter	10,0
	*** 0007a7	57 			push	di
	*** 0007a8	56 			push	si
;	pComInfo = -10
;	pRMparms = -4
;	rc = -6
;	BusType = 8
;	usPortNumber = 6
;|***   DEVDEF _far *pComInfo;
;|***   RMDEF _far *pRMparms;
;|***   USHORT rc=0;
; Line 532
	*** 0007a9	c7 46 fa 00 00 		mov	WORD PTR [bp-6],0	;rc
;|*** 
;|***   pRMparms = &stRMparms[usPortNumber];
; Line 534
	*** 0007ae	8b 46 06 		mov	ax,WORD PTR [bp+6]	;usPortNumber
	*** 0007b1	8b c8 			mov	cx,ax
	*** 0007b3	d1 e0 			shl	ax,1
	*** 0007b5	03 c1 			add	ax,cx
	*** 0007b7	c1 e0 02 		shl	ax,2
	*** 0007ba	05 00 00 		add	ax,OFFSET _stRMparms
	*** 0007bd	89 46 fc 		mov	WORD PTR [bp-4],ax	;pRMparms
	*** 0007c0	c7 46 fe 00 00 		mov	WORD PTR [bp-2],SEG _stRMparms
;|***   pComInfo = &_stDeviceParms[usPortNumber];
; Line 535
	*** 0007c5	69 46 06 be 00 		imul	ax,WORD PTR [bp+6],190	;usPortNumber
	*** 0007ca	05 00 00 		add	ax,OFFSET __stDeviceParms
	*** 0007cd	89 46 f6 		mov	WORD PTR [bp-10],ax	;pComInfo
	*** 0007d0	c7 46 f8 00 00 		mov	WORD PTR [bp-8],SEG __stDeviceParms
;|***   switch (BusType)
; Line 536
	*** 0007d5	8b 46 08 		mov	ax,WORD PTR [bp+8]	;BusType
	*** 0007d8	e9 39 00 		jmp	$S1973
;|***     {
; Line 537
;|***     case MACH_EISA:
; Line 538
					$SC1977:
;|***       AdapterStruct.HostBusType=AS_HOSTBUS_EISA;
; Line 539
	*** 0007db	c7 06 e0 00 02 00 	mov	WORD PTR _AdapterStruct+12,2
;|***       break;
; Line 540
	*** 0007e1	e9 51 00 		jmp	$SB1974
;|***     case MACH_UCHNL:
; Line 541
					$SC1978:
;|***       AdapterStruct.HostBusType=AS_HOSTBUS_uCHNL;
; Line 542
	*** 0007e4	c7 06 e0 00 03 00 	mov	WORD PTR _AdapterStruct+12,3
;|***       break;
; Line 543
	*** 0007ea	e9 48 00 		jmp	$SB1974
;|***     case MACH_PCMCIA:
; Line 544
					$SC1979:
;|***       AdapterStruct.HostBusType=AS_HOSTBUS_PCMCIA;
; Line 545
	*** 0007ed	c7 06 e0 00 06 00 	mov	WORD PTR _AdapterStruct+12,6
;|***       break;
; Line 546
	*** 0007f3	e9 3f 00 		jmp	$SB1974
;|***     case MACH_ISA:
; Line 547
					$SC1980:
;|***       AdapterStruct.HostBusType=AS_HOSTBUS_ISA;
; Line 548
	*** 0007f6	c7 06 e0 00 01 00 	mov	WORD PTR _AdapterStruct+12,1
;|***       break;
; Line 549
	*** 0007fc	e9 36 00 		jmp	$SB1974
;|***     case MACH_PCI:
; Line 550
					$SC1981:
;|***       AdapterStruct.HostBusType=AS_HOSTBUS_PCI;
; Line 551
	*** 0007ff	c7 06 e0 00 04 00 	mov	WORD PTR _AdapterStruct+12,4
;|***       break;
; Line 552
	*** 000805	e9 2d 00 		jmp	$SB1974
;|***     default:
; Line 553
					$SD1982:
;|***       AdapterStruct.HostBusType=AS_HOSTBUS_PLANAR;
; Line 554
	*** 000808	c7 06 e0 00 08 00 	mov	WORD PTR _AdapterStruct+12,8
;|***       break;
; Line 555
	*** 00080e	e9 24 00 		jmp	$SB1974
;|***     }
; Line 556
	*** 000811	e9 21 00 		jmp	$SB1974
					$S1973:
	*** 000814	48 			dec	ax
	*** 000815	75 03 			jne	$JCC2069
	*** 000817	e9 c1 ff 		jmp	$SC1977
					$JCC2069:
	*** 00081a	48 			dec	ax
	*** 00081b	75 03 			jne	$JCC2075
	*** 00081d	e9 c4 ff 		jmp	$SC1978
					$JCC2075:
	*** 000820	48 			dec	ax
	*** 000821	75 03 			jne	$JCC2081
	*** 000823	e9 c7 ff 		jmp	$SC1979
					$JCC2081:
	*** 000826	48 			dec	ax
	*** 000827	75 03 			jne	$JCC2087
	*** 000829	e9 ca ff 		jmp	$SC1980
					$JCC2087:
	*** 00082c	48 			dec	ax
	*** 00082d	75 03 			jne	$JCC2093
	*** 00082f	e9 cd ff 		jmp	$SC1981
					$JCC2093:
	*** 000832	e9 d3 ff 		jmp	$SD1982
					$SB1974:
;|***   if ((pComInfo->usDeviceFlag2 & DEV_FLAG2_FIFO_AVAILABLE) == 0)
; Line 557
	*** 000835	c4 5e f6 		les	bx,DWORD PTR [bp-10]	;pComInfo
	*** 000838	26 f6 47 05 08 		test	BYTE PTR es:[bx+5],8
	*** 00083d	74 03 			je	$JCC2109
	*** 00083f	e9 09 00 		jmp	$I1983
					$JCC2109:
;|***     AdapterStruct.InterfaceType=AS_INTF_16450;
; Line 558
	*** 000842	c7 06 de 00 01 00 	mov	WORD PTR _AdapterStruct+10,1
;|***   else
; Line 559
	*** 000848	e9 06 00 		jmp	$I1984
					$I1983:
;|***     AdapterStruct.InterfaceType=AS_INTF_16550;
; Line 560
	*** 00084b	c7 06 de 00 02 00 	mov	WORD PTR _AdapterStruct+10,2
					$I1984:
;|*** 
;|***   /*-------------------------------*/
;|***   /* If not pcmcia modem, create   */
;|***   /* an adapter                    */
;|***   /*-------------------------------*/
;|***   if ((pComInfo->usDeviceFlag2 & DEV_FLAG2_PCMCIA_PORT) == 0)
; Line 566
	*** 000851	c4 5e f6 		les	bx,DWORD PTR [bp-10]	;pComInfo
	*** 000854	26 f6 47 05 80 		test	BYTE PTR es:[bx+5],128
	*** 000859	74 03 			je	$JCC2137
	*** 00085b	e9 3c 00 		jmp	$I1985
					$JCC2137:
;|***     if ((rc = RMHELP_CreateAdapter(usPortNumber)) == 0)
; Line 567
	*** 00085e	ff 76 06 		push	WORD PTR [bp+6]	;usPortNumber
	*** 000861	9a 00 00 00 00 		call	FAR PTR _RMHELP_CreateAdapter
	*** 000866	83 c4 02 		add	sp,2
	*** 000869	89 46 fa 		mov	WORD PTR [bp-6],ax	;rc
	*** 00086c	3d 00 00 		cmp	ax,0
	*** 00086f	74 03 			je	$JCC2159
	*** 000871	e9 26 00 		jmp	$I1986
					$JCC2159:
;|***       {
; Line 568
;|***       pRMparms->hAdapter = hAdapter[usPortNumber];
; Line 569
	*** 000874	8b 5e 06 		mov	bx,WORD PTR [bp+6]	;usPortNumber
	*** 000877	c1 e3 02 		shl	bx,2
	*** 00087a	8b 87 1a 02 		mov	ax,WORD PTR _hAdapter[bx]
	*** 00087e	8b 97 1c 02 		mov	dx,WORD PTR _hAdapter[bx+2]
	*** 000882	c4 5e fc 		les	bx,DWORD PTR [bp-4]	;pRMparms
	*** 000885	26 89 07 		mov	WORD PTR es:[bx],ax
	*** 000888	26 89 57 02 		mov	WORD PTR es:[bx+2],dx
;|***       rc = RMHELP_CreateLDev(usPortNumber);
; Line 570
	*** 00088c	ff 76 06 		push	WORD PTR [bp+6]	;usPortNumber
	*** 00088f	9a 00 00 00 00 		call	FAR PTR _RMHELP_CreateLDev
	*** 000894	83 c4 02 		add	sp,2
	*** 000897	89 46 fa 		mov	WORD PTR [bp-6],ax	;rc
;|***       }
; Line 571
;|*** 
;|***   return(rc);
; Line 573
					$I1986:
					$I1985:
	*** 00089a	8b 46 fa 		mov	ax,WORD PTR [bp-6]	;rc
	*** 00089d	e9 00 00 		jmp	$EX1969
;|***   }
; Line 574
					$EX1969:
	*** 0008a0	5e 			pop	si
	*** 0008a1	5f 			pop	di
	*** 0008a2	c9 			leave	
	*** 0008a3	cb 			ret	

_RMHELP_PortInitComplete	ENDP
;|*** 
;|*** /*----------------------------------------------------------*/
;|*** /* RMHELP_StatusPortInit - Bind status port resource        */
;|*** /*                                                          */
;|*** /*----------------------------------------------------------*/
;|*** 
;|*** USHORT FAR RMHELP_StatusPortInitComplete(void)
;|***   {
; Line 582
	PUBLIC	_RMHELP_StatusPortInitComplete
_RMHELP_StatusPortInitComplete	PROC FAR
	*** 0008a4	c8 06 00 00 		enter	6,0
	*** 0008a8	57 			push	di
	*** 0008a9	56 			push	si
;	pRMparms = -4
;	rc = -6
;|***   RMDEF _far *pRMparms;
;|***   USHORT rc=0;
; Line 584
	*** 0008aa	c7 46 fa 00 00 		mov	WORD PTR [bp-6],0	;rc
;|*** 
;|***   pRMparms = &stRMparms[wLoadCount];
; Line 586
	*** 0008af	8e 06 00 00 		mov	es,WORD PTR $T20000
	*** 0008b3	26 a1 00 00 		mov	ax,WORD PTR es:_wLoadCount
	*** 0008b7	8b c8 			mov	cx,ax
	*** 0008b9	d1 e0 			shl	ax,1
	*** 0008bb	03 c1 			add	ax,cx
	*** 0008bd	c1 e0 02 		shl	ax,2
	*** 0008c0	05 00 00 		add	ax,OFFSET _stRMparms
	*** 0008c3	89 46 fc 		mov	WORD PTR [bp-4],ax	;pRMparms
	*** 0008c6	c7 46 fe 00 00 		mov	WORD PTR [bp-2],SEG _stRMparms
;|***   AdapterStruct.HostBusType=AS_HOSTBUS_ISA;
; Line 587
	*** 0008cb	c7 06 e0 00 01 00 	mov	WORD PTR _AdapterStruct+12,1
;|***   AdapterStruct.InterfaceType=AS_INTF_16450;
; Line 588
	*** 0008d1	c7 06 de 00 01 00 	mov	WORD PTR _AdapterStruct+10,1
;|***   if ((rc = RMHELP_CreateStatusPort()) == 0)
; Line 589
	*** 0008d7	9a 00 00 00 00 		call	FAR PTR _RMHELP_CreateStatusPort
	*** 0008dc	89 46 fa 		mov	WORD PTR [bp-6],ax	;rc
	*** 0008df	3d 00 00 		cmp	ax,0
	*** 0008e2	74 03 			je	$JCC2274
	*** 0008e4	e9 32 00 		jmp	$I1991
					$JCC2274:
;|***     {
; Line 590
;|***     pRMparms->hAdapter = hAdapter[wLoadCount];
; Line 591
	*** 0008e7	8e 06 00 00 		mov	es,WORD PTR $T20000
	*** 0008eb	26 8b 1e 00 00 		mov	bx,WORD PTR es:_wLoadCount
	*** 0008f0	c1 e3 02 		shl	bx,2
	*** 0008f3	8b 87 1a 02 		mov	ax,WORD PTR _hAdapter[bx]
	*** 0008f7	8b 97 1c 02 		mov	dx,WORD PTR _hAdapter[bx+2]
	*** 0008fb	c4 5e fc 		les	bx,DWORD PTR [bp-4]	;pRMparms
	*** 0008fe	26 89 07 		mov	WORD PTR es:[bx],ax
	*** 000901	26 89 57 02 		mov	WORD PTR es:[bx+2],dx
;|***     rc = RMHELP_CreateLDev(wLoadCount);
; Line 592
	*** 000905	8e 06 00 00 		mov	es,WORD PTR $T20000
	*** 000909	26 ff 36 00 00 		push	WORD PTR es:_wLoadCount
	*** 00090e	9a 00 00 00 00 		call	FAR PTR _RMHELP_CreateLDev
	*** 000913	83 c4 02 		add	sp,2
	*** 000916	89 46 fa 		mov	WORD PTR [bp-6],ax	;rc
;|***     }
; Line 593
;|*** 
;|***   return(rc);
; Line 595
					$I1991:
	*** 000919	8b 46 fa 		mov	ax,WORD PTR [bp-6]	;rc
	*** 00091c	e9 00 00 		jmp	$EX1988
;|***   }
; Line 596
					$EX1988:
	*** 00091f	5e 			pop	si
	*** 000920	5f 			pop	di
	*** 000921	c9 			leave	
	*** 000922	cb 			ret	

_RMHELP_StatusPortInitComplete	ENDP
;|*** 
;|*** /*----------------------------------------------------------*/
;|*** /* RMHELP_PortDidntInstall - Free resources from a port     */
;|*** /*                                                          */
;|*** /* ARGS:  locus = code to indicate point of failure         */
;|*** /*        port  = adapter number to free                    */
;|*** /*                                                          */
;|*** /*----------------------------------------------------------*/
;|*** USHORT FAR RMHELP_PortDidntInstall(USHORT Locus, USHORT Port)
;|***   {
; Line 606
	PUBLIC	_RMHELP_PortDidntInstall
_RMHELP_PortDidntInstall	PROC FAR
	*** 000923	c8 00 00 00 		enter	0,0
	*** 000927	57 			push	di
	*** 000928	56 			push	si
;	Port = 8
;	Locus = 6
;|***   RMHELP_FreeAdapter(Port);
; Line 607
	*** 000929	ff 76 08 		push	WORD PTR [bp+8]	;Port
	*** 00092c	9a 00 00 00 00 		call	FAR PTR _RMHELP_FreeAdapter
	*** 000931	83 c4 02 		add	sp,2
;|***   return(0);
; Line 608
	*** 000934	b8 00 00 		mov	ax,0
	*** 000937	e9 00 00 		jmp	$EX1995
;|***   }
; Line 609
					$EX1995:
	*** 00093a	5e 			pop	si
	*** 00093b	5f 			pop	di
	*** 00093c	c9 			leave	
	*** 00093d	cb 			ret	

_RMHELP_PortDidntInstall	ENDP
;|*** 
;|*** /*----------------------------------------------------------*/
;|*** /* RMHELP_CreateLDev - Create logical device nodes          */
;|*** /*                                                          */
;|*** /* ARGS:                                                    */
;|*** /*        pComInfo  = pointer to ComInfo                    */
;|*** /*                                                          */
;|*** /*----------------------------------------------------------*/
;|*** USHORT FAR RMHELP_CreateLDev(USHORT usPortNumber)
;|***   {
; Line 619
	PUBLIC	_RMHELP_CreateLDev
_RMHELP_CreateLDev	PROC FAR
	*** 00093e	c8 4e 00 00 		enter	78,0
	*** 000942	57 			push	di
	*** 000943	56 			push	si
;	pComInfo = -78
;	pRMparms = -10
;	RMLDevStr = -26
;	pByte = -30
;	iIndex = -2
;	RMSysNameStr = -74
;	RMAdjunct = -62
;	hRMLDev = -6
;	hRMSysName = -36
;	rc = -32
;	usPortNumber = 6
;|***   DEVDEF _far *pComInfo;
;|***   RMDEF _far *pRMparms;
;|***   LDEVSTRUCT    RMLDevStr;
;|***   BYTE _far *pByte;
;|***   int iIndex;
;|***   SYSNAMESTRUCT RMSysNameStr;
;|***   ADJUNCT       RMAdjunct;
;|***   HLDEV         hRMLDev;
;|***   HSYSNAME      hRMSysName;
;|***   USHORT        rc=0;
; Line 629
	*** 000944	c7 46 e0 00 00 		mov	WORD PTR [bp-32],0	;rc
;|*** 
;|***   pComInfo = &_stDeviceParms[usPortNumber];
; Line 631
	*** 000949	69 46 06 be 00 		imul	ax,WORD PTR [bp+6],190	;usPortNumber
	*** 00094e	05 00 00 		add	ax,OFFSET __stDeviceParms
	*** 000951	89 46 b2 		mov	WORD PTR [bp-78],ax	;pComInfo
	*** 000954	c7 46 b4 00 00 		mov	WORD PTR [bp-76],SEG __stDeviceParms
;|***   pRMparms = &stRMparms[usPortNumber];
; Line 632
	*** 000959	8b 46 06 		mov	ax,WORD PTR [bp+6]	;usPortNumber
	*** 00095c	8b c8 			mov	cx,ax
	*** 00095e	d1 e0 			shl	ax,1
	*** 000960	03 c1 			add	ax,cx
	*** 000962	c1 e0 02 		shl	ax,2
	*** 000965	05 00 00 		add	ax,OFFSET _stRMparms
	*** 000968	89 46 f6 		mov	WORD PTR [bp-10],ax	;pRMparms
	*** 00096b	c7 46 f8 00 00 		mov	WORD PTR [bp-8],SEG _stRMparms
;|***   if ((pRMparms->hLDev) == 0)
; Line 633
	*** 000970	c4 5e f6 		les	bx,DWORD PTR [bp-10]	;pRMparms
	*** 000973	26 8b 47 06 		mov	ax,WORD PTR es:[bx+6]
	*** 000977	26 0b 47 04 		or	ax,WORD PTR es:[bx+4]
	*** 00097b	74 03 			je	$JCC2427
	*** 00097d	e9 13 01 		jmp	$I2008
					$JCC2427:
;|***     {
; Line 634
;|***     pByte = (BYTE *)&RMLDevStr;
; Line 635
	*** 000980	8d 46 e6 		lea	ax,WORD PTR [bp-26]	;RMLDevStr
	*** 000983	89 46 e2 		mov	WORD PTR [bp-30],ax	;pByte
	*** 000986	8c 56 e4 		mov	WORD PTR [bp-28],ss
;|***     for (iIndex = 0;iIndex < sizeof(LDEVSTRUCT);iIndex++)
; Line 636
	*** 000989	c7 46 fe 00 00 		mov	WORD PTR [bp-2],0	;iIndex
	*** 00098e	e9 03 00 		jmp	$F2009
					$FC2010:
	*** 000991	ff 46 fe 		inc	WORD PTR [bp-2]	;iIndex
					$F2009:
	*** 000994	83 7e fe 10 		cmp	WORD PTR [bp-2],16	;iIndex
	*** 000998	7c 03 			jl	$JCC2456
	*** 00099a	e9 0d 00 		jmp	$FB2011
					$JCC2456:
;|***       pByte[iIndex] = 0;
; Line 637
	*** 00099d	c4 5e e2 		les	bx,DWORD PTR [bp-30]	;pByte
	*** 0009a0	8b 76 fe 		mov	si,WORD PTR [bp-2]	;iIndex
	*** 0009a3	26 c6 00 00 		mov	BYTE PTR es:[bx][si],0
	*** 0009a7	e9 e7 ff 		jmp	$FC2010
					$FB2011:
;|***     pByte = (BYTE *)&RMSysNameStr;
; Line 638
	*** 0009aa	8d 46 b6 		lea	ax,WORD PTR [bp-74]	;RMSysNameStr
	*** 0009ad	89 46 e2 		mov	WORD PTR [bp-30],ax	;pByte
	*** 0009b0	8c 56 e4 		mov	WORD PTR [bp-28],ss
;|***     for (iIndex = 0;iIndex < sizeof(SYSNAMESTRUCT);iIndex++)
; Line 639
	*** 0009b3	c7 46 fe 00 00 		mov	WORD PTR [bp-2],0	;iIndex
	*** 0009b8	e9 03 00 		jmp	$F2012
					$FC2013:
	*** 0009bb	ff 46 fe 		inc	WORD PTR [bp-2]	;iIndex
					$F2012:
	*** 0009be	83 7e fe 0c 		cmp	WORD PTR [bp-2],12	;iIndex
	*** 0009c2	7c 03 			jl	$JCC2498
	*** 0009c4	e9 0d 00 		jmp	$FB2014
					$JCC2498:
;|***       pByte[iIndex] = 0;
; Line 640
	*** 0009c7	c4 5e e2 		les	bx,DWORD PTR [bp-30]	;pByte
	*** 0009ca	8b 76 fe 		mov	si,WORD PTR [bp-2]	;iIndex
	*** 0009cd	26 c6 00 00 		mov	BYTE PTR es:[bx][si],0
	*** 0009d1	e9 e7 ff 		jmp	$FC2013
					$FB2014:
;|*** 
;|***     RMLDevStr.LDevClass        = LDEV_CLASS_SERIAL;
; Line 642
	*** 0009d4	c7 46 ec 04 00 		mov	WORD PTR [bp-20],4
;|***     RMLDevStr.pAdjunctList     = &RMAdjunct;
; Line 643
	*** 0009d9	8d 46 c2 		lea	ax,WORD PTR [bp-62]	;RMAdjunct
	*** 0009dc	89 46 f2 		mov	WORD PTR [bp-14],ax
	*** 0009df	8c 56 f4 		mov	WORD PTR [bp-12],ss
;|***     RMAdjunct.AdjType          = ADJ_DEVICE_NUMBER;
; Line 644
	*** 0009e2	c7 46 c8 03 00 		mov	WORD PTR [bp-56],3
;|***     RMAdjunct.AdjLength        = sizeof(ADJUNCT);
; Line 645
	*** 0009e7	c7 46 c6 19 00 		mov	WORD PTR [bp-58],25
;|***     RMAdjunct.pNextAdj         = NULL;
; Line 646
	*** 0009ec	2b c9 			sub	cx,cx
	*** 0009ee	89 4e c4 		mov	WORD PTR [bp-60],cx
	*** 0009f1	89 4e c2 		mov	WORD PTR [bp-62],cx	;RMAdjunct
;|*** 
;|***     RMLDevStr.LDevDescriptName = LComName;
; Line 648
	*** 0009f4	c7 46 e6 ec 00 		mov	WORD PTR [bp-26],OFFSET DGROUP:_LComName	;RMLDevStr
	*** 0009f9	8c 5e e8 		mov	WORD PTR [bp-24],ds
;|***     RMAdjunct.Device_Number = usPortNumber;
; Line 649
	*** 0009fc	8b 46 06 		mov	ax,WORD PTR [bp+6]	;usPortNumber
	*** 0009ff	89 46 ca 		mov	WORD PTR [bp-54],ax
;|*** 
;|***     if ((rc = RMCreateLDev((HDRIVER)hDriver,
;|***                              (PHLDEV)&hRMLDev,
;|***                              (HDEVICE)pRMparms->hAdapter,
;|***                              (PLDEVSTRUCT)&RMLDevStr)) == 0)
; Line 654
	*** 000a02	8d 46 e6 		lea	ax,WORD PTR [bp-26]	;RMLDevStr
	*** 000a05	16 			push	ss
	*** 000a06	50 			push	ax
	*** 000a07	c4 5e f6 		les	bx,DWORD PTR [bp-10]	;pRMparms
	*** 000a0a	26 ff 77 02 		push	WORD PTR es:[bx+2]
	*** 000a0e	26 ff 37 		push	WORD PTR es:[bx]
	*** 000a11	8d 46 fa 		lea	ax,WORD PTR [bp-6]	;hRMLDev
	*** 000a14	16 			push	ss
	*** 000a15	50 			push	ax
	*** 000a16	ff 36 18 02 		push	WORD PTR _hDriver+2
	*** 000a1a	ff 36 16 02 		push	WORD PTR _hDriver
	*** 000a1e	9a 00 00 00 00 		call	FAR PTR _RMCreateLDev
	*** 000a23	83 c4 10 		add	sp,16
	*** 000a26	89 46 e0 		mov	WORD PTR [bp-32],ax	;rc
	*** 000a29	3d 00 00 		cmp	ax,0
	*** 000a2c	74 03 			je	$JCC2604
	*** 000a2e	e9 62 00 		jmp	$I2015
					$JCC2604:
;|***       {
; Line 655
;|***       pRMparms->hLDev = hRMLDev;
; Line 656
	*** 000a31	8b 46 fa 		mov	ax,WORD PTR [bp-6]	;hRMLDev
	*** 000a34	8b 56 fc 		mov	dx,WORD PTR [bp-4]
	*** 000a37	c4 5e f6 		les	bx,DWORD PTR [bp-10]	;pRMparms
	*** 000a3a	26 89 47 04 		mov	WORD PTR es:[bx+4],ax
	*** 000a3e	26 89 57 06 		mov	WORD PTR es:[bx+6],dx
;|***       RMSysNameStr.SysDescriptName = aszFSComName[usPortNumber];
; Line 657
	*** 000a42	8b 46 06 		mov	ax,WORD PTR [bp+6]	;usPortNumber
	*** 000a45	8b c8 			mov	cx,ax
	*** 000a47	c1 e0 02 		shl	ax,2
	*** 000a4a	03 c1 			add	ax,cx
	*** 000a4c	d1 e0 			shl	ax,1
	*** 000a4e	05 fa 00 		add	ax,OFFSET DGROUP:_aszFSComName
	*** 000a51	89 46 b6 		mov	WORD PTR [bp-74],ax	;RMSysNameStr
	*** 000a54	8c 5e b8 		mov	WORD PTR [bp-72],ds
;|***       RMSysNameStr.pAdjunctList    = NULL;
; Line 658
	*** 000a57	2b c0 			sub	ax,ax
	*** 000a59	89 46 bc 		mov	WORD PTR [bp-68],ax
	*** 000a5c	89 46 ba 		mov	WORD PTR [bp-70],ax
;|*** 
;|***       rc = RMCreateSysName((HDRIVER)hDriver,
;|***                            (PHSYSNAME)&hRMSysName,
;|***                            (HDEVICE)hRMLDev,
;|***                            (PSYSNAMESTRUCT)&RMSysNameStr);
; Line 663
	*** 000a5f	8d 46 b6 		lea	ax,WORD PTR [bp-74]	;RMSysNameStr
	*** 000a62	16 			push	ss
	*** 000a63	50 			push	ax
	*** 000a64	ff 76 fc 		push	WORD PTR [bp-4]
	*** 000a67	ff 76 fa 		push	WORD PTR [bp-6]	;hRMLDev
	*** 000a6a	8d 46 dc 		lea	ax,WORD PTR [bp-36]	;hRMSysName
	*** 000a6d	16 			push	ss
	*** 000a6e	50 			push	ax
	*** 000a6f	ff 36 18 02 		push	WORD PTR _hDriver+2
	*** 000a73	ff 36 16 02 		push	WORD PTR _hDriver
	*** 000a77	9a 00 00 00 00 		call	FAR PTR _RMCreateSysName
	*** 000a7c	83 c4 10 		add	sp,16
	*** 000a7f	89 46 e0 		mov	WORD PTR [bp-32],ax	;rc
;|*** 
;|***       pRMparms->hSysName = hRMSysName;
; Line 665
	*** 000a82	8b 46 dc 		mov	ax,WORD PTR [bp-36]	;hRMSysName
	*** 000a85	8b 56 de 		mov	dx,WORD PTR [bp-34]
	*** 000a88	c4 5e f6 		les	bx,DWORD PTR [bp-10]	;pRMparms
	*** 000a8b	26 89 47 08 		mov	WORD PTR es:[bx+8],ax
	*** 000a8f	26 89 57 0a 		mov	WORD PTR es:[bx+10],dx
;|***       }
; Line 666
;|***     }
; Line 667
					$I2015:
;|***   return rc;
; Line 668
					$I2008:
	*** 000a93	8b 46 e0 		mov	ax,WORD PTR [bp-32]	;rc
	*** 000a96	e9 00 00 		jmp	$EX1997
;|***   }
; Line 669
					$EX1997:
	*** 000a99	5e 			pop	si
	*** 000a9a	5f 			pop	di
	*** 000a9b	c9 			leave	
	*** 000a9c	cb 			ret	

_RMHELP_CreateLDev	ENDP
;|*** 
;|*** /*----------------------------------------------------------*/
;|*** /* RMHELP_DestroyLDev - Destroy logical device nodes        */
;|*** /*                                                          */
;|*** /* ARGS:  pComInfo = pointer to ComInfo Structure           */
;|*** /*                                                          */
;|*** /*                                                          */
;|*** /*----------------------------------------------------------*/
;|*** VOID FAR RMHELP_DestroyLDev(RMDEF _far *pRMparms)
;|***   {
; Line 679
	PUBLIC	_RMHELP_DestroyLDev
_RMHELP_DestroyLDev	PROC FAR
	*** 000a9d	c8 00 00 00 		enter	0,0
	*** 000aa1	57 			push	di
	*** 000aa2	56 			push	si
;	pRMparms = 6
;|***   if (pRMparms)
; Line 680
	*** 000aa3	8b 46 08 		mov	ax,WORD PTR [bp+8]
	*** 000aa6	0b 46 06 		or	ax,WORD PTR [bp+6]	;pRMparms
	*** 000aa9	75 03 			jne	$JCC2729
	*** 000aab	e9 63 00 		jmp	$I2018
					$JCC2729:
;|***     {
; Line 681
;|***     if (pRMparms->hSysName != 0)
; Line 682
	*** 000aae	c4 5e 06 		les	bx,DWORD PTR [bp+6]	;pRMparms
	*** 000ab1	26 8b 47 0a 		mov	ax,WORD PTR es:[bx+10]
	*** 000ab5	26 0b 47 08 		or	ax,WORD PTR es:[bx+8]
	*** 000ab9	75 03 			jne	$JCC2745
	*** 000abb	e9 1b 00 		jmp	$I2019
					$JCC2745:
;|***       RMDestroySysName(hDriver,pRMparms->hSysName);
; Line 683
	*** 000abe	c4 5e 06 		les	bx,DWORD PTR [bp+6]	;pRMparms
	*** 000ac1	26 ff 77 0a 		push	WORD PTR es:[bx+10]
	*** 000ac5	26 ff 77 08 		push	WORD PTR es:[bx+8]
	*** 000ac9	ff 36 18 02 		push	WORD PTR _hDriver+2
	*** 000acd	ff 36 16 02 		push	WORD PTR _hDriver
	*** 000ad1	9a 00 00 00 00 		call	FAR PTR _RMDestroySysName
	*** 000ad6	83 c4 08 		add	sp,8
;|***     if (pRMparms->hLDev)
; Line 684
					$I2019:
	*** 000ad9	c4 5e 06 		les	bx,DWORD PTR [bp+6]	;pRMparms
	*** 000adc	26 8b 47 06 		mov	ax,WORD PTR es:[bx+6]
	*** 000ae0	26 0b 47 04 		or	ax,WORD PTR es:[bx+4]
	*** 000ae4	75 03 			jne	$JCC2788
	*** 000ae6	e9 1b 00 		jmp	$I2020
					$JCC2788:
;|***       RMDestroyLDev(hDriver,pRMparms->hLDev);
; Line 685
	*** 000ae9	c4 5e 06 		les	bx,DWORD PTR [bp+6]	;pRMparms
	*** 000aec	26 ff 77 06 		push	WORD PTR es:[bx+6]
	*** 000af0	26 ff 77 04 		push	WORD PTR es:[bx+4]
	*** 000af4	ff 36 18 02 		push	WORD PTR _hDriver+2
	*** 000af8	ff 36 16 02 		push	WORD PTR _hDriver
	*** 000afc	9a 00 00 00 00 		call	FAR PTR _RMDestroyLDev
	*** 000b01	83 c4 08 		add	sp,8
;|***     pRMparms->hLDev = 0;
; Line 686
					$I2020:
	*** 000b04	c4 5e 06 		les	bx,DWORD PTR [bp+6]	;pRMparms
	*** 000b07	2b c0 			sub	ax,ax
	*** 000b09	26 89 47 06 		mov	WORD PTR es:[bx+6],ax
	*** 000b0d	26 89 47 04 		mov	WORD PTR es:[bx+4],ax
;|***     }
; Line 687
;|***   }
; Line 688
					$I2018:
					$EX2017:
	*** 000b11	5e 			pop	si
	*** 000b12	5f 			pop	di
	*** 000b13	c9 			leave	
	*** 000b14	cb 			ret	

_RMHELP_DestroyLDev	ENDP
;|*** 
;|*** /*----------------------------------------------------------*/
;|*** /* RMHELP_FindPCMCIA - Find PCMCIA Node to hang LDEV        */
;|*** /*                                                          */
;|*** /*----------------------------------------------------------*/
;|*** VOID FAR RMHELP_FindPCMCIANode(USHORT usPortNumber)
;|***   {
; Line 695
	PUBLIC	_RMHELP_FindPCMCIANode
_RMHELP_FindPCMCIANode	PROC FAR
	*** 000b15	c8 0c 00 00 		enter	12,0
	*** 000b19	57 			push	di
	*** 000b1a	56 			push	si
;	pRMparms = -4
;	HandleList = -12
;	usPortNumber = 6
;|***   RMDEF _far *pRMparms;
;|***   HANDLELIST HandleList;
;|*** 
;|***   pRMparms = &stRMparms[usPortNumber];
; Line 699
	*** 000b1b	8b 46 06 		mov	ax,WORD PTR [bp+6]	;usPortNumber
	*** 000b1e	8b c8 			mov	cx,ax
	*** 000b20	d1 e0 			shl	ax,1
	*** 000b22	03 c1 			add	ax,cx
	*** 000b24	c1 e0 02 		shl	ax,2
	*** 000b27	05 00 00 		add	ax,OFFSET _stRMparms
	*** 000b2a	89 46 fc 		mov	WORD PTR [bp-4],ax	;pRMparms
	*** 000b2d	c7 46 fe 00 00 		mov	WORD PTR [bp-2],SEG _stRMparms
;|***   HandleList.cMaxHandles = 1;
; Line 700
	*** 000b32	c7 46 f4 01 00 		mov	WORD PTR [bp-12],1	;HandleList
;|*** 
;|***   if (!(RMKeyToHandleList(HANDLE_PHYS_TREE,"PCMCIA*",&HandleList)))
; Line 702
	*** 000b37	8d 46 f4 		lea	ax,WORD PTR [bp-12]	;HandleList
	*** 000b3a	16 			push	ss
	*** 000b3b	50 			push	ax
	*** 000b3c	1e 			push	ds
	*** 000b3d	68 72 04 		push	OFFSET DGROUP:$SG2027
	*** 000b40	6a ff 			push	-1
	*** 000b42	68 00 80 		push	-32768
	*** 000b45	9a 00 00 00 00 		call	FAR PTR _RMKeyToHandleList
	*** 000b4a	83 c4 0c 		add	sp,12
	*** 000b4d	3d 00 00 		cmp	ax,0
	*** 000b50	74 03 			je	$JCC2896
	*** 000b52	e9 2b 00 		jmp	$I2026
					$JCC2896:
;|***     {
; Line 703
;|***     if(HandleList.cHandles)
; Line 704
	*** 000b55	83 7e f6 00 		cmp	WORD PTR [bp-10],0
	*** 000b59	75 03 			jne	$JCC2905
	*** 000b5b	e9 13 00 		jmp	$I2028
					$JCC2905:
;|***       pRMparms->hAdapter = HandleList.Handles[0];
; Line 705
	*** 000b5e	8b 46 f8 		mov	ax,WORD PTR [bp-8]
	*** 000b61	8b 56 fa 		mov	dx,WORD PTR [bp-6]
	*** 000b64	c4 5e fc 		les	bx,DWORD PTR [bp-4]	;pRMparms
	*** 000b67	26 89 07 		mov	WORD PTR es:[bx],ax
	*** 000b6a	26 89 57 02 		mov	WORD PTR es:[bx+2],dx
;|***     else
; Line 706
	*** 000b6e	e9 0c 00 		jmp	$I2029
					$I2028:
;|***       pRMparms->hAdapter = 0;
; Line 707
	*** 000b71	c4 5e fc 		les	bx,DWORD PTR [bp-4]	;pRMparms
	*** 000b74	2b c0 			sub	ax,ax
	*** 000b76	26 89 47 02 		mov	WORD PTR es:[bx+2],ax
	*** 000b7a	26 89 07 		mov	WORD PTR es:[bx],ax
					$I2029:
;|***     }
; Line 708
;|***   else
; Line 709
	*** 000b7d	e9 0c 00 		jmp	$I2030
					$I2026:
;|***    pRMparms->hAdapter = 0;
; Line 710
	*** 000b80	c4 5e fc 		les	bx,DWORD PTR [bp-4]	;pRMparms
	*** 000b83	2b c0 			sub	ax,ax
	*** 000b85	26 89 47 02 		mov	WORD PTR es:[bx+2],ax
	*** 000b89	26 89 07 		mov	WORD PTR es:[bx],ax
					$I2030:
;|***   }
; Line 711
					$EX2023:
	*** 000b8c	5e 			pop	si
	*** 000b8d	5f 			pop	di
	*** 000b8e	c9 			leave	
	*** 000b8f	cb 			ret	

_RMHELP_FindPCMCIANode	ENDP
;|*** 
;|*** /*----------------------------------------------------------*/
;|*** /* RMHELP_HasPNPCaps - Has PNP Capabilities                 */
;|*** /*                                                          */
;|*** /*                                                          */
;|*** /*----------------------------------------------------------*/
;|*** BOOL FAR RMHELP_HasPNPCaps(void)
;|***   {
; Line 719
	PUBLIC	_RMHELP_HasPNPCaps
_RMHELP_HasPNPCaps	PROC FAR
	*** 000b90	c8 0a 00 00 		enter	10,0
	*** 000b94	57 			push	di
	*** 000b95	56 			push	si
;	rc = -6
;	pSelGInfoSeg = -10
;	pGInfoSeg = -4
;|***   APIRET     rc;
;|***   PSEL       pSelGInfoSeg;
;|***   PGINFOSEG  pGInfoSeg = NULL;
; Line 722
	*** 000b96	2b c0 			sub	ax,ax
	*** 000b98	89 46 fe 		mov	WORD PTR [bp-2],ax
	*** 000b9b	89 46 fc 		mov	WORD PTR [bp-4],ax	;pGInfoSeg
;|*** 
;|*** 
;|***   /*--------------------------------------------------*/
;|***   /* Resource manager originally did not include      */
;|***   /* RMGetVersion so this is our only method to know  */
;|***   /* if it is safe to later call RMDevIDToHandleList  */
;|***   /*--------------------------------------------------*/
;|*** 
;|***   /*---------------------------------------------------*/
;|***   /* Call GetDOSVar to find OS Major and Minor Version */
;|***   /* PDD Ref states that it is not safe at Init time   */
;|***   /* but tests show it is.  Anyway, we don't have any  */
;|***   /* other method since the 16 bit DosQSysInfo didn't  */
;|***   /* support getting the OS version.                   */
;|***   /*---------------------------------------------------*/
;|*** 
;|*** 
;|***   rc = DevHelp_GetDOSVar( DHGETDOSV_SYSINFOSEG, &pSelGInfoSeg );
; Line 740
	*** 000b9e	8d 46 f6 		lea	ax,WORD PTR [bp-10]	;pSelGInfoSeg
	*** 000ba1	16 			push	ss
	*** 000ba2	50 			push	ax
	*** 000ba3	6a 01 			push	1
	*** 000ba5	9a 00 00 00 00 		call	FAR PTR _DevHelp_GetDOSVar
	*** 000baa	83 c4 06 		add	sp,6
	*** 000bad	89 46 fa 		mov	WORD PTR [bp-6],ax	;rc
;|*** //  rc = DevHelp_GetDOSVar( DHGETDOSV_SYSINFOSEG, pGInfoSeg );
;|*** 
;|***   if(rc == 0)
; Line 743
	*** 000bb0	83 7e fa 00 		cmp	WORD PTR [bp-6],0	;rc
	*** 000bb4	74 03 			je	$JCC2996
	*** 000bb6	e9 44 00 		jmp	$I2036
					$JCC2996:
;|***     {
; Line 744
;|***     /*--------------------------------*/
;|***     /* Build virtaddr from selector   */
;|***     /*--------------------------------*/
;|*** 
;|***     pGInfoSeg = (PGINFOSEG)((ULONG)*pSelGInfoSeg << 16);
; Line 749
	*** 000bb9	c4 5e f6 		les	bx,DWORD PTR [bp-10]	;pSelGInfoSeg
	*** 000bbc	26 8b 07 		mov	ax,WORD PTR es:[bx]
	*** 000bbf	c7 46 fc 00 00 		mov	WORD PTR [bp-4],0	;pGInfoSeg
	*** 000bc4	89 46 fe 		mov	WORD PTR [bp-2],ax
;|*** 
;|***     /*-------------------------*/
;|***     /* Is on version > Warp?   */
;|***     /*-------------------------*/
;|*** 
;|***     if ( (pGInfoSeg->uchMajorVersion > 20) ||
;|***        ( (pGInfoSeg->uchMajorVersion == 20) &&
;|***          (pGInfoSeg->uchMinorVersion > 30) ) )
; Line 757
	*** 000bc7	c4 5e fc 		les	bx,DWORD PTR [bp-4]	;pGInfoSeg
	*** 000bca	26 80 7f 15 14 		cmp	BYTE PTR es:[bx+21],20
	*** 000bcf	76 03 			jbe	$JCC3023
	*** 000bd1	e9 1a 00 		jmp	$I2038
					$JCC3023:
	*** 000bd4	c4 5e fc 		les	bx,DWORD PTR [bp-4]	;pGInfoSeg
	*** 000bd7	26 80 7f 15 14 		cmp	BYTE PTR es:[bx+21],20
	*** 000bdc	74 03 			je	$JCC3036
	*** 000bde	e9 16 00 		jmp	$I2037
					$JCC3036:
	*** 000be1	c4 5e fc 		les	bx,DWORD PTR [bp-4]	;pGInfoSeg
	*** 000be4	26 80 7f 16 1e 		cmp	BYTE PTR es:[bx+22],30
	*** 000be9	77 03 			ja	$JCC3049
	*** 000beb	e9 09 00 		jmp	$I2037
					$JCC3049:
					$I2038:
;|***       return(TRUE);
; Line 758
	*** 000bee	b8 01 00 		mov	ax,1
	*** 000bf1	e9 0f 00 		jmp	$EX2032
;|***     else
; Line 759
	*** 000bf4	e9 06 00 		jmp	$I2039
					$I2037:
;|***       return(FALSE);
; Line 760
	*** 000bf7	b8 00 00 		mov	ax,0
	*** 000bfa	e9 06 00 		jmp	$EX2032
					$I2039:
;|***     }
; Line 761
;|***   return(FALSE);
; Line 762
					$I2036:
	*** 000bfd	b8 00 00 		mov	ax,0
	*** 000c00	e9 00 00 		jmp	$EX2032
;|***   }
; Line 763
					$EX2032:
	*** 000c03	5e 			pop	si
	*** 000c04	5f 			pop	di
	*** 000c05	c9 			leave	
	*** 000c06	cb 			ret	

_RMHELP_HasPNPCaps	ENDP
;|*** /*----------------------------------------------------------*/
;|*** /* RMHELP_FindDetectedRes - Return port resource for this  */
;|*** /*                          Detected Struct                */
;|*** /*                                                          */
;|*** /*----------------------------------------------------------*/
;|*** BOOL FAR RMHELP_FindDetectedRes( RMHANDLE hDetected, PUSHORT pAddr, PUSHORT pIRQ )
;|***   {
; Line 770
	PUBLIC	_RMHELP_FindDetectedRes
_RMHELP_FindDetectedRes	PROC FAR
	*** 000c07	c8 24 02 00 		enter	548,0
	*** 000c0b	57 			push	di
	*** 000c0c	56 			push	si
;	portAddr = -6
;	i = -548
;	hResource = -4
;	rs = -538
;	rc = -540
;	NodeInfo = -518
;	pResList = -544
;	pIRQ = 14
;	pAddr = 10
;	hDetected = 6
;|***   APIRET rc;
;|*** 
;|***   UCHAR          NodeInfo[512];  // Big Number
;|***   PRESOURCELIST  pResList;
;|***   USHORT         portAddr=0;
; Line 775
	*** 000c0d	c7 46 fa 00 00 		mov	WORD PTR [bp-6],0	;portAddr
;|***   ULONG          i;
;|***   HRESOURCE      hResource;
;|***   RESOURCESTRUCT rs;
;|*** 
;|***   *pIRQ = *pAddr = 0;
; Line 780
	*** 000c12	b8 00 00 		mov	ax,0
	*** 000c15	c4 5e 0a 		les	bx,DWORD PTR [bp+10]	;pAddr
	*** 000c18	26 89 07 		mov	WORD PTR es:[bx],ax
	*** 000c1b	c4 5e 0e 		les	bx,DWORD PTR [bp+14]	;pIRQ
	*** 000c1e	26 89 07 		mov	WORD PTR es:[bx],ax
;|*** 
;|***   rc = RMGetNodeInfo( hDetected,
;|***                      (PRM_GETNODE_DATA)&NodeInfo[0],
;|***                       512);
; Line 784
	*** 000c21	68 00 02 		push	512
	*** 000c24	8d 86 fa fd 		lea	ax,WORD PTR [bp-518]	;NodeInfo
	*** 000c28	16 			push	ss
	*** 000c29	50 			push	ax
	*** 000c2a	ff 76 08 		push	WORD PTR [bp+8]
	*** 000c2d	ff 76 06 		push	WORD PTR [bp+6]	;hDetected
	*** 000c30	9a 00 00 00 00 		call	FAR PTR _RMGetNodeInfo
	*** 000c35	83 c4 0a 		add	sp,10
	*** 000c38	89 86 e4 fd 		mov	WORD PTR [bp-540],ax	;rc
;|*** 
;|***   /*-----------------------------*/
;|***   /* Find Base Port Address      */
;|***   /*-----------------------------*/
;|*** 
;|***   if(!rc)
; Line 790
	*** 000c3c	83 be e4 fd 00 		cmp	WORD PTR [bp-540],0	;rc
	*** 000c41	74 03 			je	$JCC3137
	*** 000c43	e9 bf 00 		jmp	$I2052
					$JCC3137:
;|***     if(pResList = ((PRM_GETNODE_DATA)NodeInfo)->RMNode.pResourceList)
; Line 791
	*** 000c46	8b 86 0e fe 		mov	ax,WORD PTR [bp-498]
	*** 000c4a	8b 96 10 fe 		mov	dx,WORD PTR [bp-496]
	*** 000c4e	89 86 e0 fd 		mov	WORD PTR [bp-544],ax	;pResList
	*** 000c52	89 96 e2 fd 		mov	WORD PTR [bp-542],dx
	*** 000c56	0b d0 			or	dx,ax
	*** 000c58	75 03 			jne	$JCC3160
	*** 000c5a	e9 a8 00 		jmp	$I2053
					$JCC3160:
;|***       for(i=0;i<pResList->Count;i++)
; Line 792
	*** 000c5d	2b c0 			sub	ax,ax
	*** 000c5f	89 86 de fd 		mov	WORD PTR [bp-546],ax
	*** 000c63	89 86 dc fd 		mov	WORD PTR [bp-548],ax	;i
	*** 000c67	e9 0a 00 		jmp	$F2054
					$FC2055:
	*** 000c6a	83 86 dc fd 01 		add	WORD PTR [bp-548],1	;i
	*** 000c6f	83 96 de fd 00 		adc	WORD PTR [bp-546],0
					$F2054:
	*** 000c74	8b 86 dc fd 		mov	ax,WORD PTR [bp-548]	;i
	*** 000c78	8b 96 de fd 		mov	dx,WORD PTR [bp-546]
	*** 000c7c	c4 9e e0 fd 		les	bx,DWORD PTR [bp-544]	;pResList
	*** 000c80	26 39 57 02 		cmp	WORD PTR es:[bx+2],dx
	*** 000c84	73 03 			jae	$JCC3204
	*** 000c86	e9 7c 00 		jmp	$FB2056
					$JCC3204:
	*** 000c89	76 03 			jbe	$JCC3209
	*** 000c8b	e9 08 00 		jmp	$L20004
					$JCC3209:
	*** 000c8e	26 39 07 		cmp	WORD PTR es:[bx],ax
	*** 000c91	77 03 			ja	$JCC3217
	*** 000c93	e9 6f 00 		jmp	$FB2056
					$JCC3217:
					$L20004:
;|***         {
; Line 793
;|***         if(pResList->Resource[i].ResourceType == RS_TYPE_IO)
; Line 794
	*** 000c96	6b b6 dc fd 14 		imul	si,WORD PTR [bp-548],20	;i
	*** 000c9b	c4 9e e0 fd 		les	bx,DWORD PTR [bp-544]	;pResList
	*** 000c9f	26 83 78 04 01 		cmp	WORD PTR es:[bx+4][si],1
	*** 000ca4	74 03 			je	$JCC3236
	*** 000ca6	e9 20 00 		jmp	$I2057
					$JCC3236:
	*** 000ca9	26 83 78 06 00 		cmp	WORD PTR es:[bx+6][si],0
	*** 000cae	74 03 			je	$JCC3246
	*** 000cb0	e9 16 00 		jmp	$I2057
					$JCC3246:
;|***           {
; Line 795
;|***           *pAddr = pResList->Resource[i].IOResource.BaseIOPort;
; Line 796
	*** 000cb3	6b b6 dc fd 14 		imul	si,WORD PTR [bp-548],20	;i
	*** 000cb8	c4 9e e0 fd 		les	bx,DWORD PTR [bp-544]	;pResList
	*** 000cbc	26 8b 40 08 		mov	ax,WORD PTR es:[bx+8][si]
	*** 000cc0	c4 5e 0a 		les	bx,DWORD PTR [bp+10]	;pAddr
	*** 000cc3	26 89 07 		mov	WORD PTR es:[bx],ax
;|***           }
; Line 797
;|***         else
; Line 798
	*** 000cc6	e9 39 00 		jmp	$I2058
					$I2057:
;|***           if(pResList->Resource[i].ResourceType == RS_TYPE_IRQ)
; Line 799
	*** 000cc9	6b b6 dc fd 14 		imul	si,WORD PTR [bp-548],20	;i
	*** 000cce	c4 9e e0 fd 		les	bx,DWORD PTR [bp-544]	;pResList
	*** 000cd2	26 83 78 04 02 		cmp	WORD PTR es:[bx+4][si],2
	*** 000cd7	74 03 			je	$JCC3287
	*** 000cd9	e9 20 00 		jmp	$I2059
					$JCC3287:
	*** 000cdc	26 83 78 06 00 		cmp	WORD PTR es:[bx+6][si],0
	*** 000ce1	74 03 			je	$JCC3297
	*** 000ce3	e9 16 00 		jmp	$I2059
					$JCC3297:
;|***             *pIRQ = pResList->Resource[i].IRQResource.IRQLevel;
; Line 800
	*** 000ce6	6b b6 dc fd 14 		imul	si,WORD PTR [bp-548],20	;i
	*** 000ceb	c4 9e e0 fd 		les	bx,DWORD PTR [bp-544]	;pResList
	*** 000cef	26 8b 40 08 		mov	ax,WORD PTR es:[bx+8][si]
	*** 000cf3	c4 5e 0e 		les	bx,DWORD PTR [bp+14]	;pIRQ
	*** 000cf6	26 89 07 		mov	WORD PTR es:[bx],ax
;|***           else
; Line 801
	*** 000cf9	e9 06 00 		jmp	$I2060
					$I2059:
;|***             return(FALSE);
; Line 802
	*** 000cfc	b8 00 00 		mov	ax,0
	*** 000cff	e9 97 00 		jmp	$EX2044
					$I2060:
					$I2058:
;|***         }
; Line 803
	*** 000d02	e9 65 ff 		jmp	$FC2055
					$FB2056:
;|*** 
;|***   /*-------------------------------*/
;|***   /* Make sure we found resources  */
;|***   /* Note: IRQ0 not possible       */
;|***   /*-------------------------------*/
;|*** 
;|***   if (!(*pAddr && *pIRQ))
; Line 810
					$I2053:
					$I2052:
	*** 000d05	c4 5e 0a 		les	bx,DWORD PTR [bp+10]	;pAddr
	*** 000d08	26 83 3f 00 		cmp	WORD PTR es:[bx],0
	*** 000d0c	75 03 			jne	$JCC3340
	*** 000d0e	e9 0c 00 		jmp	$I2062
					$JCC3340:
	*** 000d11	c4 5e 0e 		les	bx,DWORD PTR [bp+14]	;pIRQ
	*** 000d14	26 83 3f 00 		cmp	WORD PTR es:[bx],0
	*** 000d18	74 03 			je	$JCC3352
	*** 000d1a	e9 06 00 		jmp	$I2061
					$JCC3352:
					$I2062:
;|***     return(FALSE);
; Line 811
	*** 000d1d	b8 00 00 		mov	ax,0
	*** 000d20	e9 76 00 		jmp	$EX2044
;|*** 
;|***   /*------------------------------------*/
;|***   /* Try to get the IO resource from RM */
;|***   /* just in case serial snooper found  */
;|***   /* driver, but mouse actually claimed */
;|***   /*------------------------------------*/
;|*** 
;|***   rs.ResourceType = RS_TYPE_IO;
; Line 819
					$I2061:
	*** 000d23	c7 86 e6 fd 01 00 	mov	WORD PTR [bp-538],1	;rs
	*** 000d29	c7 86 e8 fd 00 00 	mov	WORD PTR [bp-536],0
;|***   rs.IOResource.BaseIOPort = *pAddr;
; Line 820
	*** 000d2f	c4 5e 0a 		les	bx,DWORD PTR [bp+10]	;pAddr
	*** 000d32	26 8b 07 		mov	ax,WORD PTR es:[bx]
	*** 000d35	89 86 ea fd 		mov	WORD PTR [bp-534],ax
;|***   rs.IOResource.NumIOPorts = 8;
; Line 821
	*** 000d39	c7 86 ec fd 08 00 	mov	WORD PTR [bp-532],8
;|***   rs.IOResource.IOFlags = RS_IO_EXCLUSIVE;
; Line 822
	*** 000d3f	c7 86 ee fd 01 00 	mov	WORD PTR [bp-530],1
;|***   rs.IOResource.IOAddressLines = 16;
; Line 823
	*** 000d45	c7 86 f0 fd 10 00 	mov	WORD PTR [bp-528],16
;|*** 
;|***   rc = RMAllocResource(hDriver, &hResource, &rs);
; Line 825
	*** 000d4b	8d 86 e6 fd 		lea	ax,WORD PTR [bp-538]	;rs
	*** 000d4f	16 			push	ss
	*** 000d50	50 			push	ax
	*** 000d51	8d 46 fc 		lea	ax,WORD PTR [bp-4]	;hResource
	*** 000d54	16 			push	ss
	*** 000d55	50 			push	ax
	*** 000d56	ff 36 18 02 		push	WORD PTR _hDriver+2
	*** 000d5a	ff 36 16 02 		push	WORD PTR _hDriver
	*** 000d5e	9a 00 00 00 00 		call	FAR PTR _RMAllocResource
	*** 000d63	83 c4 0c 		add	sp,12
	*** 000d66	89 86 e4 fd 		mov	WORD PTR [bp-540],ax	;rc
;|*** 
;|***   if(rc)
; Line 827
	*** 000d6a	83 be e4 fd 00 		cmp	WORD PTR [bp-540],0	;rc
	*** 000d6f	75 03 			jne	$JCC3439
	*** 000d71	e9 09 00 		jmp	$I2063
					$JCC3439:
;|***     return(FALSE);
; Line 828
	*** 000d74	b8 00 00 		mov	ax,0
	*** 000d77	e9 1f 00 		jmp	$EX2044
;|***   else
; Line 829
	*** 000d7a	e9 16 00 		jmp	$I2064
					$I2063:
;|***     RMDeallocResource(hDriver, hResource);
; Line 830
	*** 000d7d	ff 76 fe 		push	WORD PTR [bp-2]
	*** 000d80	ff 76 fc 		push	WORD PTR [bp-4]	;hResource
	*** 000d83	ff 36 18 02 		push	WORD PTR _hDriver+2
	*** 000d87	ff 36 16 02 		push	WORD PTR _hDriver
	*** 000d8b	9a 00 00 00 00 		call	FAR PTR _RMDeallocResource
	*** 000d90	83 c4 08 		add	sp,8
					$I2064:
;|*** 
;|***   return(TRUE);
; Line 832
	*** 000d93	b8 01 00 		mov	ax,1
	*** 000d96	e9 00 00 		jmp	$EX2044
;|***   }
; Line 833
					$EX2044:
	*** 000d99	5e 			pop	si
	*** 000d9a	5f 			pop	di
	*** 000d9b	c9 			leave	
	*** 000d9c	cb 			ret	

_RMHELP_FindDetectedRes	ENDP
;|*** 
;|*** /*----------------------------------------------------------*/
;|*** /* RMHELP_FindDetected - Find Detected Structures           */
;|*** /*                                                          */
;|*** /* ARGS:  pComInfo = pointer to ComInfo Structure           */
;|*** /*                                                          */
;|*** /*                                                          */
;|*** /*----------------------------------------------------------*/
;|*** VOID FAR RMHELP_UpdateComInfo( DEVDEF *pComInfo, PHANDLELIST pHandlelist )
;|***   {
; Line 843
	PUBLIC	_RMHELP_UpdateComInfo
_RMHELP_UpdateComInfo	PROC FAR
	*** 000d9d	c8 14 00 00 		enter	20,0
	*** 000da1	57 			push	di
	*** 000da2	56 			push	si
;	rc = -8
;	i = -14
;	j = -16
;	portAddr = -2
;	Irq = -20
;	pBDA = -12
;	found = -18
;	pFirstComInfo = -6
;	pHandlelist = 10
;	pComInfo = 6
;|*** //  COMDCB _far *pConfig;
;|*** //  DEVDEF _far *pComInfo;
;|*** //  pComInfo = &_stDeviceParms[usPortNumber];
;|*** //  pConfig = &stConfigParms[usPortNumber];
;|*** 
;|***   APIRET      rc;
;|***   USHORT      i,j;
;|***   USHORT      portAddr;
;|***   USHORT      Irq;
;|***   PUSHORT     pBDA = (PUSHORT)0x400000;  /* 40:0000 Bios Data Area */
; Line 853
	*** 000da3	c7 46 f4 00 00 		mov	WORD PTR [bp-12],0	;pBDA
	*** 000da8	c7 46 f6 40 00 		mov	WORD PTR [bp-10],64
;|***   BOOL        found;
;|***   DEVDEF      *pFirstComInfo = pComInfo;
; Line 855
	*** 000dad	8b 46 06 		mov	ax,WORD PTR [bp+6]	;pComInfo
	*** 000db0	8b 56 08 		mov	dx,WORD PTR [bp+8]
	*** 000db3	89 46 fa 		mov	WORD PTR [bp-6],ax	;pFirstComInfo
	*** 000db6	89 56 fc 		mov	WORD PTR [bp-4],dx
;|*** 
;|*** 
;|***   /*-----------------------------------------*/
;|***   /* Reminder - Don't count ports with mouse */
;|***   /*-----------------------------------------*/
;|*** 
;|***   for (i=0; i<pHandlelist->cHandles;i++)
; Line 862
	*** 000db9	c7 46 f2 00 00 		mov	WORD PTR [bp-14],0	;i
	*** 000dbe	e9 03 00 		jmp	$F2077
					$FC2078:
	*** 000dc1	ff 46 f2 		inc	WORD PTR [bp-14]	;i
					$F2077:
	*** 000dc4	8b 46 f2 		mov	ax,WORD PTR [bp-14]	;i
	*** 000dc7	c4 5e 0a 		les	bx,DWORD PTR [bp+10]	;pHandlelist
	*** 000dca	26 39 47 02 		cmp	WORD PTR es:[bx+2],ax
	*** 000dce	77 03 			ja	$JCC3534
	*** 000dd0	e9 4e 01 		jmp	$FB2079
					$JCC3534:
;|***     {
; Line 863
;|***     /****************************************/
;|***     /* Get Resources for this device handle */
;|***     /****************************************/
;|*** 
;|***     rc = RMHELP_FindDetectedRes( pHandlelist->Handles[i], &portAddr, &Irq);
; Line 868
	*** 000dd3	8d 46 ec 		lea	ax,WORD PTR [bp-20]	;Irq
	*** 000dd6	16 			push	ss
	*** 000dd7	50 			push	ax
	*** 000dd8	8d 46 fe 		lea	ax,WORD PTR [bp-2]	;portAddr
	*** 000ddb	16 			push	ss
	*** 000ddc	50 			push	ax
	*** 000ddd	8b 76 f2 		mov	si,WORD PTR [bp-14]	;i
	*** 000de0	c1 e6 02 		shl	si,2
	*** 000de3	c4 5e 0a 		les	bx,DWORD PTR [bp+10]	;pHandlelist
	*** 000de6	83 c3 04 		add	bx,4
	*** 000de9	26 ff 70 02 		push	WORD PTR es:[bx+2][si]
	*** 000ded	26 ff 30 		push	WORD PTR es:[bx][si]
	*** 000df0	9a 00 00 00 00 		call	FAR PTR _RMHELP_FindDetectedRes
	*** 000df5	83 c4 0c 		add	sp,12
	*** 000df8	89 46 f8 		mov	WORD PTR [bp-8],ax	;rc
;|*** 
;|***     if(rc==TRUE)
; Line 870
	*** 000dfb	83 7e f8 01 		cmp	WORD PTR [bp-8],1	;rc
	*** 000dff	74 03 			je	$JCC3583
	*** 000e01	e9 1a 01 		jmp	$I2080
					$JCC3583:
;|***       {
; Line 871
;|***       found = FALSE;
; Line 872
	*** 000e04	c7 46 ee 00 00 		mov	WORD PTR [bp-18],0	;found
;|***       pComInfo = pFirstComInfo;
; Line 873
	*** 000e09	8b 46 fa 		mov	ax,WORD PTR [bp-6]	;pFirstComInfo
	*** 000e0c	8b 56 fc 		mov	dx,WORD PTR [bp-4]
	*** 000e0f	89 46 06 		mov	WORD PTR [bp+6],ax	;pComInfo
	*** 000e12	89 56 08 		mov	WORD PTR [bp+8],dx
;|*** 
;|***       for(j = 0; j < MAXADN; j++)
; Line 875
	*** 000e15	c7 46 f0 00 00 		mov	WORD PTR [bp-16],0	;j
	*** 000e1a	e9 03 00 		jmp	$F2081
					$FC2082:
	*** 000e1d	ff 46 f0 		inc	WORD PTR [bp-16]	;j
					$F2081:
	*** 000e20	83 7e f0 10 		cmp	WORD PTR [bp-16],16	;j
	*** 000e24	72 03 			jb	$JCC3620
	*** 000e26	e9 1f 00 		jmp	$FB2083
					$JCC3620:
;|***         {
; Line 876
;|***         if(pComInfo->wIObaseAddress == portAddr)
; Line 877
	*** 000e29	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;portAddr
	*** 000e2c	c4 5e 06 		les	bx,DWORD PTR [bp+6]	;pComInfo
	*** 000e2f	26 39 47 32 		cmp	WORD PTR es:[bx+50],ax
	*** 000e33	74 03 			je	$JCC3635
	*** 000e35	e9 08 00 		jmp	$I2084
					$JCC3635:
;|***           {
; Line 878
;|***           found = TRUE;
; Line 879
	*** 000e38	c7 46 ee 01 00 		mov	WORD PTR [bp-18],1	;found
;|***           break;
; Line 880
	*** 000e3d	e9 08 00 		jmp	$FB2083
;|***           }
; Line 881
;|*** 
;|***         pComInfo++;    /* Jump to next cominfo */
; Line 883
					$I2084:
	*** 000e40	81 46 06 be 00 		add	WORD PTR [bp+6],190	;pComInfo
;|***         }
; Line 884
	*** 000e45	e9 d5 ff 		jmp	$FC2082
					$FB2083:
;|*** 
;|***       if(found == TRUE)    /* Config.sys line had it filled in */
; Line 886
	*** 000e48	83 7e ee 01 		cmp	WORD PTR [bp-18],1	;found
	*** 000e4c	74 03 			je	$JCC3660
	*** 000e4e	e9 03 00 		jmp	$I2085
					$JCC3660:
;|***         continue;
; Line 887
	*** 000e51	e9 6d ff 		jmp	$FC2078
;|*** 
;|***       /*-------------------------------------------------*/
;|***       /* Searched Cominfo and and didn't find so lets    */
;|***       /* stuff it in a cominfo. Try to use 40:0 as a     */
;|***       /* guide.                                          */
;|***       /*-------------------------------------------------*/
;|***       pComInfo = pFirstComInfo;
; Line 894
					$I2085:
	*** 000e54	8b 46 fa 		mov	ax,WORD PTR [bp-6]	;pFirstComInfo
	*** 000e57	8b 56 fc 		mov	dx,WORD PTR [bp-4]
	*** 000e5a	89 46 06 		mov	WORD PTR [bp+6],ax	;pComInfo
	*** 000e5d	89 56 08 		mov	WORD PTR [bp+8],dx
;|***       pBDA = (PUSHORT)0x400000;  /* 40:0000 Bios Data Area */
; Line 895
	*** 000e60	c7 46 f4 00 00 		mov	WORD PTR [bp-12],0	;pBDA
	*** 000e65	c7 46 f6 40 00 		mov	WORD PTR [bp-10],64
;|*** 
;|***       for(j=0;j < MAXADN;j++)
; Line 897
	*** 000e6a	c7 46 f0 00 00 		mov	WORD PTR [bp-16],0	;j
	*** 000e6f	e9 03 00 		jmp	$F2086
					$FC2087:
	*** 000e72	ff 46 f0 		inc	WORD PTR [bp-16]	;j
					$F2086:
	*** 000e75	83 7e f0 10 		cmp	WORD PTR [bp-16],16	;j
	*** 000e79	72 03 			jb	$JCC3705
	*** 000e7b	e9 43 00 		jmp	$FB2088
					$JCC3705:
;|***         {
; Line 898
;|***         if(*pBDA == portAddr)
; Line 899
	*** 000e7e	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;portAddr
	*** 000e81	c4 5e f4 		les	bx,DWORD PTR [bp-12]	;pBDA
	*** 000e84	26 39 07 		cmp	WORD PTR es:[bx],ax
	*** 000e87	74 03 			je	$JCC3719
	*** 000e89	e9 29 00 		jmp	$I2089
					$JCC3719:
;|***           {
; Line 900
;|***           if(pComInfo->wIObaseAddress == 0)
; Line 901
	*** 000e8c	c4 5e 06 		les	bx,DWORD PTR [bp+6]	;pComInfo
	*** 000e8f	26 83 7f 32 00 		cmp	WORD PTR es:[bx+50],0
	*** 000e94	74 03 			je	$JCC3732
	*** 000e96	e9 1c 00 		jmp	$I2090
					$JCC3732:
;|***             {
; Line 902
;|***             pComInfo->wIObaseAddress = portAddr;
; Line 903
	*** 000e99	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;portAddr
	*** 000e9c	c4 5e 06 		les	bx,DWORD PTR [bp+6]	;pComInfo
	*** 000e9f	26 89 47 32 		mov	WORD PTR es:[bx+50],ax
;|*** //            pComInfo->ci_port_number = j;
;|***             pComInfo->byInterruptLevel = (BYTE)Irq;
; Line 905
	*** 000ea3	8a 46 ec 		mov	al,BYTE PTR [bp-20]	;Irq
	*** 000ea6	c4 5e 06 		les	bx,DWORD PTR [bp+6]	;pComInfo
	*** 000ea9	26 88 47 36 		mov	BYTE PTR es:[bx+54],al
;|***             found = TRUE;
; Line 906
	*** 000ead	c7 46 ee 01 00 		mov	WORD PTR [bp-18],1	;found
;|***             break;
; Line 907
	*** 000eb2	e9 0c 00 		jmp	$FB2088
;|***             }
; Line 908
;|***           }
; Line 909
					$I2090:
;|***         pBDA++;
; Line 910
					$I2089:
	*** 000eb5	83 46 f4 02 		add	WORD PTR [bp-12],2	;pBDA
;|***         pComInfo++;
; Line 911
	*** 000eb9	81 46 06 be 00 		add	WORD PTR [bp+6],190	;pComInfo
;|***         }
; Line 912
	*** 000ebe	e9 b1 ff 		jmp	$FC2087
					$FB2088:
;|*** 
;|***       if(found == TRUE)
; Line 914
	*** 000ec1	83 7e ee 01 		cmp	WORD PTR [bp-18],1	;found
	*** 000ec5	74 03 			je	$JCC3781
	*** 000ec7	e9 03 00 		jmp	$I2091
					$JCC3781:
;|***         continue;
; Line 915
	*** 000eca	e9 f4 fe 		jmp	$FC2078
;|*** 
;|***       /*------------------------------------------*/
;|***       /* No help from 40:0; find first empty slot */
;|***       /*------------------------------------------*/
;|*** 
;|***       pComInfo = pFirstComInfo;
; Line 921
					$I2091:
	*** 000ecd	8b 46 fa 		mov	ax,WORD PTR [bp-6]	;pFirstComInfo
	*** 000ed0	8b 56 fc 		mov	dx,WORD PTR [bp-4]
	*** 000ed3	89 46 06 		mov	WORD PTR [bp+6],ax	;pComInfo
	*** 000ed6	89 56 08 		mov	WORD PTR [bp+8],dx
;|***       for(j=0;j < MAXADN;j++)
; Line 922
	*** 000ed9	c7 46 f0 00 00 		mov	WORD PTR [bp-16],0	;j
	*** 000ede	e9 03 00 		jmp	$F2092
					$FC2093:
	*** 000ee1	ff 46 f0 		inc	WORD PTR [bp-16]	;j
					$F2092:
	*** 000ee4	83 7e f0 10 		cmp	WORD PTR [bp-16],16	;j
	*** 000ee8	72 03 			jb	$JCC3816
	*** 000eea	e9 31 00 		jmp	$FB2094
					$JCC3816:
;|***         {
; Line 923
;|***         if(pComInfo->wIObaseAddress == 0)
; Line 924
	*** 000eed	c4 5e 06 		les	bx,DWORD PTR [bp+6]	;pComInfo
	*** 000ef0	26 83 7f 32 00 		cmp	WORD PTR es:[bx+50],0
	*** 000ef5	74 03 			je	$JCC3829
	*** 000ef7	e9 1c 00 		jmp	$I2095
					$JCC3829:
;|***           {
; Line 925
;|***           pComInfo->wIObaseAddress = portAddr;
; Line 926
	*** 000efa	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;portAddr
	*** 000efd	c4 5e 06 		les	bx,DWORD PTR [bp+6]	;pComInfo
	*** 000f00	26 89 47 32 		mov	WORD PTR es:[bx+50],ax
;|*** //          pComInfo->ci_port_number = j;
;|***           pComInfo->byInterruptLevel = (BYTE)Irq;
; Line 928
	*** 000f04	8a 46 ec 		mov	al,BYTE PTR [bp-20]	;Irq
	*** 000f07	c4 5e 06 		les	bx,DWORD PTR [bp+6]	;pComInfo
	*** 000f0a	26 88 47 36 		mov	BYTE PTR es:[bx+54],al
;|***           found = TRUE;
; Line 929
	*** 000f0e	c7 46 ee 01 00 		mov	WORD PTR [bp-18],1	;found
;|***           break;
; Line 930
	*** 000f13	e9 08 00 		jmp	$FB2094
;|***           }
; Line 931
;|***         pComInfo++;
; Line 932
					$I2095:
	*** 000f16	81 46 06 be 00 		add	WORD PTR [bp+6],190	;pComInfo
;|***         }
; Line 933
	*** 000f1b	e9 c3 ff 		jmp	$FC2093
					$FB2094:
;|***       }
; Line 934
;|***     }
; Line 935
					$I2080:
	*** 000f1e	e9 a0 fe 		jmp	$FC2078
					$FB2079:
;|***   }
; Line 936
					$EX2068:
	*** 000f21	5e 			pop	si
	*** 000f22	5f 			pop	di
	*** 000f23	c9 			leave	
	*** 000f24	cb 			ret	

_RMHELP_UpdateComInfo	ENDP
;|*** 
;|*** /*----------------------------------------------------------*/
;|*** /* RMHELP_FindDetected - Find Detected Structures           */
;|*** /*                                                          */
;|*** /* ARGS:  pComInfo = pointer to ComInfo Structure           */
;|*** /*                                                          */
;|*** /*                                                          */
;|*** /*----------------------------------------------------------*/
;|*** VOID FAR RMHELP_FindDetected( DEVDEF *pComInfo )
;|***   {
; Line 946
	PUBLIC	_RMHELP_FindDetected
_RMHELP_FindDetected	PROC FAR
	*** 000f25	c8 4e 00 00 		enter	78,0
	*** 000f29	57 			push	di
	*** 000f2a	56 			push	si
;	rc = -2
;	Handlelist = -74
;	pHandlelist = -6
;	devID = -78
;	pComInfo = 6
;|***   APIRET      rc;
;|***   UCHAR       Handlelist[sizeof(HANDLELIST)+(sizeof(HADAPTER)*(MAXADN-1))];
;|***   PHANDLELIST pHandlelist = (PHANDLELIST)&Handlelist[0];
; Line 949
	*** 000f2b	8d 46 b6 		lea	ax,WORD PTR [bp-74]	;Handlelist
	*** 000f2e	89 46 fa 		mov	WORD PTR [bp-6],ax	;pHandlelist
	*** 000f31	8c 56 fc 		mov	WORD PTR [bp-4],ss
;|***   DEVID       devID;
;|*** 
;|*** 
;|***   /*--------------------------------------------------*/
;|***   /* Are we on a version of OS/2 which has snoopers?  */
;|***   /*--------------------------------------------------*/
;|*** 
;|*** 
;|***   if(bPnPcapable)
; Line 958
_TEXT      ENDS
CONST      SEGMENT
$T20005	DW SEG _bPnPcapable 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 000f34	8e 06 08 00 		mov	es,WORD PTR $T20005
	*** 000f38	26 83 3e 00 00 00 	cmp	WORD PTR es:_bPnPcapable,0
	*** 000f3e	75 03 			jne	$JCC3902
	*** 000f40	e9 d7 00 		jmp	$I2103
					$JCC3902:
;|***     {
; Line 959
;|***     /*------------------------------------------------------------------*/
;|***     /* serial snooper is currently only emitting this ID for discovered */
;|***     /* com ports.  This code will need to change if it does.            */
;|***     /*------------------------------------------------------------------*/
;|*** 
;|***     RMConvertID( &devID,"PNP0500",RM_CONVERT_TO_ID);
; Line 965
	*** 000f43	6a 02 			push	2
	*** 000f45	1e 			push	ds
	*** 000f46	68 7a 04 		push	OFFSET DGROUP:$SG2104
	*** 000f49	8d 46 b2 		lea	ax,WORD PTR [bp-78]	;devID
	*** 000f4c	16 			push	ss
	*** 000f4d	50 			push	ax
	*** 000f4e	9a 00 00 00 00 		call	FAR PTR _RMConvertID
	*** 000f53	83 c4 0a 		add	sp,10
;|*** 
;|***     pHandlelist->cMaxHandles = MAXADN;
; Line 967
	*** 000f56	c4 5e fa 		les	bx,DWORD PTR [bp-6]	;pHandlelist
	*** 000f59	26 c7 07 10 00 		mov	WORD PTR es:[bx],16
;|*** 
;|***     rc = RMDevIDToHandleList( RM_IDTYPE_EISA,
;|***                               devID,   /* Device ID */
;|***                               0L,
;|***                               0L,
;|***                               0L,
;|***                               0L,
;|***                               SEARCH_ID_DEVICEID,
;|***                               HANDLE_CURRENT_DETECTED,
;|***                               pHandlelist);
; Line 977
	*** 000f5e	ff 76 fc 		push	WORD PTR [bp-4]
	*** 000f61	ff 76 fa 		push	WORD PTR [bp-6]	;pHandlelist
	*** 000f64	6a ff 			push	-1
	*** 000f66	68 06 80 		push	-32762
	*** 000f69	6a 00 			push	0
	*** 000f6b	6a 01 			push	1
	*** 000f6d	6a 00 			push	0
	*** 000f6f	6a 00 			push	0
	*** 000f71	6a 00 			push	0
	*** 000f73	6a 00 			push	0
	*** 000f75	6a 00 			push	0
	*** 000f77	6a 00 			push	0
	*** 000f79	6a 00 			push	0
	*** 000f7b	6a 00 			push	0
	*** 000f7d	ff 76 b4 		push	WORD PTR [bp-76]
	*** 000f80	ff 76 b2 		push	WORD PTR [bp-78]	;devID
	*** 000f83	6a 00 			push	0
	*** 000f85	6a 01 			push	1
	*** 000f87	9a 00 00 00 00 		call	FAR PTR _RMDevIDToHandleList
	*** 000f8c	83 c4 24 		add	sp,36
	*** 000f8f	89 46 fe 		mov	WORD PTR [bp-2],ax	;rc
;|*** 
;|***     if(!rc)
; Line 979
	*** 000f92	83 7e fe 00 		cmp	WORD PTR [bp-2],0	;rc
	*** 000f96	74 03 			je	$JCC3990
	*** 000f98	e9 21 00 		jmp	$I2105
					$JCC3990:
;|***       if(pHandlelist->cHandles)
; Line 980
	*** 000f9b	c4 5e fa 		les	bx,DWORD PTR [bp-6]	;pHandlelist
	*** 000f9e	26 83 7f 02 00 		cmp	WORD PTR es:[bx+2],0
	*** 000fa3	75 03 			jne	$JCC4003
	*** 000fa5	e9 14 00 		jmp	$I2106
					$JCC4003:
;|***         RMHELP_UpdateComInfo(pComInfo,pHandlelist);
; Line 981
	*** 000fa8	ff 76 fc 		push	WORD PTR [bp-4]
	*** 000fab	ff 76 fa 		push	WORD PTR [bp-6]	;pHandlelist
	*** 000fae	ff 76 08 		push	WORD PTR [bp+8]
	*** 000fb1	ff 76 06 		push	WORD PTR [bp+6]	;pComInfo
	*** 000fb4	9a 00 00 00 00 		call	FAR PTR _RMHELP_UpdateComInfo
	*** 000fb9	83 c4 08 		add	sp,8
;|*** 
;|***     rc = RMDevIDToHandleList( RM_IDTYPE_EISA,
; Line 983
					$I2106:
					$I2105:
;|***                               0L,
;|***                               0L,
;|***                               devID,   /* Compatible ID */
;|***                               0L,
;|***                               0L,
;|***                               SEARCH_ID_COMPATIBLEID,
;|***                               HANDLE_CURRENT_DETECTED,
;|***                               pHandlelist);
; Line 991
	*** 000fbc	ff 76 fc 		push	WORD PTR [bp-4]
	*** 000fbf	ff 76 fa 		push	WORD PTR [bp-6]	;pHandlelist
	*** 000fc2	6a ff 			push	-1
	*** 000fc4	68 06 80 		push	-32762
	*** 000fc7	6a 00 			push	0
	*** 000fc9	6a 04 			push	4
	*** 000fcb	6a 00 			push	0
	*** 000fcd	6a 00 			push	0
	*** 000fcf	6a 00 			push	0
	*** 000fd1	6a 00 			push	0
	*** 000fd3	ff 76 b4 		push	WORD PTR [bp-76]
	*** 000fd6	ff 76 b2 		push	WORD PTR [bp-78]	;devID
	*** 000fd9	6a 00 			push	0
	*** 000fdb	6a 00 			push	0
	*** 000fdd	6a 00 			push	0
	*** 000fdf	6a 00 			push	0
	*** 000fe1	6a 00 			push	0
	*** 000fe3	6a 01 			push	1
	*** 000fe5	9a 00 00 00 00 		call	FAR PTR _RMDevIDToHandleList
	*** 000fea	83 c4 24 		add	sp,36
	*** 000fed	89 46 fe 		mov	WORD PTR [bp-2],ax	;rc
;|*** 
;|***     if(!rc)
; Line 993
	*** 000ff0	83 7e fe 00 		cmp	WORD PTR [bp-2],0	;rc
	*** 000ff4	74 03 			je	$JCC4084
	*** 000ff6	e9 21 00 		jmp	$I2107
					$JCC4084:
;|***       if(pHandlelist->cHandles)
; Line 994
	*** 000ff9	c4 5e fa 		les	bx,DWORD PTR [bp-6]	;pHandlelist
	*** 000ffc	26 83 7f 02 00 		cmp	WORD PTR es:[bx+2],0
	*** 001001	75 03 			jne	$JCC4097
	*** 001003	e9 14 00 		jmp	$I2108
					$JCC4097:
;|***         RMHELP_UpdateComInfo(pComInfo,pHandlelist);
; Line 995
	*** 001006	ff 76 fc 		push	WORD PTR [bp-4]
	*** 001009	ff 76 fa 		push	WORD PTR [bp-6]	;pHandlelist
	*** 00100c	ff 76 08 		push	WORD PTR [bp+8]
	*** 00100f	ff 76 06 		push	WORD PTR [bp+6]	;pComInfo
	*** 001012	9a 00 00 00 00 		call	FAR PTR _RMHELP_UpdateComInfo
	*** 001017	83 c4 08 		add	sp,8
;|***     }
; Line 996
					$I2108:
					$I2107:
;|***   }
; Line 997
					$I2103:
					$EX2098:
	*** 00101a	5e 			pop	si
	*** 00101b	5f 			pop	di
	*** 00101c	c9 			leave	
	*** 00101d	cb 			ret	

_RMHELP_FindDetected	ENDP
_TEXT	ENDS
END
