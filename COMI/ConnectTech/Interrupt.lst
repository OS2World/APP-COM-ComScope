Microsoft (R) Macro Assembler Version 6.00     		    08/24/02 23:27:35
Interrupt.asm						     Page 1 - 1


				;************************************************************************
				;
				; $Revision:   1.12  $
				;
				; $Log:   P:/archive/comi/int.asv  $
				;
				;     Rev 1.12   28 Mar 1996 00:20:10   EMMETT
				;  Added resource manager.  Began work on VDD support.
				;
				;     Rev 1.11   21 Feb 1996 12:08:34   EMMETT
				;  Fixed COMscope buffer access for DosDevIOCtl function calls
				;  so that single byte transfers of packet data would not make write
				;  pointer odd.
				;
				;     Rev 1.10   18 Feb 1996 14:21:38   EMMETT
				;  Added many features.  Notably:
				;  Tracing of DosDevIOCtl function calls and packets.
				;  Added 16650 and 16750 support.
				;  Streamlined interrupt routine.
				;
				;     Rev 1.9   25 Apr 1995 22:16:48   EMMETT
				;  Added Support for DigiBoard PC/16.  Changed interrupt Routine for better adapter independence.
				;  Changed interrupt routine to allow user to select interrupting device selection algorithim.  Fixed
				;  ABIOS interaction for better "non.INI" initialization in MCA machines.  Fixed various initialization
				;  message strings.  COMscope and receive buffer are now allocated from system memory, allowing
				;  a 32k (word) COMscope buffer and a 64k (byte) receive buffer.
				;
				;     Rev 1.8   03 Dec 1994 15:09:10   EMMETT
				;  Changed segment names.
				;
				;     Rev 1.7   29 Jun 1994 07:40:30   EMMETT
				;  Fixed transmit immediate byte to better handle null.
				;
				;     Rev 1.6   28 Jun 1994 09:10:52   EMMETT
				;  Fixed problem with early transmit time-outs.
				;
				;     Rev 1.5   11 Jun 1994 10:37:44   EMMETT
				;  Changed all references to "Mirror" to "COMscope".
				;
				;     Rev 1.4   11 Jun 1994 09:24:08   EMMETT
				;  added code to fix problems with Comtrol Hostess and Texas Instrument 16C550B
				;  UARTs, including adding flag to wLoadFoags to indicate htat UART is present.
				;
				;
				;     Rev 1.3   07 Jun 1994 00:19:14   EMMETT
				;  Added support for DigiBoard.
				;  Added initialization support for OEM specific loads.
				;  Fixed bug in StartWriteStream and ProcessModemSignals that caused handshaking problems.
				;  Fixed hardware tests to set baud rate before testing interrupts.
				;  Fixed hardware tests off switch to work only for retail version.
				;
				;     Rev 1.2   27 Apr 1994 22:56:26   EMMETT
				;  FIxed ABIOS stuff to work better than before.
				;
				;     Rev 1.1   18 Apr 1994 23:18:12   EMMETT
				;  Changed ABIOS processing and added ability to disallow a port to initialize.
				;
				;     Rev 1.0   16 Apr 1994 08:35:18   EMMETT
				;  Initial version control archive.
				;
				;************************************************************************

				  IFNDEF x16_BIT
				.386P
				  ELSE
				  ENDIF
				.NOLISTMACRO                   ;suppress macro expansion in listing

				.XLIST                  ;Suppress listing of INCLUDE files
				.LIST

 0000				RES_DATA SEGMENT

				    EXTRN device_hlp                    :DWORD
				    EXTRN bSharedInterrupts             :WORD
				    EXTRN stDeviceParms                 :s_stDeviceParms
				    EXTRN wIntIDregister                :WORD
				    EXTRN wOEMjumpEntry                 :WORD
				    EXTRN wOEMjumpExit                  :WORD
				    EXTRN wDeviceIntOffsetTable         :WORD
				    EXTRN wLastDeviceParmsOffset        :WORD
				    EXTRN byIntStatusMask               :BYTE

 0000				RES_DATA ENDS

 0000				RES_CODE SEGMENT
				    ASSUME CS:RCGROUP, ES:nothing, SS:nothing, DS:RDGROUP

				;  util externals

				    EXTRN WrtReceiveQueue    :NEAR
				    EXTRN StartWriteStream   :NEAR

				    EXTRN ProcessModemSignals:NEAR
				;-------------------------------------------------------------------------------
				; Interrupt Routine
				;-------------------------------------------------------------------------------

 0000				COM_interrupt_1::                                                               ; makes it global
 0000  FA			        cli
 0001  B8 0001			        mov     ax,1
 0004  EB 52			        jmp     COM_interrupt

 0006				COM_interrupt_2::                                                               ; makes it global
 0006  FA			        cli
 0007  B8 0002			        mov     ax,2
 000A  EB 4C			        jmp     COM_interrupt

 000C				COM_interrupt_3::                                                               ; makes it global
 000C  FA			        cli
 000D  B8 0003			        mov     ax,3
 0010  EB 46			        jmp     COM_interrupt

 0012				COM_interrupt_4::                                                               ; makes it global
 0012  FA			        cli
 0013  B8 0004			        mov     ax,4
 0016  EB 40			        jmp     COM_interrupt

 0018				COM_interrupt_5::                                                               ; makes it global
 0018  FA			        cli
 0019  B8 0005			        mov     ax,5
 001C  EB 3A			        jmp     COM_interrupt

 001E				COM_interrupt_6::                                                               ; makes it global
 001E  FA			        cli
 001F  B8 0006			        mov     ax,6
 0022  EB 34			        jmp     COM_interrupt

 0024				COM_interrupt_7::                                                               ; makes it global
 0024  FA			        cli
 0025  B8 0007			        mov     ax,7
 0028  EB 2E			        jmp     COM_interrupt

 002A				COM_interrupt_8::                                                               ; makes it global
 002A  FA			        cli
 002B  B8 0008			        mov     ax,8
 002E  EB 28			        jmp     COM_interrupt

 0030				COM_interrupt_9::                                                               ; makes it global
 0030  FA			        cli
 0031  B8 0009			        mov     ax,9
 0034  EB 22			        jmp     COM_interrupt

 0036				COM_interrupt_10::                                                               ; makes it global
 0036  FA			        cli
 0037  B8 000A			        mov     ax,10
 003A  EB 1C			        jmp     COM_interrupt

 003C				COM_interrupt_11::                                                               ; makes it global
 003C  FA			        cli
 003D  B8 000B			        mov     ax,11
 0040  EB 16			        jmp     COM_interrupt

 0042				COM_interrupt_12::                                                               ; makes it global
 0042  FA			        cli
 0043  B8 000C			        mov     ax,12
 0046  EB 10			        jmp     COM_interrupt

 0048				COM_interrupt_13::                                                               ; makes it global
 0048  FA			        cli
 0049  B8 000D			        mov     ax,13
 004C  EB 0A			        jmp     COM_interrupt

 004E				COM_interrupt_14::                                                               ; makes it global
 004E  FA			        cli
 004F  B8 000E			        mov     ax,14
 0052  EB 04			        jmp     COM_interrupt

 0054				COM_interrupt_15::                                                               ; makes it global
 0054  FA			        cli
 0055  B8 000F			        mov     ax,15

 0058				COM_interrupt::                                                               ; makes it global

				  IFDEF DEBUG_INTS
				  ENDIF
 = WORD PTR [BP-4]		        wInterruptLevel         EQU <WORD PTR [BP-4]>
 = WORD PTR [BP-2]		        fInterruptFlags         EQU <WORD PTR [BP-2]>

 0058  55			        push    bp
 0059  8B EC			        mov     bp, sp
				  IFDEF DEBUG_INTS
				  ELSE
 005B  83 EC 04			        sub     sp,((TYPE WORD) * 2)
				  ENDIF
 005E  89 46 FC			        mov     wInterruptLevel,ax
 0061  C7 46 FE 0000		        mov     fInterruptFlags,ZERO

 0066  8B 1E 0000 E		        mov     bx,wOEMjumpEntry
 006A  2E: FF A7 057A R		        jmp     CS:OEM_int_entry_table[bx]

 006F				process_initial_interrupt::                                                               ; makes it global
 006F  83 4E FE 01		        or      fInterruptFlags,INTERRUPT_HIT
 0073  A8 0F			        test    al,0fh
 0075  0F 84 00D0		        jz      modem_int

				;  What do you suppose would happen if a receive interrupt occurred while
				;  the interrupt ID register was being read because of a write interrupt?
				;  Well, this next few lines should overcome that little deficiency
				;;;  This is only required for 8250 and 16450 support (no FIFOs).
				;  This is only required for 8250, 16450, 16550 support (no FIFOs). 

 0079  8A E0			        mov     ah,al           ; save UART interrupt status register (ISR) contents

 007B  F7 44 04 2000		        test    [si].s_stDeviceParms.wDeviceFlag2,DEV_FLAG2_FIFO_AVAILABLE
 0080  74 07			        jz      HACK_TX_int
				        test_DeviceFlag2 DEV_FLAG2_16650_UART                               ;---- changed to use hack for 16550 UARTS as well - 2/7/02
 0087  74 1D			        jz      get_modem_signals
				        
 0089				HACK_TX_int:
 0089  83 C2 FF			        add     dx,INT_EN_REG_OFFSET - INT_ID_REG_OFFSET
				        InByteImm
 008D  A8 02			        test    al,INT_EN_TX_HOLD_EMPTY
 008F  74 12			        jz      @f
 0091  24 FD			        and     al,NOT INT_EN_TX_HOLD_EMPTY
				        OutByteDel bx
 009A  0C 02			        or      al,INT_EN_TX_HOLD_EMPTY
				        OutByteImm
				        IOdelay bx
 00A3				@@:
 00A3  83 C2 01			        add     dx,INT_ID_REG_OFFSET - INT_EN_REG_OFFSET

 00A6				get_modem_signals::                                                               ; makes it global
 00A6  83 C2 04			        add     dx,MDM_ST_REG_OFFSET - INT_ID_REG_OFFSET
				        InByteImm
 00AA  83 C2 FC			        add     dx,INT_ID_REG_OFFSET - MDM_ST_REG_OFFSET
				        test_DeviceFlag2 DEV_FLAG2_MONITOR_CTS
 00B2  74 14			        jz      test_delta_bits
 00B4  8A D8			        mov     bl,al
 00B6  80 E3 F0			        and     bl,0f0h
 00B9  3A 9C 0087		        cmp     bl,[si].s_stDeviceParms.byMSRimage
 00BD  74 09			        je      test_delta_bits
 00BF  80 CB 01			        or      bl,MDM_ST_DELTA_CTS
 00C2  88 9C 0087		        mov     [si].s_stDeviceParms.byMSRimage,bl
 00C6  EB 04			        jmp     process_modem_signals

 00C8				test_delta_bits:
 00C8  A8 0F			        test    al,MDM_ST_DELTA_MASK
 00CA  74 03			        jz      restore_AL

 00CC				process_modem_signals:
 00CC  E8 0000 E		        call    ProcessModemSignals

 00CF				restore_AL:
 00CF  8A C4			        mov     al,ah           ; restore UART interrupt status register (ISR) contents

 00D1				vector_interrupt::                                                               ; makes it global
 00D1  83 66 FE FD		        and     fInterruptFlags,NOT FIFO_TO
 00D5  8A D8			        mov     bl,al
				  IFNDEF NO_16650_Xon_HS_support
				  ELSE
 00D7  83 E3 0F			        and     bx,0fh
				  ENDIF
				  IFDEF DEBUG_INTS
				  ENDIF
 00DA  2E: FF A7 056A R		        jmp     CS:Interrupt_Vector[bx]

				;-----------------------------------------------------------------------------
				; test for next highest prioity interrupt for this same device
				;-----------------------------------------------------------------------------
 00DF				retest_int_status::                                                               ; makes it global

 00DF  8B 54 32			        mov     dx,[si].s_stDeviceParms.wIObaseAddress
 00E2  83 C2 02			        add     dx,INT_ID_REG_OFFSET

 00E5				read_int_status_reg::                                                               ; makes it global
				        InByteImm
 00E6  A8 01			        test    al,INT_ID_INT_PENDING
 00E8  74 E7			        jz      vector_interrupt
 00EA  F7 44 4A 0001		        test    [si].s_stDeviceParms.wDeviceStatus2,DEV_ST2_RESTARTSTREAM
 00EF  74 03			        jz      @f
 00F1  E8 0000 E		        call    StartWriteStream
 00F4				@@:
 00F4  8B 4E FC			        mov     cx,wInterruptLevel
 00F7  8B 1E 0000 E		        mov     bx,wOEMjumpExit
 00FB  2E: FF A7 0586 R		        jmp     CS:OEM_int_exit_table[bx]

				;-----------------------------------------------------------------------------
 0100				start_polling::                                                               ; makes it global
 0100  BE 0000 E		        lea     si,stDeviceParms
 0103  8B 4E FC			        mov     cx,wInterruptLevel

 0106				polling_loop::                                                               ; makes it global
 0106  39 4C 4C			        cmp     [si].s_stDeviceParms.wInterruptStatus,cx
 0109  75 11			        jne     poll_next
 010B  8B 54 32			        mov     dx,[si].s_stDeviceParms.wIObaseAddress
 010E  83 C2 02			        add     dx,INT_ID_REG_OFFSET
				        InByteImm
 0112  A8 01			        test    al,INT_ID_INT_PENDING
 0114  75 06			        jnz     poll_next
				  IFNDEF x16_BIT
				;        test_DeviceFlag2 DEV_FLAG2_USE_DD_DATA_SEGMENT
				;        jnz     process_initial_interrupt
				   IFNDEF NO_COMscope
				   ENDIF
 0116  8E 6C 50			        mov     gs,[si].s_stDeviceParms.wRdBuffSelector
				  ENDIF
 0119  E9 FF53			        jmp     process_initial_interrupt

 011C				poll_next::                                                               ; makes it global
 011C  81 C6 00BE		        add     si,TYPE stDeviceParms
 0120  3B 36 0000 E		        cmp     si,wLastDeviceParmsOffset
 0124  76 E0			        jbe     polling_loop

 0126  FA			        cli
 0127  83 3E 0000 E 01		        cmp     bSharedInterrupts,TRUE
 012C  75 0C			        jne     send_EOI

 012E				do_cleanup::                                                               ; makes it global
 012E  F7 46 FE 0001		        test    fInterruptFlags,INTERRUPT_HIT
 0133  75 05			        jnz     send_EOI
 0135  8B E5			        mov     sp, bp
 0137  5D			        pop     bp
 0138  F9			        stc
 0139  CB			        retf

				    IFDEF this_junk
				    ENDIF
				;last_device_exit:
				;        test    [si].s_stDeviceParms.wDeviceStatus2,DEV_ST2_RESTARTSTREAM
				;        jz      @f
				;        call    StartWriteStream
				;@@:
 013A				send_EOI::                                                               ; makes it global
 013A  8B 46 FC			        mov     ax,wInterruptLevel
 013D  B2 31			        mov     dl,DevHlp_EOI
 013F  8B E5			        mov     sp, bp
 0141  5D			        pop     bp
 0142  FA			        cli
 0143  FF 1E 0000 E		        call    device_hlp
 0147  F8			        clc
 0148  CB			        retf

				  IFNDEF NO_16650_Xon_HS_support
				  ENDIF
				;-----------------------------------------------------------------------------
 0149				modem_int::                                                               ; makes it global
 0149  83 C2 04			        add     dx,MDM_ST_REG_OFFSET - INT_ID_REG_OFFSET
				        InByteImm
 014D  88 84 0087		        mov     [si].s_stDeviceParms.byMSRimage,al
 0151  80 A4 0087 F0		        and     [si].s_stDeviceParms.byMSRimage,0f0h

 0156  83 C2 FC			        add     dx,INT_ID_REG_OFFSET - MDM_ST_REG_OFFSET
 0159  A8 0F			        test    al,MDM_ST_DELTA_MASK
 015B  74 88			        jz      read_int_status_reg

 015D  E8 0000 E		        call    ProcessModemSignals

 0160  F7 44 4A 0001		        test    [si].s_stDeviceParms.wDeviceStatus2,DEV_ST2_RESTARTSTREAM
 0165  0F 84 FF7C		        jz      read_int_status_reg
 0169  E8 0000 E		        call    StartWriteStream
 016C  E9 FF76			        jmp     read_int_status_reg

				;-----------------------------------------------------------------------------
 016F				receive_line_status::                                                               ; makes it global
 016F  33 C9			        xor     cx,cx
 0171  83 C2 03			        add     dx,LINE_ST_REG_OFFSET - INT_ID_REG_OFFSET
				        InByteImm
 0175  A8 02			        test    al,LINE_ST_OVERRUN_ERROR
 0177  74 03			        jz      @f
 0179  83 C9 04			        or      cx,OVERRUN
 017C				@@:
 017C  8A 5C 26			        mov     bl,[si].s_stDeviceParms.byFlag3
 017F  80 E3 06			        and     bl,F3_READ_TIMEOUT_MASK
 0182  80 FB 04			        cmp     bl,F3_WAIT_SOMETHING
 0185  75 05			        jne     error_read_loop
 0187  81 4C 48 0080		        or      [si].s_stDeviceParms.wDeviceStatus1,DEV_ST1_LAST_CHAR_RCVD

 018C				error_read_loop::                                                               ; makes it global
 018C  8A E0			        mov     ah,al
 018E  83 EA 05			        sub     dx,LINE_ST_REG_OFFSET
				        InByteImm
 0192  FB			        sti
 0193  22 44 37			        and     al,[si].s_stDeviceParms.byDataLengthMask
 0196  F6 84 008D 80		        test    [si].s_stDeviceParms.byHSstatus,RX_WAITING_MASK
 019B  0F 85 0092		        jnz     get_next_status

 019F  F6 C4 10			        test    ah,LINE_ST_BREAK_DETECT
 01A2  74 1C			        jz      test_error_status
 01A4  8A C4			        mov     al,ah
 01A6  F7 C1 0008		        test    cx,BREAK
 01AA  0F 85 0083		        jnz     get_next_status
				        COMscopeStream ebx, CSFUNC_TRACE_ERRORS, CS_BREAK_RX
 01AE  83 C9 08			        or      cx,BREAK
 01B1  83 4C 44 40		        or      [si].s_stDeviceParms.wCOMevent,COM_EVENT_BREAK_DETECT
 01B5  F6 44 25 10		        test    [si].s_stDeviceParms.byFlag2,F2_ENABLE_BREAK_REPL
 01B9  74 76			        jz      get_next_status      ; changed back for 4.0c
				;       jz      queue_error_byte     ; changed to fix KFC break, no data byte problem 2/7/02 -> 4.0.b
 01BB  8A 44 28			        mov     al,[si].s_stDeviceParms.byBreakChar
 01BE  EB 56			        jmp     queue_error_byte

 01C0				test_error_status::                                                               ; makes it global
 01C0  83 E1 F7			        and     cx,NOT BREAK
 01C3  F6 C4 0C			        test    ah,(LINE_ST_PARITY_ERROR OR LINE_ST_FRAMING_ERROR)
 01C6  74 1A			        jz      test_null
 01C8  50			        push    ax
 01C9  8A C4			        mov     al,ah
 01CB  83 E0 0C			        and     ax,(LINE_ST_PARITY_ERROR OR LINE_ST_FRAMING_ERROR)
 01CE  09 44 46			        or      [si].s_stDeviceParms.wCOMerror,ax
				        COMscopeStream ebx, CSFUNC_TRACE_ERRORS, CS_HDW_ERROR
 01D1  58			        pop     ax
 01D2  81 4C 44 0080		        or      [si].s_stDeviceParms.wCOMevent,COM_EVENT_COM_ERROR
 01D7  F6 44 25 04		        test    [si].s_stDeviceParms.byFlag2,F2_ENABLE_ERROR_REPL
 01DB  74 39			        jz      queue_error_byte
 01DD  8A 44 27			        mov     al,[si].s_stDeviceParms.byErrorChar
 01E0  EB 34			        jmp     queue_error_byte

 01E2				test_null::                                                               ; makes it global

				; IF input byte is ZERO AND NULL stripping is enabled THEN
				; go get next character

 01E2  0A C0			        or      al,al
 01E4  75 08			        jnz     test_XHS_rls
 01E6  F6 44 25 08		        test    [si].s_stDeviceParms.byFlag2,F2_ENABLE_NULL_STRIP
 01EA  74 02			        jz      test_XHS_rls
 01EC  EB 43			        jmp     get_next_status

				; IF XMIT Xon/Xoff HS is enabled

 01EE				test_XHS_rls::                                                               ; makes it global
 01EE  F6 44 25 01		        test    [si].s_stDeviceParms.byFlag2,F2_ENABLE_XMIT_XON_XOFF_FLOW
 01F2  74 22			        jz      queue_error_byte

				; IF Xoff character received THEN flag Tx to wait

 01F4  3A 44 2A			        cmp     al,[si].s_stDeviceParms.byXoffChar
 01F7  75 07			        jne     not_Xoff_rls

				        COMscopeStream ebx, CSFUNC_TRACE_IMM_STREAM, CS_READ_IMM

 01F9  80 8C 008D 08		        or      [si].s_stDeviceParms.byHSstatus,TX_WAITING_BECAUSE_XOFF_RX
 01FE  EB 31			        jmp     get_next_status

				; IF Xoff had been received AND Xon was just received THEN
				; flag Tx to and try to restart write stream

 0200				not_Xoff_rls::                                                               ; makes it global
 0200  F6 84 008D 08		        test    [si].s_stDeviceParms.byHSstatus,TX_WAITING_BECAUSE_XOFF_RX
 0205  74 0F			        jz      queue_error_byte
 0207  3A 44 29			        cmp     al,[si].s_stDeviceParms.byXonChar
 020A  75 0A			        jne     queue_error_byte

				        COMscopeStream ebx, CSFUNC_TRACE_IMM_STREAM, CS_READ_IMM

 020C  80 A4 008D F7		        and     [si].s_stDeviceParms.byHSstatus,NOT TX_WAITING_BECAUSE_XOFF_RX
 0211  E8 0000 E		        call    StartWriteStream
 0214  EB 1B			        jmp     get_next_status

 0216				queue_error_byte::                                                               ; makes it global
 0216  8A E0			        mov     ah,al
 0218  F7 C1 0004		        test    cx,OVERRUN
 021C  75 03			        jnz     @f
 021E  E8 0000 E		        call    WrtReceiveQueue
 0221				@@:
				; IF we are blocked on read THEN decrement byte counter

 0221  83 7C 72 00		        cmp     [si].s_stDeviceParms.wReadByteCount,0
 0225  74 0A			        je      get_next_status
 0227  FF 4C 72			        dec     [si].s_stDeviceParms.wReadByteCount

				; IF counter goes to zero THEN mark last character received

 022A  75 05			        jnz     get_next_status
 022C  81 4C 48 0080		        or      [si].s_stDeviceParms.wDeviceStatus1,DEV_ST1_LAST_CHAR_RCVD

 0231				get_next_status::                                                               ; makes it global
 0231  83 C2 05			        add     dx,LINE_ST_REG_OFFSET
				        InByteImm
 0235  A8 01			        test    al,LINE_ST_RCV_DATA_READY
 0237  74 12			        jz      last_byte
 0239  F7 C1 0004		        test    cx,OVERRUN
 023D  0F 85 FF4B		        jnz     error_read_loop  ; changed from jz for KFC fix to 4.0c, 
 0241  50			        push    ax
 0242  8A C4			        mov     al,ah
 0244  E8 0000 E		        call    WrtReceiveQueue
 0247  58			        pop     ax
 0248  E9 FF41			        jmp     error_read_loop

 024B				last_byte::                                                               ; makes it global
 024B  F7 C1 0004		        test    cx,OVERRUN
 024F  74 1D			        jz      line_status_exit
 0251  8A C4			        mov     al,ah
 0253  E8 0000 E		        call    WrtReceiveQueue

 0256  B0 02			        mov     al,LINE_ST_OVERRUN_ERROR
 0258  09 44 46			        or      [si].s_stDeviceParms.wCOMerror,ax
 025B  81 4C 44 0080		        or      [si].s_stDeviceParms.wCOMevent,COM_EVENT_COM_ERROR
 0260  F6 44 25 04		        test    [si].s_stDeviceParms.byFlag2,F2_ENABLE_ERROR_REPL
 0264  74 08			        jz      @f
 0266  50			        push    ax
 0267  8A 44 27			        mov     al,[si].s_stDeviceParms.byErrorChar
 026A  E8 0000 E		        call    WrtReceiveQueue
 026D  58			        pop     ax
 026E				@@:
				        COMscopeStream ebx, CSFUNC_TRACE_ERRORS, CS_HDW_ERROR

 026E				line_status_exit::                                                               ; makes it global
 026E  83 C2 FD			        add     dx,INT_ID_REG_OFFSET - LINE_ST_REG_OFFSET
				;        test    cx,RCV_BYTE
				;        jz      read_int_status_reg
 0271  83 4C 44 01		        or      [si].s_stDeviceParms.wCOMevent,COM_EVENT_RCV_BYTE
				        OR_DeviceFlag1 DEV_FLAG1_EVENT_RCV_BYTE
 027A  F7 44 48 0080		        test    [si].s_stDeviceParms.wDeviceStatus1,DEV_ST1_LAST_CHAR_RCVD
 027F  75 1C			        jnz     clear_rd_sem_rls
 0281  83 7C 72 00		        cmp     [si].s_stDeviceParms.wReadByteCount,0
 0285  0F 84 FE5C		        je      read_int_status_reg
 0289  83 BC 0080 00		        cmp     [si].s_stDeviceParms.wRdTimerCount,ZERO
 028E  0F 84 FE53		        je      read_int_status_reg
 0292  8B 84 0082		        mov     ax,[si].s_stDeviceParms.wReadTimerStart
 0296  89 84 0080		        mov     [si].s_stDeviceParms.wRdTimerCount,ax
 029A  E9 FE48			        jmp     read_int_status_reg

 029D				clear_rd_sem_rls::                                                               ; makes it global
 029D  83 BC 0080 00		        cmp     [si].s_stDeviceParms.wRdTimerCount,ZERO
 02A2  0F 84 FE3F		        je      read_int_status_reg
 02A6  8C D8			        mov     ax,ds
 02A8  8D 5C 5C			        lea     bx,[si].s_stDeviceParms.dwRdSemaphore
 02AB  B2 07			        mov     dl,DevHlp_SemClear
 02AD  FF 1E 0000 E		        call    device_hlp
 02B1  C7 84 0080 0000		        mov     [si].s_stDeviceParms.wRdTimerCount,ZERO
 02B7  E9 FE25			        jmp     retest_int_status

				;-----------------------------------------------------------------------------
 02BA				read_com_TO::                                                               ; makes it global
 02BA  83 4C 44 02		        or      [si].s_stDeviceParms.wCOMevent,COM_EVENT_RCV_TO
 02BE  83 4E FE 02		        or      fInterruptFlags,FIFO_TO

				;-----------------------------------------------------------------------------
 02C2				read_com::                                                               ; makes it global
 02C2  8A 4C 26			        mov     cl,[si].s_stDeviceParms.byFlag3
 02C5  80 E1 06			        and     cl,F3_READ_TIMEOUT_MASK
 02C8  80 F9 04			        cmp     cl,F3_WAIT_SOMETHING
 02CB  75 05			        jne     @f
 02CD  81 4C 48 0080		        or      [si].s_stDeviceParms.wDeviceStatus1,DEV_ST1_LAST_CHAR_RCVD
 02D2				@@:
 02D2  83 4C 44 01		        or      [si].s_stDeviceParms.wCOMevent,COM_EVENT_RCV_BYTE
				        OR_DeviceFlag1 DEV_FLAG1_EVENT_RCV_BYTE
 02DB  83 C2 03			        add     dx,LINE_ST_REG_OFFSET - INT_ID_REG_OFFSET

 02DE				read_loop::                                                               ; makes it global
				        InByteImm
 02DF  A8 01			        test    al,LINE_ST_RCV_DATA_READY
 02E1  75 5E			        jnz     get_byte
 02E3  83 C2 FD			        add     dx,INT_ID_REG_OFFSET - LINE_ST_REG_OFFSET
 02E6  F7 46 FE 0002		        test    fInterruptFlags,FIFO_TO
 02EB  74 14			        jz      @f
				;        test    [si].s_stDeviceParms.wDeviceFlag2,(DEV_FLAG2_TIB_UART OR DEV_FLAG2_16750_UART OR DEV_FLAG2_TI16550C_UART)
 02ED  F7 44 04 0010		        test    [si].s_stDeviceParms.wDeviceFlag2,DEV_FLAG2_TIB_UART
 02F2  74 0D			        jz      @f
				        InByteImm
 02F5  24 0F			        and     al,0fh
 02F7  3C 0C			        cmp     al,INT_ID_CHAR_TIMEOUT
 02F9  75 06			        jne     @f

 02FB				FIFO_TO_INT_BAD::           ; Texas Instruments 16550B fixup
				        InByteImm
				;        test    [si].s_stDeviceParms.wDeviceFlag2,(DEV_FLAG2_16750_UART OR DEV_FLAG2_TI16550C_UART)
				;        jz      @f
 02FC  83 C2 03			        add     dx,LINE_ST_REG_OFFSET - INT_ID_REG_OFFSET
 02FF  EB 40			        jmp     get_byte
 0301				@@:
 0301  F7 44 48 0080		        test    [si].s_stDeviceParms.wDeviceStatus1,DEV_ST1_LAST_CHAR_RCVD
 0306  75 1C			        jnz     clear_rd_sem
 0308  83 7C 72 00		        cmp     [si].s_stDeviceParms.wReadByteCount,0
 030C  0F 84 FDD5		        je      read_int_status_reg
 0310  83 BC 0080 00		        cmp     [si].s_stDeviceParms.wRdTimerCount,ZERO
 0315  0F 84 FDCC		        je      read_int_status_reg
 0319  8B 84 0082		        mov     ax,[si].s_stDeviceParms.wReadTimerStart
 031D  89 84 0080		        mov     [si].s_stDeviceParms.wRdTimerCount,ax
 0321  E9 FDC1			        jmp     read_int_status_reg

 0324				clear_rd_sem::                                                               ; makes it global
 0324  83 BC 0080 00		        cmp     [si].s_stDeviceParms.wRdTimerCount,ZERO
 0329  0F 84 FDB8		        je      read_int_status_reg
 032D  C7 84 0080 0000		        mov     [si].s_stDeviceParms.wRdTimerCount,ZERO
 0333  8C D8			        mov     ax,ds
 0335  8D 5C 5C			        lea     bx,[si].s_stDeviceParms.dwRdSemaphore
 0338  B2 07			        mov     dl,DevHlp_SemClear
 033A  FF 1E 0000 E		        call    device_hlp
 033E  E9 FD9E			        jmp     retest_int_status

 0341				get_byte::                                                               ; makes it global
 0341  83 EA 05			        sub     dx,LINE_ST_REG_OFFSET        ; back to receive register
 0344  83 66 FE FD		        and     fInterruptFlags,NOT FIFO_TO
				        InByteImm
 0349  FB			        sti
 034A  F6 84 008D 80		        test    [si].s_stDeviceParms.byHSstatus,RX_WAITING_MASK
 034F  75 4A			        jnz     test_next

 0351  22 44 37			        and     al,[si].s_stDeviceParms.byDataLengthMask

				; IF input byte is ZERO AND NULL stripping is enabled THEN
				; go get next character

 0354  0A C0			        or      al,al
 0356  75 08			        jnz     test_XHS
 0358  F6 44 25 08		        test    [si].s_stDeviceParms.byFlag2,F2_ENABLE_NULL_STRIP
 035C  74 02			        jz      test_XHS
 035E  EB 3B			        jmp     test_next

				; IF XMIT Xon/Xoff HS is enabled

 0360				test_XHS::                                                               ; makes it global
 0360  F6 44 25 01		        test    [si].s_stDeviceParms.byFlag2,F2_ENABLE_XMIT_XON_XOFF_FLOW
 0364  74 22			        jz      queue_byte

				; IF Xoff character received THEN flag Tx to wait

 0366  3A 44 2A			        cmp     al,[si].s_stDeviceParms.byXoffChar
 0369  75 07			        jne     not_Xoff

				        COMscopeStream ebx, CSFUNC_TRACE_IMM_STREAM, CS_READ_IMM

 036B  80 8C 008D 08		        or      [si].s_stDeviceParms.byHSstatus,TX_WAITING_BECAUSE_XOFF_RX
 0370  EB 29			        jmp     test_next

				; IF Xoff had been received AND Xon was just received THEN
				; flag Tx to and try to restart write stream

 0372				not_Xoff::                                                               ; makes it global
 0372  F6 84 008D 08		        test    [si].s_stDeviceParms.byHSstatus,TX_WAITING_BECAUSE_XOFF_RX
 0377  74 0F			        jz      queue_byte
 0379  3A 44 29			        cmp     al,[si].s_stDeviceParms.byXonChar
 037C  75 0A			        jne     queue_byte

				        COMscopeStream ebx, CSFUNC_TRACE_IMM_STREAM, CS_READ_IMM

 037E  80 A4 008D F7		        and     [si].s_stDeviceParms.byHSstatus,NOT TX_WAITING_BECAUSE_XOFF_RX
 0383  E8 0000 E		        call    StartWriteStream
 0386  EB 13			        jmp     test_next

 0388				queue_byte::                                                               ; makes it global
 0388  E8 0000 E		        call    WrtReceiveQueue

				; IF we are blocked on read THEN decrement byte counter

 038B  83 7C 72 00		        cmp     [si].s_stDeviceParms.wReadByteCount,0
 038F  74 0A			        je      test_next
 0391  FF 4C 72			        dec     [si].s_stDeviceParms.wReadByteCount

				; IF counter goes to zero THEN mark last character received

 0394  75 05			        jnz     test_next
 0396  81 4C 48 0080		        or      [si].s_stDeviceParms.wDeviceStatus1,DEV_ST1_LAST_CHAR_RCVD

 039B				test_next::                                                               ; makes it global
 039B  83 C2 05			        add     dx,LINE_ST_REG_OFFSET
 039E  E9 FF3D			        jmp     read_loop
				;-----------------------------------------------------------------------------
 03A1				write_com::                                                               ; makes it global
 03A1  FB			        sti
 03A2  83 EA 02			        sub     dx,INT_ID_REG_OFFSET
				  IFDEF this_junk ;SHARE
				  ENDIF
				; test if CTS, DSR, or DCD handshaking has us in the transmit hold mode
 03A5  F6 84 008D 27		        test    [si].s_stDeviceParms.byHSstatus,TX_WAITING_HDW_MASK
 03AA  0F 85 0081		        jnz     disable_TX_interrupt

				; set up FIFO counter
 03AE  8B 4C 6C			        mov     cx,[si].s_stDeviceParms.wTxFIFOdepth

				; test if an "immediate" byte needs to be transmitted
				        test_DeviceFlag1 DEV_FLAG1_IMM_BYTE_WAITING
 03B6  74 1E			        jz      test_queue

				; transmit "immediate" byte
 03B8  8A 44 2B			        mov     al,[si].s_stDeviceParms.byImmediateByte
				        COMscopeStream ebx, CSFUNC_TRACE_IMM_STREAM, CS_WRITE_IMM
				        OutByteDel bx
				        AND_DeviceFlag1 (NOT DEV_FLAG1_IMM_BYTE_WAITING)
 03C6  E2 0E			        loop    test_queue
				; got here because only one byte is to be written to UART at each interrupt

				        IOdelay bx
 03CE  83 7C 52 00		        cmp     [si].s_stDeviceParms.wXmitQueueCount,0
 03D2  74 47			        je      clear_wrt_sem
 03D4  EB 31			        jmp     reset_timer

 03D6				test_queue::                                                               ; makes it global
 03D6  83 7C 52 00		        cmp     [si].s_stDeviceParms.wXmitQueueCount,0
 03DA  74 3F			        je      clear_wrt_sem
 03DC  F6 84 008D 3F		        test    [si].s_stDeviceParms.byHSstatus,TX_WAITING_MASK
 03E1  75 4C			        jnz     disable_TX_interrupt
 03E3  8B 7C 54			        mov     di,[si].s_stDeviceParms.wXmitQueueReadPointer
 03E6  83 64 4A FE		        and     [si].s_stDeviceParms.wDeviceStatus2,(NOT DEV_ST2_RESTARTSTREAM)
				        IOdelay bx

				  IFNDEF NO_COMscope
				  ENDIF
 03F0				fill_loop:
 03F0  66| FF 84 0094		        inc     [si].s_stDeviceParms.dwTransmitCount
 03F5  8A 05			        mov     al,[di]
				        OutByteImm
 03F8  47			        inc     di
 03F9  FF 4C 52			        dec     [si].s_stDeviceParms.wXmitQueueCount
 03FC  E0 F2			        loopnz  fill_loop

				  IFNDEF NO_COMscope
				  ENDIF ; NOT NO_COMscope or x16_BIT

 03FE  89 7C 54			        mov     [si].s_stDeviceParms.wXmitQueueReadPointer,di

				        IOdelay bx

 0407				reset_timer::                                                               ; makes it global
 0407  83 C2 02			        add     dx,INT_ID_REG_OFFSET
				; We have queued data to be transmitted so reinitialize timer if required

 040A  F6 44 26 01		        test    [si].s_stDeviceParms.byFlag3,F3_INFINITE_WRT_TIMEOUT
 040E  0F 85 FCD3		        jnz     read_int_status_reg
 0412  8B 44 5A			        mov     ax,[si].s_stDeviceParms.wWriteTimerStart
 0415  89 44 58			        mov     [si].s_stDeviceParms.wWrtTimerCount,ax       ;update timer
 0418  E9 FCCA			        jmp     read_int_status_reg

 041B				clear_wrt_sem::                                                               ; makes it global
				; The last byte in the buffer has been transmitted so clear the semaphore

				;        mov     [si].s_stDeviceParms.wWrtTimerCount,0
 041B  8C D8			        mov     ax,ds
 041D  8D 5C 60			        lea     bx,[si].s_stDeviceParms.dwWrtSemaphore
 0420  B2 07			        mov     dl,DevHlp_SemClear
 0422  FF 1E 0000 E		        call    device_hlp
 0426  8B 54 32			        mov     dx,[si].s_stDeviceParms.wIObaseAddress
 0429  83 C2 02			        add     dx,INT_ID_REG_OFFSET
 042C  E9 FCB6			        jmp     read_int_status_reg

 042F				disable_TX_interrupt::
				; Cannot transmit character so disable write interrupts.  Interrupts will be
				; reenabled when StartWriteStream says so.

 042F  42			        inc     dx
				        InByteDel bx
 0437  24 FD			        and     al,NOT INT_EN_TX_HOLD_EMPTY
				        OutByteDel bx
 0440  42			        inc     dx
				        IOdelay bx
 0447  E9 FC9B			        jmp     read_int_status_reg

				;-----------------------------------------------------------------------------
 044A				test_zero_ID::                                                               ; makes it global
 044A  8B 16 0000 E		        mov     dx, wIntIDregister
				        InByteImm
 044F  22 06 0000 E		        and     al,byIntStatusMask
 0453  0F 84 FCE3		        jz      send_EOI

 0457				zero_poll_next::                                                               ; makes it global
 0457  81 C6 00BE		        add     si,TYPE s_stDeviceParms
 045B  3B 36 0000 E		        cmp     si,wLastDeviceParmsOffset
 045F  76 13			        jbe     zero_poll_loop

 0461				zero_is_clear_ID_entry::                                                               ; makes it global
 0461  8B 16 0000 E		        mov     dx, wIntIDregister
				        InByteImm
 0466  22 06 0000 E		        and     al,byIntStatusMask
 046A  0F 84 FCCC		        jz      send_EOI
 046E  BE 0000 E		        lea     si,stDeviceParms
 0471  8B 4E FC			        mov     cx,wInterruptLevel

 0474				zero_poll_loop::                                                               ; makes it global
 0474  39 4C 4C			        cmp     [si].s_stDeviceParms.wInterruptStatus,cx
 0477  75 DE			        jne     zero_poll_next
 0479  8B 54 32			        mov     dx,[si].s_stDeviceParms.wIObaseAddress
 047C  83 C2 02			        add     dx,INT_ID_REG_OFFSET
				        InByteImm
 0480  A8 01			        test    al,INT_ID_INT_PENDING
 0482  75 D3			        jnz     zero_poll_next
				  IFNDEF x16_BIT
				;        test_DeviceFlag2 DEV_FLAG2_USE_DD_DATA_SEGMENT
				;        jnz     process_initial_interrupt
				   IFNDEF NO_COMscope
				   ENDIF
 0484  8E 6C 50			        mov     gs,[si].s_stDeviceParms.wRdBuffSelector
				  ENDIF
 0487  E9 FBE5			        jmp     process_initial_interrupt

				;-----------------------------------------------------------------------------
 048A				test_FF_ID::                                                               ; makes it global
 048A  8B 16 0000 E		        mov     dx,wIntIDregister
				        InByteImm
 048F  0A 06 0000 E		        or      al,byIntStatusMask
 0493  3C FF			        cmp     al,0ffh
 0495  0F 84 FCA1		        je      send_EOI

 0499				FF_poll_next::                                                               ; makes it global
 0499  81 C6 00BE		        add     si,TYPE stDeviceParms
 049D  3B 36 0000 E		        cmp     si,wLastDeviceParmsOffset
 04A1  76 15			        jbe     FF_poll_loop

 04A3				FF_is_clear_ID_entry::                                                               ; makes it global
 04A3  8B 16 0000 E		        mov     dx,wIntIDregister
				        InByteImm
 04A8  0A 06 0000 E		        or      al,byIntStatusMask
 04AC  3C FF			        cmp     al,0ffh
 04AE  0F 84 FC88		        je      send_EOI
 04B2  BE 0000 E		        lea     si,stDeviceParms
 04B5  8B 4E FC			        mov     cx,wInterruptLevel

 04B8				FF_poll_loop::                                                               ; makes it global
 04B8  39 4C 4C			        cmp     [si].s_stDeviceParms.wInterruptStatus,cx
 04BB  75 DC			        jne     FF_poll_next
 04BD  8B 54 32			        mov     dx,[si].s_stDeviceParms.wIObaseAddress
 04C0  83 C2 02			        add     dx,INT_ID_REG_OFFSET
				        InByteImm
 04C4  A8 01			        test    al,INT_ID_INT_PENDING
 04C6  75 D1			        jnz     FF_poll_next
				  IFNDEF x16_BIT
				;        test_DeviceFlag2 DEV_FLAG2_USE_DD_DATA_SEGMENT
				;        jnz     process_initial_interrupt
				   IFNDEF NO_COMscope
				   ENDIF
 04C8  8E 6C 50			        mov     gs,[si].s_stDeviceParms.wRdBuffSelector
				  ENDIF
 04CB  E9 FBA1			        jmp     process_initial_interrupt

				;COM_interrupt  ENDP

				;----------------------------------------------------------------------------
				; OEM interrupt vector function

				; this function is executed when a new device is to be "polled"
				;----------------------------------------------------------------------------
 04CE				OEM_test_int_status::                                                               ; makes it global
				  IFNDEF x16_BIT
				;        test_DeviceFlag2 DEV_FLAG2_USE_DD_DATA_SEGMENT
				;        jnz     @f
				   IFNDEF NO_COMscope
				   ENDIF
 04CE  8E 6C 50			        mov     gs,[si].s_stDeviceParms.wRdBuffSelector
				;@@:
				  ENDIF
 04D1  8B 54 32			        mov     dx,[si].s_stDeviceParms.wIObaseAddress
 04D4  83 C2 02			        add     dx,INT_ID_REG_OFFSET

				        InByteImm
 04D8  A8 01			        test    al,INT_ID_INT_PENDING
 04DA  0F 84 FB91		        jz      process_initial_interrupt
 04DE  8B 4E FC			        mov     cx,wInterruptLevel
 04E1  8B 1E 0000 E		        mov     bx,wOEMjumpExit
 04E5  2E: FF A7 0586 R		        jmp     CS:OEM_int_exit_table[bx]

				;----------------------------------------------------------------------------
				;  OEM device selection routines
				;----------------------------------------------------------------------------
				;  Interrupt ID register is zero when no interrupts are pending and
				;  bit is on when device is in the interrupt state
				;  Mask was added because Comtrol Hostess four port ties unused bits high
				;  in inturrupt status byte.
				;----------------------------------------------------------------------------
 04EA				ID_is_bits_on::                                                               ; makes it global

 04EA  8B 16 0000 E		        mov     dx,wIntIDregister
				        InByteImm
 04EF  22 06 0000 E		        and     al,byIntStatusMask            ;test is ID is zero
 04F3  0F 84 FC43		        jz      send_EOI
 04F7  D0 E0			        shl     al,1
 04F9  72 4F			        jc      device_eight  ;since we had to shift anyway
				                              ; side-efect: makes device eight the highest priority
 04FB  8A D8			        mov     bl,al
 04FD  32 FF			        xor     bh,bh
 04FF  2E: FF A7 0592 R		        jmp     CS:BitIDjumpTable[bx]

				;----------------------------------------------------------------------------
				;  Interrupt ID register is 0xff when no interrupts are pending and
				;  bit is off (zero) when device is in the interrupt state
				;    This type is DigiBoard PC/x specific
				;----------------------------------------------------------------------------
 0504				ID_is_bits_off::                                                               ; makes it global

 0504  8B 16 0000 E		        mov     dx,wIntIDregister
        InByteImm
 0509  F6 D0			        not     al
 050B  22 06 0000 E		        and     al,byIntStatusMask            ;test is ID is zero
 050F  0F 84 FC27		        jz      send_EOI
 0513  D0 E0			        shl     al,1         ; useless for Boca IOAT66
 0515  72 33			        jc      device_eight ;since we had to shift anyway
				                             ; side-efect: makes device eight the highest priority
 0517  8A D8			        mov     bl,al
 0519  32 FF			        xor     bh,bh
 051B  2E: FF A7 0592 R		        jmp     CS:BitIDjumpTable[bx]

				;----------------------------------------------------------------------------
				; load SI based on device in interrupt - used by ID_is_bits... functions
				;----------------------------------------------------------------------------
 0520				device_one::                                                               ; makes it global
 0520  8B 36 0000 E		        mov     si,wDeviceIntOffsetTable[0]
 0524  EB A8			        jmp     OEM_test_int_status

 0526				device_two::                                                               ; makes it global
 0526  8B 36 0002 E		        mov     si,wDeviceIntOffsetTable[2]
 052A  EB A2			        jmp     OEM_test_int_status

 052C				device_three::                                                               ; makes it global
 052C  8B 36 0004 E		        mov     si,wDeviceIntOffsetTable[4]
 0530  EB 9C			        jmp     OEM_test_int_status

 0532				device_four::                                                               ; makes it global
 0532  8B 36 0006 E		        mov     si,wDeviceIntOffsetTable[6]
 0536  EB 96			        jmp     OEM_test_int_status

 0538				device_five::                                                               ; makes it global
 0538  8B 36 0008 E		        mov     si,wDeviceIntOffsetTable[8]
 053C  EB 90			        jmp     OEM_test_int_status

 053E				device_six::                                                               ; makes it global
 053E  8B 36 000A E		        mov     si,wDeviceIntOffsetTable[10]
 0542  EB 8A			        jmp     OEM_test_int_status

 0544				device_seven::                                                               ; makes it global
 0544  8B 36 000C E		        mov     si,wDeviceIntOffsetTable[12]
 0548  EB 84			        jmp     OEM_test_int_status

 054A				device_eight::                                                               ; makes it global
 054A  8B 36 000E E		        mov     si,wDeviceIntOffsetTable[14]
 054E  E9 FF7D			        jmp     OEM_test_int_status

				;----------------------------------------------------------------------------
				;  Interrupt ID register is all ones (0xff) when no interrupts are pending
				;----------------------------------------------------------------------------
 0551				DigiBoard_ID::                                                               ; makes it global

 0551  8B 16 0000 E		        mov     dx,wIntIDregister
				        InByteImm

 0556  3C FF			        cmp    al,0ffh
 0558  0F 84 FBDE		        je     send_EOI

 055C				db_valid_int::                                                               ; makes it global
 055C  33 DB			        xor     bx,bx
 055E  8A D8			        mov     bl,al
 0560  D1 E3			        shl     bx,1
 0562  8B B7 0000 E		        mov     si,wDeviceIntOffsetTable[bx]
 0566  E9 FF65			        jmp     OEM_test_int_status

				;-------------------------------------------------------------------------------
				; Interrupt Jump Table
				;-------------------------------------------------------------------------------
				EVEN
 056A				Interrupt_Vector LABEL WORD

 056A  0149 R			        WORD modem_int                  ;0
 056C  03A1 R			        WORD write_com                  ;2
 056E  02C2 R			        WORD read_com                   ;4
 0570  016F R			        WORD receive_line_status        ;6
 0572  0578 R			        WORD dummy_vector_ret           ;  8
 0574  0578 R			        WORD dummy_vector_ret           ;  10
 0576  02BA R			        WORD read_com_TO                ;12
				  IFNDEF NO_16650_Xon_HS_support
				  ENDIF
 0578				dummy_vector_ret::                                                               ; makes it global
 0578  CB			        retf

				;----------------------------------------------------------------------------
				;  OEM interrupt jump tables (non-MCA only)
				;----------------------------------------------------------------------------
				EVEN
 057A				OEM_int_entry_table LABEL WORD

 057A  0100 R			        WORD    start_polling
 057C  04EA R			        WORD    ID_is_bits_on
 057E  0551 R			        WORD    DigiBoard_ID
 0580  0461 R			        WORD    zero_is_clear_ID_entry
 0582  04A3 R			        WORD    FF_is_clear_ID_entry
 0584  0504 R			        WORD    ID_is_bits_off

				EVEN
 0586				OEM_int_exit_table LABEL WORD

 0586  011C R			        WORD    poll_next
 0588  04EA R			        WORD    ID_is_bits_on
 058A  0551 R			        WORD    DigiBoard_ID
 058C  044A R			        WORD    test_zero_ID
 058E  048A R			        WORD    test_FF_ID
 0590  0504 R			        WORD    ID_is_bits_off

				EVEN
 0592				BitIDjumpTable LABEL WORD
 0592  013A R			        WORD    send_EOI                ;0
 0594  0520 R			        WORD    device_one              ;00000001  1
 0596  0526 R			        WORD    device_two              ;00000010  2
 0598  0520 R			        WORD    device_one              ;00000011  3
 059A  052C R			        WORD    device_three            ;00000100  4
 059C  0520 R			        WORD    device_one              ;00000101  5
 059E  0526 R			        WORD    device_two              ;00000110  6
 05A0  0520 R			        WORD    device_one              ;00000111  7
 05A2  0532 R			        WORD    device_four             ;00001000  8
 05A4  0520 R			        WORD    device_one              ;00001001  9
 05A6  0526 R			        WORD    device_two              ;00001010  10 a
 05A8  0520 R			        WORD    device_one              ;00001011  11 b
 05AA  052C R			        WORD    device_three            ;00001100  12 c
 05AC  0520 R			        WORD    device_one              ;00001101  13 d
 05AE  0526 R			        WORD    device_two              ;00001110  14 e
 05B0  0520 R			        WORD    device_one              ;00001111  15 f
 05B2  0538 R			        WORD    device_five             ;00010000  16 10
 05B4  0520 R			        WORD    device_one              ;00010001  17 11
 05B6  0526 R			        WORD    device_two              ;00010010  18 12
 05B8  0520 R			        WORD    device_one              ;00010011  19 13
 05BA  052C R			        WORD    device_three            ;00010100  20 14
 05BC  0520 R			        WORD    device_one              ;00010101  21 15
 05BE  0526 R			        WORD    device_two              ;00010110  22 16
 05C0  0520 R			        WORD    device_one              ;00010111  23 17
 05C2  0532 R			        WORD    device_four             ;00011000  24 18
 05C4  0520 R			        WORD    device_one              ;00011001  25 19
 05C6  0526 R			        WORD    device_two              ;00011010  26 1a
 05C8  0520 R			        WORD    device_one              ;00011011  27 1b
 05CA  052C R			        WORD    device_three            ;00011100  28 1c
 05CC  0520 R			        WORD    device_one              ;00011101  29 1d
 05CE  0526 R			        WORD    device_two              ;00011110  30 1e
 05D0  0520 R			        WORD    device_one              ;00011111  31 1f
 05D2  053E R			        WORD    device_six              ;00100000  32 20
 05D4  0520 R			        WORD    device_one              ;00100001  33 21
 05D6  0526 R			        WORD    device_two              ;00100010  34 22
 05D8  0520 R			        WORD    device_one              ;00100011  35 23
 05DA  052C R			        WORD    device_three            ;00100100  36 24
 05DC  0520 R			        WORD    device_one              ;00100101  37 25
 05DE  0526 R			        WORD    device_two              ;00100110  38 26
 05E0  0520 R			        WORD    device_one              ;00100111  39 27
 05E2  0532 R			        WORD    device_four             ;00101000  40 28
 05E4  0520 R			        WORD    device_one              ;00101001  41 29
 05E6  0526 R			        WORD    device_two              ;00101010  42 2a
 05E8  0520 R			        WORD    device_one              ;00101011  43 2b
 05EA  052C R			        WORD    device_three            ;00101100  44 2c
 05EC  0520 R			        WORD    device_one              ;00101101  45 2d
 05EE  0526 R			        WORD    device_two              ;00101110  46 2e
 05F0  0520 R			        WORD    device_one              ;00101111  47 2f
 05F2  0538 R			        WORD    device_five             ;00110000  48 30
 05F4  0520 R			        WORD    device_one              ;00110001  49 31
 05F6  0526 R			        WORD    device_two              ;00110010  50 32
 05F8  0520 R			        WORD    device_one              ;00110011  51 33
 05FA  052C R			        WORD    device_three            ;00110100  52 34
 05FC  0520 R			        WORD    device_one              ;00110101  53 35
 05FE  0526 R			        WORD    device_two              ;00110110  54 36
 0600  0520 R			        WORD    device_one              ;00110111  55 37
 0602  0532 R			        WORD    device_four             ;00111000  56 38
 0604  0520 R			        WORD    device_one              ;00111001  57 39
 0606  0526 R			        WORD    device_two              ;00111010  58 3a
 0608  0520 R			        WORD    device_one              ;00111011  59 3b
 060A  052C R			        WORD    device_three            ;00111100  60 3c
 060C  0520 R			        WORD    device_one              ;00111101  61 3d
 060E  0526 R			        WORD    device_two              ;00111110  62 3e
 0610  0520 R			        WORD    device_one              ;00111111  63 3f
 0612  0544 R			        WORD    device_seven            ;01000000  64  40
 0614  0520 R			        WORD    device_one              ;01000001  1   41
 0616  0526 R			        WORD    device_two              ;01000010  2   42
 0618  0520 R			        WORD    device_one              ;01000011  3   43
 061A  052C R			        WORD    device_three            ;01000100  4   44
 061C  0520 R			        WORD    device_one              ;01000101  5   45
 061E  0526 R			        WORD    device_two              ;01000110  6   46
 0620  0520 R			        WORD    device_one              ;01000111  7   47
 0622  0532 R			        WORD    device_four             ;01001000  8   48
 0624  0520 R			        WORD    device_one              ;01001001  9   49
 0626  0526 R			        WORD    device_two              ;01001010  10  4a
 0628  0520 R			        WORD    device_one              ;01001011  11  4b
 062A  052C R			        WORD    device_three            ;01001100  12  4c
 062C  0520 R			        WORD    device_one              ;01001101  13  4d
 062E  0526 R			        WORD    device_two              ;01001110  14  4e
 0630  0520 R			        WORD    device_one              ;01001111  15  4f
 0632  0538 R			        WORD    device_five             ;01010000  16  50
 0634  0520 R			        WORD    device_one              ;01010001  17  51
 0636  0526 R			        WORD    device_two              ;01010010  18  52
 0638  0520 R			        WORD    device_one              ;01010011  19  53
 063A  052C R			        WORD    device_three            ;01010100  20  54
 063C  0520 R			        WORD    device_one              ;01010101  21  55
 063E  0526 R			        WORD    device_two              ;01010110  22  56
 0640  0520 R			        WORD    device_one              ;01010111  23  57
 0642  0532 R			        WORD    device_four             ;01011000  24  58
 0644  0520 R			        WORD    device_one              ;01011001  25  59
 0646  0526 R			        WORD    device_two              ;01011010  26  5a
 0648  0520 R			        WORD    device_one              ;01011011  27  5b
 064A  052C R			        WORD    device_three            ;01011100  28  5c
 064C  0520 R			        WORD    device_one              ;01011101  29  5d
 064E  0526 R			        WORD    device_two              ;01011110  30  5e
 0650  0520 R			        WORD    device_one              ;01011111  31  5f
 0652  053E R			        WORD    device_six              ;01100000  32  60
 0654  0520 R			        WORD    device_one              ;01100001  33  61
 0656  0526 R			        WORD    device_two              ;01100010  34  62
 0658  0520 R			        WORD    device_one              ;01100011  35  63
 065A  052C R			        WORD    device_three            ;01100100  36  64
 065C  0520 R			        WORD    device_one              ;01100101  37  65
 065E  0526 R			        WORD    device_two              ;01100110  38  66
 0660  0520 R			        WORD    device_one              ;01100111  39  67
 0662  0532 R			        WORD    device_four             ;01101000  40  68
 0664  0520 R			        WORD    device_one              ;01101001  41  69
 0666  0526 R			        WORD    device_two              ;01101010  42  6a
 0668  0520 R			        WORD    device_one              ;01101011  43  6b
 066A  052C R			        WORD    device_three            ;01101100  44  6c
 066C  0520 R			        WORD    device_one              ;01101101  45  6d
 066E  0526 R			        WORD    device_two              ;01101110  46  6e
 0670  0520 R			        WORD    device_one              ;01101111  47  6f
 0672  0538 R			        WORD    device_five             ;01110000  48  70
 0674  0520 R			        WORD    device_one              ;01110001  49  71
 0676  0526 R			        WORD    device_two              ;01110010  50  72
 0678  0520 R			        WORD    device_one              ;01110011  51  73
 067A  052C R			        WORD    device_three            ;01110100  52  74
 067C  0520 R			        WORD    device_one              ;01110101  53  75
 067E  0526 R			        WORD    device_two              ;01110110  54  76
 0680  0520 R			        WORD    device_one              ;01110111  55  77
 0682  0532 R			        WORD    device_four             ;01111000  56  78
 0684  0520 R			        WORD    device_one              ;01111001  57  79
 0686  0526 R			        WORD    device_two              ;01111010  58  7a
 0688  0520 R			        WORD    device_one              ;01111011  59  7b
 068A  052C R			        WORD    device_three            ;01111100  60  7c
 068C  0520 R			        WORD    device_one              ;01111101  61  7d
 068E  0526 R			        WORD    device_two              ;01111110  62  7e
 0690  0520 R			        WORD    device_one              ;01111111  63  7f

 0692				RES_CODE ENDS

				    END

