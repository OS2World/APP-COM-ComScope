;	Static Name Aliases
;
	TITLE   IniAccess.c
	.286p
	.287
INCLUDELIB	LLIBCE
_TEXT	SEGMENT  WORD PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT  WORD PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT  WORD PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT  WORD PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT  BYTE PUBLIC 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT  BYTE PUBLIC 'DEBTYP'
$$TYPES	ENDS
RMCode	SEGMENT  WORD PUBLIC 'CODE'
RMCode	ENDS
DGROUP	GROUP	CONST, _BSS, _DATA
	ASSUME DS: DGROUP
	ASSUME  SS: NOTHING
PUBLIC  _szInterruptLevelError_u
PUBLIC  _szInterruptIDerror_u
PUBLIC  _szFinalError
PUBLIC  _iLIDcount
PUBLIC  _szAllocBuffers_ululu
PUBLIC  _szAllocError
PUBLIC  _szMemoryError_u
PUBLIC  _szNoPortAvailable
PUBLIC  _szNoStackAvailable_uu
PUBLIC  _szLogoMessage_s
PUBLIC  _szVerMod
PUBLIC  _szSubLogo
PUBLIC  _szCopyright
PUBLIC  _szCreditHeader
PUBLIC  _szVersion
PUBLIC  _szVersionString_ss
PUBLIC  _szPath_sss
PUBLIC  _stConfigInfo
PUBLIC  _szHighlightOn
PUBLIC  _stConfigHeader
PUBLIC  _szHighlightOff
PUBLIC  _stDCBheader
PUBLIC  _szBeepChar
PUBLIC  _szNoise
PUBLIC  _bPrevErrorMsg
PUBLIC  _szCR_2x
PUBLIC  _hCom
PUBLIC  _szCR
PUBLIC  _hFile
PUBLIC  _pDeviceParms
PUBLIC  _szCRonly
PUBLIC  _szWaitKeyMessage
PUBLIC  _pStart
PUBLIC  _szDebugMessage
PUBLIC  _pPrevious
PUBLIC  _wDeviceStrategy
PUBLIC  _szCodeLocation_xxxxxxx
PUBLIC  _szClockRate_u
PUBLIC  _stDefaultDevHeader
PUBLIC  _szCOMmessage_u
PUBLIC  _szVerboseMessage_uxu
PUBLIC  _bBreakInitialization
PUBLIC  _szInputBuff_lu
PUBLIC  _szOutputBuff_lu
PUBLIC  _awPorts
PUBLIC  _szInputQueue_u
PUBLIC  _szOutputQueue_u
PUBLIC  _szUART_s
PUBLIC  _szUART_is
PUBLIC  _szAnd
PUBLIC  _szAnd4x
PUBLIC  _szAnd8x
PUBLIC  _szAnd12x
PUBLIC  _szAnd16x
PUBLIC  _szBlankPad
PUBLIC  _szPeriod
PUBLIC  _szExtended16550
PUBLIC  _szExtended16650
PUBLIC  _szExtended16654
PUBLIC  _szExtended16750
PUBLIC  _szExtended16950
PUBLIC  _szExtendedTI16550C
PUBLIC  _szABIOSaddrInvalid_u
PUBLIC  _szABIOSaddrTaken_u
PUBLIC  _szABIOSname_u
PUBLIC  _szABIOSowned_u
PUBLIC  _szRMowned_u
PUBLIC  _szSkippedPort_u
PUBLIC  _szBadInstall
PUBLIC  _szHDWinterruptError_uu
PUBLIC  _szPCIerror_u
PUBLIC  _szHDWerror_xu
PUBLIC  _szInterruptError_uu
PUBLIC  _szBaseAddrError_u
EXTRN	_GetLIDentry:FAR
EXTRN	_FreeLIDentry:FAR
EXTRN	_GetAllSerialPCIAdapters:FAR
EXTRN	DOS16OPEN:FAR
EXTRN	_sprintf:FAR
EXTRN	_RMHELP_GetStatusPort:FAR
EXTRN	_RMHELP_HasPNPCaps:FAR
EXTRN	_RMHELP_GetPorts:FAR
EXTRN	_RMHELP_StatusPortInitComplete:FAR
EXTRN	_RMHELP_CreateDriver:FAR
EXTRN	_RMHELP_DestroyDriver:FAR
EXTRN	DOS16CHGFILEPTR:FAR
EXTRN	_StringLength:FAR
EXTRN	_LoadPCIAdapter:FAR
EXTRN	DOS16SLEEP:FAR
EXTRN	_AttachDD:FAR
EXTRN	DOS16CLOSE:FAR
EXTRN	VIO16WRTTTY:FAR
EXTRN	_GetDeviceInterrupt:FAR
EXTRN	DOS16READ:FAR
EXTRN	_GetDeviceBlockOffset:FAR
EXTRN	_GetDeviceBlockLen:FAR
EXTRN	_atoi:FAR
EXTRN	_GetKernalData:FAR
EXTRN	_GetDeviceAddress:FAR
EXTRN	DOS16WRITE:FAR
EXTRN	_bIsTheFirst:WORD
EXTRN	_LIDtable:BYTE
EXTRN	_ulAvailableBufferSpace:DWORD
EXTRN	_ulRequiredBufferSpace:DWORD
EXTRN	_ulWriteBufferSpace:DWORD
EXTRN	_bUseDDdataSegment:WORD
EXTRN	__wPCIvendor:WORD
EXTRN	__wPCIdevice:WORD
EXTRN	__stDummyHeader:BYTE
EXTRN	__abyPath:BYTE
EXTRN	_wPCIadapterCount:WORD
EXTRN	__bSharedInterrupts:WORD
EXTRN	_wDeviceCount:WORD
EXTRN	__wIntIDregister:WORD
EXTRN	_wDriverLoadCount:WORD
EXTRN	_wDelayCount:WORD
EXTRN	__wOEMjumpEntry:WORD
EXTRN	__wOEMjumpExit:WORD
EXTRN	__bOEMpresent:WORD
EXTRN	__wMaxDeviceCount:WORD
EXTRN	_chWrongOEM_ss:BYTE
EXTRN	__wEndOfData:WORD
EXTRN	_chCompanyName:BYTE
EXTRN	__stDeviceParms:BYTE
EXTRN	_chAdapterName:BYTE
EXTRN	__stAttachDD:BYTE
EXTRN	_szMessage:BYTE
EXTRN	_astInstallParms:BYTE
EXTRN	__wBusType:WORD
EXTRN	_astMCAportTable:BYTE
EXTRN	_bDisableRM:WORD
EXTRN	_bPnPcapable:WORD
EXTRN	__szName:BYTE
EXTRN	__byAdapterType:BYTE
EXTRN	__byOEMtype:BYTE
EXTRN	_byNextPCIslot:BYTE
EXTRN	_bSeparateIDreg:WORD
EXTRN	__pDeviceStrategy:WORD
EXTRN	_chFailedReadIni:BYTE
EXTRN	_chFailedWriteIni:BYTE
EXTRN	_chFailedIniCorrupt_1:BYTE
EXTRN	_chFailedIniCorrupt_2:BYTE
EXTRN	_chFailedIniNotInit_1:BYTE
EXTRN	_chFailedIniNotInit_2:BYTE
EXTRN	_chFailedBadPath:BYTE
EXTRN	_chFailedBadVersion_1:BYTE
EXTRN	_chFailedBadVersion_2:BYTE
EXTRN	_chPCIMissing:BYTE
EXTRN	_chPCIBadIRQ:BYTE
EXTRN	_chTooManyPCIadapters:BYTE
EXTRN	_stPCIadapterTable:BYTE
EXTRN	_stPCIadapterHold:BYTE
EXTRN	_stConfigParms:BYTE
EXTRN	_bVerbose:WORD
EXTRN	_abyFileBuffer:BYTE
EXTRN	_bPrintLocation:WORD
EXTRN	_bWaitForCR:WORD
EXTRN	_wLoadNumber:WORD
EXTRN	_wLoadCount:WORD
EXTRN	_wLoadFlags:WORD
EXTRN	_abyCOMnumbers:BYTE
EXTRN	_byLoadAdapterType:BYTE
EXTRN	_bABIOSpresent:WORD
_DATA      SEGMENT
	ORG	$+3640
$SG2584	DB	'Load Number %u',  0dH,  0aH,  00H
$SG2758	DB	'COM%d    ',  00H
	ORG	$+3
$SG2781	DB	'COM%u    ',  00H
	ORG	$-3680
_szLogoMessage_s	DB	1bH, '[36mInstalling OS/tools'' COMi Asynchronous Communicat'
	DB	'ions device driver',  1bH, '[0m',  0dH,  0aH, '%s',  0dH,  0aH
	DB	00H
	ORG	$+1
_szVerMod	DB	'SS',  00H
	ORG	$+1
_szSubLogo	DB	'For Sealevel Systems Incorporated serial adapters',  00H
_szCopyright	DB	0dH,  0aH, 'OS/tools'' COMi Asynchronous Communications devi'
	DB	'ce driver installed',  0dH,  0aH, 'Copyright (c) ',  1bH, '['
	DB	'36mOS/tools Incorporated',  1bH, '[0m 1989-2002 -- All right'
	DB	's reserved',  0dH,  0aH, 'e-mail: support@os-tools.com, URL:'
	DB	' http://www.os-tools.com',  0dH,  0aH,  00H
_szCreditHeader	DB	'Copyright (c) 1989-2002',  0dH,  0aH, 'OS/tools Incorporated'
	DB	0dH,  0aH, 'Gilroy, California',  0dH,  0aH, '(408)847-7487',  0dH
	DB	0aH, 'Written By Emmett S. Culley Jr.',  0dH,  0aH,  00H
	ORG	$+1
_szVersion	DB	'Version 4.00e',  00H
_szVersionString_ss	DB	1bH, '[1m%s %s',  1bH, '[0m',  0dH,  0aH,  00H
_szPath_sss	DB	'%s %s %s ',  00H
_szHighlightOn	DB	1bH, '[1m',  00H
	ORG	$+1
_szHighlightOff	DB	1bH, '[0m',  00H
	ORG	$+1
_szBeepChar	DB	07H,  00H
_szNoise	DB	07H, 'h.',  00H
_szCR_2x	DB	0dH,  0aH,  0dH,  0aH,  00H
	ORG	$+1
_szCR	DB	0dH,  0aH,  00H
	ORG	$+1
_szCRonly	DB	0dH,  00H
_szWaitKeyMessage	DB	0dH,  0aH, 'Press Enter to continue.',  0dH,  0aH,  00H
	ORG	$+1
_szDebugMessage	DB	0dH,  0aH,  07H,  1bH, '[1mHit CTRL+C to cause debug trap.',  1bH
	DB	'[0m',  00H
	ORG	$+1
_szCodeLocation_xxxxxxx	DB	'C@ %04X:%04X I-%04X',  0dH,  0aH, 'D@ %04X:%04X I-%04X B-%04'
	DB	'X',  0dH,  0aH,  00H
_szClockRate_u	DB	1bH, '[1m',  07H, 'System clock rate expected to be %u milli'
	DB	'seconds for this OS/2 session',  1bH, '[0m',  0dH,  0aH,  00H
_szCOMmessage_u	DB	'COM%u installed',  00H
_szVerboseMessage_uxu	DB	'COM%u installed at address 0x%X, hardware interrupt level = '
	DB	'%u',  0dH,  0aH,  00H
	ORG	$+1
_szInputBuff_lu	DB	'      input buffer length = %lu',  00H
_szOutputBuff_lu	DB	'      output buffer length = %lu',  00H
	ORG	$+1
_szInputQueue_u	DB	'      input packet queue = %u',  00H
_szOutputQueue_u	DB	'      output packet queue = %u',  00H
	ORG	$+1
_szUART_s	DB	'UART is %s',  00H
	ORG	$+1
_szUART_is	DB	'UART is ',  00H
	ORG	$+1
_szAnd	DB	' - ',  00H
_szAnd4x	DB	1bH, '[37;1m and 4x baud rate clock.',  1bH, '[0m',  00H
_szAnd8x	DB	1bH, '[37;1m and 8x baud rate clock.',  1bH, '[0m',  00H
_szAnd12x	DB	1bH, '[37;1m and 12x baud rate clock.',  1bH, '[0m',  00H
	ORG	$+1
_szAnd16x	DB	1bH, '[37;1m and 16x baud rate clock.',  1bH, '[0m',  00H
	ORG	$+1
_szBlankPad	DB	'      ',  00H
	ORG	$+1
_szPeriod	DB	'.',  1bH, '[0m',  00H
_szExtended16550	DB	'16550 with 16 byte FIFOs',  00H
	ORG	$+1
_szExtended16650	DB	1bH, '[33;1m16650 with 32 byte FIFOs',  00H
_szExtended16654	DB	1bH, '[35;1m16654 with 64 byte FIFOs',  00H
_szExtended16750	DB	1bH, '[31;1m16750 with 64 byte FIFOs',  00H
_szExtended16950	DB	1bH, '[32;1m16950 with 128 byte FIFOs',  00H
	ORG	$+1
_szExtendedTI16550C	DB	1bH, '[34;1mTI16550C with 16 byte FIFOs',  00H
	ORG	$+1
_szABIOSaddrInvalid_u	DB	1bH, '[1m',  07H, 'COM%u not installed because a valid devic'
	DB	'e was not detected at the specified base I/O address',  1bH, '['
	DB	'0m',  0dH,  0aH,  00H
	ORG	$+1
_szABIOSaddrTaken_u	DB	1bH, '[1m',  07H, 'COM%u not installed because a previously '
	DB	'loaded device driver owns the device',  0dH,  0aH, 'under a '
	DB	'different device name',  1bH, '[0m',  0dH,  0aH,  00H
_szABIOSname_u	DB	1bH, '[1m',  07H, 'COM%u not installed because name is taken'
	DB	' by a previously loaded device driver',  1bH, '[0m',  0dH,  0aH
	DB	00H
_szABIOSowned_u	DB	1bH, '[1m',  07H, 'COM%u not installed because device is own'
	DB	'ed by a previously loaded process',  1bH, '[0m',  0dH,  0aH,  00H
_szRMowned_u	DB	1bH, '[1m',  07H, 'COM%u not installed because IRQ or I/O ad'
	DB	'dress resource is not available.',  1bH, '[0m',  0dH,  0aH,  00H
	ORG	$+1
_szSkippedPort_u	DB	'COM%u not installed at users request',  1bH, '[0m',  0dH,  0aH
	DB	00H
	ORG	$+1
_szBadInstall	DB	1bH, '[1m',  07H, 'You must use either COMscope or Install t'
	DB	'o install the COMi device drvier.',  0dH,  0aH, 'See documen'
	DB	'tation for instructions on installation and configuration of'
	DB	' COMi.',  1bH, '[0m',  0dH,  0aH,  0dH,  0aH,  00H
	ORG	$+1
_szHDWinterruptError_uu	DB	1bH, '[1m',  07H, 'COM%u device is not connected to interrup'
	DB	't %u as expected and was not installed',  1bH, '[0m',  0dH,  0aH
	DB	00H
	ORG	$+1
_szPCIerror_u	DB	1bH, '[1m',  07H, 'No supported PCI device found, COM%u was '
	DB	'not installed.',  1bH, '[0m',  0dH,  0aH,  00H
	ORG	$+1
_szHDWerror_xu	DB	1bH, '[1m',  07H, 'No supported device was found at base add'
	DB	'ress 0x%X - COM%u was not installed.',  1bH, '[0m',  0dH,  0aH
	DB	00H
	ORG	$+1
_szInterruptError_uu	DB	1bH, '[1m',  07H, 'Interrupt %u is unavailable - COM%u was n'
	DB	'ot intalled.',  1bH, '[0m',  0dH,  0aH,  00H
	ORG	$+1
_szBaseAddrError_u	DB	1bH, '[1m',  07H, 'Invalid base I/O address was specified - '
	DB	'COM%u was not installed.',  1bH, '[0m',  0dH,  0aH,  00H
	ORG	$+1
_szInterruptLevelError_u	DB	1bH, '[1m',  07H, 'Invalid or no interrupt level was specifi'
	DB	'ed - COM%u was not installed.',  1bH, '[0m',  0dH,  0aH,  00H
_szInterruptIDerror_u	DB	1bH, '[1m',  07H, 'COM%u device does not support an Interrup'
	DB	't Status register as configured.',  1bH, '[0m',  0dH,  0aH,  00H
	ORG	$+1
_szFinalError	DB	1bH, '[1m',  07H, 'At least one installed device was not con'
	DB	'figured correctly.  See adapter',  0dH,  0aH, 'and/or COMi d'
	DB	'ocumentation for explanation.',  1bH, '[0m',  0dH,  0aH,  00H
_szAllocBuffers_ululu	DB	1bH, '[1m',  07H, 'Allocating %u selectors and %lu bytes RAM'
	DB	' for device driver buffers.',  0dH,  0aH, '%lu bytes were av'
	DB	'ailable in device driver data segment.',  1bH, '[0m',  0dH,  0aH
	DB	00H
	ORG	$+1
_szAllocError	DB	1bH, '[1m',  07H, 'Unable to allocate memory or selectors fo'
	DB	'r device driver buffers.  Your',  0dH,  0aH, 'system is unab'
	DB	'le to support the memory requested',  1bH, '[0m',  0dH,  0aH
	DB	00H
	ORG	$+1
_szMemoryError_u	DB	1bH, '[1m',  07H, 'Segment Overflow, decrease transmit buffe'
	DB	'r sizes  - COM%u was not installed',  1bH, '[0m',  0dH,  0aH
	DB	00H
	ORG	$+1
_szNoPortAvailable	DB	1bH, '[1m',  07H, 'There are no serial devices available for'
	DB	' COMi access.  Either there are no',  0dH,  0aH, 'standard s'
	DB	'erial devices installed, or all standard devices are already'
	DB	' owned',  0dH,  0aH, 'by one, or more, previously loaded dev'
	DB	'ice drivers (i.e., COM.SYS).',  1bH, '[0m',  0dH,  0aH,  00H
	ORG	$+1
_szNoStackAvailable_uu	DB	1bH, '[1mNo stack available for interrupt level %u - COM%u w'
	DB	'as not installed',  1bH, '[0m',  0dH,  0aH,  00H
_stConfigInfo	DD	00H
 	DB	40 DUP(0)

_stConfigHeader	DW	00H
 	DB	60 DUP(0)

_stDCBheader	DB	00H
 	DB	57 DUP(0)

_bPrevErrorMsg	DW	00H
_hCom	DW	00H
_hFile	DW	00H
_pDeviceParms	DD	00H
_pStart	DD	00H
_pPrevious	DD	00H
_wDeviceStrategy	DW	00H
_stDefaultDevHeader	DD	00H
	DW	00H
 	DB	20 DUP(0)

_bBreakInitialization	DW	00H
_awPorts	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	ORG	$+28
_iLIDcount	DW	00H
_DATA      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
;|*** /************************************************************************
; Line 1
;|*** **
;|*** ** $Revision:  $
;|*** **
;|*** ** $Log:   $
;|*** **
;|*** ************************************************************************/
;|*** 
;|*** #define INCL_DOSDEVICES
;|*** #define INCL_VIO
;|*** #define INCL_DOS
;|*** #define INCL_DOSERRORS
;|*** #define INCL_NOPM
;|*** #define building_DD
;|*** 
;|*** #include <os2.h>
; Line 16
;|*** /*DDK*************************************************************************/
;|*** /*                                                                           */
;|*** /* COPYRIGHT (C) Microsoft Corporation, 1989                                 */
;|*** /* COPYRIGHT    Copyright (C) 1995 IBM Corporation                           */
;|*** /*                                                                           */
;|*** /*    The following IBM OS/2 WARP source code is provided to you solely for  */
;|*** /*    the purpose of assisting you in your development of OS/2 WARP device   */
;|*** /*    drivers. You may use this code in accordance with the IBM License      */
;|*** /*    Agreement provided in the IBM Device Driver Source Kit for OS/2. This  */
;|*** /*    Copyright statement may not be removed.                                */
;|*** /*                                                                           */
;|*** /*****************************************************************************/
;|*** /*static char *SCCSID = "@(#)os2.h	6.3 91/05/26";*/
;|*** /****************************** Module Header ******************************\
;|*** *
;|*** *
;|*** * Module Name: OS2.H
;|*** *
;|*** * This is the top level include file that includes all the files necessary
;|*** * for writing an OS/2 application.
;|*** *
;|*** \***************************************************************************/
;|*** 
;|*** #define OS2_INCLUDED
;|*** 
;|*** #if !(defined(INCL_32) || defined(INCL_16))
;|*** #ifdef M_I386
;|***     #define INCL_32
;|*** #else /* not M_I386 */
;|***     #define INCL_16
;|*** #endif /* M_I386 */
;|*** #endif /* INCL_32 || INCL_16 */
;|*** 
;|*** /* XLATOFF */
;|*** #if (defined(INCL_32) && defined(INCL_16))
;|*** #error message ("Illegal combination of API Flags - 32 && 16")
;|*** #endif /* INCL_32 && INCL_16 */
;|*** /* XLATON */
;|*** 
;|*** /* Common definitions */
;|*** 
;|*** #include <os2def.h>
; Line 42
;|*** /*DDK*************************************************************************/
;|*** /*                                                                           */
;|*** /* COPYRIGHT    Copyright (C) 1995 IBM Corporation                           */
;|*** /*                                                                           */
;|*** /*    The following IBM OS/2 WARP source code is provided to you solely for  */
;|*** /*    the purpose of assisting you in your development of OS/2 WARP device   */
;|*** /*    drivers. You may use this code in accordance with the IBM License      */
;|*** /*    Agreement provided in the IBM Device Driver Source Kit for OS/2. This  */
;|*** /*    Copyright statement may not be removed.                                */
;|*** /*                                                                           */
;|*** /*****************************************************************************/
;|*** /****************************** Module Header ******************************\
;|*** *
;|*** * Module Name: OS2DEF.H
;|*** *
;|*** * OS/2 Common Definitions file
;|*** *
;|*** *
;|*** * ===========================================================================
;|*** *
;|*** * Comments at the end of each typedef line give the name tags used in
;|*** * the assembler include version of this file.
;|*** *
;|*** * The assembler include version of this file excludes lines between NOINC
;|*** * and INC comments.
;|*** *
;|*** #ifndef __IBMC__
;|***    * The public version of this file (as shipped with the OS/2 Toolkit
;|***    * product) excludes all non 32-bit material marked in this file
;|***    * as well as any areas specifically marked with __IBMC__ conditional
;|***    * sections - including this paragraph. The H2IBMH rexx command file
;|***    * removes these sections.
;|*** #endif
;|*** \***************************************************************************/
;|*** 
;|*** #ifdef __IBMC__
;|***    #pragma checkout( suspend )
;|***       #ifndef __CHKHDR__
;|***          #pragma checkout( suspend )
;|***       #endif
;|***    #pragma checkout( resume )
;|*** #endif
;|*** 
;|*** #define OS2DEF_INCLUDED
;|*** 
;|*** #ifndef INCL_32         /* If neither INCL_32 or INCL_16 set already */
;|***    #ifndef INCL_16      /* find out from compiler if 32-bit or not.  */
;|***      #ifdef M_I386
;|***         #define INCL_32 /* Compiling for 32-bit */
;|***      #else
;|***         #define INCL_16 /* Compiling for 16-bit */
;|***      #endif
;|***   #endif
;|*** #endif
;|*** 
;|*** #ifdef INCL_32
;|***    #ifndef __IBMC__
;|***    /*****************************************************************/
;|***    /* This #ifdef brackets the rest of this entire file.  It is     */
;|***    /* used to include either the 32-bit or 16-bit base definitions. */
;|***    /* No definitions (other than 16/32-bit determination) must be   */
;|***    /* placed above this.                                            */
;|***    /*****************************************************************/
;|***    #endif
;|*** 
;|***    /* NOINC */
;|***    #ifdef INCL_16
;|***       #error message ("Using 32 bit definitions when compiling 16 bit code")
;|***    #endif /* INCL_16 */
;|***    #ifdef __IBMC__
;|***       #define FAR         /* this will be deleted shortly */
;|***       #define NEAR        /* this will be deleted shortly */
;|*** 
;|***       #define APIENTRY    _System
;|***       #define EXPENTRY    _System
;|*** 
;|***       #define APIENTRY16  _Far16 _Pascal
;|***       #define PASCAL16    _Far16 _Pascal
;|***       #define CDECL16     _Far16 _Cdecl
;|***    #else
;|***       #define FAR         /* nothing */
;|***       #define NEAR        /* nothing */
;|*** 
;|***       #define APIENTRY    _syscall
;|***       #define EXPENTRY    _syscall
;|*** 
;|***       #define PASCAL      /* nothing */
;|***    #endif
;|*** 
;|***    #define VOID        void
;|***    /* INC */
;|*** 
;|***    typedef unsigned long  APIRET;
;|***    typedef unsigned short APIRET16;
;|***    typedef unsigned long  APIRET32;
;|*** 
;|***    #ifndef FALSE
;|***       #define FALSE   0
;|***    #endif
;|*** 
;|***    #ifndef TRUE
;|***       #define TRUE    1
;|***    #endif
;|*** 
;|***    #ifndef NULL
;|***       #ifdef __IBMC__
;|***          #define NULL ((void *)0)
;|***       #else
;|***          #define NULL 0
;|***       #endif
;|***    #endif
;|*** 
;|***    #ifdef __IBMC__
;|***       typedef unsigned short   SHANDLE;
;|***    #else
;|***       /* TEMP      - David Kerr, this will change to short when the    */
;|***       /*             rest of the BSExxx.H files are changed to LHANDLE */
;|***       typedef unsigned long   SHANDLE;
;|***    #endif
;|***    typedef unsigned long    LHANDLE;
;|*** 
;|***    #define NULLHANDLE    ( (LHANDLE) 0)
;|***    #define NULLSHANDLE   ( (SHANDLE) 0)
;|*** 
;|***    /* NOINC */
;|***    #define CHAR    char            /* ch  */
;|***    #define SHORT   short           /* s   */
;|***    #define LONG    long            /* l   */
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #define INT  int             /* i   */
;|***    #endif /* !INCL_SAADEFS */
;|***    /* INC */
;|*** 
;|***    typedef unsigned char  UCHAR;   /* uch */
;|***    typedef unsigned short USHORT;  /* us  */
;|***    typedef unsigned long  ULONG;   /* ul  */
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       typedef unsigned int UINT;   /* ui  */
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    #ifdef __IBMC__
;|***       typedef UCHAR     * _Seg16 PUCHAR16;
;|***       typedef CHAR      * _Seg16 PCHAR16;
;|***    #endif
;|*** 
;|***    typedef unsigned char BYTE;     /* b   */
;|*** 
;|***    typedef unsigned char FAR  *PSZ;
;|***    typedef unsigned char NEAR *NPSZ;
;|*** 
;|***    typedef unsigned char FAR  *PCH;
;|***    typedef unsigned char NEAR *NPCH;
;|*** 
;|***    #ifdef __IBMC__
;|***       typedef int (* APIENTRY PFN)  ();
;|***       typedef int (* APIENTRY NPFN) ();
;|***    #else
;|***       typedef int   (PASCAL FAR  *PFN)();
;|***       typedef int   (PASCAL NEAR *NPFN)();
;|***    #endif
;|*** 
;|***    typedef BYTE   FAR  *PBYTE;
;|***    typedef BYTE   NEAR *NPBYTE;
;|*** 
;|***    typedef CHAR   FAR *PCHAR;
;|***    typedef SHORT  FAR *PSHORT;
;|***    typedef LONG   FAR *PLONG;
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       typedef INT    FAR *PINT;
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    typedef UCHAR  FAR *PUCHAR;
;|***    typedef USHORT FAR *PUSHORT;
;|***    typedef ULONG  FAR *PULONG;
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       typedef UINT FAR *PUINT;
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    typedef VOID   FAR *PVOID;
;|***    typedef PVOID  FAR *PPVOID;
;|*** 
;|***    typedef unsigned long BOOL;     /* f   */
;|***    typedef BOOL FAR *PBOOL;
;|*** 
;|***    typedef unsigned short  BOOL16;
;|***    #ifdef __IBMC__
;|***       typedef BOOL16     * _Seg16 PBOOL16;
;|***    #else
;|***       typedef BOOL16 FAR *PBOOL16;
;|***    #endif
;|*** 
;|***    /* NOINC */
;|***    #define BOOL32    BOOL
;|***    #define PBOOL32   PBOOL
;|***    /* INC */
;|*** 
;|***    /* NOINC */
;|***    /* Quad-word */
;|***    typedef struct _QWORD {        /* qword */
;|***       ULONG   ulLo;
;|***       ULONG   ulHi;
;|***    } QWORD;
;|***    typedef QWORD FAR *PQWORD;
;|***    /* INC */
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       typedef unsigned short SEL;     /* sel */
;|***       typedef SEL FAR *PSEL;
;|*** 
;|***       /*** Useful Helper Macros */
;|*** 
;|***       /* Create untyped far pointer from selector and offset */
;|***       #ifdef __IBMC__
;|***          #define MAKEP(sel,off) ((void * _Seg16)((((sel)&0xfff8)<<13)|(off)))
;|***       #else
;|***          #define MAKEP(sel, off)     ((PVOID)MAKEULONG(off, sel))
;|***       #endif
;|*** 
;|***       /* Extract selector or offset from far pointer */
;|***       #ifdef __IBMC__
;|***          #define SELECTOROF(ptr)     ((((ULONG)(ptr))>>13)|7)
;|***       #else
;|***          #define SELECTOROF(p)       (((PUSHORT)&(p))[1])
;|***       #endif
;|***       #define OFFSETOF(p)         (((PUSHORT)&(p))[0])
;|***    #endif  /* !INCL_SAADEFS */
;|*** 
;|***    /* Cast any variable to an instance of the specified type. */
;|***    #define MAKETYPE(v, type)   (*((type FAR *)&v))
;|*** 
;|***    /* Calculate the byte offset of a field in a structure of type type. */
;|***    #define FIELDOFFSET(type, field)    ((SHORT)&(((type *)0)->field))
;|*** 
;|***    /* Combine l & h to form a 32 bit quantity. */
;|***    #define MAKEULONG(l, h)  ((ULONG)(((USHORT)(l)) | ((ULONG)((USHORT)(h))) << 16))
;|***    #define MAKELONG(l, h)   ((LONG)MAKEULONG(l, h))
;|*** 
;|***    /* Combine l & h to form a 16 bit quantity. */
;|***    #define MAKEUSHORT(l, h) (((USHORT)(l)) | ((USHORT)(h)) << 8)
;|***    #define MAKESHORT(l, h)  ((SHORT)MAKEUSHORT(l, h))
;|*** 
;|***    /* Extract high and low order parts of 16 and 32 bit quantity */
;|***    #define LOBYTE(w)       LOUCHAR(w)
;|***    #define HIBYTE(w)       HIUCHAR(w)
;|***    #define LOUCHAR(w)      ((UCHAR)(w))
;|***    #define HIUCHAR(w)      ((UCHAR)(((USHORT)(w) >> 8) & 0xff))
;|***    #define LOUSHORT(l)     ((USHORT)((ULONG)l))
;|***    #define HIUSHORT(l)     ((USHORT)(((ULONG)(l) >> 16) & 0xffff))
;|*** 
;|***    /*** Common Error definitions ****/
;|*** 
;|***    typedef ULONG ERRORID;  /* errid */
;|***    typedef ERRORID FAR *PERRORID;
;|*** 
;|***    /* Combine severity and error code to produce ERRORID */
;|***    #define MAKEERRORID(sev, error) (ERRORID)(MAKEULONG((error), (sev)))
;|*** 
;|***    /* Extract error number from an errorid */
;|***    #define ERRORIDERROR(errid)            (LOUSHORT(errid))
;|*** 
;|***    /* Extract severity from an errorid */
;|***    #define ERRORIDSEV(errid)              (HIUSHORT(errid))
;|*** 
;|***    /* Severity codes */
;|***    #define SEVERITY_NOERROR                    0x0000
;|***    #define SEVERITY_WARNING                    0x0004
;|***    #define SEVERITY_ERROR                      0x0008
;|***    #define SEVERITY_SEVERE                     0x000C
;|***    #define SEVERITY_UNRECOVERABLE              0x0010
;|*** 
;|***    /* Base component error values */
;|*** 
;|***    #define WINERR_BASE     0x1000  /* Window Manager                  */
;|***    #define GPIERR_BASE     0x2000  /* Graphics Presentation Interface */
;|***    #define DEVERR_BASE     0x3000  /* Device Manager                  */
;|***    #define SPLERR_BASE     0x4000  /* Spooler                         */
;|*** 
;|***    /*** Common types used across components */
;|*** 
;|***    /*** Common DOS types */
;|*** 
;|***    typedef LHANDLE HMODULE;        /* hmod */
;|***    typedef LHANDLE PID;            /* pid  */
;|***    typedef LHANDLE TID;            /* tid  */
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       typedef USHORT  SGID;        /* sgid */
;|***    #endif  /* !INCL_SAADEFS */
;|*** 
;|***    typedef HMODULE FAR *PHMODULE;
;|***    typedef PID FAR *PPID;
;|***    typedef TID FAR *PTID;
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       typedef VOID FAR *HSEM;      /* hsem */
;|***       typedef HSEM FAR *PHSEM;
;|***    #endif  /* !INCL_SAADEFS */
;|*** 
;|***    /*** Common SUP types */
;|*** 
;|***    typedef LHANDLE   HAB;         /* hab  */
;|***    typedef HAB FAR *PHAB;
;|*** 
;|***    /*** Common GPI/DEV types */
;|*** 
;|***    typedef LHANDLE   HPS;         /* hps  */
;|***    typedef HPS FAR *PHPS;
;|*** 
;|***    typedef LHANDLE   HDC;         /* hdc  */
;|***    typedef HDC FAR *PHDC;
;|*** 
;|***    typedef LHANDLE   HRGN;        /* hrgn */
;|***    typedef HRGN FAR *PHRGN;
;|*** 
;|***    typedef LHANDLE   HBITMAP;     /* hbm  */
;|***    typedef HBITMAP FAR *PHBITMAP;
;|*** 
;|***    typedef LHANDLE   HMF;         /* hmf  */
;|***    typedef HMF FAR *PHMF;
;|*** 
;|***    typedef LHANDLE   HPAL;        /* hpal */
;|***    typedef HPAL FAR *PHPAL;
;|*** 
;|***    typedef LONG     COLOR;        /* clr  */
;|***    typedef COLOR FAR *PCOLOR;
;|*** 
;|***    typedef struct _POINTL  {      /* ptl  */
;|***       LONG  x;
;|***       LONG  y;
;|***    } POINTL;
;|***    typedef POINTL  FAR  *PPOINTL;
;|***    typedef POINTL  NEAR *NPPOINTL;
;|*** 
;|***    typedef struct _POINTS {       /* pts */
;|***       SHORT x;
;|***       SHORT y;
;|***    } POINTS;
;|***    typedef POINTS FAR *PPOINTS;
;|*** 
;|***    typedef struct _RECTL {        /* rcl */
;|***       LONG  xLeft;
;|***       LONG  yBottom;
;|***       LONG  xRight;
;|***       LONG  yTop;
;|***    } RECTL;
;|***    typedef RECTL FAR  *PRECTL;
;|***    typedef RECTL NEAR *NPRECTL;
;|*** 
;|***    typedef CHAR STR8[8];          /* str8 */
;|***    typedef STR8 FAR *PSTR8;
;|*** 
;|***    /*** common DEV/SPL types */
;|*** 
;|***    /* structure for Device Driver data */
;|*** 
;|***    typedef struct _DRIVDATA {     /* driv */
;|***       LONG    cb;
;|***       LONG    lVersion;
;|***       CHAR    szDeviceName[32];
;|***       CHAR    abGeneralData[1];
;|***    } DRIVDATA;
;|***    typedef DRIVDATA FAR *PDRIVDATA;
;|*** 
;|***    /* pointer data for DevOpenDC */
;|*** 
;|***    typedef PSZ FAR *PDEVOPENDATA;
;|*** 
;|***    /* array indices for array parameter for DevOpenDC, SplQmOpen or SplQpOpen */
;|*** 
;|***    #define ADDRESS          0
;|***    #ifndef INCL_SAADEFS
;|***       #define DRIVER_NAME      1
;|***       #define DRIVER_DATA      2
;|***       #define DATA_TYPE        3
;|***       #define COMMENT          4
;|***       #define PROC_NAME        5
;|***       #define PROC_PARAMS      6
;|***       #define SPL_PARAMS       7
;|***       #define NETWORK_PARAMS   8
;|*** 
;|***       /* structure definition as an alternative of the array parameter */
;|*** 
;|***       typedef struct _DEVOPENSTRUC {    /* dop */
;|***          PSZ        pszLogAddress;
;|***          PSZ        pszDriverName;
;|***          PDRIVDATA  pdriv;
;|***          PSZ        pszDataType;
;|***          PSZ        pszComment;
;|***          PSZ        pszQueueProcName;
;|***          PSZ        pszQueueProcParams;
;|***          PSZ        pszSpoolerParams;
;|***          PSZ        pszNetworkParams;
;|***       } DEVOPENSTRUC;
;|***       typedef DEVOPENSTRUC FAR *PDEVOPENSTRUC;
;|***    #endif  /* !INCL_SAADEFS */
;|*** 
;|***    /* common PMWP object and PMSTDDLG drag data */
;|*** 
;|***    typedef struct _PRINTDEST {   /* prntdst */
;|***       ULONG        cb;
;|***       LONG         lType;
;|***       PSZ          pszToken;
;|***       LONG         lCount;
;|***       PDEVOPENDATA pdopData;
;|***       ULONG        fl;
;|***       PSZ          pszPrinter;
;|***    } PRINTDEST;
;|***    typedef PRINTDEST FAR *PPRINTDEST;
;|*** 
;|***    #define PD_JOB_PROPERTY   0x0001      /* Flags for .fl field           */
;|*** 
;|***    /*** common AVIO/GPI types */
;|*** 
;|***    /* values of fsSelection field of FATTRS structure */
;|***    #define FATTR_SEL_ITALIC        0x0001
;|***    #define FATTR_SEL_UNDERSCORE    0x0002
;|***    #define FATTR_SEL_OUTLINE       0x0008
;|***    #define FATTR_SEL_STRIKEOUT     0x0010
;|***    #define FATTR_SEL_BOLD          0x0020
;|*** 
;|***    /* values of fsType field of FATTRS structure */
;|***    #define FATTR_TYPE_KERNING      0x0004
;|***    #define FATTR_TYPE_MBCS         0x0008
;|***    #define FATTR_TYPE_DBCS         0x0010
;|***    #define FATTR_TYPE_ANTIALIASED  0x0020
;|*** 
;|***    /* values of fsFontUse field of FATTRS structure */
;|***    #define FATTR_FONTUSE_NOMIX         0x0002
;|***    #define FATTR_FONTUSE_OUTLINE       0x0004
;|***    #define FATTR_FONTUSE_TRANSFORMABLE 0x0008
;|***    /* size for fields in the font structures */
;|*** 
;|***    #define FACESIZE 32
;|*** 
;|***    /* font struct for Vio/GpiCreateLogFont */
;|*** 
;|***    typedef struct _FATTRS {          /* fat */
;|***       USHORT  usRecordLength;
;|***       USHORT  fsSelection;
;|***       LONG    lMatch;
;|***       CHAR    szFacename[FACESIZE];
;|***       USHORT  idRegistry;
;|***       USHORT  usCodePage;
;|***       LONG    lMaxBaselineExt;
;|***       LONG    lAveCharWidth;
;|***       USHORT  fsType;
;|***       USHORT  fsFontUse;
;|***    } FATTRS;
;|***    typedef FATTRS FAR *PFATTRS;
;|*** 
;|***    /* values of fsType field of FONTMETRICS structure */
;|***    #define FM_TYPE_FIXED           0x0001
;|***    #define FM_TYPE_LICENSED        0x0002
;|***    #define FM_TYPE_KERNING         0x0004
;|***    #define FM_TYPE_DBCS            0x0010
;|***    #define FM_TYPE_MBCS            0x0018
;|***    #define FM_TYPE_64K             0x8000
;|***    #define FM_TYPE_ATOMS           0x4000
;|***    #define FM_TYPE_FAMTRUNC        0x2000
;|***    #define FM_TYPE_FACETRUNC       0x1000
;|*** 
;|***    /* values of fsDefn field of FONTMETRICS structure */
;|***    #define FM_DEFN_OUTLINE         0x0001
;|***    #define FM_DEFN_IFI             0x0002
;|***    #define FM_DEFN_WIN             0x0004
;|***    #define FM_DEFN_GENERIC         0x8000
;|*** 
;|***    /* values of fsSelection field of FONTMETRICS structure */
;|***    #define FM_SEL_ITALIC           0x0001
;|***    #define FM_SEL_UNDERSCORE       0x0002
;|***    #define FM_SEL_NEGATIVE         0x0004
;|***    #define FM_SEL_OUTLINE          0x0008          /* Hollow Outline Font */
;|***    #define FM_SEL_STRIKEOUT        0x0010
;|***    #define FM_SEL_BOLD             0x0020
;|***    #define FM_SEL_ISO9241_TESTED   0x0040
;|*** 
;|***    /* ISO 9241 is an international standard covering health and safety      */
;|***    /* in the work place for users of visual display terminals. Part 3 of    */
;|***    /* this standard covers clarity and legibility of text displayed on      */
;|***    /* computer screens, it places requirements on minimum sizes and         */
;|***    /* luminance contrast. The presence of FM_SEL_ISO9241_TESTED flag in the */
;|***    /* font metrics indicates that the font has been tested for compliance   */
;|***    /* to the standard. The FM_ISO_XXX flags indicate the results of the     */
;|***    /* test on the IBM 9515, 9517 and 9518 color displays at the supported   */
;|***    /* dimensions of 640x480 and 1024x768. To ensure compliance the          */
;|***    /* sXDeviceRes and sYDeviceRes must also match the target display        */
;|***    /* resolution.                                                           */
;|*** 
;|***    /* values of fbPassed/FailedISO field in the PANOSE structure */
;|***    #define FM_ISO_9518_640        0x01
;|***    #define FM_ISO_9515_640        0x02
;|***    #define FM_ISO_9515_1024       0x04
;|***    #define FM_ISO_9517_640        0x08
;|***    #define FM_ISO_9517_1024       0x10
;|*** 
;|***    /* values of fsCapabilities field of FONTMETRICS structure */
;|***    #define FM_CAP_NOMIX            0x0001
;|*** 
;|***    /* font metrics returned by GpiQueryFonts and others */
;|*** 
;|***    typedef struct _PANOSE { /* panose */
;|***       BYTE    bFamilyType;
;|***       BYTE    bSerifStyle;
;|***       BYTE    bWeight;
;|***       BYTE    bProportion;
;|***       BYTE    bContrast;
;|***       BYTE    bStrokeVariation;
;|***       BYTE    bArmStyle;
;|***       BYTE    bLetterform;
;|***       BYTE    bMidline;
;|***       BYTE    bXHeight;
;|***       BYTE    fbPassedISO;
;|***       BYTE    fbFailedISO;
;|***    } PANOSE;
;|*** 
;|***    typedef struct _FONTMETRICS {   /* fm */
;|***       CHAR    szFamilyname[FACESIZE];
;|***       CHAR    szFacename[FACESIZE];
;|***       USHORT  idRegistry;
;|***       USHORT  usCodePage;
;|***       LONG    lEmHeight;
;|***       LONG    lXHeight;
;|***       LONG    lMaxAscender;
;|***       LONG    lMaxDescender;
;|***       LONG    lLowerCaseAscent;
;|***       LONG    lLowerCaseDescent;
;|***       LONG    lInternalLeading;
;|***       LONG    lExternalLeading;
;|***       LONG    lAveCharWidth;
;|***       LONG    lMaxCharInc;
;|***       LONG    lEmInc;
;|***       LONG    lMaxBaselineExt;
;|***       SHORT   sCharSlope;
;|***       SHORT   sInlineDir;
;|***       SHORT   sCharRot;
;|***       USHORT  usWeightClass;
;|***       USHORT  usWidthClass;
;|***       SHORT   sXDeviceRes;
;|***       SHORT   sYDeviceRes;
;|***       SHORT   sFirstChar;
;|***       SHORT   sLastChar;
;|***       SHORT   sDefaultChar;
;|***       SHORT   sBreakChar;
;|***       SHORT   sNominalPointSize;
;|***       SHORT   sMinimumPointSize;
;|***       SHORT   sMaximumPointSize;
;|***       USHORT  fsType;
;|***       USHORT  fsDefn;
;|***       USHORT  fsSelection;
;|***       USHORT  fsCapabilities;
;|***       LONG    lSubscriptXSize;
;|***       LONG    lSubscriptYSize;
;|***       LONG    lSubscriptXOffset;
;|***       LONG    lSubscriptYOffset;
;|***       LONG    lSuperscriptXSize;
;|***       LONG    lSuperscriptYSize;
;|***       LONG    lSuperscriptXOffset;
;|***       LONG    lSuperscriptYOffset;
;|***       LONG    lUnderscoreSize;
;|***       LONG    lUnderscorePosition;
;|***       LONG    lStrikeoutSize;
;|***       LONG    lStrikeoutPosition;
;|***       SHORT   sKerningPairs;
;|***       SHORT   sFamilyClass;
;|***       LONG    lMatch;
;|***       LONG    FamilyNameAtom;
;|***       LONG    FaceNameAtom;
;|***       PANOSE  panose;
;|***    } FONTMETRICS;
;|***    typedef FONTMETRICS FAR *PFONTMETRICS;
;|*** 
;|***    /*** Common WIN types */
;|*** 
;|***    typedef LHANDLE HWND;      /* hwnd */
;|***    typedef HWND FAR *PHWND;
;|*** 
;|***    typedef LHANDLE HMQ;       /* hmq */
;|***    typedef LHANDLE FAR *PHMQ;
;|*** 
;|***    /* NOINC */
;|***    #define WRECT RECTL
;|***    #define PWRECT PRECTL
;|***    #define NPWRECT NPRECTL
;|*** 
;|***    #define WPOINT POINTL
;|***    #define PWPOINT PPOINTL
;|***    #define NPWPOINT NPPOINTL
;|***    /* INC */
;|*** 
;|***    typedef struct _ICONINFO {  /* icninf */
;|***       ULONG   cb;                  /* size of ICONINFO structure */
;|***       ULONG   fFormat;
;|***       PSZ     pszFileName;         /* use when fFormat = ICON_FILE */
;|***       HMODULE hmod;                /* use when fFormat = ICON_RESOURCE */
;|***       ULONG   resid;               /* use when fFormat = ICON_RESOURCE */
;|***       ULONG   cbIconData;          /* use when fFormat = ICON_DATA     */
;|***       PVOID   pIconData;           /* use when fFormat = ICON_DATA     */
;|***    } ICONINFO;
;|***    typedef ICONINFO FAR *PICONINFO;
;|*** 
;|***    #define ICON_FILE     1         /* flags for fFormat */
;|***    #define ICON_RESOURCE 2
;|***    #define ICON_DATA     3
;|***    #define ICON_CLEAR    4
;|*** 
;|*** #else /* not INCL_32 */
;|***    /* The previous #else/#endif corresponds to a #if near the top of this  */
;|***    /* file.  The next three lines include the 16-bit version of this file, */
;|***    /* hence these lines MUST be the last lines in this include file.       */
;|*** 
;|***    #ifdef INCL_16
;|***       #include <os2def16.h>
; Line 616
;|*** 
;|*** /* OS/2 Base Include File */
;|*** 
;|*** #ifndef INCL_NOBASEAPI
;|*** #include <bse.h>
; Line 47
;|*** /*DDK*************************************************************************/
;|*** /*                                                                           */
;|*** /* COPYRIGHT (C) Microsoft Corporation, 1989                                 */
;|*** /* COPYRIGHT    Copyright (C) 1995 IBM Corporation                           */
;|*** /*                                                                           */
;|*** /*    The following IBM OS/2 WARP source code is provided to you solely for  */
;|*** /*    the purpose of assisting you in your development of OS/2 WARP device   */
;|*** /*    drivers. You may use this code in accordance with the IBM License      */
;|*** /*    Agreement provided in the IBM Device Driver Source Kit for OS/2. This  */
;|*** /*    Copyright statement may not be removed.                                */
;|*** /*                                                                           */
;|*** /*****************************************************************************/
;|*** /*static char *SCCSID = "@(#)bse.h	6.2 91/02/12";*/
;|*** /*static char *SCCSID = "@(#)bse.h	6.2 91/02/12";*/
;|*** /****************************** Module Header ******************************\
;|*** *
;|*** * Module Name: BSE.H
;|*** *
;|*** * This file includes the definitions necessary for writing Base OS/2 applications.
;|*** *
;|*** *
;|*** *
;|*** *
;|*** * ===========================================================================
;|*** *
;|*** * The following symbols are used in this file for conditional sections.
;|*** *
;|*** *   INCL_BASE   -  ALL of OS/2 Base
;|*** *   INCL_DOS    -  OS/2 DOS Kernel
;|*** *   INCL_SUB    -  OS/2 VIO/KBD/MOU
;|*** *   INCL_DOSERRORS -  OS/2 Errors         - only included if symbol defined
;|*** *
;|*** \***************************************************************************/
;|*** 
;|*** #define INCL_BASEINCLUDED
;|*** 
;|*** /* if INCL_BASE defined then define all the symbols */
;|*** #ifdef INCL_BASE
;|***     #define INCL_DOS
;|***     #define INCL_SUB
;|***     #define INCL_DOSERRORS
;|*** #endif /* INCL_BASE */
;|*** 
;|*** #ifndef OS2_INCLUDED
;|*** #if !(defined(INCL_32) || defined(INCL_16))
;|*** #ifdef M_I386
;|***     #define INCL_32
;|*** #else /* not M_I386 */
;|***     #define INCL_16
;|*** #endif /* M_I386 */
;|*** #endif /* INCL_32 || INCL_16 */
;|*** #endif /* OS2_INCLUDED */
;|*** 
;|*** /* XLATOFF */
;|*** #ifdef INCL_32
;|*** #if defined(INCL_16)
;|*** #error message ("Illegal combination of API Flags - 32 && 16")
;|*** #endif /* || INCL_16 */
;|*** #endif /* INCL_32 */
;|*** /* XLATON */
;|*** 
;|*** #include <bsedos.h>       /* Base definitions */
; Line 62
;|*** /*DDK*************************************************************************/
;|*** /*                                                                           */
;|*** /* COPYRIGHT (C) Microsoft Corporation, 1989                                 */
;|*** /* COPYRIGHT    Copyright (C) 1995 IBM Corporation                           */
;|*** /*                                                                           */
;|*** /*    The following IBM OS/2 WARP source code is provided to you solely for  */
;|*** /*    the purpose of assisting you in your development of OS/2 WARP device   */
;|*** /*    drivers. You may use this code in accordance with the IBM License      */
;|*** /*    Agreement provided in the IBM Device Driver Source Kit for OS/2. This  */
;|*** /*    Copyright statement may not be removed.                                */
;|*** /*                                                                           */
;|*** /*****************************************************************************/
;|*** /*static char *SCCSID = "@(#)bsedos.h   6.29 92/03/10";*/
;|*** /***************************************************************************\
;|*** *
;|*** * Module Name: BSEDOS.H
;|*** *
;|*** * OS/2 Base Include File
;|*** *
;|*** *
;|*** *****************************************************************************
;|*** *
;|*** * Subcomponents marked with "+" are partially included by default
;|*** *
;|*** *   #define:                To include:
;|*** *
;|*** * + INCL_DOSPROCESS         Process and thread support
;|*** * + INCL_DOSFILEMGR         File Management
;|*** * + INCL_DOSMEMMGR          Memory Management
;|*** * + INCL_DOSSEMAPHORES      Semaphore support
;|*** * + INCL_DOSDATETIME        Date/Time and Timer support
;|*** *   INCL_DOSMODULEMGR       Module manager
;|*** * + INCL_DOSRESOURCES       Resource support
;|*** *   INCL_DOSNLS             National Language Support
;|*** *   INCL_DOSEXCEPTIONS      Exceptions
;|*** *   INCL_DOSMISC            Miscellaneous
;|*** *   INCL_DOSMONITORS        Monitors
;|*** *   INCL_DOSQUEUES          Queues
;|*** *   INCL_DOSSESMGR          Session Manager Support
;|*** *   INCL_DOSDEVICES         Device specific, ring 2 support
;|*** *   INCL_DOSNMPIPES         Named Pipes Support
;|*** *   INCL_DOSPROFILE         DosProfile API
;|*** *   INCL_DOSMVDM            MVDM support
;|*** *
;|*** \***************************************************************************/
;|*** 
;|*** #define INCL_DOSINCLUDED
;|*** 
;|*** #ifndef INCL_BASEINCLUDED
;|*** #if !(defined(INCL_32) || defined(INCL_16))
;|*** #ifdef M_I386
;|***     #define INCL_32
;|*** #else /* not M_I386 */
;|***     #define INCL_16
;|*** #endif /* M_I386 */
;|*** #endif /* INCL_32 || INCL_16 */
;|*** 
;|*** /* XLATOFF */
;|*** #if defined(INCL_16)
;|*** #pragma message ("32-bit Base API included when using 16-bit compiler")
;|*** #endif /* INCL_16 */
;|*** /* XLATON */
;|*** #endif /* INCL_BASEINCLUDED */
;|*** 
;|*** #ifdef INCL_32  /* This #ifdef brackets the rest of this entire */
;|***                         /* file.  It is used to include either the      */
;|***                         /* 32-bit or 16-bit base definitions.  No       */
;|***                         /* definitions (other than 16/32-bit            */
;|***                         /* determination) must be placed above this.    */
;|*** 
;|*** #ifdef INCL_DOS
;|*** 
;|*** #define INCL_DOSPROCESS
;|*** #define INCL_DOSFILEMGR
;|*** #define INCL_DOSMEMMGR
;|*** #define INCL_DOSSEMAPHORES
;|*** #define INCL_DOSDATETIME
;|*** #define INCL_DOSMODULEMGR
;|*** #define INCL_DOSRESOURCES
;|*** #define INCL_DOSNLS
;|*** #define INCL_DOSEXCEPTIONS
;|*** #define INCL_DOSMISC
;|*** #define INCL_DOSMONITORS
;|*** #define INCL_DOSQUEUES
;|*** #define INCL_DOSSESMGR
;|*** #define INCL_DOSDEVICES
;|*** #define INCL_DOSNMPIPES
;|*** #define INCL_DOSPROFILE
;|*** #define INCL_DOSMVDM
;|*** 
;|*** #endif /* INCL_DOS */
;|*** 
;|*** #ifdef INCL_ERRORS
;|*** #define INCL_DOSERRORS
;|*** #endif /* INCL_ERRORS */
;|*** 
;|*** #if (defined(INCL_DOSPROCESS) || !defined(INCL_NOCOMMON))
;|*** 
;|*** /*** General services */
;|*** 
;|*** APIRET  APIENTRY        DosBeep(ULONG freq, ULONG dur);
;|*** 
;|*** /*** Process and Thread support */
;|*** 
;|*** VOID    APIENTRY        DosExit(ULONG action, ULONG result);
;|*** 
;|*** /* DosExit codes */
;|*** 
;|*** #define EXIT_THREAD         0
;|*** #define EXIT_PROCESS        1
;|*** 
;|*** #endif /* common INCL_DOSPROCESS stuff */
;|*** 
;|*** #ifdef INCL_DOSPROCESS
;|*** 
;|*** /* XLATOFF */
;|*** #define DosCwait        DosWaitChild
;|*** #define DosSetPrty      DosSetPriority
;|*** /* XLATON */
;|*** 
;|*** #include <bsetib.h>
;|*** 
;|*** typedef VOID (*PFNTHREAD)(VOID);
;|*** 
;|*** APIRET  APIENTRY        DosCreateThread(PTID ptid, PFNTHREAD pfn, ULONG param, ULONG flag, ULONG cbStack);
;|*** 
;|*** APIRET  APIENTRY        DosResumeThread(TID tid);
;|*** 
;|*** APIRET  APIENTRY        DosSuspendThread(TID tid);
;|*** 
;|*** APIRET  APIENTRY        DosGetInfoBlocks(PTIB *pptib,PPIB *pppib);
;|*** 
;|*** APIRET  APIENTRY        DosKillThread(TID tid);
;|*** 
;|*** APIRET APIENTRY DosAllocThreadLocalMemory(ULONG cb, PULONG *p);
;|*** APIRET APIENTRY DosFreeThreadLocalMemory(ULONG *p);
;|*** 
;|*** /* Action code values */
;|*** 
;|*** #define DCWA_PROCESS        0
;|*** #define DCWA_PROCESSTREE    1
;|*** 
;|*** /* Wait option values */
;|*** 
;|*** #define DCWW_WAIT   0
;|*** #define DCWW_NOWAIT 1
;|*** 
;|*** /* Thread Flags for DosCreateThread options 59468 */
;|*** 
;|*** #define CREATE_READY        0
;|*** #define CREATE_SUSPENDED    1
;|*** #define STACK_SPARSE        0
;|*** #define STACK_COMMITTED     2
;|*** 
;|*** typedef struct _RESULTCODES {     /* resc */
;|***     ULONG codeTerminate;
;|***     ULONG codeResult;
;|*** } RESULTCODES;
;|*** typedef RESULTCODES     *PRESULTCODES;
;|*** 
;|*** APIRET  APIENTRY        DosWaitChild(ULONG action, ULONG option, PRESULTCODES pres, PPID ppid, PID pid);
;|*** 
;|*** APIRET  APIENTRY        DosWaitThread(PTID ptid, ULONG option);
;|*** 
;|*** APIRET  APIENTRY        DosSleep(ULONG msec);
;|*** 
;|*** APIRET  APIENTRY        DosDebug(PVOID pdbgbuf);
;|*** 
;|*** 
;|*** /* codeTerminate values (also passed to ExitList routines) */
;|*** 
;|*** #define TC_EXIT          0
;|*** #define TC_HARDERROR     1
;|*** #define TC_TRAP          2
;|*** #define TC_KILLPROCESS   3
;|*** #define TC_EXCEPTION     4
;|*** 
;|*** typedef VOID    (*PFNEXITLIST)(ULONG);
;|*** 
;|*** APIRET  APIENTRY        DosEnterCritSec(VOID);
;|*** 
;|*** APIRET  APIENTRY        DosExitCritSec(VOID);
;|*** 
;|*** APIRET  APIENTRY        DosExitList(ULONG ordercode, PFNEXITLIST pfn);
;|*** 
;|*** /* DosExitList functions */
;|*** 
;|*** #define EXLST_ADD       1
;|*** #define EXLST_REMOVE    2
;|*** #define EXLST_EXIT      3
;|*** 
;|*** APIRET  APIENTRY        DosExecPgm(PCHAR pObjname, LONG cbObjname, ULONG execFlag, PSZ pArg, PSZ pEnv, PRESULTCODES pRes, PSZ pName);
;|*** 
;|*** /* DosExecPgm functions */
;|*** 
;|*** #define EXEC_SYNC           0
;|*** #define EXEC_ASYNC          1
;|*** #define EXEC_ASYNCRESULT    2
;|*** #define EXEC_TRACE          3
;|*** #define EXEC_BACKGROUND     4
;|*** #define EXEC_LOAD           5
;|*** #define EXEC_ASYNCRESULTDB  6
;|*** 
;|*** 
;|*** APIRET  APIENTRY        DosSetPriority(ULONG scope, ULONG class, LONG delta, ULONG PorTid);
;|*** 
;|*** /* Priority scopes */
;|*** 
;|*** #define PRTYS_PROCESS       0
;|*** #define PRTYS_PROCESSTREE   1
;|*** #define PRTYS_THREAD        2
;|*** 
;|*** /* Priority classes */
;|*** 
;|*** #define PRTYC_NOCHANGE      0
;|*** #define PRTYC_IDLETIME      1
;|*** #define PRTYC_REGULAR       2
;|*** #define PRTYC_TIMECRITICAL  3
;|*** #define PRTYC_FOREGROUNDSERVER  4
;|*** 
;|*** /* Priority deltas */
;|*** 
;|*** #define PRTYD_MINIMUM      -31
;|*** #define PRTYD_MAXIMUM       31
;|*** 
;|*** APIRET  APIENTRY        DosKillProcess(ULONG action, PID pid);
;|*** 
;|*** #define DKP_PROCESSTREE     0
;|*** #define DKP_PROCESS         1
;|*** 
;|*** #endif /* INCL_DOSPROCESS */
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** 
;|*** /*
;|***  * CCHMAXPATH is the maximum fully qualified path name length including
;|***  * the drive letter, colon, backslashes and terminating NULL.
;|***  */
;|*** #define CCHMAXPATH      260
;|*** 
;|*** /*
;|***  * CCHMAXPATHCOMP is the maximum individual path component name length
;|***  * including a terminating NULL.
;|***  */
;|*** #define CCHMAXPATHCOMP  256
;|*** 
;|*** #endif  /* !INCL_SAADEFS */
;|*** 
;|*** #if (defined(INCL_DOSFILEMGR) || !defined(INCL_NOCOMMON))
;|*** 
;|*** /*** File manager */
;|*** 
;|*** /* DosSetFilePtr() file position codes */
;|*** 
;|*** #define FILE_BEGIN      0x0000  /* Move relative to beginning of file */
;|*** #define FILE_CURRENT    0x0001  /* Move relative to current fptr position */
;|*** #define FILE_END        0x0002  /* Move relative to end of file */
;|*** 
;|*** /* DosFindFirst/Next Directory handle types */
;|*** 
;|*** #define HDIR_SYSTEM     1       /* Use system handle (1) */
;|*** #define HDIR_CREATE     (-1)    /* Allocate a new, unused handle */
;|*** 
;|*** /* DosCopy control bits; may be or'ed together */
;|*** #define DCPY_EXISTING   0x00001         /* Copy even if target exists */
;|*** #define DCPY_APPEND     0x00002         /* Append to existing file, do not replace */
;|*** #define DCPY_FAILEAS    0x00004         /* Fail if EAs not supported on target*/
;|*** 
;|*** /* DosOpen/DosQFHandState/DosQueryFileInfo et al file attributes; also */
;|*** /* known as Dos File Mode bits... */
;|*** #define FILE_NORMAL     0x0000
;|*** #define FILE_READONLY   0x0001
;|*** #define FILE_HIDDEN     0x0002
;|*** #define FILE_SYSTEM     0x0004
;|*** #define FILE_DIRECTORY  0x0010
;|*** #define FILE_ARCHIVED   0x0020
;|*** 
;|*** 
;|*** #define MUST_HAVE_READONLY      ( (FILE_READONLY  << 8) | FILE_READONLY  )
;|*** #define MUST_HAVE_HIDDEN        ( (FILE_HIDDEN    << 8) | FILE_HIDDEN    )
;|*** #define MUST_HAVE_SYSTEM        ( (FILE_SYSTEM    << 8) | FILE_SYSTEM    )
;|*** #define MUST_HAVE_DIRECTORY     ( (FILE_DIRECTORY << 8) | FILE_DIRECTORY )
;|*** #define MUST_HAVE_ARCHIVED      ( (FILE_ARCHIVED  << 8) | FILE_ARCHIVED  )
;|*** 
;|*** /* DosOpen() actions */
;|*** 
;|*** #define FILE_EXISTED    0x0001
;|*** #define FILE_CREATED    0x0002
;|*** #define FILE_TRUNCATED  0x0003
;|*** 
;|*** /* DosOpen() open flags */
;|*** #define FILE_OPEN                  0x0001
;|*** #define FILE_TRUNCATE              0x0002
;|*** #define FILE_CREATE                0x0010
;|*** 
;|*** /*     this nibble applies if file already exists                xxxx */
;|*** 
;|*** #define OPEN_ACTION_FAIL_IF_EXISTS     0x0000  /* ---- ---- ---- 0000 */
;|*** #define OPEN_ACTION_OPEN_IF_EXISTS     0x0001  /* ---- ---- ---- 0001 */
;|*** #define OPEN_ACTION_REPLACE_IF_EXISTS  0x0002  /* ---- ---- ---- 0010 */
;|*** 
;|*** /*     this nibble applies if file does not exist           xxxx      */
;|*** 
;|*** #define OPEN_ACTION_FAIL_IF_NEW        0x0000  /* ---- ---- 0000 ---- */
;|*** #define OPEN_ACTION_CREATE_IF_NEW      0x0010  /* ---- ---- 0001 ---- */
;|*** 
;|*** /* DosOpen/DosSetFHandState flags */
;|*** 
;|*** #define OPEN_ACCESS_READONLY        0x0000  /* ---- ---- ---- -000 */
;|*** #define OPEN_ACCESS_WRITEONLY       0x0001  /* ---- ---- ---- -001 */
;|*** #define OPEN_ACCESS_READWRITE       0x0002  /* ---- ---- ---- -010 */
;|*** #define OPEN_SHARE_DENYREADWRITE    0x0010  /* ---- ---- -001 ---- */
;|*** #define OPEN_SHARE_DENYWRITE        0x0020  /* ---- ---- -010 ---- */
;|*** #define OPEN_SHARE_DENYREAD         0x0030  /* ---- ---- -011 ---- */
;|*** #define OPEN_SHARE_DENYNONE         0x0040  /* ---- ---- -100 ---- */
;|*** #define OPEN_FLAGS_NOINHERIT        0x0080  /* ---- ---- 1--- ---- */
;|*** #define OPEN_FLAGS_NO_LOCALITY      0x0000  /* ---- -000 ---- ---- */
;|*** #define OPEN_FLAGS_SEQUENTIAL       0x0100  /* ---- -001 ---- ---- */
;|*** #define OPEN_FLAGS_RANDOM           0x0200  /* ---- -010 ---- ---- */
;|*** #define OPEN_FLAGS_RANDOMSEQUENTIAL 0x0300  /* ---- -011 ---- ---- */
;|*** #define OPEN_FLAGS_NO_CACHE         0x1000  /* ---1 ---- ---- ---- */
;|*** #define OPEN_FLAGS_FAIL_ON_ERROR    0x2000  /* --1- ---- ---- ---- */
;|*** #define OPEN_FLAGS_WRITE_THROUGH    0x4000  /* -1-- ---- ---- ---- */
;|*** #define OPEN_FLAGS_DASD             0x8000  /* 1--- ---- ---- ---- */
;|*** #define OPEN_FLAGS_NONSPOOLED       0x00040000
;|*** #define OPEN_FLAGS_PROTECTED_HANDLE 0x40000000
;|*** 
;|*** 
;|*** /* DosSearchPath() constants */
;|*** 
;|*** #define SEARCH_PATH            0x0000
;|*** #define SEARCH_CUR_DIRECTORY   0x0001
;|*** #define SEARCH_ENVIRONMENT     0x0002
;|*** #define SEARCH_IGNORENETERRS   0x0004
;|*** 
;|*** 
;|*** /************************************************************
;|*** EA Info Levels & Find First/Next
;|*** =========================================
;|*** API's: DosFindFirst, DosQueryFileInfo, DosQueryPathInfo, DosSetFileInfo,
;|***        DosSetPathInfo
;|*** ************************************************************/
;|*** 
;|*** /* File info levels&gml All listed API's */
;|*** #define FIL_STANDARD            1       /* Info level 1, standard file info */
;|*** #define FIL_QUERYEASIZE         2       /* Level 2, return Full EA size */
;|*** #define FIL_QUERYEASFROMLIST    3       /* Level 3, return requested EA's */
;|*** 
;|*** /* File info levels: Dos...PathInfo only */
;|*** #define FIL_QUERYFULLNAME       5       /* Level 5, return fully qualified
;|***                                            name of file */
;|*** /* DosFsAttach() */
;|*** /* Attact or detach */
;|*** #define FS_ATTACH       0       /* Attach file server */
;|*** #define FS_DETACH       1       /* Detach file server */
;|*** #define FS_SPOOLATTACH  2       /* Register a spooler device */
;|*** #define FS_SPOOLDETACH  3       /* De-register a spooler device */
;|*** 
;|*** 
;|*** /* DosFsCtl() */
;|*** /* Routing type */
;|*** #define FSCTL_HANDLE    1       /* File Handle directs req routing */
;|*** #define FSCTL_PATHNAME  2       /* Path Name directs req routing */
;|*** #define FSCTL_FSDNAME   3       /* FSD Name directs req routing */
;|*** 
;|*** /* defined FSCTL functions */
;|*** #define FSCTL_ERROR_INFO        1       /* return error info from FSD */
;|*** #define FSCTL_MAX_EASIZE        2       /* Max ea size for the FSD */
;|*** 
;|*** typedef struct  _EASIZEBUF {    /* struct for FSCTL fn 2 - max ea size */
;|***         USHORT  cbMaxEASize;    /* max. size of one EA */
;|***         ULONG   cbMaxEAListSize;        /* max size of the full EA List */
;|*** } EASIZEBUF;
;|*** typedef EASIZEBUF FAR * PEASIZEBUF;
;|*** 
;|*** 
;|*** /* DosQueryFSAttach() */
;|*** /* Information level types (defines method of query) */
;|*** #define FSAIL_QUERYNAME 1       /* Return data for a Drive or Device */
;|*** #define FSAIL_DEVNUMBER 2       /* Return data for Ordinal Device # */
;|*** #define FSAIL_DRVNUMBER 3       /* Return data for Ordinal Drive # */
;|*** 
;|*** /* Item types (from data structure item "iType") */
;|*** #define FSAT_CHARDEV    1       /* Resident character device */
;|*** #define FSAT_PSEUDODEV  2       /* Pseudo-character device */
;|*** #define FSAT_LOCALDRV   3       /* Local drive */
;|*** #define FSAT_REMOTEDRV  4       /* Remote drive attached to FSD */
;|*** 
;|*** 
;|*** typedef struct  _FSQBUFFER {    /* fsqbuf Data structure for QFSAttach*/
;|***     USHORT      iType;          /* Item type */
;|***     USHORT      cbName;         /* Length of item name, sans NULL */
;|***     UCHAR       szName[1];      /* ASCIIZ item name */
;|***     USHORT      cbFSDName;      /* Length of FSD name, sans NULL */
;|***     UCHAR       szFSDName[1];   /* ASCIIZ FSD name */
;|***     USHORT      cbFSAData;      /* Length of FSD Attach data returned */
;|***     UCHAR       rgFSAData[1];   /* FSD Attach data from FSD */
;|*** } FSQBUFFER;
;|*** typedef FSQBUFFER FAR *PFSQBUFFER;
;|*** 
;|*** 
;|*** typedef struct _FSQBUFFER2 {    /* fsqbuf Data structure for QFSAttach*/
;|***     USHORT  iType;
;|***     USHORT  cbName;
;|***     USHORT  cbFSDName;
;|***     USHORT  cbFSAData;
;|***     UCHAR   szName[1];
;|***     UCHAR   szFSDName[1];
;|***     UCHAR   rgFSAData[1];
;|*** } FSQBUFFER2;
;|*** 
;|*** typedef FSQBUFFER2 FAR * PFSQBUFFER2;
;|*** 
;|*** typedef struct _SPOOLATTACH {   /* Data structure for spooler operations */
;|***     USHORT      hNmPipe;        /* Named pipe handle                     */
;|***     ULONG       ulKey;          /* Attached key                          */
;|*** } SPOOLATTACH;
;|*** typedef SPOOLATTACH FAR *PSPOOLATTACH;
;|*** 
;|*** /***********
;|*** File System Drive Information&gml DosQueryFSInfo DosSetFSInfo
;|*** ***********/
;|*** 
;|*** /* FS Drive Info Levels */
;|*** #define FSIL_ALLOC      1       /* Drive allocation info (Query only) */
;|*** #define FSIL_VOLSER     2       /* Drive Volum/Serial info */
;|*** 
;|*** /* DosQueryFHType() */
;|*** /* Handle classes (low 8 bits of Handle Type) */
;|*** #define FHT_DISKFILE    0x0000          /* Disk file handle */
;|*** #define FHT_CHRDEV      0x0001          /* Character device handle */
;|*** #define FHT_PIPE        0x0002          /* Pipe handle */
;|*** 
;|*** /* Handle bits (high 8 bits of Handle Type) */
;|*** #define FHB_DSKREMOTE           0x8000  /* Remote disk */
;|*** #define FHB_CHRDEVREMOTE        0x8000  /* Remote character device */
;|*** #define FHB_PIPEREMOTE          0x8000  /* Remote pipe */
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** 
;|*** /* File time and date types */
;|*** 
;|*** typedef struct _FTIME {         /* ftime */
;|***     USHORT twosecs : 5;
;|***     USHORT minutes : 6;
;|***     USHORT hours   : 5;
;|*** } FTIME;
;|*** typedef FTIME   *PFTIME;
;|*** 
;|*** typedef struct _FDATE {         /* fdate */
;|***     USHORT day     : 5;
;|***     USHORT month   : 4;
;|***     USHORT year    : 7;
;|*** } FDATE;
;|*** typedef FDATE   *PFDATE;
;|*** 
;|*** #endif /* INCL_SAADEFS */
;|*** 
;|*** typedef struct _VOLUMELABEL {    /* vol */
;|***     BYTE cch;
;|***     CHAR szVolLabel[12];
;|*** } VOLUMELABEL;
;|*** typedef VOLUMELABEL FAR *PVOLUMELABEL;
;|*** 
;|*** typedef struct _FSINFO {    /* fsinf */
;|***     ULONG ulVSN;
;|***     VOLUMELABEL vol;
;|*** } FSINFO;
;|*** typedef FSINFO FAR *PFSINFO;
;|*** 
;|*** /* HANDTYPE values */
;|*** 
;|*** #define HANDTYPE_FILE     0x0000
;|*** #define HANDTYPE_DEVICE   0x0001
;|*** #define HANDTYPE_PIPE     0x0002
;|*** #define HANDTYPE_PROTECTED 0x4000
;|*** #define HANDTYPE_NETWORK  0x8000
;|*** 
;|*** typedef struct _FILELOCK {    /* flock */
;|***     LONG lOffset;
;|***     LONG lRange;
;|*** } FILELOCK;
;|*** typedef FILELOCK FAR *PFILELOCK;
;|*** 
;|*** typedef SHANDLE HFILE;     /* hf */
;|*** typedef HFILE   *PHFILE;
;|*** 
;|*** typedef  ULONG    HEV;             /* hev */
;|*** typedef  HEV      *PHEV;
;|*** typedef  ULONG  FHLOCK;
;|*** typedef  PULONG  PFHLOCK;
;|*** 
;|*** APIRET  APIENTRY        DosSetFileLocks(HFILE hFile, PFILELOCK pflUnlock, PFILELOCK pflLock, ULONG timeout, ULONG flags);
;|*** APIRET  APIENTRY        DosProtectSetFileLocks(HFILE hFile,
;|***                                                PFILELOCK pflUnlock,
;|***                                                PFILELOCK pflLock,
;|***                                                ULONG timeout, ULONG flags,
;|***                                                FHLOCK fhFileHandleLockID);
;|*** 
;|*** APIRET  APIENTRY        DosCancelLockRequest(HFILE hFile, PFILELOCK pflLock);
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** 
;|*** typedef struct _FILEFINDBUF {   /* findbuf */
;|***     FDATE  fdateCreation;
;|***     FTIME  ftimeCreation;
;|***     FDATE  fdateLastAccess;
;|***     FTIME  ftimeLastAccess;
;|***     FDATE  fdateLastWrite;
;|***     FTIME  ftimeLastWrite;
;|***     ULONG  cbFile;
;|***     ULONG  cbFileAlloc;
;|***     USHORT attrFile;
;|***     UCHAR  cchName;
;|***     CHAR   achName[CCHMAXPATHCOMP];
;|*** } FILEFINDBUF;
;|*** typedef FILEFINDBUF     *PFILEFINDBUF;
;|*** 
;|*** /* XLATOFF */
;|*** #pragma pack(2)
;|*** /* XLATON */
;|*** 
;|*** typedef struct _FILEFINDBUF2 {  /* findbuf2 */
;|***     FDATE  fdateCreation;
;|***     FTIME  ftimeCreation;
;|***     FDATE  fdateLastAccess;
;|***     FTIME  ftimeLastAccess;
;|***     FDATE  fdateLastWrite;
;|***     FTIME  ftimeLastWrite;
;|***     ULONG  cbFile;
;|***     ULONG  cbFileAlloc;
;|***     USHORT attrFile;
;|***     ULONG  cbList;
;|***     UCHAR  cchName;
;|***     CHAR   achName[CCHMAXPATHCOMP];
;|*** } FILEFINDBUF2;
;|*** typedef FILEFINDBUF2    *PFILEFINDBUF2;
;|*** 
;|*** /* XLATOFF */
;|*** #pragma pack()
;|*** /* XLATON */
;|*** 
;|*** typedef struct _FILEFINDBUF3 {   /* findbuf3 */
;|***     ULONG   oNextEntryOffset;                   /* new field */
;|***     FDATE   fdateCreation;
;|***     FTIME   ftimeCreation;
;|***     FDATE   fdateLastAccess;
;|***     FTIME   ftimeLastAccess;
;|***     FDATE   fdateLastWrite;
;|***     FTIME   ftimeLastWrite;
;|***     ULONG   cbFile;
;|***     ULONG   cbFileAlloc;
;|***     ULONG   attrFile;                           /* widened field */
;|***     UCHAR   cchName;
;|***     CHAR    achName[CCHMAXPATHCOMP];
;|*** } FILEFINDBUF3;
;|*** typedef FILEFINDBUF3    *PFILEFINDBUF3;
;|*** 
;|*** typedef struct _FILEFINDBUF4 {   /* findbuf4 */
;|***     ULONG   oNextEntryOffset;                   /* new field */
;|***     FDATE   fdateCreation;
;|***     FTIME   ftimeCreation;
;|***     FDATE   fdateLastAccess;
;|***     FTIME   ftimeLastAccess;
;|***     FDATE   fdateLastWrite;
;|***     FTIME   ftimeLastWrite;
;|***     ULONG   cbFile;
;|***     ULONG   cbFileAlloc;
;|***     ULONG   attrFile;                           /* widened field */
;|***     ULONG   cbList;
;|***     UCHAR   cchName;
;|***     CHAR    achName[CCHMAXPATHCOMP];
;|*** } FILEFINDBUF4;
;|*** typedef FILEFINDBUF4    *PFILEFINDBUF4;
;|*** 
;|*** /* extended attribute structures */
;|*** 
;|*** typedef struct _GEA {       /* gea */
;|***     BYTE cbName;            /* name length not including NULL */
;|***     CHAR szName[1];         /* attribute name */
;|*** } GEA;
;|*** typedef GEA     *PGEA;
;|*** 
;|*** typedef struct _GEALIST {   /* geal */
;|***     ULONG cbList;           /* total bytes of structure including full list */
;|***     GEA list[1];            /* variable length GEA structures */
;|*** } GEALIST;
;|*** typedef GEALIST* PGEALIST;
;|*** 
;|*** typedef struct _FEA {       /* fea */
;|***     BYTE fEA;               /* flags                              */
;|***     BYTE cbName;            /* name length not including NULL */
;|***     USHORT cbValue;         /* value length */
;|*** } FEA;
;|*** typedef FEA     *PFEA;
;|*** 
;|*** /* flags for _FEA.fEA */
;|*** 
;|*** #define FEA_NEEDEA 0x80     /* need EA bit */
;|*** 
;|*** typedef struct _FEALIST {   /* feal */
;|***     ULONG cbList;           /* total bytes of structure including full list */
;|***     FEA list[1];            /* variable length FEA structures */
;|*** } FEALIST;
;|*** typedef FEALIST* PFEALIST;
;|*** 
;|*** typedef struct _EAOP {      /* eaop */
;|***     PGEALIST fpGEAList;     /* general EA list */
;|***     PFEALIST fpFEAList;     /* full EA list */
;|***     ULONG oError;
;|*** } EAOP;
;|*** typedef EAOP* PEAOP;
;|*** 
;|*** 
;|*** /* XLATOFF */
;|*** #pragma pack(1)
;|*** /* XLATON */
;|*** 
;|*** typedef struct _FEA2 {      /* fea2 */
;|***     ULONG   oNextEntryOffset;                   /* new field */
;|***     BYTE    fEA;
;|***     BYTE    cbName;
;|***     USHORT  cbValue;
;|***     CHAR    szName[1];                          /* new field */
;|*** } FEA2;
;|*** 
;|*** typedef FEA2 *PFEA2;
;|*** 
;|*** /* flags for _FEA.fEA */
;|*** 
;|*** #define FEA_NEEDEA 0x80     /* need EA bit */
;|*** 
;|*** typedef struct _FEA2LIST {    /* fea2l */
;|***     ULONG   cbList;
;|***     FEA2    list[1];
;|*** } FEA2LIST;
;|*** 
;|*** typedef FEA2LIST *PFEA2LIST;
;|*** 
;|*** typedef struct _GEA2 {        /* gea2 */
;|***     ULONG   oNextEntryOffset;                   /* new field */
;|***     BYTE    cbName;
;|***     CHAR    szName[1];                          /* new field */
;|*** } GEA2;
;|*** 
;|*** typedef GEA2 *PGEA2;
;|*** 
;|*** typedef struct _GEA2LIST {    /* gea2l */
;|***     ULONG   cbList;
;|***     GEA2    list[1];
;|*** } GEA2LIST;
;|*** 
;|*** typedef GEA2LIST *PGEA2LIST;
;|*** 
;|*** typedef struct _EAOP2 {      /* eaop2 */
;|***     PGEA2LIST   fpGEA2List;                     /* GEA set */
;|***     PFEA2LIST   fpFEA2List;                     /* FEA set */
;|***     ULONG       oError;                         /* offset of FEA error */
;|*** } EAOP2;
;|*** 
;|*** typedef EAOP2 *PEAOP2;
;|*** 
;|*** /* XLATOFF */
;|*** #pragma pack()
;|*** /* XLATON */
;|*** 
;|*** /*
;|***  * Equates for the types of EAs that follow the convention that we have
;|***  * established.
;|***  *
;|***  * Values 0xFFFE thru 0x8000 are reserved.
;|***  * Values 0x0000 thru 0x7fff are user definable.
;|***  * Value  0xFFFC is not used
;|***  */
;|*** 
;|*** #define EAT_BINARY      0xFFFE          /* length preceeded binary */
;|*** #define EAT_ASCII       0xFFFD          /* length preceeded ASCII */
;|*** #define EAT_BITMAP      0xFFFB          /* length preceeded bitmap */
;|*** #define EAT_METAFILE    0xFFFA          /* length preceeded metafile */
;|*** #define EAT_ICON        0xFFF9          /* length preceeded icon */
;|*** #define EAT_EA          0xFFEE          /* length preceeded ASCII */
;|***                                         /* name of associated data (#include) */
;|*** #define EAT_MVMT        0xFFDF          /* multi-valued, multi-typed field */
;|*** #define EAT_MVST        0xFFDE          /* multi-valued, single-typed field */
;|*** #define EAT_ASN1        0xFFDD          /* ASN.1 field */
;|*** 
;|*** /* XLATOFF */
;|*** #pragma pack(1)
;|*** /* XLATON */
;|*** 
;|*** typedef struct _CNPATH {      /* CHANGENOTIFYPATH */
;|***     ULONG   oNextEntryOffset;
;|***     ULONG   wFlags;
;|***     USHORT  cbName;
;|***     CHAR    szName[1];
;|*** } CNPATH;
;|*** 
;|*** typedef CNPATH *PCNPATH;
;|*** 
;|*** typedef struct _CNINFO {      /* CHANGENOTIFYINFO */
;|***     ULONG   oNextEntryOffset;
;|***     CHAR    bAction;
;|***     USHORT  cbName;
;|***     CHAR    szName[1];
;|*** } CNINFO;
;|*** 
;|*** typedef CNINFO *PCNINFO;
;|*** 
;|*** /* XLATOFF */
;|*** #pragma pack()
;|*** /* XLATON */
;|*** 
;|*** /*
;|***  *  Equates for ChangeNotifyInfo baction field
;|***  *
;|***  */
;|*** 
;|*** #define             RCNF_FILE_ADDED        0x0001
;|*** #define             RCNF_FILE_DELETED      0x0002
;|*** #define             RCNF_DIR_ADDED         0x0003
;|*** #define             RCNF_DIR_DELETED       0x0004
;|*** #define             RCNF_MOVED_IN          0x0005
;|*** #define             RCNF_MOVED_OUT         0x0006
;|*** #define             RCNF_CHANGED           0x0007
;|*** #define             RCNF_OLDNAME           0x0008
;|*** #define             RCNF_NEWNAME           0x0009
;|*** #define             RCNF_DEVICE_ATTACHED   0x000A
;|*** #define             RCNF_DEVICE_DETACHED   0x000B
;|*** 
;|*** #endif  /* !INCL_SAADEFS */
;|*** 
;|*** APIRET  APIENTRY        DosOpen(PSZ pszFileName, PHFILE phf, PULONG pulAction, ULONG cbFile, ULONG ulAttribute, ULONG fsOpenFlags, ULONG fsOpenMode, PEAOP2 peaop2 );
;|*** APIRET  APIENTRY        DosProtectOpen(PSZ pszFileName, PHFILE phf,
;|***                                        PULONG pulAction, ULONG cbFile,
;|***                                        ULONG ulAttribute, ULONG fsOpenFlags,
;|***                                        ULONG fsOpenMode, PEAOP2 peaop2,
;|***                                        PFHLOCK pfhFileHandleLockID);
;|*** 
;|*** APIRET  APIENTRY        DosClose(HFILE hFile);
;|*** APIRET  APIENTRY        DosProtectClose(HFILE hFile, FHLOCK fhFileHandleLockID);
;|*** 
;|*** APIRET  APIENTRY        DosRead(HFILE hFile, PVOID pBuffer, ULONG cbRead, PULONG pcbActual);
;|*** APIRET  APIENTRY        DosProtectRead(HFILE hFile, PVOID pBuffer,
;|***                                        ULONG cbRead, PULONG pcbActual,
;|***                                        FHLOCK fhFileHandleLockID);
;|*** 
;|*** APIRET  APIENTRY        DosWrite(HFILE hFile, PVOID pBuffer, ULONG cbWrite, PULONG pcbActual);
;|*** APIRET  APIENTRY        DosProtectWrite(HFILE hFile, PVOID pBuffer,
;|***                                         ULONG cbWrite, PULONG pcbActual,
;|***                                         FHLOCK fhFileHandleLockID);
;|*** 
;|*** /* File time and date types */
;|*** 
;|*** typedef struct _FILESTATUS {    /* fsts */
;|***     FDATE  fdateCreation;
;|***     FTIME  ftimeCreation;
;|***     FDATE  fdateLastAccess;
;|***     FTIME  ftimeLastAccess;
;|***     FDATE  fdateLastWrite;
;|***     FTIME  ftimeLastWrite;
;|***     ULONG  cbFile;
;|***     ULONG  cbFileAlloc;
;|***     USHORT attrFile;
;|*** } FILESTATUS;
;|*** typedef FILESTATUS      *PFILESTATUS;
;|*** 
;|*** typedef struct _FILESTATUS2 {   /* fsts2 */
;|***     FDATE  fdateCreation;
;|***     FTIME  ftimeCreation;
;|***     FDATE  fdateLastAccess;
;|***     FTIME  ftimeLastAccess;
;|***     FDATE  fdateLastWrite;
;|***     FTIME  ftimeLastWrite;
;|***     ULONG  cbFile;
;|***     ULONG  cbFileAlloc;
;|***     USHORT attrFile;
;|***     ULONG  cbList;
;|*** } FILESTATUS2;
;|*** typedef FILESTATUS2     *PFILESTATUS2;
;|*** 
;|*** 
;|*** typedef struct _FILESTATUS3 {   /* fsts3 */
;|***     FDATE  fdateCreation;
;|***     FTIME  ftimeCreation;
;|***     FDATE  fdateLastAccess;
;|***     FTIME  ftimeLastAccess;
;|***     FDATE  fdateLastWrite;
;|***     FTIME  ftimeLastWrite;
;|***     ULONG  cbFile;
;|***     ULONG  cbFileAlloc;
;|***     ULONG  attrFile;
;|*** } FILESTATUS3;
;|*** typedef FILESTATUS3     *PFILESTATUS3;
;|*** 
;|*** typedef struct _FILESTATUS4 {    /* fsts4 */
;|***     FDATE  fdateCreation;
;|***     FTIME  ftimeCreation;
;|***     FDATE  fdateLastAccess;
;|***     FTIME  ftimeLastAccess;
;|***     FDATE  fdateLastWrite;
;|***     FTIME  ftimeLastWrite;
;|***     ULONG  cbFile;
;|***     ULONG  cbFileAlloc;
;|***     ULONG  attrFile;
;|***     ULONG  cbList;
;|*** } FILESTATUS4;
;|*** typedef FILESTATUS4     *PFILESTATUS4;
;|*** 
;|*** 
;|*** typedef struct _FSALLOCATE {    /* fsalloc */
;|***     ULONG  idFileSystem;
;|***     ULONG  cSectorUnit;
;|***     ULONG  cUnit;
;|***     ULONG  cUnitAvail;
;|***     USHORT cbSector;
;|*** } FSALLOCATE;
;|*** typedef FSALLOCATE      *PFSALLOCATE;
;|*** 
;|*** typedef SHANDLE HDIR;        /* hdir */
;|*** typedef HDIR    *PHDIR;
;|*** 
;|*** /* XLATOFF */
;|*** #define DosOpen2        DosOpen
;|*** #define DosFindFirst2   DosFindFirst
;|*** #define DosQFHandState  DosQueryFHState
;|*** #define DosProtectQFHandState  DosProtectQueryFHState
;|*** #define DosSetFHandState        DosSetFHState
;|*** #define DosProtectSetFHandState        DosProtectSetFHState
;|*** #define DosQHandType    DosQueryHType
;|*** #define DosQFSAttach    DosQueryFSAttach
;|*** #define DosNewSize      DosSetFileSize
;|*** #define DosProtectNewSize      DosProtectSetFileSize
;|*** #define DosBufReset     DosResetBuffer
;|*** #define DosChgFilePtr   DosSetFilePtr
;|*** #define DosProtectChgFilePtr   DosProtectSetFilePtr
;|*** #define DosMkDir        DosCreateDir
;|*** #define DosMkDir2       DosCreateDir
;|*** #define DosRmDir        DosDeleteDir
;|*** #define DosSelectDisk   DosSetDefaultDisk
;|*** #define DosQCurDisk     DosQueryCurrentDisk
;|*** #define DosChDir        DosSetCurrentDir
;|*** #define DosQCurDir      DosQueryCurrentDir
;|*** #define DosQFSInfo      DosQueryFSInfo
;|*** #define DosQVerify      DosQueryVerify
;|*** #define DosQFileInfo    DosQueryFileInfo
;|*** #define DosProtectQFileInfo    DosProtectQueryFileInfo
;|*** #define DosQPathInfo    DosQueryPathInfo
;|*** /* XLATON */
;|*** 
;|*** APIRET  APIENTRY DosOpenChangeNotify(PCNPATH PathBuf, ULONG LogSize, PHDIR hdir,
;|***                                      ULONG ulReserved);
;|*** APIRET  APIENTRY DosResetChangeNotify(PCNINFO LogBuf, ULONG BufferSize,
;|***                                       PULONG LogCount, HDIR hdir);
;|*** APIRET  APIENTRY DosCloseChangeNotify(HDIR hdir);
;|*** 
;|*** APIRET  APIENTRY        DosDelete(PSZ pszFile);
;|*** 
;|*** APIRET  APIENTRY        DosForceDelete(PSZ pszFile);
;|*** 
;|*** APIRET  APIENTRY        DosDupHandle(HFILE hFile, PHFILE pHfile);
;|*** 
;|*** APIRET  APIENTRY        DosQueryFHState(HFILE hFile, PULONG pMode);
;|*** APIRET  APIENTRY        DosProtectQueryFHState(HFILE hFile, PULONG pMode,
;|***                                                FHLOCK fhFileHandleLockID);
;|*** 
;|*** APIRET  APIENTRY        DosSetFHState(HFILE hFile, ULONG mode);
;|*** APIRET  APIENTRY        DosProtectSetFHState(HFILE hFile, ULONG mode,
;|***                                              FHLOCK fhFileHandleLockID);
;|*** 
;|*** APIRET  APIENTRY        DosQueryHType(HFILE hFile, PULONG pType, PULONG pAttr);
;|*** 
;|*** APIRET  APIENTRY        DosFindFirst(PSZ pszFileSpec, PHDIR phdir, ULONG flAttribute, PVOID pfindbuf, ULONG cbBuf, PULONG pcFileNames, ULONG ulInfoLevel );
;|*** 
;|*** APIRET  APIENTRY        DosFindNext(HDIR hdir, PVOID pfindbuf, ULONG cbfindbuf, PULONG pcFilenames );
;|*** 
;|*** APIRET  APIENTRY        DosFindClose(HDIR hDir);
;|*** 
;|*** APIRET  APIENTRY        DosFSAttach(PSZ pszDevice, PSZ pszFilesystem, PVOID pData, ULONG cbData, ULONG flag);
;|*** 
;|*** APIRET  APIENTRY        DosQueryFSAttach(PSZ pszDeviceName, ULONG ulOrdinal, ULONG ulFSAInfoLevel, PFSQBUFFER2 pfsqb, PULONG pcbBuffLength );
;|*** 
;|*** APIRET  APIENTRY        DosFSCtl(PVOID pData, ULONG cbData, PULONG pcbData, PVOID pParms, ULONG cbParms, PULONG pcbParms, ULONG function, PSZ pszRoute, HFILE hFile, ULONG method);
;|*** 
;|*** APIRET  APIENTRY        DosSetFileSize(HFILE hFile, ULONG cbSize);
;|*** APIRET  APIENTRY        DosProtectSetFileSize(HFILE hFile, ULONG cbSize,
;|***                                               FHLOCK fhFileHandleLockID);
;|*** 
;|*** APIRET  APIENTRY        DosResetBuffer(HFILE hFile);
;|*** 
;|*** APIRET  APIENTRY        DosSetFilePtr(HFILE hFile, LONG ib, ULONG method, PULONG ibActual);
;|*** APIRET  APIENTRY        DosProtectSetFilePtr(HFILE hFile, LONG ib,
;|***                                              ULONG method, PULONG ibActual,
;|***                                              FHLOCK fhFileHandleLockID);
;|*** 
;|*** APIRET  APIENTRY        DosMove(PSZ pszOld, PSZ pszNew);
;|*** 
;|*** APIRET  APIENTRY        DosCopy(PSZ pszOld, PSZ pszNew, ULONG option);
;|*** 
;|*** APIRET  APIENTRY        DosEditName(ULONG metalevel, PSZ pszSource, PSZ pszEdit, PBYTE pszTarget, ULONG cbTarget);
;|*** 
;|*** APIRET  APIENTRY        DosCreateDir(PSZ pszDirName, PEAOP2 peaop2 );
;|*** 
;|*** APIRET  APIENTRY        DosDeleteDir(PSZ pszDir);
;|*** 
;|*** APIRET  APIENTRY        DosSetDefaultDisk(ULONG disknum);
;|*** 
;|*** APIRET  APIENTRY        DosQueryCurrentDisk(PULONG pdisknum, PULONG plogical);
;|*** 
;|*** APIRET  APIENTRY        DosSetCurrentDir(PSZ pszDir);
;|*** 
;|*** APIRET  APIENTRY        DosQueryCurrentDir(ULONG disknum, PBYTE pBuf, PULONG pcbBuf);
;|*** 
;|*** APIRET  APIENTRY        DosQueryFSInfo(ULONG disknum, ULONG infolevel, PVOID pBuf, ULONG cbBuf);
;|*** 
;|*** APIRET  APIENTRY        DosSetFSInfo(ULONG disknum, ULONG infolevel, PVOID pBuf, ULONG cbBuf);
;|*** 
;|*** APIRET  APIENTRY        DosQueryVerify(PBOOL32 pBool);
;|*** 
;|*** APIRET  APIENTRY        DosSetVerify(BOOL32);
;|*** 
;|*** APIRET  APIENTRY        DosSetMaxFH(ULONG cFH);
;|*** 
;|*** APIRET  APIENTRY        DosSetRelMaxFH(PLONG pcbReqCount, PULONG pcbCurMaxFH);
;|*** 
;|*** APIRET  APIENTRY        DosQueryFileInfo(HFILE hf, ULONG ulInfoLevel, PVOID pInfo,  ULONG cbInfoBuf );
;|*** APIRET  APIENTRY        DosProtectQueryFileInfo(HFILE hf, ULONG ulInfoLevel,
;|***                                                 PVOID pInfo, ULONG cbInfoBuf,
;|***                                                 FHLOCK fhFileHandleLockID);
;|*** 
;|*** APIRET  APIENTRY        DosSetFileInfo(HFILE hf, ULONG ulInfoLevel, PVOID pInfoBuf, ULONG cbInfoBuf );
;|*** APIRET  APIENTRY        DosProtectSetFileInfo(HFILE hf, ULONG ulInfoLevel,
;|***                                               PVOID pInfoBuf, ULONG cbInfoBuf,
;|***                                               FHLOCK fhFileHandleLockID);
;|*** 
;|*** APIRET  APIENTRY        DosQueryPathInfo(PSZ pszPathName, ULONG ulInfoLevel, PVOID pInfoBuf, ULONG cbInfoBuf );
;|*** 
;|*** APIRET  APIENTRY        DosSetPathInfo(PSZ pszPathName, ULONG ulInfoLevel, PVOID pInfoBuf, ULONG cbInfoBuf, ULONG flOptions );
;|*** 
;|*** /* defines for DosSetPathInfo -pathinfo flag */
;|*** #define DSPI_WRTTHRU    0x10    /* write through */
;|*** 
;|*** APIRET  APIENTRY        DosShutdown(ULONG ulReserved);
;|*** 
;|*** APIRET  APIENTRY        DosEnumAttribute(ULONG ulRefType, PVOID pvFile, ULONG ulEntry, PVOID pvBuf, ULONG cbBuf, PULONG pulCount, ULONG ulInfoLevel );
;|*** 
;|*** APIRET  APIENTRY        DosProtectEnumAttribute(ULONG ulRefType, PVOID pvFile, ULONG ulEntry, PVOID pvBuf, ULONG cbBuf, PULONG pulCount, ULONG ulInfoLevel, FHLOCK fhFileHandleLockID );
;|*** 
;|*** /* XLATOFF */
;|*** #pragma pack(1)
;|*** /* XLATON */
;|*** 
;|*** typedef struct _DENA1 { /* _dena1 level 1 info returned from DosEnumAttribute */
;|***     UCHAR       reserved;       /* 0 */
;|***     UCHAR       cbName;         /* length of name exculding NULL */
;|***     USHORT      cbValue;        /* length of value */
;|***     UCHAR       szName[1];      /* variable length asciiz name */
;|*** } DENA1;
;|*** typedef DENA1 FAR *PDENA1;
;|*** 
;|*** /* XLATOFF */
;|*** #pragma pack()
;|*** /* XLATON */
;|*** 
;|*** typedef FEA2 DENA2;
;|*** typedef PFEA2 PDENA2;
;|*** 
;|*** /* Infolevels for DosEnumAttribute  */
;|*** #define ENUMEA_LEVEL_NO_VALUE   1L      /* FEA without value */
;|*** /* Reference types for DosEnumAttribute */
;|*** #define ENUMEA_REFTYPE_FHANDLE  0       /* file handle */
;|*** #define ENUMEA_REFTYPE_PATH     1       /* path name */
;|*** #define ENUMEA_REFTYPE_MAX      ENUMEA_REFTYPE_PATH
;|*** 
;|*** #endif /* common INCL_DOSFILEMGR */
;|*** 
;|*** #if (defined(INCL_DOSMEMMGR) || !defined(INCL_NOCOMMON))
;|*** /*** Memory management */
;|*** 
;|*** APIRET  APIENTRY        DosAllocMem(PPVOID ppb, ULONG cb, ULONG flag);
;|*** 
;|*** APIRET  APIENTRY        DosFreeMem(PVOID pb);
;|*** 
;|*** APIRET  APIENTRY        DosSetMem(PVOID pb, ULONG cb, ULONG flag);
;|*** 
;|*** APIRET  APIENTRY        DosGiveSharedMem(PVOID pb, PID pid, ULONG flag);
;|*** 
;|*** APIRET  APIENTRY        DosGetSharedMem(PVOID pb, ULONG flag);
;|*** 
;|*** APIRET  APIENTRY        DosGetNamedSharedMem(PPVOID ppb, PSZ pszName, ULONG flag);
;|*** 
;|*** APIRET  APIENTRY        DosAllocSharedMem(PPVOID ppb, PSZ pszName, ULONG cb, ULONG flag);
;|*** 
;|*** APIRET  APIENTRY        DosQueryMem(PVOID pb, PULONG pcb, PULONG pFlag);
;|*** 
;|*** #define DosSubAlloc     DosSubAllocMem
;|*** #define DOSSUBALLOC     DosSubAllocMem
;|*** APIRET  APIENTRY        DosSubAllocMem(PVOID pbBase, PPVOID ppb, ULONG cb);
;|*** 
;|*** #define DosSubFree      DosSubFreeMem
;|*** #define DOSSUBFREE      DosSubFreeMem
;|*** APIRET  APIENTRY        DosSubFreeMem(PVOID pbBase, PVOID pb, ULONG cb);
;|*** 
;|*** #define DosSubSet       DosSubSetMem
;|*** #define DOSSUBSET       DosSubSetMem
;|*** APIRET  APIENTRY        DosSubSetMem(PVOID pbBase, ULONG flag, ULONG cb);
;|*** 
;|*** #define DosSubUnset     DosSubUnsetMem
;|*** #define DOSSUBUNSET     DosSubUnsetMem
;|*** APIRET  APIENTRY        DosSubUnsetMem(PVOID pbBase);
;|*** 
;|*** #include <bsememf.h>    /* get flags for API                            */
;|*** 
;|*** #endif /* INCL_DOSMEMMGR */
;|*** 
;|*** #if (defined(INCL_DOSSEMAPHORES) || !defined(INCL_NOCOMMON))
;|*** 
;|*** /*
;|***  *     32-bit Semaphore Support
;|***  */
;|*** 
;|*** /* Semaphore Attributes */
;|*** 
;|*** #define DC_SEM_SHARED   0x01      /* DosCreateMutex, DosCreateEvent, and     */
;|***                                   /*   DosCreateMuxWait use it to indicate   */
;|***                                   /*   whether the semaphore is shared or    */
;|***                                   /*   private when the PSZ is null          */
;|*** #define DCMW_WAIT_ANY   0x02      /* DosCreateMuxWait option for wait on any */
;|***                                   /*   event/mutex to occur                  */
;|*** #define DCMW_WAIT_ALL   0x04      /* DosCreateMuxWait option for wait on all */
;|***                                   /*   events/mutexs to occur                */
;|*** 
;|*** /* PMxxxxxx */
;|*** #define DC_SEM_PM       0x40      /* PM Shared Event Semaphore.              */
;|*** 
;|*** #define PM_EVENT_POSTED 3000      /* PM Shared Event Posted                  */
;|*** 
;|*** #define SEM_INDEFINITE_WAIT      0xFFFFFFFF
;|*** #define SEM_IMMEDIATE_RETURN     0L
;|*** 
;|*** typedef struct _PSEMRECORD {    /* psr */
;|***     HSEM        hsemCur;
;|***     ULONG       ulUser;
;|*** } SEMRECORD;
;|*** typedef SEMRECORD       *PSEMRECORD;
;|*** 
;|*** #endif /* common INCL_DOSSEMAPHORES */
;|*** 
;|*** #ifdef INCL_DOSSEMAPHORES
;|*** 
;|*** typedef  ULONG    HEV;             /* hev */
;|*** typedef  HEV      *PHEV;
;|*** typedef  ULONG    HMTX;            /* hmtx */
;|*** typedef  HMTX     *PHMTX;
;|*** typedef  ULONG    HMUX;            /* hmux */
;|*** typedef  HMUX     *PHMUX;
;|*** 
;|*** APIRET  APIENTRY        DosCreateEventSem (PSZ pszName, PHEV phev, ULONG flAttr, BOOL32 fState);
;|*** APIRET  APIENTRY        DosOpenEventSem (PSZ pszName, PHEV phev);
;|*** APIRET  APIENTRY        DosCloseEventSem (HEV hev);
;|*** APIRET  APIENTRY        DosResetEventSem (HEV hev, PULONG pulPostCt);
;|*** APIRET  APIENTRY        DosPostEventSem (HEV hev);
;|*** APIRET  APIENTRY        DosWaitEventSem (HEV hev, ULONG ulTimeout);
;|*** APIRET  APIENTRY        DosQueryEventSem (HEV hev, PULONG pulPostCt);
;|*** 
;|*** APIRET  APIENTRY        DosCreateMutexSem (PSZ pszName, PHMTX phmtx, ULONG flAttr, BOOL32 fState);
;|*** APIRET  APIENTRY        DosOpenMutexSem (PSZ pszName, PHMTX phmtx);
;|*** APIRET  APIENTRY        DosCloseMutexSem (HMTX hmtx);
;|*** APIRET  APIENTRY        DosRequestMutexSem (HMTX hmtx, ULONG ulTimeout);
;|*** APIRET  APIENTRY        DosReleaseMutexSem (HMTX hmtx);
;|*** APIRET  APIENTRY        DosQueryMutexSem (HMTX hmtx, PPID ppid, PTID ptid, PULONG pulCount);
;|*** 
;|*** APIRET  APIENTRY        DosCreateMuxWaitSem (PSZ pszName, PHMUX phmux, ULONG cSemRec, PSEMRECORD pSemRec, ULONG flAttr);
;|*** APIRET  APIENTRY        DosOpenMuxWaitSem (PSZ pszName, PHMUX phmux);
;|*** APIRET  APIENTRY        DosCloseMuxWaitSem (HMUX hmux);
;|*** APIRET  APIENTRY        DosWaitMuxWaitSem (HMUX hmux, ULONG ulTimeout, PULONG pulUser);
;|*** APIRET  APIENTRY        DosAddMuxWaitSem (HMUX hmux, PSEMRECORD pSemRec);
;|*** APIRET  APIENTRY        DosDeleteMuxWaitSem (HMUX hmux, HSEM hSem);
;|*** APIRET  APIENTRY        DosQueryMuxWaitSem (HMUX hmux, PULONG pcSemRec, PSEMRECORD pSemRec, PULONG pflAttr);
;|*** 
;|*** APIRET  APIENTRY        DosPMPostEventSem (HEV hev);
;|*** APIRET  APIENTRY        DosPMWaitEventSem (HEV pmhev, HEV hev, ULONG ulTimeout);
;|*** APIRET  APIENTRY        DosPMRequestMutexSem (HEV hev, HMTX hmtx, ULONG ulTimeout);
;|*** APIRET  APIENTRY        DosPMWaitMuxWaitSem (HEV hev, HMUX hmux, ULONG ulTimeout, PULONG pulUser);
;|*** 
;|*** #endif /* INCL_DOSSEMAPHORES */
;|*** 
;|*** #if (defined(INCL_DOSDATETIME) || !defined(INCL_NOCOMMON))
;|*** 
;|*** /*** Time support */
;|*** 
;|*** typedef struct _DATETIME {    /* date */
;|***     UCHAR   hours;
;|***     UCHAR   minutes;
;|***     UCHAR   seconds;
;|***     UCHAR   hundredths;
;|***     UCHAR   day;
;|***     UCHAR   month;
;|***     USHORT  year;
;|***     SHORT   timezone;
;|***     UCHAR   weekday;
;|*** } DATETIME;
;|*** typedef DATETIME        *PDATETIME;
;|*** 
;|*** APIRET  APIENTRY        DosGetDateTime(PDATETIME pdt);
;|*** 
;|*** APIRET  APIENTRY        DosSetDateTime(PDATETIME pdt);
;|*** 
;|*** #endif /* common INCL_DOSDATETIME */
;|*** 
;|*** #ifdef INCL_DOSDATETIME
;|*** 
;|*** /* XLATOFF */
;|*** #define DosTimerAsync   DosAsyncTimer
;|*** #define DosTimerStart   DosStartTimer
;|*** #define DosTimerStop    DosStopTimer
;|*** /* XLATON */
;|*** 
;|*** typedef SHANDLE HTIMER;
;|*** typedef HTIMER  *PHTIMER;
;|*** 
;|*** APIRET  APIENTRY        DosAsyncTimer(ULONG msec, HSEM hsem, PHTIMER phtimer);
;|*** 
;|*** APIRET  APIENTRY        DosStartTimer(ULONG msec, HSEM hsem, PHTIMER phtimer);
;|*** 
;|*** APIRET  APIENTRY        DosStopTimer(HTIMER htimer);
;|*** 
;|*** #endif /* INCL_DOSDATETIME */
;|*** 
;|*** 
;|*** /*** Module manager */
;|*** 
;|*** #ifdef INCL_DOSMODULEMGR
;|*** 
;|*** /* XLATOFF */
;|*** #define DosGetProcAddr          DosQueryProcAddr
;|*** #define DosGetModHandle         DosQueryModuleHandle
;|*** #define DosGetModName           DosQueryModuleName
;|*** /* XLATON */
;|*** 
;|*** APIRET  APIENTRY  DosLoadModule(PSZ pszName, ULONG cbName, PSZ pszModname, PHMODULE phmod);
;|*** 
;|*** APIRET  APIENTRY  DosFreeModule(HMODULE hmod);
;|*** 
;|*** APIRET  APIENTRY  DosQueryProcAddr(HMODULE hmod, ULONG ordinal, PSZ pszName,PFN* ppfn);
;|*** 
;|*** APIRET  APIENTRY  DosQueryModuleHandle(PSZ pszModname, PHMODULE phmod);
;|*** 
;|*** APIRET  APIENTRY  DosQueryModuleName(HMODULE hmod, ULONG cbName, PCHAR pch);
;|*** 
;|*** #define PT_16BIT  0
;|*** #define PT_32BIT  1
;|*** 
;|*** APIRET  APIENTRY  DosQueryProcType(HMODULE hmod, ULONG ordinal, PSZ pszName, PULONG pulproctype);
;|*** 
;|*** APIRET  APIENTRY  DosQueryModFromEIP(HMODULE *phMod, ULONG *pObjNum, ULONG BuffLen, PCHAR pBuff, ULONG *pOffset, ULONG Address);
;|*** 
;|*** #define HW_CFG_MCA              0x00000001
;|*** #define HW_CFG_EISA             0x00000002
;|*** #define HW_CFG_ABIOS_SUPPORTED  0x00000004
;|*** #define HW_CFG_ABIOS_PRESENT    0x00000008
;|*** 
;|*** APIRET  APIENTRY DosQueryABIOSSupport(ULONG reserved);
;|*** 
;|*** #endif /* INCL_DOSMODULEMGR */
;|*** 
;|*** #if (defined(INCL_DOSRESOURCES) || !defined(INCL_NOCOMMON))
;|*** 
;|*** /*** Resource support */
;|*** 
;|*** /* Predefined resource types */
;|*** 
;|*** #define RT_POINTER      1   /* mouse pointer shape */
;|*** #define RT_BITMAP       2   /* bitmap */
;|*** #define RT_MENU         3   /* menu template */
;|*** #define RT_DIALOG       4   /* dialog template */
;|*** #define RT_STRING       5   /* string tables */
;|*** #define RT_FONTDIR      6   /* font directory */
;|*** #define RT_FONT         7   /* font */
;|*** #define RT_ACCELTABLE   8   /* accelerator tables */
;|*** #define RT_RCDATA       9   /* binary data */
;|*** #define RT_MESSAGE      10  /* error msg     tables */
;|*** #define RT_DLGINCLUDE   11  /* dialog include file name */
;|*** #define RT_VKEYTBL      12  /* key to vkey tables */
;|*** #define RT_KEYTBL       13  /* key to UGL tables */
;|*** #define RT_CHARTBL      14  /* glyph to character tables */
;|*** #define RT_DISPLAYINFO  15  /* screen display information */
;|*** 
;|*** #define RT_FKASHORT     16  /* function key area short form */
;|*** #define RT_FKALONG      17  /* function key area long form */
;|*** 
;|*** #define RT_HELPTABLE    18  /* Help table for Cary Help manager */
;|*** #define RT_HELPSUBTABLE 19  /* Help subtable for Cary Help manager */
;|*** 
;|*** #define RT_FDDIR        20  /* DBCS uniq/font driver directory */
;|*** #define RT_FD           21  /* DBCS uniq/font driver */
;|*** 
;|*** #define RT_MAX          22  /* 1st unused Resource Type */
;|*** 
;|*** 
;|*** #define RF_ORDINALID    0x80000000L     /* ordinal id flag in resource table */
;|*** 
;|*** #endif /* common INCL_DOSRESOURCES */
;|*** 
;|*** #ifdef INCL_DOSRESOURCES
;|*** 
;|*** /* XLATOFF */
;|*** #define DosGetResource2 DosGetResource
;|*** /* XLATON */
;|*** 
;|*** APIRET  APIENTRY        DosGetResource(HMODULE hmod, ULONG idType, ULONG idName, PPVOID ppb);
;|*** 
;|*** APIRET  APIENTRY        DosFreeResource(PVOID pb);
;|*** 
;|*** APIRET  APIENTRY        DosQueryResourceSize(HMODULE hmod, ULONG idt, ULONG idn, PULONG pulsize);
;|*** 
;|*** #endif /* INCL_DOSRESOURCES */
;|*** 
;|*** 
;|*** /*** NLS Support */
;|*** 
;|*** #ifdef INCL_DOSNLS
;|*** 
;|*** typedef struct _COUNTRYCODE { /* ctryc */
;|***     ULONG       country;
;|***     ULONG       codepage;
;|*** } COUNTRYCODE;
;|*** typedef COUNTRYCODE     *PCOUNTRYCODE;
;|*** 
;|*** typedef struct _COUNTRYINFO { /* ctryi */
;|***     ULONG       country;
;|***     ULONG       codepage;
;|***     ULONG       fsDateFmt;
;|***     CHAR        szCurrency[5];
;|***     CHAR        szThousandsSeparator[2];
;|***     CHAR        szDecimal[2];
;|***     CHAR        szDateSeparator[2];
;|***     CHAR        szTimeSeparator[2];
;|***     UCHAR       fsCurrencyFmt;
;|***     UCHAR       cDecimalPlace;
;|***     UCHAR       fsTimeFmt;
;|***     USHORT      abReserved1[2];
;|***     CHAR        szDataSeparator[2];
;|***     USHORT      abReserved2[5];
;|*** } COUNTRYINFO;
;|*** typedef COUNTRYINFO     *PCOUNTRYINFO;
;|*** 
;|*** /* XLATOFF */
;|*** #define DosGetCtryInfo  DosQueryCtryInfo
;|*** #define DosGetDBCSEv    DosQueryDBCSEnv
;|*** #define DosCaseMap      DosMapCase
;|*** #define DosGetCollate   DosQueryCollate
;|*** #define DosGetCp        DosQueryCp
;|*** #define DosSetProcCp    DosSetProcessCp
;|*** /* XLATON */
;|*** 
;|*** APIRET  APIENTRY        DosQueryCtryInfo(ULONG cb, PCOUNTRYCODE pcc, PCOUNTRYINFO pci, PULONG pcbActual);
;|*** 
;|*** APIRET  APIENTRY        DosQueryDBCSEnv(ULONG cb, PCOUNTRYCODE pcc, PCHAR pBuf);
;|*** 
;|*** APIRET  APIENTRY        DosMapCase(ULONG cb, PCOUNTRYCODE pcc, PCHAR pch);
;|*** 
;|*** APIRET  APIENTRY        DosQueryCollate(ULONG cb, PCOUNTRYCODE pcc, PCHAR pch, PULONG pcch);
;|*** 
;|*** APIRET  APIENTRY        DosQueryCp(ULONG cb, PULONG arCP, PULONG pcCP);
;|*** 
;|*** APIRET  APIENTRY        DosSetProcessCp(ULONG cp);
;|*** 
;|*** #endif /* INCL_DOSNLS */
;|*** 
;|*** 
;|*** /*** Signal support */
;|*** 
;|*** #ifdef INCL_DOSEXCEPTIONS
;|*** 
;|*** /* DosSetSigExceptionFocus codes */
;|*** 
;|*** #define SIG_UNSETFOCUS 0
;|*** #define SIG_SETFOCUS 1
;|*** 
;|*** #include <bsexcpt.h>
;|*** 
;|*** APIRET  APIENTRY        DosSetExceptionHandler(PEXCEPTIONREGISTRATIONRECORD pERegRec);
;|*** 
;|*** APIRET  APIENTRY        DosUnsetExceptionHandler(PEXCEPTIONREGISTRATIONRECORD pERegRec);
;|*** 
;|*** APIRET  APIENTRY        DosRaiseException(PEXCEPTIONREPORTRECORD pexcept);
;|*** 
;|*** APIRET  APIENTRY        DosSendSignalException(PID pid, ULONG exception);
;|*** 
;|*** APIRET  APIENTRY        DosUnwindException(PEXCEPTIONREGISTRATIONRECORD phandler, PVOID pTargetIP, PEXCEPTIONREPORTRECORD pERepRec);
;|*** 
;|*** APIRET  APIENTRY        DosSetSignalExceptionFocus(BOOL32 flag, PULONG pulTimes);
;|*** 
;|*** APIRET  APIENTRY        DosEnterMustComplete(PULONG pulNesting);
;|*** 
;|*** APIRET  APIENTRY        DosExitMustComplete(PULONG pulNesting);
;|*** 
;|*** APIRET  APIENTRY        DosAcknowledgeSignalException(ULONG ulSignalNum);
;|*** 
;|*** #endif /* INCL_DOSEXCEPTIONS */
;|*** 
;|*** 
;|*** /*** Pipe and queue support */
;|*** 
;|*** #ifdef INCL_DOSQUEUES
;|*** #if (defined(INCL_DOSFILEMGR) || !defined(INCL_NOCOMMON))
;|*** 
;|*** typedef SHANDLE HQUEUE;  /* hq */
;|*** typedef HQUEUE  *PHQUEUE;
;|*** typedef struct _REQUESTDATA {   /* reqqdata */
;|***     PID         pid;
;|***     ULONG       ulData;
;|*** } REQUESTDATA;
;|*** typedef REQUESTDATA     *PREQUESTDATA;
;|*** 
;|*** #define QUE_FIFO              0L
;|*** #define QUE_LIFO              1L
;|*** #define QUE_PRIORITY          2L
;|*** #define QUE_NOCONVERT_ADDRESS 0L
;|*** #define QUE_CONVERT_ADDRESS   4L
;|*** 
;|*** /* XLATOFF */
;|*** #define DosMakePipe     DosCreatePipe
;|*** /* XLATON */
;|*** 
;|*** APIRET  APIENTRY        DosCreatePipe(PHFILE phfRead, PHFILE phfWrite, ULONG cb);
;|*** 
;|*** APIRET  APIENTRY        DosCloseQueue(HQUEUE hq);
;|*** 
;|*** APIRET  APIENTRY        DosCreateQueue(PHQUEUE phq, ULONG priority, PSZ pszName);
;|*** 
;|*** APIRET  APIENTRY        DosOpenQueue(PPID ppid, PHQUEUE phq, PSZ pszName);
;|*** 
;|*** APIRET  APIENTRY        DosPeekQueue(HQUEUE hq, PREQUESTDATA pRequest, PULONG pcbData, PPVOID ppbuf, PULONG element, BOOL32 nowait, PBYTE ppriority, HEV hsem);
;|*** 
;|*** APIRET  APIENTRY        DosPurgeQueue(HQUEUE hq);
;|*** 
;|*** APIRET  APIENTRY        DosQueryQueue(HQUEUE hq, PULONG pcbEntries);
;|*** 
;|*** APIRET  APIENTRY        DosReadQueue(HQUEUE hq, PREQUESTDATA pRequest, PULONG pcbData, PPVOID ppbuf, ULONG element, BOOL32 wait, PBYTE ppriority, HEV hsem);
;|*** 
;|*** APIRET  APIENTRY        DosWriteQueue(HQUEUE hq, ULONG request, ULONG cbData, PVOID pbData, ULONG priority);
;|*** 
;|*** #else /* INCL_DOSFILEMGR || !INCL_NOCOMMON */
;|*** #error PHFILE not defined - define INCL_DOSFILEMGR or undefine INCL_NOCOMMON
;|*** #endif /* INCL_DOSFILEMGR || !INCL_NOCOMMON */
;|*** #endif /* INCL_DOSQUEUES */
;|*** 
;|*** #ifdef INCL_DOSMISC
;|*** 
;|*** /* definitions for DosSearchPath control word */
;|*** #define DSP_IMPLIEDCUR          1 /* current dir will be searched first */
;|*** #define DSP_PATHREF             2 /* from env.variable */
;|*** #define DSP_IGNORENETERR        4 /* ignore net errs & continue search */
;|*** 
;|*** /* indices for DosQuerySysInfo */
;|*** #define QSV_MAX_PATH_LENGTH     1
;|*** #define Q_MAX_PATH_LENGTH       QSV_MAX_PATH_LENGTH
;|*** #define QSV_MAX_TEXT_SESSIONS   2
;|*** #define QSV_MAX_PM_SESSIONS     3
;|*** #define QSV_MAX_VDM_SESSIONS    4
;|*** #define QSV_BOOT_DRIVE          5       /* 1=A, 2=B, etc. */
;|*** #define QSV_DYN_PRI_VARIATION   6       /* 0=Absolute, 1=Dynamic */
;|*** #define QSV_MAX_WAIT            7       /* seconds */
;|*** #define QSV_MIN_SLICE           8       /* milli seconds */
;|*** #define QSV_MAX_SLICE           9       /* milli seconds */
;|*** #define QSV_PAGE_SIZE           10
;|*** #define QSV_VERSION_MAJOR       11
;|*** #define QSV_VERSION_MINOR       12
;|*** #define QSV_VERSION_REVISION    13      /* Revision letter */
;|*** #define QSV_MS_COUNT            14      /* Free running millisecond counter */
;|*** #define QSV_TIME_LOW            15      /* Low dword of time in seconds */
;|*** #define QSV_TIME_HIGH           16      /* High dword of time in seconds */
;|*** #define QSV_TOTPHYSMEM          17      /* Physical memory on system */
;|*** #define QSV_TOTRESMEM           18      /* Resident memory on system */
;|*** #define QSV_TOTAVAILMEM         19      /* Available memory for all processes */
;|*** #define QSV_MAXPRMEM            20      /* Avail private mem for calling proc */
;|*** #define QSV_MAXSHMEM            21      /* Avail shared mem for calling proc */
;|*** #define QSV_TIMER_INTERVAL      22      /* Timer interval in tenths of ms */
;|*** #define QSV_MAX_COMP_LENGTH     23      /* max len of one component in a name */
;|*** #define QSV_FGND_SG_ID          24      /* Foreground Screen Group ID 26215   */
;|*** #define QSV_FGND_PID            25      /* Foreground Process ID      26215   */
;|*** #define QSV_MAX                 QSV_MAX_COMP_LENGTH
;|*** 
;|*** /* definitions for DosError - combine with | */
;|*** #define FERR_DISABLEHARDERR     0x00000000L     /* disable hard error popups */
;|*** #define FERR_ENABLEHARDERR      0x00000001L     /* enable hard error popups */
;|*** #define FERR_ENABLEEXCEPTION    0x00000000L     /* enable exception popups */
;|*** #define FERR_DISABLEEXCEPTION   0x00000002L     /* disable exception popups */
;|*** 
;|*** /* definitions for DosDumpProcess */
;|*** #define DDP_DISABLEPROCDUMP     0x00000000L     /* disable process dumps */
;|*** #define DDP_ENABLEPROCDUMP      0x00000001L     /* enable process dumps */
;|*** #define DDP_PERFORMPROCDUMP     0x00000002L     /* perform process dump */
;|*** 
;|*** /* definitions for DosSuppressPopUps */
;|*** #define SPU_DISABLESUPPRESSION  0x00000000L     /* disable popup suppression */
;|*** #define SPU_ENABLESUPPRESSION   0x00000001L     /* enable popup suppression */
;|*** 
;|*** /* definitions for DosQueryRASInfo Index */
;|*** #define SIS_MMIOADDR            0
;|*** #define SIS_MEC_TABLE           1
;|*** #define SIS_SYS_LOG             2
;|*** 
;|*** /* definitions for DosQueryExtLIBPATH and DosSetExtLIBPATH flags parameter */
;|*** #define BEGIN_LIBPATH   1
;|*** #define END_LIBPATH     2
;|*** 
;|*** /* XLATOFF */
;|*** #define DosInsMessage   DosInsertMessage
;|*** #define DosQSysInfo     DosQuerySysInfo
;|*** /* XLATON */
;|*** 
;|*** APIRET  APIENTRY        DosError(ULONG error);
;|*** 
;|*** APIRET  APIENTRY        DosGetMessage(PCHAR* pTable, ULONG cTable, PCHAR pBuf, ULONG cbBuf, ULONG msgnumber, PSZ pszFile, PULONG pcbMsg);
;|*** 
;|*** APIRET  APIENTRY        DosErrClass(ULONG code, PULONG pClass, PULONG pAction, PULONG pLocus);
;|*** 
;|*** APIRET  APIENTRY        DosInsertMessage(PCHAR* pTable, ULONG cTable, PSZ pszMsg, ULONG cbMsg, PCHAR pBuf, ULONG cbBuf, PULONG pcbMsg);
;|*** 
;|*** APIRET  APIENTRY        DosPutMessage(HFILE hfile, ULONG cbMsg, PCHAR pBuf);
;|*** 
;|*** APIRET  APIENTRY        DosQuerySysInfo(ULONG iStart, ULONG iLast, PVOID pBuf, ULONG cbBuf);
;|*** 
;|*** APIRET  APIENTRY        DosScanEnv(PSZ pszName, PSZ *ppszValue);
;|*** 
;|*** APIRET  APIENTRY        DosSearchPath(ULONG flag, PSZ pszPathOrName, PSZ pszFilename, PBYTE pBuf, ULONG cbBuf);
;|*** 
;|*** APIRET  APIENTRY        DosQueryMessageCP(PCHAR pb, ULONG cb, PSZ pszFilename, PULONG cbBuf);
;|*** 
;|*** APIRET  APIENTRY        DosQueryRASInfo(ULONG Index, PPVOID Addr);
;|*** 
;|*** APIRET  APIENTRY        DosForceSystemDump(ULONG reserved);
;|*** 
;|*** APIRET  APIENTRY        DosDumpProcess(ULONG Flag, ULONG Drive, PID Pid);
;|*** 
;|*** APIRET  APIENTRY        DosSuppressPopUps(ULONG Flag, ULONG Drive);
;|*** 
;|*** APIRET  APIENTRY        DosSetExtLIBPATH( PSZ pszExtLIBPATH, ULONG flags);
;|*** 
;|*** APIRET  APIENTRY        DosQueryExtLIBPATH( PSZ pszExtLIBPATH, ULONG flags);
;|*** 
;|*** APIRET  APIENTRY        DosVerifyPidTid(PID Pid, TID Tid);   /* 88344 */
;|*** 
;|*** #endif /* INCL_DOSMISC */
;|*** 
;|*** 
;|*** /*** Session manager support */
;|*** 
;|*** #ifdef INCL_DOSSESMGR
;|*** 
;|*** typedef struct _STARTDATA {   /* stdata */
;|***     USHORT  Length;
;|***     USHORT  Related;
;|***     USHORT  FgBg;
;|***     USHORT  TraceOpt;
;|***     PSZ     PgmTitle;
;|***     PSZ     PgmName;
;|***     PBYTE   PgmInputs;
;|***     PBYTE   TermQ;
;|***     PBYTE   Environment;
;|***     USHORT  InheritOpt;
;|***     USHORT  SessionType;
;|***     PSZ     IconFile;
;|***     ULONG   PgmHandle;
;|***     USHORT  PgmControl;
;|***     USHORT  InitXPos;
;|***     USHORT  InitYPos;
;|***     USHORT  InitXSize;
;|***     USHORT  InitYSize;
;|***     USHORT  Reserved;
;|***     PSZ     ObjectBuffer;
;|***     ULONG   ObjectBuffLen;
;|*** } STARTDATA;
;|*** typedef STARTDATA       *PSTARTDATA;
;|*** 
;|*** #define SSF_RELATED_INDEPENDENT 0
;|*** #define SSF_RELATED_CHILD       1
;|*** 
;|*** #define SSF_FGBG_FORE           0
;|*** #define SSF_FGBG_BACK           1
;|*** 
;|*** #define SSF_TRACEOPT_NONE       0
;|*** #define SSF_TRACEOPT_TRACE      1
;|*** #define SSF_TRACEOPT_TRACEALL   2
;|*** 
;|*** #define SSF_INHERTOPT_SHELL     0
;|*** #define SSF_INHERTOPT_PARENT    1
;|*** 
;|*** /* note that these types are identical to those in pmshl.h for PROG_* */
;|*** #define SSF_TYPE_DEFAULT        0
;|*** #define SSF_TYPE_FULLSCREEN     1
;|*** #define SSF_TYPE_WINDOWABLEVIO  2
;|*** #define SSF_TYPE_PM             3
;|*** #define SSF_TYPE_VDM            4
;|*** #define SSF_TYPE_GROUP          5
;|*** #define SSF_TYPE_DLL            6
;|*** #define SSF_TYPE_WINDOWEDVDM    7
;|*** #define SSF_TYPE_PDD            8
;|*** #define SSF_TYPE_VDD            9
;|*** 
;|*** /* note that these flags are identical to those in pmshl.h for SHE_* */
;|*** #define SSF_CONTROL_VISIBLE     0x0000
;|*** #define SSF_CONTROL_INVISIBLE   0x0001
;|*** #define SSF_CONTROL_MAXIMIZE    0x0002
;|*** #define SSF_CONTROL_MINIMIZE    0x0004
;|*** #define SSF_CONTROL_NOAUTOCLOSE 0x0008
;|*** #define SSF_CONTROL_SETPOS      0x8000
;|*** 
;|*** typedef struct _STATUSDATA { /* stsdata */
;|***     USHORT Length;
;|***     USHORT SelectInd;
;|***     USHORT BondInd;
;|*** } STATUSDATA;
;|*** typedef STATUSDATA      *PSTATUSDATA;
;|*** 
;|*** /* SelectInd and BondInd paramater values for DosSetSession */
;|*** #define SET_SESSION_UNCHANGED      0
;|*** #define SET_SESSION_SELECTABLE     1
;|*** #define SET_SESSION_NON_SELECTABLE 2
;|*** #define SET_SESSION_BOND           1
;|*** #define SET_SESSION_NO_BOND        2
;|*** 
;|*** /* TargetOption (scope) parameter values for DosStopSession */
;|*** #define STOP_SESSION_SPECIFIED     0
;|*** #define STOP_SESSION_ALL           1
;|*** 
;|*** /* XLATOFF */
;|*** #define DosQAppType     DosQueryAppType
;|*** /* XLATON */
;|*** 
;|*** APIRET  APIENTRY        DosStartSession(PSTARTDATA psd, PULONG pidSession, PPID ppid);
;|*** 
;|*** APIRET  APIENTRY        DosSetSession(ULONG idSession, PSTATUSDATA psd);
;|*** 
;|*** APIRET  APIENTRY        DosSelectSession(ULONG idSession);
;|*** 
;|*** APIRET  APIENTRY        DosStopSession(ULONG scope, ULONG idSession);
;|*** 
;|*** APIRET  APIENTRY        DosQueryAppType(PSZ pszName, PULONG pFlags);
;|*** 
;|*** #endif /* INCL_DOSSESMGR */
;|*** 
;|*** #if (defined(INCL_DOSSESMGR) || defined(INCL_DOSFILEMGR))
;|*** 
;|*** /* AppType returned in by DosQueryAppType in pFlags as follows          */
;|*** #define FAPPTYP_NOTSPEC         0x00000000
;|*** #define FAPPTYP_NOTWINDOWCOMPAT 0x00000001
;|*** #define FAPPTYP_WINDOWCOMPAT    0x00000002
;|*** #define FAPPTYP_WINDOWAPI       0x00000003
;|*** #define FAPPTYP_BOUND           0x00000008
;|*** #define FAPPTYP_DLL             0x00000010
;|*** #define FAPPTYP_DOS             0x00000020
;|*** #define FAPPTYP_PHYSDRV         0x00000040 /* physical device driver       */
;|*** #define FAPPTYP_VIRTDRV         0x00000080 /* virtual device driver        */
;|*** #define FAPPTYP_PROTDLL         0x00000100 /* 'protected memory' dll       */
;|*** #define FAPPTYP_WINDOWSREAL     0x00000200 /*         real mode app        */
;|*** #define FAPPTYP_WINDOWSPROT     0x00000400 /*         protect mode app     */
;|*** #define FAPPTYP_WINDOWSPROT31   0x00001000 /*         3.1 protect mode app */
;|*** #define FAPPTYP_32BIT           0x00004000
;|*** #define FAPPTYP_EXETYPE         FAPPTYP_WINDOWAPI
;|*** 
;|*** #define FAPPTYP_RESERVED        ~(FAPPTYP_WINDOWAPI | FAPPTYP_BOUND | FAPPTYP_DLL | FAPPTYP_DOS | FAPPTYP_PHYSDRV | FAPPTYP_VIRTDRV | FAPPTYP_PROTDLL | FAPPTYP_32BIT)
;|*** 
;|*** #ifdef INCL_DOSFILEMGR
;|*** 
;|*** #define EAT_APPTYP_PMAPI        0x00            /* Uses PM API */
;|*** #define EAT_APPTYP_DOS          0x01            /* DOS APP */
;|*** #define EAT_APPTYP_PMW          0x02            /* Window compatible */
;|*** #define EAT_APPTYP_NOPMW        0x03            /* Not Window compatible */
;|*** #define EAT_APPTYP_EXETYPE      0x03            /* EXE type mask */
;|*** #define EAT_APPTYP_RESERVED     ~(EAT_APPTYP_EXETYPE)
;|*** 
;|*** #endif /* INCL_DOSFILEMGR */
;|*** 
;|*** #endif /* INCL_DOSSESMGR || INCL_DOSFILEMGR */
;|*** 
;|*** 
;|*** /*** Device support */
;|*** 
;|*** #ifdef INCL_DOSDEVICES
;|*** 
;|*** /* XLATOFF */
;|*** #define DosDevIOCtl2    DosDevIOCtl
;|*** /* XLATON */
;|*** 
;|*** APIRET  APIENTRY        DosDevConfig(PVOID pdevinfo, ULONG item);
;|*** #define DEVINFO_PRINTER         0       /* Number of printers attached */
;|*** #define DEVINFO_RS232           1       /* Number of RS232 ports */
;|*** #define DEVINFO_FLOPPY          2       /* Number of diskette drives */
;|*** #define DEVINFO_COPROCESSOR     3       /* Presence of math coprocessor */
;|*** #define DEVINFO_SUBMODEL        4       /* PC Submodel Type */
;|*** #define DEVINFO_MODEL           5       /* PC Model Type */
;|*** #define DEVINFO_ADAPTER         6       /* Primary display adapter type */
;|*** 
;|*** APIRET  APIENTRY        DosDevIOCtl(HFILE hDevice, ULONG category, ULONG function, PVOID pParams, ULONG cbParmLenMax, PULONG pcbParmLen, PVOID pData, ULONG cbDataLenMax, PULONG pcbDataLen);
;|*** 
;|*** 
;|*** APIRET  APIENTRY        DosPhysicalDisk(ULONG function, PVOID pBuf, ULONG cbBuf, PVOID pParams, ULONG cbParams);
;|*** #define INFO_COUNT_PARTITIONABLE_DISKS  1       /* # of partitionable disks */
;|*** #define INFO_GETIOCTLHANDLE             2       /* Obtain handle            */
;|*** #define INFO_FREEIOCTLHANDLE            3       /* Release handle           */
;|*** 
;|*** #endif /* INCL_DOSDEVICES */
;|*** 
;|*** 
;|*** /*** DosNamedPipes API Support */
;|*** 
;|*** #ifdef INCL_DOSNMPIPES
;|*** 
;|*** /*** Data structures used with named pipes ***/
;|*** 
;|*** typedef SHANDLE HPIPE;     /* hp */
;|*** typedef HPIPE   *PHPIPE;
;|*** 
;|*** typedef struct _AVAILDATA {             /* AVAILDATA */
;|***     USHORT      cbpipe;                 /* bytes left in the pipe */
;|***     USHORT      cbmessage;              /* bytes left in the current message */
;|*** } AVAILDATA;
;|*** typedef AVAILDATA FAR *PAVAILDATA;
;|*** 
;|*** typedef struct _PIPEINFO {              /* nmpinf */
;|***     USHORT cbOut;                       /* length of outgoing I/O buffer */
;|***     USHORT cbIn;                        /* length of incoming I/O buffer */
;|***     BYTE   cbMaxInst;                   /* maximum number of instances   */
;|***     BYTE   cbCurInst;                   /* current number of instances   */
;|***     BYTE   cbName;                      /* length of pipe name           */
;|***     CHAR   szName[1];                   /* start of name                 */
;|*** } PIPEINFO;
;|*** typedef PIPEINFO FAR *PPIPEINFO;
;|*** 
;|*** typedef struct _PIPESEMSTATE {  /* nmpsmst */
;|***     BYTE   fStatus;             /* type of record, 0 = EOI, 1 = read ok, */
;|***                                 /* 2 = write ok, 3 = pipe closed         */
;|***     BYTE   fFlag;               /* additional info, 01 = waiting thread  */
;|***     USHORT usKey;               /* user's key value                      */
;|***     USHORT usAvail;             /* available data/space if status = 1/2  */
;|*** } PIPESEMSTATE;
;|*** typedef PIPESEMSTATE FAR *PPIPESEMSTATE;
;|*** 
;|*** #define NP_INDEFINITE_WAIT      -1
;|*** #define NP_DEFAULT_WAIT         0L
;|*** 
;|*** /* DosPeekNmPipe() pipe states */
;|*** 
;|*** #define NP_STATE_DISCONNECTED   0x0001
;|*** #define NP_STATE_LISTENING      0x0002
;|*** #define NP_STATE_CONNECTED      0x0003
;|*** #define NP_STATE_CLOSING        0x0004
;|*** 
;|*** /* DosCreateNPipe open modes */
;|*** 
;|*** #define NP_ACCESS_INBOUND       0x0000
;|*** #define NP_ACCESS_OUTBOUND      0x0001
;|*** #define NP_ACCESS_DUPLEX        0x0002
;|*** #define NP_INHERIT              0x0000
;|*** #define NP_NOINHERIT            0x0080
;|*** #define NP_WRITEBEHIND          0x0000
;|*** #define NP_NOWRITEBEHIND        0x4000
;|*** 
;|*** /* DosCreateNPipe and DosQueryNPHState state */
;|*** 
;|*** #define NP_READMODE_BYTE        0x0000
;|*** #define NP_READMODE_MESSAGE     0x0100
;|*** #define NP_TYPE_BYTE            0x0000
;|*** #define NP_TYPE_MESSAGE         0x0400
;|*** #define NP_END_CLIENT           0x0000
;|*** #define NP_END_SERVER           0x4000
;|*** #define NP_WAIT                 0x0000
;|*** #define NP_NOWAIT               0x8000
;|*** #define NP_UNLIMITED_INSTANCES  0x00FF
;|*** 
;|*** /* XLATOFF */
;|*** #define DosCallNmPipe   DosCallNPipe
;|*** #define DosConnectNmPipe        DosConnectNPipe
;|*** #define DosDisConnectNmPipe     DosDisConnectNPipe
;|*** #define DosMakeNmPipe   DosCreateNPipe
;|*** #define DosPeekNmPipe   DosPeekNPipe
;|*** #define DosQNmPHandState        DosQueryNPHState
;|*** #define DosQNmPipeInfo  DosQueryNPipeInfo
;|*** #define DosQNmPipeSemState      DosQueryNPipeSemState
;|*** #define DosRawReadNmPipe        DosRawReadNPipe
;|*** #define DosRawWriteNmPipe       DosRawWriteNPipe
;|*** #define DosSetNmPHandState      DosSetNPHState
;|*** #define DosSetNmPipeSem DosSetNPipeSem
;|*** #define DosTransactNmPipe       DosTransactNPipe
;|*** #define DosWaitNmPipe   DosWaitNPipe
;|*** /* XLATON */
;|*** 
;|*** APIRET  APIENTRY        DosCallNPipe(PSZ pszName, PVOID pInbuf, ULONG cbIn, PVOID pOutbuf, ULONG cbOut, PULONG pcbActual, ULONG msec);
;|*** 
;|*** APIRET  APIENTRY        DosConnectNPipe(HPIPE hpipe);
;|*** 
;|*** APIRET  APIENTRY        DosDisConnectNPipe(HPIPE hpipe);
;|*** 
;|*** APIRET  APIENTRY        DosCreateNPipe(PSZ pszName, PHPIPE pHpipe, ULONG openmode, ULONG pipemode, ULONG cbInbuf, ULONG cbOutbuf, ULONG msec);
;|*** 
;|*** APIRET  APIENTRY        DosPeekNPipe(HPIPE hpipe, PVOID pBuf, ULONG cbBuf, PULONG pcbActual, PAVAILDATA pAvail, PULONG pState);
;|*** 
;|*** APIRET  APIENTRY        DosQueryNPHState(HPIPE hpipe, PULONG pState);
;|*** 
;|*** APIRET  APIENTRY        DosQueryNPipeInfo(HPIPE hpipe, ULONG infolevel, PVOID pBuf, ULONG cbBuf);
;|*** 
;|*** APIRET  APIENTRY        DosQueryNPipeSemState(HSEM hsem, PPIPESEMSTATE pnpss, ULONG cbBuf);
;|*** 
;|*** APIRET  APIENTRY        DosSetNPHState(HPIPE hpipe, ULONG state);
;|*** 
;|*** APIRET  APIENTRY        DosSetNPipeSem(HPIPE hpipe, HSEM hsem, ULONG key);
;|*** 
;|*** APIRET  APIENTRY        DosTransactNPipe(HPIPE hpipe, PVOID pOutbuf, ULONG cbOut, PVOID pInbuf, ULONG cbIn, PULONG pcbRead);
;|*** 
;|*** APIRET  APIENTRY        DosWaitNPipe(PSZ pszName, ULONG msec);
;|*** 
;|*** /* values in fStatus */
;|*** #define NPSS_EOI                   0     /* End Of Information    */
;|*** #define NPSS_RDATA                 1     /* read data available   */
;|*** #define NPSS_WSPACE                2     /* write space available */
;|*** #define NPSS_CLOSE                 3     /* pipe in CLOSING state */
;|*** 
;|*** /* values in npss_flag */
;|*** #define NPSS_WAIT                  0x01  /* waiting thread on end of pipe */
;|*** 
;|*** /* defined bits in pipe mode */
;|*** #define NP_NBLK                    0x8000 /* non-blocking read/write */
;|*** #define NP_SERVER                  0x4000 /* set if server end       */
;|*** #define NP_WMESG                   0x0400 /* write messages          */
;|*** #define NP_RMESG                   0x0100 /* read as messages        */
;|*** #define NP_ICOUNT                  0x00FF /* instance count field    */
;|*** 
;|*** 
;|*** /*      Named pipes may be in one of several states depending on the actions
;|***  *      that have been taken on it by the server end and client end.  The
;|***  *      following state/action table summarizes the valid state transitions:
;|***  *
;|***  *      Current state           Action                  Next state
;|***  *
;|***  *       <none>             server DosMakeNmPipe        DISCONNECTED
;|***  *       DISCONNECTED       server connect              LISTENING
;|***  *       LISTENING          client open                 CONNECTED
;|***  *       CONNECTED          server disconn              DISCONNECTED
;|***  *       CONNECTED          client close                CLOSING
;|***  *       CLOSING            server disconn              DISCONNECTED
;|***  *       CONNECTED          server close                CLOSING
;|***  *       <any other>        server close                <pipe deallocated>
;|***  *
;|***  *      If a server disconnects his end of the pipe, the client end will enter a
;|***  *      special state in which any future operations (except close) on the file
;|***  *      descriptor associated with the pipe will return an error.
;|***  */
;|*** 
;|*** /*
;|***  *      Values for named pipe state
;|***  */
;|*** 
;|*** #define NP_DISCONNECTED            1    /* after pipe creation or Disconnect */
;|*** #define NP_LISTENING               2    /* after DosNmPipeConnect            */
;|*** #define NP_CONNECTED               3    /* after Client open                 */
;|*** #define NP_CLOSING                 4    /* after Client or Server close      */
;|*** 
;|*** 
;|*** #endif /* INCL_DOSNMPIPES */
;|*** 
;|*** 
;|*** /*** DosProfile API support */
;|*** 
;|*** #ifdef INCL_DOSPROFILE
;|*** 
;|*** /*** Perfview API support */
;|*** 
;|*** APIRET  APIENTRY        DosTmrQueryFreq(PULONG pulTmrFreq);
;|*** APIRET  APIENTRY        DosTmrQueryTime(PQWORD pqwTmrTime);
;|*** APIRET  APIENTRY        DosRegisterPerfCtrs(PBYTE pbDataBlk, PBYTE pbTextBlk, ULONG flFlags);
;|*** 
;|*** /* DosProfile ordinal number */
;|*** 
;|*** #define PROF_ORDINAL     133
;|*** 
;|*** /* DosProfile usType */
;|*** 
;|*** #define PROF_SYSTEM      0
;|*** #define PROF_USER        1
;|*** #define PROF_USEDD       2
;|*** #define PROF_KERNEL      4
;|*** #define PROF_VERBOSE     8
;|*** #define PROF_ENABLE     16
;|*** 
;|*** /* DosProfile usFunc */
;|*** 
;|*** #define PROF_ALLOC       0
;|*** #define PROF_CLEAR       1
;|*** #define PROF_ON          2
;|*** #define PROF_OFF         3
;|*** #define PROF_DUMP        4
;|*** #define PROF_FREE        5
;|*** 
;|*** /* DosProfile tic count granularity (DWORD) */
;|*** 
;|*** #define PROF_SHIFT       2
;|*** 
;|*** /* DosProfile module name string length */
;|*** 
;|*** #define PROF_MOD_NAME_SIZE   10
;|*** 
;|*** /* DosProfile error code for end of data */
;|*** 
;|*** #define PROF_END_OF_DATA     13
;|*** 
;|*** #endif /* INCL_DOSPROFILE */
;|*** 
;|*** 
;|*** /*** Virtual DOS Machine API support */
;|*** 
;|*** #ifdef INCL_DOSMVDM
;|*** 
;|*** typedef LHANDLE   HVDD;     /* hvdd */
;|*** typedef HVDD FAR *PHVDD;    /* phvdd */
;|*** 
;|*** APIRET  APIENTRY DosOpenVDD(PSZ pszVDD, PHVDD phvdd);
;|*** 
;|*** APIRET  APIENTRY DosRequestVDD(HVDD hvdd, SGID sgid, ULONG cmd,
;|***                                ULONG cbInput, PVOID pInput,
;|***                                ULONG cbOutput, PVOID pOutput);
;|*** 
;|*** APIRET  APIENTRY DosCloseVDD(HVDD hvdd);
;|*** 
;|*** APIRET  APIENTRY DosQueryDOSProperty(SGID sgid, PSZ pszName,
;|***                                      ULONG cb, PSZ pch);
;|*** 
;|*** APIRET  APIENTRY DosSetDOSProperty(SGID sgid, PSZ pszName,
;|***                                    ULONG cb, PSZ pch);
;|*** #endif /* INCL_DOSMVDM */
;|*** 
;|*** 
;|*** /* The following #else/#endif corresponds to a #if near the top of this */
;|*** /* file.  The next three lines include the 16-bit version of this file, */
;|*** /* hence these lines MUST be the last lines in this include file.       */
;|*** #else /* not INCL_32 */
;|*** 
;|*** #ifdef INCL_16
;|*** #include <bsedos16.h>
; Line 1841
;|*** 
;|*** #ifdef INCL_DOSDEVIOCTL
;|*** #include <bsedev.h>       /* Structures and constants for DosDevIOCtl */
;|*** #endif /* INCL_DOSDEVIOCTL */
;|*** 
;|*** #ifndef INCL_32
;|*** #include <bsesub.h>       /* VIO/KBD/MOU definitions */
; Line 69
;|*** #endif /* INCL_32 */
;|*** #include <bseerr.h>       /* Base error code definitions */
; Line 71
;|*** #endif /* INCL_NOBASEAPI */
;|*** 
;|*** /* OS/2 Presentation Manager Include File */
;|*** 
;|*** #ifndef INCL_NOPMAPI
;|*** #include <pm.h>
; Line 53
;|*** /*DDK*************************************************************************/
;|*** /*                                                                           */
;|*** /* COPYRIGHT    Copyright (C) 1995 IBM Corporation                           */
;|*** /*                                                                           */
;|*** /*    The following IBM OS/2 WARP source code is provided to you solely for  */
;|*** /*    the purpose of assisting you in your development of OS/2 WARP device   */
;|*** /*    drivers. You may use this code in accordance with the IBM License      */
;|*** /*    Agreement provided in the IBM Device Driver Source Kit for OS/2. This  */
;|*** /*    Copyright statement may not be removed.                                */
;|*** /*                                                                           */
;|*** /*****************************************************************************/
;|*** /****************************** Module Header ******************************\
;|*** *
;|*** * Module Name: PM.H
;|*** *
;|*** * OS/2 Presentation Manager top level include file.
;|*** *
;|*** *
;|*** * ===========================================================================
;|*** *
;|*** * The following symbols are used in this file for conditional sections.
;|*** *
;|*** *   #define:                To include:
;|*** *
;|*** *   INCL_PM                  ALL of OS/2 Presentation Manager
;|*** *   INCL_AVIO                OS/2 Advanced VIO (16-Bit only)
;|*** *   INCL_BITMAPFILEFORMAT    OS/2 Bitmap File Format
;|*** *   INCL_DEV                 OS/2 Device Support
;|*** *   INCL_ERRORS              OS/2 Errors
;|*** *   INCL_FONTFILEFORMAT      OS/2 Font File Format
;|*** *   INCL_GPI                 OS/2 GPI
;|*** *   INCL_ORDERS              OS/2 Graphical Order Formats
;|*** *   INCL_PIC                 OS/2 Picture utilities
;|*** *   INCL_SPL                 OS/2 Spooler
;|*** *   INCL_WINSTDDLGS          CUA controls and dialogs
;|*** *   INCL_WIN                 OS/2 Window Manager
;|*** *   INCL_WINWORKPLACE        OS/2 Workplace Shell
;|*** *
;|*** * ===========================================================================
;|*** *
;|*** * Comments at the end of each typedef line give the name tags used in
;|*** * the assembler include version of this file.
;|*** *
;|*** * The assembler include version of this file excludes lines between NOINC
;|*** * and INC comments.
;|*** *
;|*** #ifndef __IBMC__
;|***    * The public version of this file (as shipped with the OS/2 Toolkit
;|***    * product) excludes all non 32-bit material marked in this file
;|***    * as well as any areas specifically marked with __IBMC__ conditional
;|***    * sections - including this paragraph. The H2IBMH rexx command file
;|***    * removes these sections.
;|*** #endif
;|*** \***************************************************************************/
;|*** 
;|*** /* NOINC */
;|*** #ifdef __IBMC__
;|***    #pragma checkout( suspend )
;|***       #ifndef __CHKHDR__
;|***          #pragma checkout( suspend )
;|***       #endif
;|***    #pragma checkout( resume )
;|*** #endif
;|*** /* INC */
;|*** 
;|*** #define PM_INCLUDED
;|*** 
;|*** #ifndef INCL_32         /* If neither INCL_32 or INCL_16 set already */
;|***    #ifndef INCL_16      /* find out from compiler if 32-bit or not.  */
;|***      #ifdef M_I386
;|***         #define INCL_32 /* Compiling for 32-bit */
;|***      #else
;|***         #define INCL_16 /* Compiling for 16-bit */
;|***      #endif
;|***   #endif
;|*** #endif
;|*** 
;|*** /*** if INCL_PM defined then define all the symbols ************************/
;|*** #ifdef INCL_PM
;|***    #define INCL_AVIO
;|***    #define INCL_BITMAPFILEFORMAT
;|***    #define INCL_DEV
;|***    #define INCL_ERRORS
;|***    #define INCL_FONTFILEFORMAT
;|***    #define INCL_GPI
;|***    #define INCL_ORDERS
;|***    #define INCL_PIC
;|***    #define INCL_SPL
;|***    #define INCL_WIN
;|***    #define INCL_WINSTDDLGS
;|***    #define INCL_WINWORKPLACE
;|*** #endif /* INCL_PM */
;|*** 
;|*** 
;|*** #include <pmwin.h>        /* OS/2 Window Manager definitions    */
; Line 95
;|*** /*DDK*************************************************************************/
;|*** /*                                                                           */
;|*** /* COPYRIGHT    Copyright (C) 1995 IBM Corporation                           */
;|*** /*                                                                           */
;|*** /*    The following IBM OS/2 WARP source code is provided to you solely for  */
;|*** /*    the purpose of assisting you in your development of OS/2 WARP device   */
;|*** /*    drivers. You may use this code in accordance with the IBM License      */
;|*** /*    Agreement provided in the IBM Device Driver Source Kit for OS/2. This  */
;|*** /*    Copyright statement may not be removed.                                */
;|*** /*                                                                           */
;|*** /*****************************************************************************/
;|*** /****************************** Module Header ******************************\
;|*** *
;|*** * Module Name: PMWIN.H
;|*** *
;|*** * OS/2 Presentation Manager Window Manager include file.
;|*** *
;|*** *
;|*** * ===========================================================================
;|*** *
;|*** * The folowing symbols are used in this file for conditional sections.
;|*** *
;|*** * If INCL_WIN is defined, all subcomponents are included.
;|*** *
;|*** * Subcomponents marked with "+" are partially included by default:
;|*** *
;|*** *   #define:                To include:
;|*** *
;|*** * + INCL_WINWINDOWMGR       General window management
;|*** * + INCL_WINMESSAGEMGR      Message management
;|*** * + INCL_WININPUT           Mouse and keyboard input
;|*** * + INCL_WINDIALOGS         Dialog boxes
;|*** * + INCL_WINSTATICS         Static controls
;|*** * + INCL_WINBUTTONS         Button controls
;|*** * + INCL_WINENTRYFIELDS     Entry Fields
;|*** *   INCL_WINMLE             Multiple Line Entry Fields
;|*** * + INCL_WINLISTBOXES       List box controls
;|*** * + INCL_WINMENUS           Menu controls
;|*** * + INCL_WINSCROLLBARS      Scroll bar controls
;|*** * + INCL_WINFRAMEMGR        Frame manager
;|*** *   INCL_WINFRAMECTLS       Frame controls (title bars & size border)
;|*** *   INCL_WINRECTANGLES      Rectangle routines
;|*** *   INCL_WINSYS             System values (and colors)
;|*** *   INCL_WINTIMER           Timer routines
;|*** * + INCL_WINACCELERATORS    Keyboard accelerators
;|*** *   INCL_WINTRACKRECT       WinTrackRect() function
;|*** *   INCL_WINCLIPBOARD       Clipboard manager
;|*** * + INCL_WINCURSORS         Text cursors
;|*** * + INCL_WINPOINTERS        Mouse pointers
;|*** *   INCL_WINHOOKS           Hook manager
;|*** * + INCL_WINSWITCHLIST      Shell Switch List API
;|*** *   INCL_WINPROGRAMLIST     Shell Program List API
;|*** *   INCL_WINSHELLDATA       Shell Data (?)
;|*** *   INCL_WINCOUNTRY         Country support
;|*** *   INCL_WINHEAP            Heap Manager
;|*** *   INCL_WINATOM            Atom Manager
;|*** #ifndef INCL_32
;|***    *INCL_WINCATCHTHROW      WinCatch/WinThrow support
;|*** #endif
;|*** *   INCL_WINERRORS          Error code definitions
;|*** *   INCL_NLS                DBCS window manager definition
;|*** * + INCL_WINHELP            Help Manager definitions
;|*** *   INCL_WINSEI             Set Error Info API
;|*** *   INCL_WINLOAD            Load/Delete Library/Procedure
;|*** *   INCL_WINTYPES           Definitions for Datatypes
;|*** *   INCL_WINTHUNKAPI        Thunk Procedure API
;|*** *   INCL_WINDESKTOP         Desktop API
;|*** *
;|*** * ===========================================================================
;|*** *
;|*** * Comments at the end of each typedef line give the name tags used in
;|*** * the assembler include version of this file.
;|*** *
;|*** * The assembler include version of this file excludes lines between NOINC
;|*** * and INC comments.
;|*** *
;|*** #ifndef __IBMC__
;|***    * The public version of this file (as shipped with the OS/2 Toolkit
;|***    * product) excludes all non 32-bit material marked in this file
;|***    * as well as any areas specifically marked with __IBMC__ conditional
;|***    * sections - including this paragraph. The H2IBMH rexx command file
;|***    * removes these sections.
;|*** #endif
;|*** \***************************************************************************/
;|*** 
;|*** /* NOINC */
;|*** #ifdef __IBMC__
;|***    #pragma checkout( suspend )
;|***       #ifndef __CHKHDR__
;|***          #pragma checkout( suspend )
;|***       #endif
;|***    #pragma checkout( resume )
;|*** #endif
;|*** /* INC */
;|*** 
;|*** #define WIN_INCLUDED
;|*** 
;|*** 
;|*** #ifndef INCL_32         /* If neither INCL_32 or INCL_16 set already */
;|***    #ifndef INCL_16      /* find out from compiler if 32-bit or not.  */
;|***      #ifdef M_I386
;|***         #define INCL_32 /* Compiling for 32-bit */
;|***      #else
;|***         #define INCL_16 /* Compiling for 16-bit */
;|***      #endif
;|***   #endif
;|*** #endif
;|*** 
;|*** #ifdef INCL_16
;|***    /* NOINC */
;|***    #include <pmwin16.h>
; Line 111
;|***    /* INC */
;|*** #endif /* INCL_16 */
;|*** 
;|*** /*** include everything if requested ***************************************/
;|*** #ifdef INCL_WIN
;|***    #define INCL_WINWINDOWMGR
;|***    #define INCL_WINMESSAGEMGR
;|***    #define INCL_WININPUT
;|***    #define INCL_WINDIALOGS
;|***    #define INCL_WINSTATICS
;|***    #define INCL_WINBUTTONS
;|***    #define INCL_WINENTRYFIELDS
;|***    #define INCL_WINMLE
;|***    #define INCL_WINLISTBOXES
;|***    #define INCL_WINMENUS
;|***    #define INCL_WINSCROLLBARS
;|***    #define INCL_WINFRAMEMGR
;|***    #define INCL_WINFRAMECTLS
;|***    #define INCL_WINRECTANGLES
;|***    #define INCL_WINSYS
;|***    #define INCL_WINTIMER
;|***    #define INCL_WINACCELERATORS
;|***    #define INCL_WINTRACKRECT
;|***    #define INCL_WINCLIPBOARD
;|***    #define INCL_WINCURSORS
;|***    #define INCL_WINPOINTERS
;|***    #define INCL_WINHOOKS
;|***    #define INCL_WINSWITCHLIST
;|***    #define INCL_WINPROGRAMLIST
;|***    #define INCL_WINSHELLDATA
;|***    #define INCL_WINCOUNTRY
;|***    #define INCL_WINHEAP
;|***    #define INCL_WINATOM
;|***    #ifndef INCL_32
;|***      #define INCL_WINCATCHTHROW
;|***    #endif
;|***    #define INCL_WINERRORS
;|***    #define INCL_WINDDE
;|***    #define INCL_WINHELP
;|***    #define INCL_WINSEI
;|***    #define INCL_WINLOAD
;|***    #define INCL_WINTYPES
;|***    #define INCL_WINDESKTOP
;|***    #define INCL_WINPALETTE
;|***    #define INCL_WINTHUNKAPI
;|***    #define INCL_WINSTDDLGS
;|*** #else /* INCL_WIN */
;|***    /*** include resource compiler required sections ************************/
;|***    #ifdef RC_INVOKED
;|***       #define INCL_WININPUT
;|***       #define INCL_WINDIALOGS
;|***       #define INCL_WINSTATICS
;|***       #define INCL_WINBUTTONS
;|***       #define INCL_WINENTRYFIELDS
;|***       #define INCL_WINLISTBOXES
;|***       #define INCL_WINMENUS
;|***       #define INCL_WINSCROLLBARS
;|***       #define INCL_WINFRAMEMGR
;|***       #define INCL_WINFRAMECTLS
;|***       #define INCL_WINACCELERATORS
;|***       #define INCL_WINPOINTERS
;|***       #define INCL_WINMESSAGEMGR
;|***       #define INCL_WINMLE
;|***       #define INCL_WINHELP
;|***       #define INCL_WINSTDDLGS
;|***       #define INCL_WINSYS
;|***    #endif /* RC_INVOKED */
;|*** #endif /* INCL_WIN */
;|*** 
;|*** /*** ensure standard entry field defintions if MLE is defined **************/
;|*** #ifdef INCL_WINMLE
;|***    #ifndef INCL_WINENTRYFIELDS
;|***       #define INCL_WINENTRYFIELDS
;|***    #endif /* INCL_WINENTRYFIELDS */
;|*** #endif /* INCL_WINMLE */
;|*** 
;|*** /*** INCL_WINCOMMON compatability ******************************************/
;|*** #ifdef INCL_WINCOMMON
;|***    #define INCL_WINWINDOWMGR
;|*** #endif /* INCL_WINCOMMON */
;|*** 
;|*** /*** include PMWIN errors if all errors requested **************************/
;|*** #ifdef INCL_ERRORS
;|***    #define INCL_WINERRORS
;|*** #endif  /* INCL_ERRORS */
;|*** 
;|*** /***************************************************************************/
;|*** /***        General Window Management types, constants and macros        ***/
;|*** /***************************************************************************/
;|*** 
;|*** typedef VOID FAR    *MPARAM;    /* mp    */
;|*** typedef MPARAM FAR  *PMPARAM;   /* pmp   */
;|*** typedef VOID FAR    *MRESULT;   /* mres  */
;|*** typedef MRESULT FAR *PMRESULT;  /* pmres */
;|*** 
;|*** /*** Macros to make an MPARAM from standard types. *************************/
;|*** 
;|*** #define MPVOID                     ((MPARAM)0L)
;|*** #ifdef INCL_32
;|***    #define MPFROMP(p)                 ((MPARAM)((ULONG)(p)))
;|*** #else
;|***    #define MPFROMP(p)                 ((MPARAM)(VOID FAR *)(p))
;|*** #endif
;|*** #define MPFROMHWND(hwnd)           ((MPARAM)(HWND)(hwnd))
;|*** #define MPFROMCHAR(ch)             ((MPARAM)(USHORT)(ch))
;|*** #define MPFROMSHORT(s)             ((MPARAM)(USHORT)(s))
;|*** #define MPFROM2SHORT(s1, s2)       ((MPARAM)MAKELONG(s1, s2))
;|*** #define MPFROMSH2CH(s, uch1, uch2) ((MPARAM)MAKELONG(s, MAKESHORT(uch1, uch2)))
;|*** #define MPFROMLONG(l)              ((MPARAM)(ULONG)(l))
;|*** 
;|*** /*** Macros to extract standard types from an MPARAM ***********************/
;|*** 
;|*** #define PVOIDFROMMP(mp)            ((VOID FAR *)(mp))
;|*** #define HWNDFROMMP(mp)             ((HWND)(mp))
;|*** #define CHAR1FROMMP(mp)            ((UCHAR)((ULONG)mp))
;|*** #define CHAR2FROMMP(mp)            ((UCHAR)((ULONG)mp >> 8))
;|*** #define CHAR3FROMMP(mp)            ((UCHAR)((ULONG)mp >> 16))
;|*** #define CHAR4FROMMP(mp)            ((UCHAR)((ULONG)mp >> 24))
;|*** #define SHORT1FROMMP(mp)           ((USHORT)(ULONG)(mp))
;|*** #define SHORT2FROMMP(mp)           ((USHORT)((ULONG)mp >> 16))
;|*** #define LONGFROMMP(mp)             ((ULONG)(mp))
;|*** 
;|*** /*** Macros to make an MRESULT from standard types. ************************/
;|*** 
;|*** #define MRFROMP(p)                 ((MRESULT)(VOID FAR *)(p))
;|*** #define MRFROMSHORT(s)             ((MRESULT)(USHORT)(s))
;|*** #define MRFROM2SHORT(s1, s2)       ((MRESULT)MAKELONG(s1, s2))
;|*** #define MRFROMLONG(l)              ((MRESULT)(ULONG)(l))
;|*** 
;|*** /*** Macros to extract standard types from an MRESULT **********************/
;|*** 
;|*** #define PVOIDFROMMR(mr)            ((VOID FAR *)(mr))
;|*** #define SHORT1FROMMR(mr)           ((USHORT)((ULONG)mr))
;|*** #define SHORT2FROMMR(mr)           ((USHORT)((ULONG)mr >> 16))
;|*** #define LONGFROMMR(mr)             ((ULONG)(mr))
;|*** 
;|*** 
;|*** /****************************************************************************
;|*** * This is the standard function definition for window procedures.
;|*** * Typically they are names like "XxxxxxxxWndProc", where the prefix
;|*** * "Xxxxxxxxx" is replaced by some name descriptive of the window procedure
;|*** * being declared.  Window procedures must be EXPORTED in the definitions
;|*** * file used by the linker.
;|*** *
;|*** * MRESULT EXPENTRY MyclassWndProc(HWND hwnd,   * window handle        *
;|*** *                                 ULONG msg,   * message number       *
;|*** *                                 MPARAM mp1,  * 1st (packed) parms   *
;|*** *                                 MPARAM mp2); * 2nd (packed) parms   *
;|*** *
;|*** ****************************************************************************/
;|*** 
;|*** /*** Pointer to a window procedure function ********************************/
;|*** #ifdef INCL_32
;|***    typedef MRESULT (EXPENTRY FNWP)(HWND, ULONG, MPARAM, MPARAM);
;|***    typedef FNWP FAR *PFNWP;
;|*** #else
;|***    typedef MRESULT (PASCAL FAR *PFNWP)(HWND, USHORT, MPARAM, MPARAM);
;|*** #endif
;|*** 
;|*** /*** Predefined window handles *********************************************/
;|*** #ifndef INCL_SAADEFS
;|***    #define HWND_DESKTOP               (HWND)1
;|***    #define HWND_OBJECT                (HWND)2
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** #define HWND_TOP                      (HWND)3
;|*** #define HWND_BOTTOM                   (HWND)4
;|*** 
;|*** #ifndef INCL_SAADEFS
;|***    #define HWND_THREADCAPTURE         (HWND)5
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** 
;|*** /*** Standard Window Classes ***********************************************/
;|*** 
;|*** #define WC_FRAME             ((PSZ)0xffff0001L)
;|*** #define WC_COMBOBOX          ((PSZ)0xffff0002L)
;|*** #define WC_BUTTON            ((PSZ)0xffff0003L)
;|*** #define WC_MENU              ((PSZ)0xffff0004L)
;|*** #define WC_STATIC            ((PSZ)0xffff0005L)
;|*** #define WC_ENTRYFIELD        ((PSZ)0xffff0006L)
;|*** #define WC_LISTBOX           ((PSZ)0xffff0007L)
;|*** #define WC_SCROLLBAR         ((PSZ)0xffff0008L)
;|*** #define WC_TITLEBAR          ((PSZ)0xffff0009L)
;|*** #define WC_MLE               ((PSZ)0xffff000AL)
;|*** /* 000B to 000F reserved */
;|*** #define WC_APPSTAT           ((PSZ)0xffff0010L)
;|*** #define WC_KBDSTAT           ((PSZ)0xffff0011L)
;|*** #define WC_PECIC             ((PSZ)0xffff0012L)
;|*** #define WC_DBE_KKPOPUP       ((PSZ)0xffff0013L)
;|*** /* 0014 to 001F reserved */
;|*** #define WC_SPINBUTTON        ((PSZ)0xffff0020L)
;|*** /* 0021 to 0024 reserved */
;|*** #define WC_CONTAINER         ((PSZ)0xffff0025L)
;|*** #define WC_SLIDER            ((PSZ)0xffff0026L)
;|*** #define WC_VALUESET          ((PSZ)0xffff0027L)
;|*** #define WC_NOTEBOOK          ((PSZ)0xffff0028L)
;|*** /* 0029 to 002C used by PEN */
;|*** #define WC_PENFIRST          ((PSZ)0xffff0029L)
;|*** #define WC_PENLAST           ((PSZ)0xffff002CL)
;|*** /* 002D to 0030 reserved */
;|*** /* 0030 to 003F reserved */
;|*** #define WC_MMPMFIRST         ((PSZ)0xffff0040L)
;|*** #define WC_CIRCULARSLIDER    ((PSZ)0xffff0041L)
;|*** #define WC_MMPMLAST          ((PSZ)0xffff004fL)
;|*** 
;|*** /*** Standard Window Styles ************************************************/
;|*** 
;|*** #define WS_VISIBLE                 0x80000000L
;|*** #define WS_DISABLED                0x40000000L
;|*** #define WS_CLIPCHILDREN            0x20000000L
;|*** #define WS_CLIPSIBLINGS            0x10000000L
;|*** #define WS_PARENTCLIP              0x08000000L
;|*** #define WS_SAVEBITS                0x04000000L
;|*** #define WS_SYNCPAINT               0x02000000L
;|*** #define WS_MINIMIZED               0x01000000L
;|*** #define WS_MAXIMIZED               0x00800000L
;|*** #define WS_ANIMATE                 0x00400000L
;|*** 
;|*** /*** Dialog manager styles *************************************************/
;|*** 
;|*** #define WS_GROUP                   0x00010000L
;|*** #define WS_TABSTOP                 0x00020000L
;|*** #define WS_MULTISELECT             0x00040000L
;|*** 
;|*** /*** Class styles *********************************************************/
;|*** 
;|*** #define CS_MOVENOTIFY              0x00000001L
;|*** #define CS_SIZEREDRAW              0x00000004L
;|*** #define CS_HITTEST                 0x00000008L
;|*** #define CS_PUBLIC                  0x00000010L
;|*** #define CS_FRAME                   0x00000020L
;|*** #define CS_CLIPCHILDREN            0x20000000L
;|*** #define CS_CLIPSIBLINGS            0x10000000L
;|*** #define CS_PARENTCLIP              0x08000000L
;|*** #define CS_SAVEBITS                0x04000000L
;|*** #define CS_SYNCPAINT               0x02000000L
;|*** 
;|*** /***************************************************************************/
;|*** /*** Window Manager Subsection part 1 **************************************/
;|*** /***************************************************************************/
;|*** 
;|*** #if (defined(INCL_WINWINDOWMGR) || !defined(INCL_NOCOMMON))
;|*** 
;|***    #ifdef INCL_32
;|***       BOOL    APIENTRY WinRegisterClass(HAB hab,
;|***                                         PSZ pszClassName,
;|***                                         PFNWP pfnWndProc,
;|***                                         ULONG flStyle,
;|***                                         ULONG cbWindowData);
;|***    #else
;|***       BOOL    APIENTRY WinRegisterClass(HAB hab,
;|***                                         PSZ pszClassName,
;|***                                         PFNWP pfnWndProc,
;|***                                         ULONG flStyle,
;|***                                         USHORT cbWindowData);
;|***    #endif  /* INCL_32 */
;|*** 
;|***    #ifdef INCL_32
;|***       MRESULT APIENTRY WinDefWindowProc(HWND hwnd,
;|***                                         ULONG msg,
;|***                                         MPARAM mp1,
;|***                                         MPARAM mp2);
;|***    #else
;|***       MRESULT APIENTRY WinDefWindowProc(HWND hwnd,
;|***                                         USHORT msg,
;|***                                         MPARAM mp1,
;|***                                         MPARAM mp2);
;|***    #endif  /* INCL_32 */
;|*** 
;|***    BOOL    APIENTRY WinDestroyWindow(HWND hwnd);
;|*** 
;|***    BOOL    APIENTRY WinShowWindow(HWND hwnd,
;|***                                   BOOL fShow);
;|*** 
;|***    BOOL    APIENTRY WinQueryWindowRect(HWND hwnd,
;|***                                        PRECTL prclDest);
;|*** 
;|***    HPS     APIENTRY WinGetPS(HWND hwnd);
;|*** 
;|***    BOOL    APIENTRY WinReleasePS(HPS hps);
;|*** 
;|***    BOOL    APIENTRY WinEndPaint(HPS hps);
;|*** 
;|***    #ifndef INCL_SAADEFS
;|*** 
;|***       #ifdef INCL_32
;|***          HPS   APIENTRY WinGetClipPS(HWND hwnd,
;|***                                      HWND hwndClip,
;|***                                      ULONG fl);
;|***       #else
;|***          HPS   APIENTRY WinGetClipPS(HWND hwnd,
;|***                                      HWND hwndClip,
;|***                                      USHORT fs);
;|***       #endif  /* INCL_32 */
;|*** 
;|***       BOOL  APIENTRY WinIsWindowShowing(HWND hwnd);
;|*** 
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    HPS   APIENTRY WinBeginPaint(HWND hwnd,
;|***                                 HPS hps,
;|***                                 PRECTL prclPaint);
;|***    HDC   APIENTRY WinOpenWindowDC(HWND hwnd);
;|*** 
;|***    #ifdef INCL_32
;|***       LONG APIENTRY WinScrollWindow(HWND hwnd,
;|***                                     LONG dx,
;|***                                     LONG dy,
;|***                                     PRECTL prclScroll,
;|***                                     PRECTL prclClip,
;|***                                     HRGN hrgnUpdate,
;|***                                     PRECTL prclUpdate,
;|***                                     ULONG rgfsw);
;|***    #else
;|***       SHORT APIENTRY WinScrollWindow(HWND hwnd,
;|***                                      SHORT dx,
;|***                                      SHORT dy,
;|***                                      PRECTL prclScroll,
;|***                                      PRECTL prclClip,
;|***                                      HRGN hrgnUpdate,
;|***                                      PRECTL prclUpdate,
;|***                                      USHORT rgfsw);
;|***    #endif  /* INCL_32 */
;|*** 
;|***    /*** WinGetClipPS() flags ***********************************************/
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #define PSF_LOCKWINDOWUPDATE       0x0001
;|***       #define PSF_CLIPUPWARDS            0x0002
;|***       #define PSF_CLIPDOWNWARDS          0x0004
;|***       #define PSF_CLIPSIBLINGS           0x0008
;|***       #define PSF_CLIPCHILDREN           0x0010
;|***       #define PSF_PARENTCLIP             0x0020
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    /*** WinScrollWindow() flags ********************************************/
;|*** 
;|***    #define SW_SCROLLCHILDREN          0x0001
;|***    #define SW_INVALIDATERGN           0x0002
;|*** 
;|***    BOOL  APIENTRY WinFillRect(HPS hps,
;|***                               PRECTL prcl,
;|***                               LONG lColor);
;|*** 
;|***    /*** WinInitialize/WinTerminate Interface declarations ******************/
;|*** 
;|***    typedef struct _QVERSDATA {  /* qver */
;|***       USHORT   environment;
;|***       USHORT   version;
;|***    } QVERSDATA;
;|***    typedef QVERSDATA FAR *PQVERSDATA;
;|*** 
;|***    #define QV_OS2                     0x0000
;|***    #define QV_CMS                     0x0001
;|***    #define QV_TSO                     0x0002
;|***    #define QV_TSOBATCH                0x0003
;|***    #define QV_OS400                   0x0004
;|*** 
;|*** 
;|***    ULONG  APIENTRY WinQueryVersion(HAB hab);
;|*** 
;|***    #ifdef INCL_32
;|***       HAB    APIENTRY WinInitialize(ULONG flOptions);
;|***    #else
;|***       HAB    APIENTRY WinInitialize(USHORT fsOptions);
;|***    #endif  /* INCL_32 */
;|*** 
;|***    BOOL   APIENTRY WinTerminate(HAB hab);
;|*** 
;|***    HAB    APIENTRY WinQueryAnchorBlock(HWND hwnd);
;|*** 
;|*** #endif /* INCL_WINWINDOWMGR | !INCL_NOCOMMON */
;|*** 
;|*** /***************************************************************************/
;|*** /***  End of Window Manager COMMON section *********************************/
;|*** /***************************************************************************/
;|*** 
;|*** 
;|*** #ifdef INCL_32
;|***    HWND    APIENTRY WinCreateWindow(HWND hwndParent,
;|***                                     PSZ pszClass,
;|***                                     PSZ pszName,
;|***                                     ULONG flStyle,
;|***                                     LONG x,
;|***                                     LONG y,
;|***                                     LONG cx,
;|***                                     LONG cy,
;|***                                     HWND hwndOwner,
;|***                                     HWND hwndInsertBehind,
;|***                                     ULONG id,
;|***                                     PVOID pCtlData,
;|***                                     PVOID pPresParams);
;|*** #else
;|***    HWND    APIENTRY WinCreateWindow(HWND hwndParent,
;|***                                     PSZ pszClass,
;|***                                     PSZ pszName,
;|***                                     ULONG flStyle,
;|***                                     SHORT x,
;|***                                     SHORT y,
;|***                                     SHORT cx,
;|***                                     SHORT cy,
;|***                                     HWND hwndOwner,
;|***                                     HWND hwndInsertBehind,
;|***                                     USHORT id,
;|***                                     PVOID pCtlData,
;|***                                     PVOID pPresParams);
;|*** #endif  /* INCL_32 */
;|*** 
;|*** BOOL    APIENTRY WinEnableWindow(HWND hwnd,
;|***                                  BOOL fEnable);
;|*** 
;|*** BOOL    APIENTRY WinIsWindowEnabled(HWND hwnd);
;|*** 
;|*** BOOL    APIENTRY WinEnableWindowUpdate(HWND hwnd,
;|***                                        BOOL fEnable);
;|*** 
;|*** BOOL    APIENTRY WinIsWindowVisible(HWND hwnd);
;|*** 
;|*** #ifdef INCL_32
;|***    LONG    APIENTRY WinQueryWindowText(HWND hwnd,
;|***                                        LONG cchBufferMax,
;|***                                        PCH pchBuffer);
;|*** #else
;|***    SHORT   APIENTRY WinQueryWindowText(HWND hwnd,
;|***                                        SHORT cchBufferMax,
;|***                                        PCH pchBuffer);
;|*** #endif  /* INCL_32 */
;|*** 
;|*** BOOL    APIENTRY WinSetWindowText(HWND hwnd,
;|***                                   PSZ pszText);
;|*** 
;|*** #ifdef INCL_32
;|***    LONG    APIENTRY WinQueryWindowTextLength(HWND hwnd);
;|*** #else
;|***    SHORT   APIENTRY WinQueryWindowTextLength(HWND hwnd);
;|*** #endif  /* INCL_32 */
;|*** 
;|*** #ifdef INCL_32
;|***    HWND    APIENTRY WinWindowFromID(HWND hwndParent,
;|***                                     ULONG id);
;|*** #else
;|***    HWND    APIENTRY WinWindowFromID(HWND hwndParent,
;|***                                     USHORT id);
;|*** #endif  /* INCL_32 */
;|*** 
;|*** BOOL    APIENTRY WinIsWindow(HAB hab,
;|***                              HWND hwnd);
;|*** 
;|*** #ifdef INCL_32
;|***    HWND    APIENTRY WinQueryWindow(HWND hwnd,
;|***                                    LONG cmd);
;|*** #else
;|***    HWND    APIENTRY WinQueryWindow(HWND hwnd,
;|***                                    SHORT cmd,
;|***                                    BOOL fLock);
;|*** #endif  /* INCL_32 */
;|*** 
;|*** #ifdef INCL_32
;|***    LONG    APIENTRY WinMultWindowFromIDs(HWND hwndParent,
;|***                                          PHWND prghwnd,
;|***                                          ULONG idFirst,
;|***                                          ULONG idLast);
;|*** #else
;|***    SHORT   APIENTRY WinMultWindowFromIDs(HWND hwndParent,
;|***                                          PHWND prghwnd,
;|***                                          USHORT idFirst,
;|***                                          USHORT idLast);
;|*** #endif  /* INCL_32 */
;|*** 
;|*** /*** WinQueryWindow() codes ************************************************/
;|*** 
;|*** #define QW_NEXT         0
;|*** #define QW_PREV         1
;|*** #define QW_TOP          2
;|*** #define QW_BOTTOM       3
;|*** #define QW_OWNER        4
;|*** #define QW_PARENT       5
;|*** #define QW_NEXTTOP      6
;|*** #define QW_PREVTOP      7
;|*** #define QW_FRAMEOWNER   8
;|*** 
;|*** BOOL   APIENTRY WinSetParent(HWND hwnd,
;|***                              HWND hwndNewParent,
;|***                              BOOL fRedraw);
;|*** 
;|*** BOOL   APIENTRY WinIsChild(HWND hwnd,
;|***                            HWND hwndParent);
;|*** BOOL   APIENTRY WinSetOwner(HWND hwnd,
;|***                             HWND hwndNewOwner);
;|*** #ifndef INCL_SAADEFS
;|***    BOOL   APIENTRY WinQueryWindowProcess(HWND hwnd,
;|***                                          PPID ppid,
;|***                                          PTID ptid);
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** HWND   APIENTRY WinQueryObjectWindow(HWND hwndDesktop);
;|*** HWND   APIENTRY WinQueryDesktopWindow(HAB hab,
;|***                                       HDC hdc);
;|*** 
;|*** /*** Window positioning functions */
;|*** 
;|*** /* WinSetMultWindowPos() structure */
;|*** 
;|*** #ifdef INCL_32
;|***    typedef struct _SWP {  /* swp */
;|***       ULONG   fl;
;|***       LONG    cy;
;|***       LONG    cx;
;|***       LONG    y;
;|***       LONG    x;
;|***       HWND    hwndInsertBehind;
;|***       HWND    hwnd;
;|***       ULONG   ulReserved1;
;|***       ULONG   ulReserved2;
;|***    } SWP;
;|*** #else
;|***    typedef struct _SWP {  /* swp */
;|***       USHORT  fs;
;|***       SHORT   cy;
;|***       SHORT   cx;
;|***       SHORT   y;
;|***       SHORT   x;
;|***       HWND    hwndInsertBehind;
;|***       HWND    hwnd;
;|***    } SWP;
;|*** #endif
;|*** typedef SWP FAR *PSWP;
;|*** 
;|*** #ifdef INCL_32
;|***    BOOL   APIENTRY WinSetWindowPos(HWND hwnd,
;|***                                    HWND hwndInsertBehind,
;|***                                    LONG x,
;|***                                    LONG y,
;|***                                    LONG cx,
;|***                                    LONG cy,
;|***                                    ULONG fl);
;|***    BOOL   APIENTRY WinSetMultWindowPos(HAB hab,
;|***                                        PSWP pswp,
;|***                                        ULONG cswp);
;|*** #else
;|***    BOOL   APIENTRY WinSetWindowPos(HWND hwnd,
;|***                                    HWND hwndInsertBehind,
;|***                                    SHORT x,
;|***                                    SHORT y,
;|***                                    SHORT cx,
;|***                                    SHORT cy,
;|***                                    USHORT fs);
;|***    BOOL   APIENTRY WinSetMultWindowPos(HAB hab,
;|***                                        PSWP pswp,
;|***                                        USHORT cswp);
;|*** #endif
;|*** BOOL   APIENTRY WinQueryWindowPos(HWND hwnd,
;|***                                   PSWP pswp);
;|*** 
;|*** /* Values returned from WM_ADJUSTWINDOWPOS and passed to WM_WINDOWPOSCHANGED */
;|*** 
;|*** #define AWP_MINIMIZED              0x00010000L
;|*** #define AWP_MAXIMIZED              0x00020000L
;|*** #define AWP_RESTORED               0x00040000L
;|*** #define AWP_ACTIVATE               0x00080000L
;|*** #define AWP_DEACTIVATE             0x00100000L
;|*** 
;|*** /* WinSetWindowPos() flags */
;|*** 
;|*** #define SWP_SIZE                   0x0001
;|*** #define SWP_MOVE                   0x0002
;|*** #define SWP_ZORDER                 0x0004
;|*** #define SWP_SHOW                   0x0008
;|*** #define SWP_HIDE                   0x0010
;|*** #define SWP_NOREDRAW               0x0020
;|*** #define SWP_NOADJUST               0x0040
;|*** #define SWP_ACTIVATE               0x0080
;|*** #define SWP_DEACTIVATE             0x0100
;|*** #define SWP_EXTSTATECHANGE         0x0200
;|*** #define SWP_MINIMIZE               0x0400
;|*** #define SWP_MAXIMIZE               0x0800
;|*** #define SWP_RESTORE                0x1000
;|*** #define SWP_FOCUSACTIVATE          0x2000
;|*** #define SWP_FOCUSDEACTIVATE        0x4000
;|*** #define SWP_NOAUTOCLOSE            0x8000    /* Valid in PROGDETAILS struct only */
;|*** 
;|*** /* Window painting */
;|*** 
;|*** BOOL  APIENTRY WinUpdateWindow(HWND hwnd);
;|*** 
;|*** BOOL  APIENTRY WinInvalidateRect(HWND hwnd,
;|***                                  PRECTL pwrc,
;|***                                  BOOL fIncludeChildren);
;|*** 
;|*** BOOL  APIENTRY WinInvalidateRegion(HWND hwnd,
;|***                                    HRGN hrgn,
;|***                                    BOOL fIncludeChildren);
;|*** 
;|*** 
;|*** /* Drawing helpers */
;|*** 
;|*** BOOL  APIENTRY WinInvertRect(HPS hps,
;|***                              PRECTL prcl);
;|*** #ifdef INCL_32
;|***    BOOL  APIENTRY WinDrawBitmap(HPS hpsDst,
;|***                                 HBITMAP hbm,
;|***                                 PRECTL pwrcSrc,
;|***                                 PPOINTL pptlDst,
;|***                                 LONG clrFore,
;|***                                 LONG clrBack,
;|***                                 ULONG fl);
;|*** #else
;|***    BOOL  APIENTRY WinDrawBitmap(HPS hpsDst,
;|***                                 HBITMAP hbm,
;|***                                 PRECTL pwrcSrc,
;|***                                 PPOINTL pptlDst,
;|***                                 LONG clrFore,
;|***                                 LONG clrBack,
;|***                                 USHORT fs);
;|*** #endif
;|*** 
;|*** /* WinDrawBitmap() flags */
;|*** 
;|*** #define DBM_NORMAL                 0x0000
;|*** #define DBM_INVERT                 0x0001
;|*** #define DBM_HALFTONE               0x0002
;|*** #define DBM_STRETCH                0x0004
;|*** #define DBM_IMAGEATTRS             0x0008
;|*** 
;|*** 
;|*** #ifdef INCL_32
;|*** 
;|***    LONG    APIENTRY WinDrawText(HPS hps,
;|***                                 LONG cchText,
;|***                                 PCH lpchText,
;|***                                 PRECTL prcl,
;|***                                 LONG clrFore,
;|***                                 LONG clrBack,
;|***                                 ULONG flCmd);
;|*** 
;|*** #else /* not INCL_32 */
;|*** 
;|***    SHORT APIENTRY WinDrawText(HPS hps,
;|***                               SHORT cchText,
;|***                               PCH lpchText,
;|***                               PRECTL prcl,
;|***                               LONG clrFore,
;|***                               LONG clrBack,
;|***                               USHORT fsCmd);
;|*** 
;|*** #endif /* INCL_32 */
;|*** 
;|*** /*
;|*** * WinDrawText() codes:
;|*** * From DT_LEFT to DT_EXTERNALLEADING, the codes are designed to be OR'ed with
;|*** * SS_TEXT to create variations of the basic text static item.
;|*** */
;|*** #define DT_LEFT                    0x0000
;|*** #define DT_QUERYEXTENT             0x0002
;|*** #define DT_UNDERSCORE              0x0010
;|*** #define DT_STRIKEOUT               0x0020
;|*** #define DT_TEXTATTRS               0x0040
;|*** #define DT_EXTERNALLEADING         0x0080
;|*** #define DT_CENTER                  0x0100
;|*** #define DT_RIGHT                   0x0200
;|*** #define DT_TOP                     0x0000
;|*** #define DT_VCENTER                 0x0400
;|*** #define DT_BOTTOM                  0x0800
;|*** #define DT_HALFTONE                0x1000
;|*** #define DT_MNEMONIC                0x2000
;|*** #define DT_WORDBREAK               0x4000
;|*** #define DT_ERASERECT               0x8000
;|*** 
;|*** 
;|*** #ifdef INCL_32
;|*** 
;|***    BOOL APIENTRY WinDrawBorder(HPS hps,
;|***                                PRECTL prcl,
;|***                                LONG cx,
;|***                                LONG cy,
;|***                                LONG clrFore,
;|***                                LONG clrBack,
;|***                                ULONG flCmd);
;|*** 
;|*** #else /* not INCL_32 */
;|*** 
;|***    BOOL APIENTRY WinDrawBorder(HPS hps,
;|***                                PRECTL prcl,
;|***                                SHORT cx,
;|***                                SHORT cy,
;|***                                LONG clrFore,
;|***                                LONG clrBack,
;|***                                USHORT fsCmd);
;|*** 
;|*** #endif /* INCL_32 */
;|*** 
;|*** /* WinDrawBorder() flags */
;|*** 
;|*** #define DB_PATCOPY                 0x0000
;|*** #define DB_PATINVERT               0x0001
;|*** #define DB_DESTINVERT              0x0002
;|*** #define DB_AREAMIXMODE             0x0003
;|*** 
;|*** #define DB_ROP                     0x0007
;|*** #define DB_INTERIOR                0x0008
;|*** #define DB_AREAATTRS               0x0010
;|*** #define DB_STANDARD                0x0100
;|*** #define DB_DLGBORDER               0x0200
;|*** 
;|*** 
;|*** 
;|*** /** Resource loading functions */
;|*** 
;|*** #ifdef INCL_32
;|***    LONG    APIENTRY WinLoadString(HAB hab,
;|***                                   HMODULE hmod,
;|***                                   ULONG id,
;|***                                   LONG cchMax,
;|***                                   PSZ pchBuffer);
;|*** #else
;|***    SHORT   APIENTRY WinLoadString(HAB hab,
;|***                                   HMODULE hmod,
;|***                                   USHORT id,
;|***                                   SHORT cchMax,
;|***                                   PSZ pchBuffer);
;|*** #endif
;|*** #ifndef INCL_SAADEFS
;|***    #ifdef INCL_32
;|***       LONG    APIENTRY WinLoadMessage(HAB hab,
;|***                                       HMODULE hmod,
;|***                                       ULONG id,
;|***                                       LONG cchMax,
;|***                                       PSZ pchBuffer);
;|***    #else
;|***       SHORT   APIENTRY WinLoadMessage(HAB hab,
;|***                                       HMODULE hmod,
;|***                                       USHORT id,
;|***                                       SHORT cchMax,
;|***                                       PSZ pchBuffer);
;|***    #endif
;|*** 
;|*** 
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** /***************************************************************************/
;|*** /****                 Window Manager Subsection part 2                  ****/
;|*** #if (defined(INCL_WINWINDOWMGR) || !defined(INCL_NOCOMMON))
;|*** 
;|***    BOOL APIENTRY WinSetActiveWindow(HWND hwndDesktop,
;|***                                     HWND hwnd);
;|*** 
;|*** #endif /* Window Manager COMMON subsection */
;|*** 
;|*** #ifdef INCL_WINWINDOWMGR
;|***    /* WM_CREATE structure */
;|*** 
;|***    #ifdef INCL_32
;|***       typedef struct _CREATESTRUCT {  /* crst */
;|***          PVOID   pPresParams;
;|***          PVOID   pCtlData;
;|***          ULONG   id;
;|***          HWND    hwndInsertBehind;
;|***          HWND    hwndOwner;
;|***          LONG    cy;
;|***          LONG    cx;
;|***          LONG    y;
;|***          LONG    x;
;|***          ULONG   flStyle;
;|***          PSZ     pszText;
;|***          PSZ     pszClass;
;|***          HWND    hwndParent;
;|***       } CREATESTRUCT;
;|***    #else
;|***       typedef struct _CREATESTRUCT {  /* crst */
;|***          PVOID   pPresParams;
;|***          PVOID   pCtlData;
;|***          USHORT  id;
;|***          HWND    hwndInsertBehind;
;|***          HWND    hwndOwner;
;|***          SHORT   cy;
;|***          SHORT   cx;
;|***          SHORT   y;
;|***          SHORT   x;
;|***          ULONG   flStyle;
;|***          PSZ     pszText;
;|***          PSZ     pszClass;
;|***          HWND    hwndParent;
;|***       } CREATESTRUCT;
;|***    #endif
;|***    typedef CREATESTRUCT FAR *PCREATESTRUCT;
;|*** 
;|***    /* WinQueryClassInfo() structure */
;|*** 
;|***    #ifdef INCL_32
;|***       typedef struct _CLASSINFO {  /* clsi */
;|***          ULONG   flClassStyle;
;|***          PFNWP   pfnWindowProc;
;|***          ULONG   cbWindowData;
;|***       } CLASSINFO;
;|***    #else
;|***       typedef struct _CLASSINFO {  /* clsi */
;|***          ULONG   flClassStyle;
;|***          PFNWP   pfnWindowProc;
;|***          USHORT  cbWindowData;
;|***       } CLASSINFO;
;|***    #endif
;|***    typedef CLASSINFO FAR *PCLASSINFO;
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       PFNWP  APIENTRY WinSubclassWindow(HWND hwnd,
;|***                                         PFNWP pfnwp);
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    #ifdef INCL_32
;|***       LONG    APIENTRY WinQueryClassName(HWND hwnd,
;|***                                          LONG cchMax,
;|***                                          PCH pch);
;|***    #else
;|***       SHORT  APIENTRY WinQueryClassName(HWND hwnd,
;|***                                         SHORT cchMax,
;|***                                         PCH pch);
;|***    #endif
;|***    BOOL   APIENTRY WinQueryClassInfo(HAB hab,
;|***                                      PSZ pszClassName,
;|***                                      PCLASSINFO pClassInfo);
;|*** 
;|***    #ifdef INCL_32
;|***       HWND   APIENTRY WinQueryActiveWindow(HWND hwndDesktop);
;|***    #else
;|***       HWND   APIENTRY WinQueryActiveWindow(HWND hwndDesktop,
;|***                                            BOOL fLock);
;|***    #endif  /* INCL_32 */
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       BOOL   APIENTRY WinIsThreadActive(HAB hab);
;|***    #endif /* !INCL_SAADEFS */
;|***    #ifdef INCL_32
;|***       HWND   APIENTRY WinQuerySysModalWindow(HWND hwndDesktop);
;|***    #else
;|***       HWND   APIENTRY WinQuerySysModalWindow(HWND hwndDesktop,
;|***                                              BOOL fLock);
;|***    #endif /* INCL_32 */
;|*** 
;|***    #ifndef INCL_32
;|***       HWND   APIENTRY WinLockWindow(HWND hwnd,
;|***                                     BOOL fLock);
;|***       #ifndef INCL_SAADEFS
;|***          BOOL   APIENTRY WinRegisterWindowDestroy(HWND hwnd,
;|***                                                   BOOL fRegister);
;|***       #endif /* !INCL_SAADEFS */
;|*** 
;|***       SHORT   APIENTRY WinQueryWindowLockCount(HWND hwnd);
;|***    #endif /* !INCL_32 */
;|*** 
;|***    BOOL   APIENTRY WinSetSysModalWindow(HWND hwndDesktop,
;|***                                         HWND hwnd);
;|*** 
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #ifdef INCL_32
;|***          USHORT APIENTRY WinQueryWindowUShort(HWND hwnd,
;|***                                               LONG index);
;|***          BOOL   APIENTRY WinSetWindowUShort(HWND hwnd,
;|***                                             LONG index,
;|***                                             USHORT us);
;|***          ULONG  APIENTRY WinQueryWindowULong(HWND hwnd,
;|***                                              LONG index);
;|***          BOOL   APIENTRY WinSetWindowULong(HWND hwnd,
;|***                                            LONG index,
;|***                                            ULONG ul);
;|***          PVOID  APIENTRY WinQueryWindowPtr(HWND hwnd,
;|***                                            LONG index);
;|***          BOOL   APIENTRY WinSetWindowPtr(HWND hwnd,
;|***                                          LONG index,
;|***                                          PVOID p);
;|***          BOOL   APIENTRY WinSetWindowBits(HWND hwnd,
;|***                                           LONG index,
;|***                                           ULONG flData,
;|***                                           ULONG flMask);
;|***       #else
;|***          USHORT APIENTRY WinQueryWindowUShort(HWND hwnd,
;|***                                               SHORT index);
;|***          BOOL   APIENTRY WinSetWindowUShort(HWND hwnd,
;|***                                             SHORT index,
;|***                                             USHORT us);
;|***          ULONG  APIENTRY WinQueryWindowULong(HWND hwnd,
;|***                                              SHORT index);
;|***          BOOL   APIENTRY WinSetWindowULong(HWND hwnd,
;|***                                            SHORT index,
;|***                                            ULONG ul);
;|***          PVOID  APIENTRY WinQueryWindowPtr(HWND hwnd,
;|***                                            SHORT index);
;|***          BOOL   APIENTRY WinSetWindowPtr(HWND hwnd,
;|***                                          SHORT index,
;|***                                          PVOID p);
;|***          BOOL   APIENTRY WinSetWindowBits(HWND hwnd,
;|***                                           SHORT index,
;|***                                           ULONG flData,
;|***                                           ULONG flMask);
;|***       #endif
;|*** 
;|***       /*** Standard WinQueryWindowUShort/ULong() indices *******************/
;|***       #define QWS_USER                   0
;|***       #define QWS_ID                     (-1)
;|***       #define QWS_MIN                    (-1)
;|*** 
;|***       #define QWL_USER                   0
;|***       #define QWL_STYLE                  (-2)
;|***       #define QWP_PFNWP                  (-3)
;|***       #define QWL_HMQ                    (-4)
;|***       #define QWL_RESERVED               (-5)
;|*** 
;|***       #define QWL_PENDATA                (-7)
;|***       #define QWL_MIN                    (-8)
;|*** 
;|***       /*** WC_FRAME WinQueryWindowUShort/ULong() indices *******************/
;|***       #define QWL_HHEAP                  0x0004
;|***       #define QWL_HWNDFOCUSSAVE          0x0018
;|***       #define QWL_DEFBUTTON              0x0040
;|***       #define QWL_PSSCBLK                0x0048
;|***       #define QWL_PFEPBLK                0x004c
;|***       #define QWL_PSTATBLK               0x0050
;|*** 
;|***       #define QWS_FLAGS                  0x0008
;|***       #define QWS_RESULT                 0x000a
;|***       #define QWS_XRESTORE               0x000c
;|***       #define QWS_YRESTORE               0x000e
;|***       #define QWS_CXRESTORE              0x0010
;|***       #define QWS_CYRESTORE              0x0012
;|***       #define QWS_XMINIMIZE              0x0014
;|***       #define QWS_YMINIMIZE              0x0016
;|*** 
;|*** 
;|***       /*** Window enumeration **********************************************/
;|***       typedef LHANDLE HENUM;  /* henum */
;|*** 
;|***       HENUM APIENTRY WinBeginEnumWindows(HWND hwnd);
;|***       HWND  APIENTRY WinGetNextWindow(HENUM henum);
;|***       BOOL  APIENTRY WinEndEnumWindows(HENUM henum);
;|*** 
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    #ifdef INCL_32
;|***       HWND  APIENTRY WinWindowFromPoint(HWND hwnd,
;|***                                         PPOINTL pptl,
;|***                                         BOOL fChildren);
;|*** 
;|***       BOOL  APIENTRY WinMapWindowPoints(HWND hwndFrom,
;|***                                         HWND hwndTo,
;|***                                         PPOINTL prgptl,
;|***                                         LONG cwpt);
;|***    #else
;|***       HWND  APIENTRY WinWindowFromPoint(HWND hwnd,
;|***                                         PPOINTL pptl,
;|***                                         BOOL fChildren,
;|***                                         BOOL fLock);
;|*** 
;|***       BOOL  APIENTRY WinMapWindowPoints(HWND hwndFrom,
;|***                                         HWND hwndTo,
;|***                                         PPOINTL prgptl,
;|***                                         SHORT cwpt);
;|***    #endif /* INCL_32 */
;|*** 
;|*** 
;|***    /* More window painting functions */
;|*** 
;|***    BOOL  APIENTRY WinValidateRect(HWND hwnd,
;|***                                   PRECTL prcl,
;|***                                   BOOL fIncludeChildren);
;|*** 
;|***    BOOL  APIENTRY WinValidateRegion(HWND hwnd,
;|***                                     HRGN hrgn,
;|***                                     BOOL fIncludeChildren);
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       HWND  APIENTRY WinWindowFromDC(HDC hdc);
;|*** 
;|***       HDC   APIENTRY WinQueryWindowDC(HWND hwnd);
;|*** 
;|***       HPS   APIENTRY WinGetScreenPS(HWND hwndDesktop);
;|*** 
;|***       BOOL  APIENTRY WinLockWindowUpdate(HWND hwndDesktop,
;|***                                          HWND hwndLockUpdate);
;|*** 
;|***       BOOL  APIENTRY WinLockVisRegions(HWND hwndDesktop,
;|***                                        BOOL fLock);
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    BOOL  APIENTRY WinQueryUpdateRect(HWND hwnd,
;|***                                      PRECTL prcl);
;|*** 
;|***    #ifdef INCL_32
;|***       LONG APIENTRY WinQueryUpdateRegion(HWND hwnd,
;|***                                          HRGN hrgn);
;|*** 
;|***       LONG APIENTRY WinExcludeUpdateRegion(HPS hps,
;|***                                            HWND hwnd);
;|***    #else
;|***       SHORT APIENTRY WinQueryUpdateRegion(HWND hwnd,
;|***                                           HRGN hrgn);
;|*** 
;|***       SHORT APIENTRY WinExcludeUpdateRegion(HPS hps,
;|***                                             HWND hwnd);
;|***    #endif
;|*** 
;|*** #endif /* INCL_WINWINDOWMGR */
;|*** 
;|*** #if (defined(INCL_WINMESSAGEMGR) || !defined(INCL_NOCOMMON))
;|*** 
;|***    /* QMSG structure */
;|***    #ifdef INCL_32
;|***       typedef struct _QMSG {  /* qmsg */
;|***          HWND    hwnd;
;|***          ULONG   msg;
;|***          MPARAM  mp1;
;|***          MPARAM  mp2;
;|***          ULONG   time;
;|***          POINTL  ptl;
;|***          ULONG   reserved;
;|***       } QMSG;
;|***    #else
;|***       typedef struct _QMSG {  /* qmsg */
;|***          HWND    hwnd;
;|***          USHORT  msg;
;|***          MPARAM  mp1;
;|***          MPARAM  mp2;
;|***          ULONG   time;
;|***          POINTL  ptl;
;|***       } QMSG;
;|***    #endif
;|***    typedef QMSG FAR *PQMSG;
;|*** 
;|***    /*** Standard Window Messages *******************************************/
;|***    #define WM_NULL                    0x0000
;|***    #define WM_CREATE                  0x0001
;|***    #define WM_DESTROY                 0x0002
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #ifndef INCL_32
;|***          #define WM_OTHERWINDOWDESTROYED    0x0003
;|***       #endif
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    #define WM_ENABLE                  0x0004
;|***    #define WM_SHOW                    0x0005
;|***    #define WM_MOVE                    0x0006
;|***    #define WM_SIZE                    0x0007
;|***    #define WM_ADJUSTWINDOWPOS         0x0008
;|*** 
;|***    #define WM_CALCVALIDRECTS          0x0009
;|*** 
;|***    #define WM_SETWINDOWPARAMS         0x000a
;|***    #define WM_QUERYWINDOWPARAMS       0x000b
;|***    #define WM_HITTEST                 0x000c
;|***    #define WM_ACTIVATE                0x000d
;|***    #define WM_SETFOCUS                0x000f
;|***    #define WM_SETSELECTION            0x0010
;|*** 
;|***    /* language support Winproc */
;|***    #define WM_PPAINT                  0x0011
;|***    #define WM_PSETFOCUS               0x0012
;|***    #define WM_PSYSCOLORCHANGE         0x0013
;|***    #define WM_PSIZE                   0x0014
;|***    #define WM_PACTIVATE               0x0015
;|***    #define WM_PCONTROL                0x0016
;|*** 
;|***    #define WM_COMMAND                 0x0020
;|***    #define WM_SYSCOMMAND              0x0021
;|***    #define WM_HELP                    0x0022
;|***    #define WM_PAINT                   0x0023
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #define WM_TIMER                0x0024
;|***       #define WM_SEM1                 0x0025
;|***       #define WM_SEM2                 0x0026
;|***       #define WM_SEM3                 0x0027
;|***       #define WM_SEM4                 0x0028
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    #define WM_CLOSE                   0x0029
;|***    #define WM_QUIT                    0x002a
;|***    #define WM_SYSCOLORCHANGE          0x002b
;|***    #define WM_SYSVALUECHANGED         0x002d
;|***    #define WM_APPTERMINATENOTIFY      0x002e
;|***    #define WM_PRESPARAMCHANGED        0x002f
;|*** 
;|***    /* Control notification messages */
;|***    #define WM_CONTROL                 0x0030
;|***    #define WM_VSCROLL                 0x0031
;|***    #define WM_HSCROLL                 0x0032
;|***    #define WM_INITMENU                0x0033
;|***    #define WM_MENUSELECT              0x0034
;|***    #define WM_MENUEND                 0x0035
;|***    #define WM_DRAWITEM                0x0036
;|***    #define WM_MEASUREITEM             0x0037
;|***    #define WM_CONTROLPOINTER          0x0038
;|***    #define WM_QUERYDLGCODE            0x003a
;|***    #define WM_INITDLG                 0x003b
;|***    #define WM_SUBSTITUTESTRING        0x003c
;|***    #define WM_MATCHMNEMONIC           0x003d
;|***    #define WM_SAVEAPPLICATION         0x003e
;|*** 
;|***    #ifdef INCL_16
;|***       #define WM_CONTROLHEAP          0x0039
;|***    #endif /* INCL_16 */
;|*** 
;|***    /*************************************************************************
;|***    * Reserve a range of messages for help manager.  This range includes
;|***    * public messages, defined below, and private ones, which need to be
;|***    * reserved here to prevent clashing with application messages
;|***    *************************************************************************/
;|*** 
;|***    #define WM_HELPBASE                0x0F00 /* Start of msgs for help manager   */
;|***    #define WM_HELPTOP                 0x0FFF /* End of msgs for help manager     */
;|*** 
;|***    #define WM_USER                    0x1000
;|*** 
;|***    /*** WM_COMMAND msg source codes ****************************************/
;|***    #define CMDSRC_PUSHBUTTON      1
;|***    #define CMDSRC_MENU            2
;|***    #define CMDSRC_ACCELERATOR     3
;|***    #define CMDSRC_FONTDLG         4
;|***    #define CMDSRC_FILEDLG         5
;|***    #define CMDSRC_PRINTDLG        6
;|***    #define CMDSRC_COLORDLG        7
;|***    #define CMDSRC_OTHER           0
;|*** 
;|***    #pragma pack(1) /* force structure alignment packing */
;|*** 
;|***    /*
;|***    * The following structure and macro are used to access the
;|***    * WM_COMMAND, WM_HELP, and WM_SYSCOMMAND message parameters:
;|***    */
;|***    #ifdef INCL_32
;|***       typedef struct _COMMANDMSG {  /* commandmsg */
;|***          USHORT  cmd;              /* mp1 */
;|***          USHORT  unused;
;|***          USHORT  source;           /* mp2 */
;|***          USHORT  fMouse;
;|***       } CMDMSG;
;|***       typedef CMDMSG FAR *PCMDMSG;
;|*** 
;|***       #define COMMANDMSG(pmsg) \
;|***       ((PCMDMSG)((PBYTE)pmsg + sizeof(MPARAM) ))
;|***    #else
;|***       typedef struct _COMMANDMSG {  /* commandmsg */
;|***          USHORT  source;           /* mp2 */
;|***          USHORT  fMouse;
;|***          USHORT  cmd;              /* mp1 */
;|***          USHORT  unused;
;|***       } CMDMSG;
;|***       typedef CMDMSG FAR *PCMDMSG;
;|*** 
;|***       #define COMMANDMSG(pmsg) \
;|***       ((PCMDMSG)((PBYTE)pmsg - sizeof(MPARAM) * 2))
;|***    #endif
;|*** 
;|***    #pragma pack()  /* restore packing to default */
;|*** 
;|***    /*** The following structure is used by the WinQueryQueueInfo() routine */
;|***    #ifdef INCL_32
;|***       typedef struct _MQINFO {  /* mqi */
;|***          ULONG   cb;
;|***          PID     pid;
;|***          TID     tid;
;|***          ULONG   cmsgs;
;|***          PVOID   pReserved;
;|***       } MQINFO;
;|***    #else
;|***       typedef struct _MQINFO {     /* mqi */
;|***          USHORT  cb;
;|***          USHORT  pid;
;|***          USHORT  tid;
;|***          USHORT  cmsgs;
;|***          PVOID   pReserved;
;|***       } MQINFO;
;|***    #endif
;|***    typedef MQINFO FAR *PMQINFO;
;|*** 
;|***    #ifdef INCL_32
;|***       MRESULT APIENTRY WinSendMsg(HWND hwnd,
;|***                                   ULONG msg,
;|***                                   MPARAM mp1,
;|***                                   MPARAM mp2);
;|*** 
;|***       HMQ     APIENTRY WinCreateMsgQueue(HAB hab,
;|***                                          LONG cmsg);
;|*** 
;|***       BOOL    APIENTRY WinDestroyMsgQueue(HMQ hmq);
;|*** 
;|***       BOOL    APIENTRY WinQueryQueueInfo(HMQ hmq,
;|***                                          PMQINFO pmqi,
;|***                                          ULONG cbCopy);
;|***    #else
;|***       MRESULT APIENTRY WinSendMsg(HWND hwnd,
;|***                                   USHORT msg,
;|***                                   MPARAM mp1,
;|***                                   MPARAM mp2);
;|*** 
;|***       HMQ     APIENTRY WinCreateMsgQueue(HAB hab,
;|***                                          SHORT cmsg);
;|*** 
;|***       BOOL    APIENTRY WinDestroyMsgQueue(HMQ hmq);
;|*** 
;|***       BOOL    APIENTRY WinQueryQueueInfo(HMQ hmq,
;|***                                          PMQINFO pmqi,
;|***                                          USHORT cbCopy);
;|***    #endif
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       BOOL    APIENTRY WinCancelShutdown(HMQ hmq,
;|***                                          BOOL fCancelAlways);
;|***    #endif /* INCL_SAADEFS */
;|*** 
;|***    #ifdef INCL_32
;|***       BOOL    APIENTRY WinGetMsg(HAB hab,
;|***                                  PQMSG pqmsg,
;|***                                  HWND hwndFilter,
;|***                                  ULONG msgFilterFirst,
;|***                                  ULONG msgFilterLast);
;|*** 
;|***       BOOL    APIENTRY WinPeekMsg(HAB hab,
;|***                                   PQMSG pqmsg,
;|***                                   HWND hwndFilter,
;|***                                   ULONG msgFilterFirst,
;|***                                   ULONG msgFilterLast,
;|***                                   ULONG fl);
;|*** 
;|***       MRESULT APIENTRY WinDispatchMsg(HAB hab,
;|***                                       PQMSG pqmsg);
;|*** 
;|***       BOOL    APIENTRY WinPostMsg(HWND hwnd,
;|***                                   ULONG msg,
;|***                                   MPARAM mp1,
;|***                                   MPARAM mp2);
;|*** 
;|***       BOOL    APIENTRY WinRegisterUserMsg(HAB hab,
;|***                                           ULONG msgid,
;|***                                           LONG datatype1,
;|***                                           LONG dir1,
;|***                                           LONG datatype2,
;|***                                           LONG dir2,
;|***                                           LONG datatyper);
;|*** 
;|***       BOOL    APIENTRY WinRegisterUserDatatype(HAB hab,
;|***                                                LONG datatype,
;|***                                                LONG count,
;|***                                                PLONG types);
;|***       BOOL    APIENTRY WinSetMsgMode(HAB hab,
;|***                                      PSZ classname,
;|***                                      LONG control);
;|*** 
;|***       BOOL    APIENTRY WinSetSynchroMode(HAB hab,
;|***                                          LONG mode);
;|***    #else
;|***       BOOL    APIENTRY WinGetMsg(HAB hab,
;|***                                  PQMSG pqmsg,
;|***                                  HWND hwndFilter,
;|***                                  USHORT msgFilterFirst,
;|***                                  USHORT msgFilterLast);
;|*** 
;|***       BOOL    APIENTRY WinPeekMsg(HAB hab,
;|***                                   PQMSG pqmsg,
;|***                                   HWND hwndFilter,
;|***                                   USHORT msgFilterFirst,
;|***                                   USHORT msgFilterLast,
;|***                                   USHORT fs);
;|*** 
;|***       MRESULT APIENTRY WinDispatchMsg(HAB hab,
;|***                                       PQMSG pqmsg);
;|*** 
;|***       BOOL    APIENTRY WinPostMsg(HWND hwnd,
;|***                                   USHORT msg,
;|***                                   MPARAM mp1,
;|***                                   MPARAM mp2);
;|*** 
;|***       BOOL    APIENTRY WinRegisterUserMsg(HAB hab,
;|***                                           USHORT msgid,
;|***                                           SHORT datatype1,
;|***                                           SHORT dir1,
;|***                                           SHORT datatype2,
;|***                                           SHORT dir2,
;|***                                           SHORT datatyper);
;|*** 
;|***       BOOL    APIENTRY WinRegisterUserDatatype(HAB hab,
;|***                                                SHORT datatype,
;|***                                                SHORT count,
;|***                                                PSHORT types);
;|*** 
;|***       BOOL    APIENTRY WinSetMsgMode(HAB hab,
;|***                                      PSZ classname,
;|***                                      SHORT control);
;|*** 
;|***       BOOL    APIENTRY WinSetSynchroMode(HAB hab,
;|***                                          SHORT mode);
;|***    #endif
;|*** 
;|***    /*** WinPeekMsg() constants *********************************************/
;|***    #define PM_REMOVE                  0x0001
;|***    #define PM_NOREMOVE                0x0000
;|*** 
;|***    /*** WinRegisterUserDatatype datatypes defined in separate file *********/
;|***    #ifdef INCL_WINTYPES
;|***       #include <pmtypes.h>
;|***    #endif /*INCL_WINTYPES*/
;|*** 
;|***    /*** WinRegisterUserMsg direction codes *********************************/
;|***    #define RUM_IN                     1
;|***    #define RUM_OUT                    2
;|***    #define RUM_INOUT                  3
;|*** 
;|***    /*** WinSetMsgMode constants *******************************************/
;|***    #define SMD_DELAYED                0x0001
;|***    #define SMD_IMMEDIATE              0x0002
;|*** 
;|***    /*** WinSetSynchroMode constants ***************************************/
;|***    #define SSM_SYNCHRONOUS            0x0001
;|***    #define SSM_ASYNCHRONOUS           0x0002
;|***    #define SSM_MIXED                  0x0003
;|*** 
;|*** #endif /* WINMESSAGEMGR || !INCL_NOCOMMON       */
;|*** 
;|*** #ifdef INCL_WINMESSAGEMGR
;|*** 
;|***    /*** WM_CALCVALIDRECTS return flags *************************************/
;|***    #define CVR_ALIGNLEFT               0x0001
;|***    #define CVR_ALIGNBOTTOM             0x0002
;|***    #define CVR_ALIGNRIGHT              0x0004
;|***    #define CVR_ALIGNTOP                0x0008
;|***    #define CVR_REDRAW                  0x0010
;|*** 
;|***    /*** WM_HITTEST return codes ********************************************/
;|***    #define HT_NORMAL                   0
;|***    #define HT_TRANSPARENT              (-1)
;|***    #define HT_DISCARD                  (-2)
;|***    #define HT_ERROR                    (-3)
;|*** 
;|***    /*** WM_SET/QUERYWINDOWPARAMS structures and flags **********************/
;|***    #ifdef INCL_32
;|***       typedef struct _WNDPARAMS {  /* wprm */
;|***          ULONG   fsStatus;
;|***          ULONG   cchText;
;|***          PSZ     pszText;
;|***          ULONG   cbPresParams;
;|***          PVOID   pPresParams;
;|***          ULONG   cbCtlData;
;|***          PVOID   pCtlData;
;|***       } WNDPARAMS;
;|***    #else
;|***       typedef struct _WNDPARAMS {  /* wprm */
;|***          USHORT  fsStatus;
;|***          USHORT  cchText;
;|***          PSZ     pszText;
;|***          USHORT  cbPresParams;
;|***          PVOID   pPresParams;
;|***          USHORT  cbCtlData;
;|***          PVOID   pCtlData;
;|***       } WNDPARAMS;
;|***    #endif
;|***    typedef WNDPARAMS FAR *PWNDPARAMS;
;|*** 
;|***    #define WPM_TEXT                   0x0001
;|***    #define WPM_CTLDATA                0x0002
;|***    #define WPM_PRESPARAMS             0x0004
;|***    #define WPM_CCHTEXT                0x0008
;|***    #define WPM_CBCTLDATA              0x0010
;|***    #define WPM_CBPRESPARAMS           0x0020
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       BOOL    APIENTRY WinInSendMsg(HAB hab);
;|***    #endif /* INCL_SAADEFS */
;|*** 
;|***    #ifdef INCL_32
;|***       BOOL    APIENTRY WinBroadcastMsg(HWND hwnd,
;|***                                        ULONG msg,
;|***                                        MPARAM mp1,
;|***                                        MPARAM mp2,
;|***                                        ULONG rgf);
;|***    #else
;|***       BOOL    APIENTRY WinBroadcastMsg(HWND hwnd,
;|***                                        USHORT msg,
;|***                                        MPARAM mp1,
;|***                                        MPARAM mp2,
;|***                                        USHORT rgf);
;|***    #endif
;|*** 
;|***    /*** WinBroadcastMsg codes **********************************************/
;|***    #define BMSG_POST                  0x0000
;|***    #define BMSG_SEND                  0x0001
;|***    #define BMSG_POSTQUEUE             0x0002
;|***    #define BMSG_DESCENDANTS           0x0004
;|***    #define BMSG_FRAMEONLY             0x0008
;|*** 
;|***    #ifdef INCL_32
;|***       BOOL  APIENTRY WinWaitMsg(HAB hab,
;|***                                 ULONG msgFirst,
;|***                                 ULONG msgLast);
;|***    #else
;|***       BOOL  APIENTRY WinWaitMsg(HAB hab,
;|***                                 USHORT msgFirst,
;|***                                 USHORT msgLast);
;|***    #endif
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       ULONG APIENTRY WinQueryQueueStatus(HWND hwndDesktop);
;|*** 
;|***       /*** WinQueryQueueStatus() constants *********************************/
;|***       #define QS_KEY                     0x0001
;|***       #define QS_MOUSEBUTTON             0x0002
;|***       #define QS_MOUSEMOVE               0x0004
;|***       #define QS_MOUSE                   0x0006   /* QS_MOUSEMOVE|QS_MOUSEBUTTON */
;|***       #define QS_TIMER                   0x0008
;|***       #define QS_PAINT                   0x0010
;|***       #define QS_POSTMSG                 0x0020
;|***       #define QS_SEM1                    0x0040
;|***       #define QS_SEM2                    0x0080
;|***       #define QS_SEM3                    0x0100
;|***       #define QS_SEM4                    0x0200
;|***       #define QS_SENDMSG                 0x0400
;|***       #define QS_MSGINPUT                0x0800
;|*** 
;|***       BOOL  APIENTRY WinQueryMsgPos(HAB hab,
;|***                                     PPOINTL pptl);
;|*** 
;|***       ULONG APIENTRY WinQueryMsgTime(HAB hab);
;|*** 
;|***       #ifdef INCL_32
;|***          #ifndef INCL_DOSSEMAPHORES
;|***             #ifndef __HEV__
;|***                #define __HEV__
;|***                typedef ULONG HEV;    /* hev */
;|***             #endif
;|***             typedef ULONG HMTX;   /* hmtx */
;|***             typedef ULONG HMUX;   /* hmux */
;|***          #endif
;|*** 
;|***          APIRET APIENTRY WinWaitEventSem(HEV hev,
;|***                                          ULONG ulTimeout);
;|*** 
;|***          APIRET APIENTRY WinRequestMutexSem(HMTX hmtx,
;|***                                             ULONG ulTimeout);
;|*** 
;|***          APIRET APIENTRY WinWaitMuxWaitSem(HMUX hmux,
;|***                                            ULONG ulTimeout,
;|***                                            PULONG pulUser);
;|*** 
;|***       #else
;|***          USHORT APIENTRY WinMsgSemWait(HSEM hsem,
;|***                                        LONG dtTimeout);
;|*** 
;|***          USHORT APIENTRY WinMsgMuxSemWait(PUSHORT pisemCleared,
;|***                                           PVOID pmxsl,
;|***                                           LONG dtTimeout);
;|***       #endif
;|*** 
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    #ifdef INCL_32
;|***       BOOL  APIENTRY WinPostQueueMsg(HMQ hmq,
;|***                                      ULONG msg,
;|***                                      MPARAM mp1,
;|***                                      MPARAM mp2);
;|***    #else
;|***       BOOL  APIENTRY WinPostQueueMsg(HMQ hmq,
;|***                                      USHORT msg,
;|***                                      MPARAM mp1,
;|***                                      MPARAM mp2);
;|***    #endif
;|*** 
;|***    /*** WinSetMsgInterest()/WinSetClassMsgInterest() constants *************/
;|***    #define SMIM_ALL                   0x0EFF
;|***    #define SMI_NOINTEREST             0x0001
;|***    #define SMI_INTEREST               0x0002
;|***    #define SMI_RESET                  0x0004
;|***    #define SMI_AUTODISPATCH           0x0008
;|*** 
;|***    #ifdef INCL_32
;|***       BOOL  APIENTRY WinSetMsgInterest(HWND hwnd,
;|***                                        ULONG msg_class,
;|***                                        LONG control);
;|*** 
;|***       BOOL  APIENTRY WinSetClassMsgInterest(HAB hab,
;|***                                             PSZ pszClassName,
;|***                                             ULONG msg_class,
;|***                                             LONG control);
;|***    #else
;|***       BOOL  APIENTRY WinSetMsgInterest(HWND hwnd,
;|***                                        USHORT msg_class,
;|***                                        SHORT control);
;|*** 
;|***       BOOL  APIENTRY WinSetClassMsgInterest(HAB hab,
;|***                                             PSZ pszClassName,
;|***                                             USHORT msg_class,
;|***                                             SHORT control);
;|***    #endif
;|*** 
;|*** #endif /* INCL_WINMESSAGEMGR */
;|*** 
;|*** /*** Keyboard and mouse ****************************************************/
;|*** 
;|*** #if (defined(INCL_WININPUT) || !defined(INCL_NOCOMMON))
;|*** 
;|***    /*** Keyboard and mouse input COMMON subsection *************************/
;|***    BOOL  APIENTRY WinSetFocus(HWND hwndDesktop,
;|***                               HWND hwndSetFocus);
;|*** 
;|***    #ifdef INCL_32
;|***       BOOL  APIENTRY WinFocusChange(HWND hwndDesktop,
;|***                                     HWND hwndSetFocus,
;|***                                     ULONG flFocusChange);
;|*** 
;|***       BOOL  EXPENTRY WinLockupSystem(HAB hab);
;|*** 
;|***       BOOL  EXPENTRY WinUnlockSystem(HAB hab, PSZ pszPassword);
;|***    #else
;|***       BOOL  APIENTRY WinFocusChange(HWND hwndDesktop,
;|***                                     HWND hwndSetFocus,
;|***                                     USHORT fsFocusChange);
;|***    #endif
;|*** 
;|***    #define FC_NOSETFOCUS              0x0001
;|***    #define FC_NOBRINGTOTOP            FC_NOSETFOCUS
;|***    #define FC_NOLOSEFOCUS             0x0002
;|***    #define FC_NOBRINGTOPFIRSTWINDOW   FC_NOLOSEFOCUS
;|***    #define FC_NOSETACTIVE             0x0004
;|***    #define FC_NOLOSEACTIVE            0x0008
;|***    #define FC_NOSETSELECTION          0x0010
;|***    #define FC_NOLOSESELECTION         0x0020
;|*** 
;|***    #define QFC_NEXTINCHAIN            0x0001
;|***    #define QFC_ACTIVE                 0x0002
;|***    #define QFC_FRAME                  0x0003
;|***    #define QFC_SELECTACTIVE           0x0004
;|***    #define QFC_PARTOFCHAIN            0x0005
;|*** 
;|*** #endif  /* Keyboard and mouse input COMMON subsection */
;|*** 
;|*** /*
;|*** ** @86823; added WM_VRNDISABLED, WM_VRNENABLED,
;|*** **               WinSetVisibleRegionNotify, WinQueryVisibleRegion
;|*** */
;|***    #define WM_VRNDISABLED             0x007e
;|***    #define WM_VRNENABLED              0x007f
;|*** 
;|***    BOOL APIENTRY WinSetVisibleRegionNotify( HWND hwnd, BOOL fEnable);
;|*** 
;|***    ULONG APIENTRY WinQueryVisibleRegion( HWND hwnd, HRGN hrgn);
;|*** 
;|*** 
;|*** #ifdef INCL_WININPUT
;|***    #ifndef INCL_SAADEFS
;|***       BOOL  APIENTRY WinSetCapture(HWND hwndDesktop,
;|***                                    HWND hwnd);
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    #ifdef INCL_32
;|***       HWND  APIENTRY WinQueryCapture(HWND hwndDesktop);
;|***    #else
;|***       HWND  APIENTRY WinQueryCapture(HWND hwndDesktop,
;|***                                      BOOL fLock);
;|***    #endif  /* INCL_32 */
;|*** 
;|***    #ifdef INCL_32
;|***       BOOL  APIENTRY WinCheckInput(HAB hab);
;|***    #endif
;|*** 
;|***    /*** Mouse input messages ***********************************************/
;|***    #ifndef INCL_SAADEFS
;|***       #define WM_MOUSEFIRST           0x0070
;|***       #define WM_MOUSELAST            0x0079
;|***       #define WM_BUTTONCLICKFIRST     0x0071
;|***       #define WM_BUTTONCLICKLAST      0x0079
;|***    #endif /* !INCL_SAADEFS */
;|***    #define WM_MOUSEMOVE               0x0070
;|*** 
;|***    #define WM_BUTTON1DOWN             0x0071
;|*** 
;|***    #define WM_BUTTON1UP               0x0072
;|***    #define WM_BUTTON1DBLCLK           0x0073
;|***    #define WM_BUTTON2DOWN             0x0074
;|***    #define WM_BUTTON2UP               0x0075
;|***    #define WM_BUTTON2DBLCLK           0x0076
;|***    #ifndef INCL_SAADEFS
;|***       #define WM_BUTTON3DOWN          0x0077
;|***       #define WM_BUTTON3UP            0x0078
;|***       #define WM_BUTTON3DBLCLK        0x0079
;|*** 
;|***       #define WM_MOUSEMAP             0x007D
;|*** 
;|***       #define WM_EXTMOUSEFIRST        0x0410
;|***       #define WM_EXTMOUSELAST         0x0419
;|*** 
;|***       #define WM_CHORD                0x0410
;|***       #define WM_BUTTON1MOTIONSTART   0x0411
;|***       #define WM_BUTTON1MOTIONEND     0x0412
;|***       #define WM_BUTTON1CLICK         0x0413
;|***       #define WM_BUTTON2MOTIONSTART   0x0414
;|***       #define WM_BUTTON2MOTIONEND     0x0415
;|***       #define WM_BUTTON2CLICK         0x0416
;|***       #define WM_BUTTON3MOTIONSTART   0x0417
;|***       #define WM_BUTTON3MOTIONEND     0x0418
;|***       #define WM_BUTTON3CLICK         0x0419
;|*** 
;|***       /* Messages 0x041A - 0x041F are reserved */
;|*** 
;|***       #define WM_MOUSETRANSLATEFIRST  0x0420
;|***       #define WM_MOUSETRANSLATELAST   0x0428
;|*** 
;|***       #define WM_BEGINDRAG            0x0420
;|***       #define WM_ENDDRAG              0x0421
;|***       #define WM_SINGLESELECT         0x0422
;|***       #define WM_OPEN                 0x0423
;|***       #define WM_CONTEXTMENU          0x0424
;|***       #define WM_CONTEXTHELP          0x0425
;|***       #define WM_TEXTEDIT             0x0426
;|***       #define WM_BEGINSELECT          0x0427
;|***       #define WM_ENDSELECT            0x0428
;|***       #define WM_PICKUP               0x0429
;|*** 
;|***       #define WM_PENFIRST             0x04C0
;|***       #define WM_PENLAST              0x04FF
;|***       #define WM_MMPMFIRST            0x0500
;|***       #define WM_MMPMLAST             0x05FF
;|*** 
;|***       /* Messages 0x0BD0 - 0x0BFF are reserved */
;|***       /* for bidirectional language support.   */
;|*** 
;|***       #define  WM_BIDI_FIRST           0x0BD0
;|***       #define  WM_BIDI_LAST            0x0BFF
;|*** 
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    #ifdef INCL_32
;|***       HWND  APIENTRY WinQueryFocus(HWND hwndDesktop);
;|***    #else
;|***       HWND  APIENTRY WinQueryFocus(HWND hwndDesktop,
;|***                                    BOOL fLock);
;|***    #endif
;|*** 
;|*** 
;|***    /*** Key/Character input messages ***************************************/
;|***    #define WM_CHAR                    0x007a
;|***    #define WM_VIOCHAR                 0x007b
;|*** 
;|***    /* WM_CHAR fs field bits */
;|***    #define KC_NONE                    0x0000     /* Reserved */
;|***    #define KC_CHAR                    0x0001
;|***    #define KC_VIRTUALKEY              0x0002
;|***    #define KC_SCANCODE                0x0004
;|*** 
;|***    #define KC_SHIFT                   0x0008
;|***    #define KC_CTRL                    0x0010
;|***    #define KC_ALT                     0x0020
;|***    #define KC_KEYUP                   0x0040
;|***    #define KC_PREVDOWN                0x0080
;|***    #define KC_LONEKEY                 0x0100
;|***    #define KC_DEADKEY                 0x0200
;|***    #define KC_COMPOSITE               0x0400
;|***    #define KC_INVALIDCOMP             0x0800
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #define KC_TOGGLE               0x1000
;|***       #define KC_INVALIDCHAR          0x2000
;|***       #define KC_DBCSRSRVD1           0x4000
;|***       #define KC_DBCSRSRVD2           0x8000
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    #pragma pack(1) /* force structure alignment packing */
;|*** 
;|***    /*
;|***    * The following structure and macro are used to access the
;|***    * WM_MOUSEMOVE, and WM_BUTTON message parameters
;|***    */
;|***    #ifdef INCL_32
;|***       typedef struct _MOUSEMSG {  /* mousemsg */
;|***          SHORT   x;             /* mp1      */
;|***          SHORT   y;
;|***          USHORT  codeHitTest;   /* mp2      */
;|***          USHORT  fsInp;         /* input flags */
;|***       } MSEMSG;
;|***       typedef MSEMSG FAR *PMSEMSG;
;|*** 
;|***       #define MOUSEMSG(pmsg) \
;|***       ((PMSEMSG)((PBYTE)pmsg + sizeof(MPARAM) ))
;|*** 
;|***       typedef struct _CHARMSG {  /* charmsg */
;|***          USHORT  fs;           /* mp1     */
;|***          UCHAR   cRepeat;
;|***          UCHAR   scancode;
;|***          USHORT  chr;          /* mp2     */
;|***          USHORT  vkey;
;|***       } CHRMSG;
;|***       typedef CHRMSG FAR *PCHRMSG;
;|*** 
;|***       #define CHARMSG(pmsg) \
;|***       ((PCHRMSG)((PBYTE)pmsg + sizeof(MPARAM) ))
;|***    #else
;|***       typedef struct _MOUSEMSG {  /* mousemsg */
;|***          USHORT  codeHitTest;   /* mp2      */
;|***          USHORT  fsInp;         /* input flags */
;|***          SHORT   x;             /* mp1      */
;|***          SHORT   y;
;|***       } MSEMSG;
;|***       typedef MSEMSG FAR *PMSEMSG;
;|*** 
;|***       #define MOUSEMSG(pmsg) \
;|***       ((PMSEMSG)((PBYTE)pmsg - sizeof(MPARAM) * 2))
;|*** 
;|***       typedef struct _CHARMSG {  /* charmsg */
;|***          USHORT  chr;          /* mp2     */
;|***          USHORT  vkey;
;|***          USHORT  fs;           /* mp1     */
;|***          UCHAR   cRepeat;
;|***          UCHAR   scancode;
;|***       } CHRMSG;
;|***       typedef CHRMSG FAR *PCHRMSG;
;|*** 
;|***       #define CHARMSG(pmsg) \
;|***       ((PCHRMSG)((PBYTE)pmsg - sizeof(MPARAM) * 2))
;|***    #endif
;|*** 
;|***    #pragma pack()  /* restore packing to default */
;|*** 
;|***    #define INP_NONE                   0x0000
;|***    #define INP_KBD                    0x0001
;|***    #define INP_MULT                   0x0002
;|***    #define INP_RES2                   0x0004
;|***    #define INP_SHIFT                  0x0008
;|***    #define INP_CTRL                   0x0010
;|***    #define INP_ALT                    0x0020
;|***    #define INP_RES3                   0x0040
;|***    #define INP_RES4                   0x0080
;|***    #define INP_IGNORE                 0xFFFF
;|*** 
;|***    /*** Virtual key values *************************************************/
;|***    #define VK_BUTTON1                 0x01
;|***    #define VK_BUTTON2                 0x02
;|***    #define VK_BUTTON3                 0x03
;|***    #define VK_BREAK                   0x04
;|***    #define VK_BACKSPACE               0x05
;|***    #define VK_TAB                     0x06
;|***    #define VK_BACKTAB                 0x07
;|***    #define VK_NEWLINE                 0x08
;|***    #define VK_SHIFT                   0x09
;|***    #define VK_CTRL                    0x0A
;|***    #define VK_ALT                     0x0B
;|***    #define VK_ALTGRAF                 0x0C
;|***    #define VK_PAUSE                   0x0D
;|***    #define VK_CAPSLOCK                0x0E
;|***    #define VK_ESC                     0x0F
;|***    #define VK_SPACE                   0x10
;|***    #define VK_PAGEUP                  0x11
;|***    #define VK_PAGEDOWN                0x12
;|***    #define VK_END                     0x13
;|***    #define VK_HOME                    0x14
;|***    #define VK_LEFT                    0x15
;|***    #define VK_UP                      0x16
;|***    #define VK_RIGHT                   0x17
;|***    #define VK_DOWN                    0x18
;|***    #define VK_PRINTSCRN               0x19
;|***    #define VK_INSERT                  0x1A
;|***    #define VK_DELETE                  0x1B
;|***    #define VK_SCRLLOCK                0x1C
;|***    #define VK_NUMLOCK                 0x1D
;|***    #define VK_ENTER                   0x1E
;|***    #define VK_SYSRQ                   0x1F
;|***    #define VK_F1                      0x20
;|***    #define VK_F2                      0x21
;|***    #define VK_F3                      0x22
;|***    #define VK_F4                      0x23
;|***    #define VK_F5                      0x24
;|***    #define VK_F6                      0x25
;|***    #define VK_F7                      0x26
;|***    #define VK_F8                      0x27
;|***    #define VK_F9                      0x28
;|***    #define VK_F10                     0x29
;|***    #define VK_F11                     0x2A
;|***    #define VK_F12                     0x2B
;|***    #define VK_F13                     0x2C
;|***    #define VK_F14                     0x2D
;|***    #define VK_F15                     0x2E
;|***    #define VK_F16                     0x2F
;|***    #define VK_F17                     0x30
;|***    #define VK_F18                     0x31
;|***    #define VK_F19                     0x32
;|***    #define VK_F20                     0x33
;|***    #define VK_F21                     0x34
;|***    #define VK_F22                     0x35
;|***    #define VK_F23                     0x36
;|***    #define VK_F24                     0x37
;|***    #define VK_ENDDRAG                 0x38
;|***    #define VK_CLEAR                   0x39
;|***    #define VK_EREOF                   0x3A
;|***    #define VK_PA1                     0x3B
;|***    #define VK_ATTN                    0x3C
;|***    #define VK_CRSEL                   0x3D
;|***    #define VK_EXSEL                   0x3E
;|***    #define VK_COPY                    0x3F
;|***    #define VK_BLK1                    0x40
;|***    #define VK_BLK2                    0x41
;|*** 
;|*** 
;|***    #define VK_MENU                    VK_F10
;|***    #ifdef INCL_NLS
;|***       #define VK_DBCSFIRST            0x0080
;|***       #define VK_DBCSLAST             0x00ff
;|*** 
;|***       /* VK_ vluaes 0xE0 - 0xFF are reserved   */
;|***       /* for bidirectional language support.   */
;|*** 
;|***       #define VK_BIDI_FIRST           0xE0
;|***       #define VK_BIDI_LAST            0xFF
;|*** 
;|***    #endif /* INCL_NLS */
;|*** 
;|***    #define VK_USERFIRST               0x0100
;|***    #define VK_USERLAST                0x01ff
;|*** 
;|***    #ifndef INCL_SAADEFS
;|*** 
;|***       #ifdef INCL_32
;|***          LONG APIENTRY WinGetKeyState(HWND hwndDesktop,
;|***                                       LONG vkey);
;|***          LONG APIENTRY WinGetPhysKeyState(HWND hwndDesktop,
;|***                                           LONG sc);
;|***       #else
;|***          SHORT APIENTRY WinGetKeyState(HWND hwndDesktop,
;|***                                        SHORT vkey);
;|***          SHORT APIENTRY WinGetPhysKeyState(HWND hwndDesktop,
;|***                                            SHORT sc);
;|***       #endif
;|***       BOOL  APIENTRY WinEnablePhysInput(HWND hwndDesktop,
;|***                                         BOOL fEnable);
;|***       BOOL  APIENTRY WinIsPhysInputEnabled(HWND hwndDesktop);
;|***       BOOL  APIENTRY WinSetKeyboardStateTable(HWND hwndDesktop,
;|***                                               PBYTE pKeyStateTable,
;|***                                               BOOL fSet);
;|*** 
;|*** 
;|***       /* Journal Notification messages  */
;|***       #define WM_JOURNALNOTIFY           0x007c
;|*** 
;|***       /*** Define the valid commands (lParm1) for journal notify message */
;|***       #define JRN_QUEUESTATUS            0x00000001L
;|***       #define JRN_PHYSKEYSTATE           0x00000002L
;|*** 
;|***    #endif /* !INCL_SAADEFS */
;|*** #endif /* INCL_WININPUT */
;|*** 
;|***    typedef LHANDLE HPOINTER;   /* hptr */
;|*** 
;|*** 
;|*** /**** Dialog Manager */
;|*** 
;|*** #if (defined(INCL_WINDIALOGS) || !defined(INCL_NOCOMMON))
;|***    /**** Dialog Manager COMMON subsection */
;|*** 
;|***    BOOL    APIENTRY WinGetDlgMsg(HWND hwndDlg,
;|***                                  PQMSG pqmsg);
;|*** 
;|***    #ifdef INCL_32
;|***       HWND    APIENTRY WinLoadDlg(HWND hwndParent,
;|***                                   HWND hwndOwner,
;|***                                   PFNWP pfnDlgProc,
;|***                                   HMODULE hmod,
;|***                                   ULONG idDlg,
;|***                                   PVOID pCreateParams);
;|***       ULONG  APIENTRY WinDlgBox(HWND hwndParent,
;|***                                 HWND hwndOwner,
;|***                                 PFNWP pfnDlgProc,
;|***                                 HMODULE hmod,
;|***                                 ULONG idDlg,
;|***                                 PVOID pCreateParams);
;|*** 
;|***       BOOL    APIENTRY WinDismissDlg(HWND hwndDlg,
;|***                                      ULONG usResult);
;|*** 
;|***       BOOL    APIENTRY WinQueryDlgItemShort(HWND hwndDlg,
;|***                                             ULONG idItem,
;|***                                             PSHORT pResult,
;|***                                             BOOL fSigned);
;|***       BOOL    APIENTRY WinSetDlgItemShort(HWND hwndDlg,
;|***                                           ULONG idItem,
;|***                                           USHORT usValue,
;|***                                           BOOL fSigned);
;|***       BOOL    APIENTRY WinSetDlgItemText(HWND hwndDlg,
;|***                                          ULONG idItem,
;|***                                          PSZ pszText);
;|***       ULONG  APIENTRY WinQueryDlgItemText(HWND hwndDlg,
;|***                                           ULONG idItem,
;|***                                           LONG cchBufferMax,
;|***                                           PSZ pchBuffer);
;|***       LONG   APIENTRY WinQueryDlgItemTextLength(HWND hwndDlg,
;|***                                                 ULONG idItem);
;|*** 
;|***       MRESULT APIENTRY WinDefDlgProc(HWND hwndDlg,
;|***                                      ULONG msg,
;|***                                      MPARAM mp1,
;|***                                      MPARAM mp2);
;|***    #else
;|***       HWND    APIENTRY WinLoadDlg(HWND hwndParent,
;|***                                   HWND hwndOwner,
;|***                                   PFNWP pfnDlgProc,
;|***                                   HMODULE hmod,
;|***                                   USHORT idDlg,
;|***                                   PVOID pCreateParams);
;|***       USHORT  APIENTRY WinDlgBox(HWND hwndParent,
;|***                                  HWND hwndOwner,
;|***                                  PFNWP pfnDlgProc,
;|***                                  HMODULE hmod,
;|***                                  USHORT idDlg,
;|***                                  PVOID pCreateParams);
;|*** 
;|***       BOOL    APIENTRY WinDismissDlg(HWND hwndDlg,
;|***                                      USHORT usResult);
;|*** 
;|***       BOOL    APIENTRY WinQueryDlgItemShort(HWND hwndDlg,
;|***                                             USHORT idItem,
;|***                                             PSHORT pResult,
;|***                                             BOOL fSigned);
;|***       BOOL    APIENTRY WinSetDlgItemShort(HWND hwndDlg,
;|***                                           USHORT idItem,
;|***                                           USHORT usValue,
;|***                                           BOOL fSigned);
;|***       BOOL    APIENTRY WinSetDlgItemText(HWND hwndDlg,
;|***                                          USHORT idItem,
;|***                                          PSZ pszText);
;|***       USHORT  APIENTRY WinQueryDlgItemText(HWND hwndDlg,
;|***                                            USHORT idItem,
;|***                                            SHORT cchBufferMax,
;|***                                            PSZ pchBuffer);
;|***       SHORT   APIENTRY WinQueryDlgItemTextLength(HWND hwndDlg,
;|***                                                  USHORT idItem);
;|*** 
;|***       MRESULT APIENTRY WinDefDlgProc(HWND hwndDlg,
;|***                                      USHORT msg,
;|***                                      MPARAM mp1,
;|***                                      MPARAM mp2);
;|***    #endif
;|*** 
;|***    /* Special item IDs */
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #define DID_OK      1
;|***       #define DID_CANCEL  2
;|***       #define DID_ERROR   0xffff
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    #ifdef INCL_32
;|***       BOOL APIENTRY WinAlarm(HWND hwndDesktop,
;|***                              ULONG rgfType);
;|***    #else
;|***       BOOL APIENTRY WinAlarm(HWND hwndDesktop,
;|***                              USHORT rgfType);
;|***    #endif
;|*** 
;|***    /* WinAlarm Codes */
;|*** 
;|***    #define WA_WARNING                 0
;|***    #define WA_NOTE                    1
;|***    #define WA_ERROR                   2
;|***    #define WA_CWINALARMS             13     /* count of valid alarms     53304*/
;|*** 
;|***    #ifdef INCL_32
;|*** 
;|***       ULONG APIENTRY WinMessageBox(HWND hwndParent,
;|***                                    HWND hwndOwner,
;|***                                    PSZ pszText,
;|***                                    PSZ pszCaption,
;|***                                    ULONG idWindow,
;|***                                    ULONG flStyle);
;|*** 
;|***    #else /* not INCL_32 */
;|*** 
;|***       USHORT APIENTRY WinMessageBox(HWND hwndParent,
;|***                                     HWND hwndOwner,
;|***                                     PSZ pszText,
;|***                                     PSZ pszCaption,
;|***                                     USHORT idWindow,
;|***                                     USHORT fsStyle);
;|*** 
;|***    #endif /* INCL_32 */
;|*** 
;|*** 
;|*** 
;|***    #define MAX_MBDTEXT               70
;|*** 
;|*** /* NOINC */
;|***    #pragma pack(4)
;|*** 
;|***    typedef struct _MB2D
;|***    {
;|***        CHAR   achText[MAX_MBDTEXT + 1]; /* Text of the button. eg. "~Cancel"    */
;|***        ULONG  idButton;                  /* Button ID returned when user chooses */
;|***        /*  button                              */
;|***        LONG   flStyle;                   /* Button style or'ed with internal     */
;|***        /*  styles                              */
;|***    } MB2D;
;|*** 
;|***    typedef MB2D * PMB2D;
;|*** 
;|***    typedef struct _MB2INFO
;|***    {
;|***       ULONG    cb;                  /* Size of fixed part of structure          */
;|***       HPOINTER hIcon;               /* Icon handle                              */
;|***       ULONG    cButtons;            /* Number of buttons                        */
;|***       ULONG    flStyle;             /* Icon style flags (MB_ICONQUESTION, etc...)*/
;|***       HWND     hwndNotify;          /* Reserved                                 */
;|***       MB2D     mb2d[1];             /* Array of button definitions              */
;|***    } MB2INFO;
;|*** 
;|***    typedef MB2INFO * PMB2INFO;
;|*** 
;|***    #pragma pack()
;|*** 
;|***    /************************************************************************/
;|***    /* WinMessageBox2                                                       */
;|***    /*                                                                      */
;|***    /* Parameters: HWND   hwndParent   - handle of the parent window.       */
;|***    /*             HWND   hwndOwner    - handle of the owner window.        */
;|***    /*             PSZ    pszText      - message text.                      */
;|***    /*             PSZ    pszCaption   - title of the message box.          */
;|***    /*             ULONG  idWindow     - Message box id                     */
;|***    /*             PMB2INFO pmb2info   - pointer to button/icon info        */
;|***    /************************************************************************/
;|***    ULONG  EXPENTRY  WinMessageBox2(HWND     hwndParent,
;|***                                    HWND     hwndOwner,
;|***                                    PSZ      pszText,
;|***                                    PSZ      pszCaption,
;|***                                    ULONG    idWindow,
;|***                                    PMB2INFO pmb2info);
;|*** 
;|*** /* INC */
;|*** 
;|***    /* Message box types */
;|*** 
;|***    #define MB_OK                      0x0000
;|***    #define MB_OKCANCEL                0x0001
;|***    #define MB_RETRYCANCEL             0x0002
;|***    #define MB_ABORTRETRYIGNORE        0x0003
;|***    #define MB_YESNO                   0x0004
;|***    #define MB_YESNOCANCEL             0x0005
;|***    #define MB_CANCEL                  0x0006
;|***    #define MB_ENTER                   0x0007
;|***    #define MB_ENTERCANCEL             0x0008
;|*** 
;|***    #define MB_NOICON                  0x0000
;|***    #define MB_CUANOTIFICATION         0x0000
;|***    #define MB_ICONQUESTION            0x0010
;|***    #define MB_ICONEXCLAMATION         0x0020
;|***    #define MB_CUAWARNING              0x0020
;|***    #define MB_ICONASTERISK            0x0030
;|***    #define MB_ICONHAND                0x0040
;|***    #define MB_CUACRITICAL             0x0040
;|***    #define MB_QUERY                   MB_ICONQUESTION
;|***    #define MB_WARNING                 MB_CUAWARNING
;|***    #define MB_INFORMATION             MB_ICONASTERISK
;|***    #define MB_CRITICAL                MB_CUACRITICAL
;|***    #define MB_ERROR                   MB_CRITICAL
;|***    #define MB_CUSTOMICON              0x0080
;|*** 
;|***    #define MB_DEFBUTTON1              0x0000
;|***    #define MB_DEFBUTTON2              0x0100
;|***    #define MB_DEFBUTTON3              0x0200
;|*** 
;|***    #define MB_APPLMODAL               0x0000
;|***    #define MB_SYSTEMMODAL             0x1000
;|***    #define MB_HELP                    0x2000
;|***    #define MB_MOVEABLE                0x4000
;|***    #define MB_NONMODAL                0x8000
;|*** 
;|*** 
;|***    /* Message box return codes */
;|*** 
;|***    #define MBID_OK                    1
;|***    #define MBID_CANCEL                2
;|***    #define MBID_ABORT                 3
;|***    #define MBID_RETRY                 4
;|***    #define MBID_IGNORE                5
;|***    #define MBID_YES                   6
;|***    #define MBID_NO                    7
;|***    #define MBID_HELP                  8
;|***    #define MBID_ENTER                 9
;|***    #define MBID_ERROR                 0xffff
;|*** 
;|*** 
;|***    /* Useful macros */
;|*** 
;|***    /***************************************************************************
;|***    * ULONG/USHORT WinCheckButton(HWND hwndDlg, USHORT id, USHORT checkState)
;|***    *    sets the check state of button #id.
;|***    *    returns the previous check state.
;|***    ***************************************************************************/
;|***    #ifdef INCL_32
;|***       #define WinCheckButton(hwndDlg, id, usCheckState) \
;|***       ((ULONG)WinSendDlgItemMsg(hwndDlg, id, BM_SETCHECK, \
;|***       MPFROMSHORT(usCheckState), (MPARAM)NULL))
;|***    #else
;|***       #define WinCheckButton(hwndDlg, id, usCheckState) \
;|***       ((USHORT)WinSendDlgItemMsg(hwndDlg, id, BM_SETCHECK, \
;|***       MPFROMSHORT(usCheckState), (MPARAM)NULL))
;|***    #endif
;|*** 
;|***    /***************************************************************************
;|***    * ULONG/USHORT WinQueryButtonCheckstate(HWND hwndDlg, USHORT id)
;|***    *    returns the check state of buttin #id.
;|***    *
;|***    ***************************************************************************/
;|***    #ifdef INCL_32
;|***       #define WinQueryButtonCheckstate(hwndDlg, id) \
;|***       ((ULONG)WinSendDlgItemMsg(hwndDlg, id, BM_QUERYCHECK, \
;|***       (MPARAM)NULL, (MPARAM)NULL))
;|***    #else
;|***       #define WinQueryButtonCheckstate(hwndDlg, id) \
;|***       ((USHORT)WinSendDlgItemMsg(hwndDlg, id, BM_QUERYCHECK, \
;|***       (MPARAM)NULL, (MPARAM)NULL))
;|***    #endif
;|*** 
;|***    /***************************************************************************
;|***    * BOOL WinEnableControl(HWND hwndDlg, USHORT id, BOOL fEnable)
;|***    *    sets the enable state of button #id.
;|***    *    returns fSuccess.
;|***    ***************************************************************************/
;|***    #define WinEnableControl(hwndDlg, id, fEnable) \
;|***    WinEnableWindow(WinWindowFromID(hwndDlg, id), fEnable)
;|*** 
;|***    /***************************************************************************
;|***    * BOOL WinIsControlEnabled(HWND hwndDlg, ULONG id)
;|***    *    returns the enable state of control #id.
;|***    *
;|***    ***************************************************************************/
;|***    #define WinIsControlEnabled(hwndDlg, id) \
;|***    ((BOOL)WinIsWindowEnabled(WinWindowFromID(hwndDlg, id)))
;|*** 
;|*** #endif /* Dialog Manager COMMON subsection */
;|*** 
;|*** 
;|*** #ifdef INCL_WINDIALOGS
;|*** 
;|***    /* Dialog codes: returned by WM_QUERYDLGCODE msg     */
;|*** 
;|***    #define DLGC_ENTRYFIELD    0x0001  /* Entry field item understands EM_SETSEL) */
;|***    #define DLGC_BUTTON        0x0002  /* Button item                             */
;|***    #define DLGC_RADIOBUTTON   0x0004  /* Radio button                            */
;|***    #define DLGC_STATIC        0x0008  /* Static item                             */
;|***    #define DLGC_DEFAULT       0x0010  /* Default push button                     */
;|***    #define DLGC_PUSHBUTTON    0x0020  /* Normal (Non-default) push button        */
;|***    #define DLGC_CHECKBOX      0x0040  /* Check box button control                */
;|***    #define DLGC_SCROLLBAR     0x0080  /* Scroll bar                              */
;|***    #define DLGC_MENU          0x0100  /* Menu                                    */
;|***    #define DLGC_TABONCLICK    0x0200
;|***    #define DLGC_MLE           0x0400  /* Multiple Line Entry                     */
;|*** 
;|*** 
;|***    #ifdef INCL_32
;|***       ULONG  APIENTRY WinProcessDlg(HWND hwndDlg);
;|***       MRESULT APIENTRY WinSendDlgItemMsg(HWND hwndDlg,
;|***                                          ULONG idItem,
;|***                                          ULONG msg,
;|***                                          MPARAM mp1,
;|***                                          MPARAM mp2);
;|***       BOOL    APIENTRY WinMapDlgPoints(HWND hwndDlg,
;|***                                        PPOINTL prgwptl,
;|***                                        ULONG cwpt,
;|***                                        BOOL fCalcWindowCoords);
;|***       HWND    APIENTRY WinEnumDlgItem(HWND hwndDlg,
;|***                                       HWND hwnd,
;|***                                       ULONG code);
;|***       LONG   APIENTRY WinSubstituteStrings(HWND hwnd,
;|***                                            PSZ pszSrc,
;|***                                            LONG cchDstMax,
;|***                                            PSZ pszDst);
;|***    #else
;|***       USHORT  APIENTRY WinProcessDlg(HWND hwndDlg);
;|***       MRESULT APIENTRY WinSendDlgItemMsg(HWND hwndDlg,
;|***                                          USHORT idItem,
;|***                                          USHORT msg,
;|***                                          MPARAM mp1,
;|***                                          MPARAM mp2);
;|***       BOOL    APIENTRY WinMapDlgPoints(HWND hwndDlg,
;|***                                        PPOINTL prgwptl,
;|***                                        USHORT cwpt,
;|***                                        BOOL fCalcWindowCoords);
;|***       HWND    APIENTRY WinEnumDlgItem(HWND hwndDlg,
;|***                                       HWND hwnd,
;|***                                       USHORT code,
;|***                                       BOOL fLock);
;|***       SHORT   APIENTRY WinSubstituteStrings(HWND hwnd,
;|***                                             PSZ pszSrc,
;|***                                             SHORT cchDstMax,
;|***                                             PSZ pszDst);
;|***    #endif  /* INCL_32 */
;|*** 
;|*** 
;|***    /* WinEnumDlgItem() constants */
;|*** 
;|***    #define EDI_FIRSTTABITEM           0
;|***    #define EDI_LASTTABITEM            1
;|***    #define EDI_NEXTTABITEM            2
;|***    #define EDI_PREVTABITEM            3
;|***    #define EDI_FIRSTGROUPITEM         4
;|***    #define EDI_LASTGROUPITEM          5
;|***    #define EDI_NEXTGROUPITEM          6
;|***    #define EDI_PREVGROUPITEM          7
;|*** 
;|***    /*** Dialog template definitions */
;|*** 
;|***    /*** Variable-sized dialog template items: ******************************/
;|*** 
;|***    #pragma pack(2) /* force structure alignment packing */
;|*** 
;|***    /*************************************************************************
;|***    *
;|***    *  We pack the structures _DLGTITEM and _DLGTEMPLATE so that the
;|***    *  structures are identical in the 32-bit and 16-bit worlds. We have
;|***    *  to do this because is has been documented that one can pass a
;|***    *  pointer to 'the binary resource format' when calling WinCreateDlg.
;|***    *
;|***    *************************************************************************/
;|*** 
;|***    /* Binary resources may be bound into application executables or */
;|***    /* passed as a parameter when creating a window or dialog        */
;|***    /* Currently they must be the same for both 16-bit and 32-bit    */
;|***    /* so we pack the structures.                                    */
;|***    typedef struct _DLGTITEM {  /* dlgti */
;|***       USHORT  fsItemStatus;
;|***       USHORT  cChildren;
;|***       USHORT  cchClassName;
;|***       USHORT  offClassName;
;|***       USHORT  cchText;
;|***       USHORT  offText;
;|***       ULONG   flStyle;
;|***       SHORT   x;
;|***       SHORT   y;
;|***       SHORT   cx;
;|***       SHORT   cy;
;|***       USHORT  id;
;|***       USHORT  offPresParams;
;|***       USHORT  offCtlData;
;|***    } DLGTITEM;
;|***    typedef DLGTITEM FAR *PDLGTITEM;
;|*** 
;|***    /*** Dialog Template structure ******************************************/
;|*** 
;|***    /* Binary resources may be bound into application executables or */
;|***    /* passed as a parameter when creating a window or dialog        */
;|***    /* Currently they must be the same for both 16-bit and 32-bit    */
;|***    /* so we pack the structures.                                    */
;|***    typedef struct _DLGTEMPLATE {  /* dlgt */
;|***       USHORT   cbTemplate;
;|***       USHORT   type;
;|***       USHORT   codepage;
;|***       USHORT   offadlgti;
;|***       USHORT   fsTemplateStatus;
;|***       USHORT   iItemFocus;
;|***       USHORT   coffPresParams;
;|***       DLGTITEM adlgti[1];
;|***    } DLGTEMPLATE;
;|***    typedef DLGTEMPLATE FAR *PDLGTEMPLATE;
;|*** 
;|***    #pragma pack()  /* restore packing to default */
;|*** 
;|***    HWND   APIENTRY WinCreateDlg(HWND hwndParent,
;|***                                 HWND hwndOwner,
;|***                                 PFNWP pfnDlgProc,
;|***                                 PDLGTEMPLATE pdlgt,
;|***                                 PVOID pCreateParams);
;|*** 
;|*** 
;|*** #endif /* INCL_WINDIALOGS */
;|*** 
;|*** 
;|*** #ifdef INCL_WINSTATICS
;|*** 
;|***    /*** Static Control Manager */
;|*** 
;|***    /* Static control styles:
;|***    *
;|***    * NOTE: the top 9 bits of the LOWORD of the window flStyle are used for
;|***    * DT_* flags.  The lower 7 bits are for SS_* styles.  This gives us up
;|***    * to 128 distinct static control types (we currently use 11 of them).
;|***    */
;|***    #define SS_TEXT                    0x0001L
;|***    #define SS_GROUPBOX                0x0002L
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #define SS_ICON                    0x0003L
;|***       #define SS_BITMAP                  0x0004L
;|***    #endif /* !INCL_SAADEFS */
;|***    #define SS_FGNDRECT                0x0005L
;|***    #ifndef INCL_SAADEFS
;|***       #define SS_HALFTONERECT            0x0006L
;|***    #endif /* !INCL_SAADEFS */
;|***    #define SS_BKGNDRECT               0x0007L
;|***    #define SS_FGNDFRAME               0x0008L
;|***    #ifndef INCL_SAADEFS
;|***       #define SS_HALFTONEFRAME           0x0009L
;|***    #endif /* !INCL_SAADEFS */
;|***    #define SS_BKGNDFRAME              0x000aL
;|***    #define SS_SYSICON                 0x000bL
;|***    #define SS_AUTOSIZE         0x0040L
;|*** 
;|*** 
;|***    /* Static control messages */
;|*** 
;|***    #define SM_SETHANDLE               0x0100
;|***    #define SM_QUERYHANDLE             0x0101
;|*** 
;|***    /* Message Box 2 notification messages */
;|***    #define WM_MSGBOXINIT              0x010E
;|***    #define WM_MSGBOXDISMISS           0x010F
;|*** #endif /* INCL_WINSTATICS */
;|*** 
;|*** 
;|*** #ifdef INCL_WINBUTTONS
;|***    /**** Button Controls Subsection */
;|*** 
;|***    /* Button control styles */
;|*** 
;|***    #define BS_PUSHBUTTON              0L
;|***    #define BS_CHECKBOX                1L
;|***    #define BS_AUTOCHECKBOX            2L
;|***    #define BS_RADIOBUTTON             3L
;|***    #define BS_AUTORADIOBUTTON         4L
;|***    #define BS_3STATE                  5L
;|***    #define BS_AUTO3STATE              6L
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #define BS_USERBUTTON              7L
;|***    #endif /* !INCL_SAADEFS */
;|***    #define BS_PRIMARYSTYLES       0x000fL
;|*** 
;|***    #define BS_TEXT                 0x0010
;|***    #define BS_MINIICON             0x0020
;|***    #define BS_BITMAP           0x0040L
;|***    #define BS_ICON             0x0080L
;|***    #define BS_HELP                    0x0100L
;|***    #define BS_SYSCOMMAND              0x0200L
;|***    #define BS_DEFAULT                 0x0400L
;|***    #define BS_NOPOINTERFOCUS          0x0800L
;|***    #define BS_NOBORDER                0x1000L
;|***    #define BS_NOCURSORSELECT          0x2000L
;|***    #define BS_AUTOSIZE             0x4000L
;|*** 
;|*** 
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #pragma pack(2) /* force structure alignment packing */
;|*** 
;|***       /* Binary resources may be bound into application executables or */
;|***       /* passed as a parameter when creating a window or dialog        */
;|***       /* Currently they must be the same for both 16-bit and 32-bit    */
;|***       /* so we pack the structures.                                    */
;|***       typedef struct _BTNCDATA {  /* btncd */
;|***          USHORT  cb;
;|***          USHORT  fsCheckState;
;|***          USHORT  fsHiliteState;
;|***          LHANDLE hImage;
;|***       } BTNCDATA;
;|***       typedef BTNCDATA FAR *PBTNCDATA;
;|*** 
;|***       #pragma pack()  /* restore packing to default */
;|*** 
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    /*** User button structure (passed in WM_CONTROL msg) *******************/
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #ifdef INCL_32
;|***          typedef struct _USERBUTTON {  /* ubtn */
;|***             HWND    hwnd;
;|***             HPS     hps;
;|***             ULONG   fsState;
;|***             ULONG   fsStateOld;
;|***          } USERBUTTON;
;|***       #else
;|***          typedef struct _USERBUTTON {  /* ubtn */
;|***             HWND    hwnd;
;|***             HPS     hps;
;|***             USHORT  fsState;
;|***             USHORT  fsStateOld;
;|***          } USERBUTTON;
;|***       #endif
;|***       typedef USERBUTTON FAR *PUSERBUTTON;
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    /* Button control messages */
;|*** 
;|***    #define BM_CLICK                   0x0120
;|***    #define BM_QUERYCHECKINDEX         0x0121
;|***    #define BM_QUERYHILITE             0x0122
;|***    #define BM_SETHILITE               0x0123
;|***    #define BM_QUERYCHECK              0x0124
;|***    #define BM_SETCHECK                0x0125
;|***    #define BM_SETDEFAULT              0x0126
;|*** 
;|***    /* Button notification codes */
;|*** 
;|***    #define BN_CLICKED                 1
;|***    #define BN_DBLCLICKED              2
;|***    #define BN_PAINT                   3
;|*** 
;|***    /* BN_PAINT button draw state codes (must be in high byte) */
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #define BDS_HILITED                0x0100
;|***       #define BDS_DISABLED               0x0200
;|***       #define BDS_DEFAULT                0x0400
;|*** 
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|*** #endif /* INCL_WINBUTTONS */
;|*** 
;|*** 
;|*** #ifdef INCL_WINENTRYFIELDS
;|***    /**** Entryfield controls Subsection */
;|*** 
;|***    /* Entry field  styles */
;|*** 
;|***    #define ES_LEFT                    0x00000000L
;|***    #define ES_CENTER                  0x00000001L
;|***    #define ES_RIGHT                   0x00000002L
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #define ES_AUTOSCROLL              0x00000004L
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    #define ES_MARGIN                  0x00000008L
;|***    #define ES_AUTOTAB                 0x00000010L
;|***    #define ES_READONLY                0x00000020L
;|***    #define ES_COMMAND                 0x00000040L
;|***    #define ES_UNREADABLE              0x00000080L
;|***    #define ES_AUTOSIZE                0x00000200L
;|*** 
;|***    #ifdef INCL_NLS
;|***       #define ES_ANY                     0x00000000L
;|***       #define ES_SBCS                    0x00001000L
;|***       #define ES_DBCS                    0x00002000L
;|***       #define ES_MIXED                   0x00003000L
;|***    #endif /* INCL_NLS */
;|*** 
;|*** 
;|***    /*
;|***    * combo box styles
;|***    */
;|***    #define CBS_SIMPLE                 0x0001L
;|***    #define CBS_DROPDOWN               0x0002L
;|***    #define CBS_DROPDOWNLIST           0x0004L
;|*** 
;|***    /*
;|***    * Use this bit for drop down combo boxes that do not want to
;|***    * receive a CBN_ENTER on a single click in their list boxes.
;|***    * This is for compatibility with releases prior to OS/2 2.0 which
;|***    * did not send this message
;|***    */
;|***    #define CBS_COMPATIBLE             0x0008L
;|*** 
;|***    /*
;|***    * The following edit and listbox styles may be used in conjunction
;|***    * with CBS_ styles
;|***    * ES_AUTOTAB ES_ANY ES_SBCS ES_DBCS ES_MIXED LS_HORZSCROLL
;|***    */
;|*** 
;|***    /*
;|***    * IDs of combobox entry field and listbox.
;|***    */
;|***    #define CBID_LIST                  0x029A
;|***    #define CBID_EDIT                  0x029B
;|*** 
;|***    #define CBM_SHOWLIST               0x0170
;|***    #define CBM_HILITE                 0x0171
;|***    #define CBM_ISLISTSHOWING          0x0172
;|*** 
;|***    #define CBN_EFCHANGE               1
;|***    #define CBN_EFSCROLL               2
;|***    #define CBN_MEMERROR               3
;|***    #define CBN_LBSELECT               4
;|***    #define CBN_LBSCROLL               5
;|***    #define CBN_SHOWLIST               6
;|***    #define CBN_ENTER                  7
;|*** 
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #pragma pack(2) /* force structure alignment packing */
;|*** 
;|***       /* Binary resources may be bound into application executables or */
;|***       /* passed as a parameter when creating a window or dialog        */
;|***       /* Currently they must be the same for both 16-bit and 32-bit    */
;|***       /* so we pack the structures.                                    */
;|*** 
;|***       /*******************************************************************/
;|***       /* Combobox control data structure                                 */
;|***       /*******************************************************************/
;|***       typedef struct _COMBOCDATA          /* combocdata */
;|***       {
;|***          ULONG   cbSize;             /* Size of control block             */
;|***          ULONG   reserved;           /* reserved field                    */
;|***          PVOID   pHWXCtlData;        /* reserved for Pen CtlData (penpm.h)*/
;|***       } COMBOCDATA;
;|***       typedef COMBOCDATA *PCOMBOCDATA;
;|*** 
;|***       typedef struct _ENTRYFDATA {  /* efd */
;|***          USHORT  cb;
;|***          USHORT  cchEditLimit;
;|***          USHORT  ichMinSel;
;|***          USHORT  ichMaxSel;
;|***          PVOID   pHWXCtlData;    /* reserved for Pen CtlData (penpm.h)  */
;|***       } ENTRYFDATA;
;|***       typedef ENTRYFDATA FAR *PENTRYFDATA;
;|*** 
;|***       #pragma pack()  /* restore packing to default */
;|*** 
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    /* Entry Field  messages */
;|*** 
;|***    #define EM_QUERYCHANGED            0x0140
;|***    #define EM_QUERYSEL                0x0141
;|***    #define EM_SETSEL                  0x0142
;|***    #define EM_SETTEXTLIMIT            0x0143
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #define EM_CUT                     0x0144
;|***       #define EM_COPY                    0x0145
;|***    #endif /* !INCL_SAADEFS */
;|***    #define EM_CLEAR                   0x0146
;|***    #ifndef INCL_SAADEFS
;|***       #define EM_PASTE                   0x0147
;|***    #endif /* !INCL_SAADEFS */
;|***    #define EM_QUERYFIRSTCHAR          0x0148
;|***    #define EM_SETFIRSTCHAR            0x0149
;|***    #ifndef INCL_SAADEFS
;|***       #define EM_QUERYREADONLY           0x014a
;|***       #define EM_SETREADONLY             0x014b
;|***       #define EM_SETINSERTMODE           0x014c
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    /* Entry Field notification messages */
;|*** 
;|***    #define EN_SETFOCUS                0x0001
;|***    #define EN_KILLFOCUS               0x0002
;|***    #define EN_CHANGE                  0x0004
;|***    #define EN_SCROLL                  0x0008
;|***    #ifndef INCL_SAADEFS
;|***       #define EN_MEMERROR                0x0010
;|***       #define EN_OVERFLOW                0x0020
;|***       #define EN_INSERTMODETOGGLE        0x0040
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|*** #endif /* INCL_WINENTRYFIELDS */
;|*** 
;|*** 
;|*** /*  Multiple Line Entrys */
;|*** #ifdef INCL_WINMLE
;|***    #include <pmmle.h>
;|*** #endif /* !INCL_WINMLE */
;|*** #ifdef INCL_WINLISTBOXES
;|*** 
;|***    /**** Listboxes */
;|*** 
;|***    /* List box styles */
;|*** 
;|***    #define LS_MULTIPLESEL             0x00000001L
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #define LS_OWNERDRAW               0x00000002L
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    #define LS_NOADJUSTPOS             0x00000004L
;|***    #define LS_HORZSCROLL              0x00000008L
;|*** 
;|***    #define LS_EXTENDEDSEL             0x00000010L
;|*** 
;|*** 
;|***    /* List box notification messages */
;|*** 
;|***    #define LN_SELECT                  1
;|***    #define LN_SETFOCUS                2
;|***    #define LN_KILLFOCUS               3
;|***    #define LN_SCROLL                  4
;|***    #define LN_ENTER                   5
;|*** 
;|***    /* List box messages */
;|*** 
;|***    #define LM_QUERYITEMCOUNT          0x0160
;|***    #define LM_INSERTITEM              0x0161
;|***    #define LM_SETTOPINDEX             0x0162
;|***    #define LM_DELETEITEM              0x0163
;|***    #define LM_SELECTITEM              0x0164
;|***    #define LM_QUERYSELECTION          0x0165
;|***    #define LM_SETITEMTEXT             0x0166
;|***    #define LM_QUERYITEMTEXTLENGTH     0x0167
;|***    #define LM_QUERYITEMTEXT           0x0168
;|*** 
;|***    #define LM_SETITEMHANDLE           0x0169
;|***    #define LM_QUERYITEMHANDLE         0x016a
;|***    #define LM_SEARCHSTRING            0x016b
;|***    #define LM_SETITEMHEIGHT           0x016c
;|***    #define LM_QUERYTOPINDEX           0x016d
;|***    #define LM_DELETEALL               0x016e
;|***    #define LM_INSERTMULTITEMS         0x016f
;|***    #define LM_SETITEMWIDTH            0x0660
;|*** 
;|*** 
;|***    /* List box constants */
;|*** 
;|***    #define LIT_CURSOR         (-4)
;|***    #define LIT_ERROR                  (-3)
;|***    #define LIT_MEMERROR               (-2)
;|***    #define LIT_NONE                   (-1)
;|***    #define LIT_FIRST                  (-1)
;|*** 
;|***    /* For LM_INSERTITEM msg */
;|*** 
;|***    #define LIT_END                    (-1)
;|***    #define LIT_SORTASCENDING          (-2)
;|***    #define LIT_SORTDESCENDING         (-3)
;|*** 
;|***    /* For LM_SEARCHSTRING msg */
;|*** 
;|***    #define LSS_SUBSTRING              0x0001
;|***    #define LSS_PREFIX                 0x0002
;|***    #define LSS_CASESENSITIVE          0x0004
;|*** 
;|***    /*******************************************************************/
;|***    /* Structure for use with LM_INSERTMULTITEMS                       */
;|***    /*******************************************************************/
;|*** 
;|***    typedef struct _LBOXINFO         /* lboxinfo */
;|***    {
;|***        LONG  lItemIndex;            /* Item index */
;|***        ULONG ulItemCount;           /* Item count */
;|***        ULONG reserved;              /* Reserved - must be zero */
;|***        ULONG reserved2;             /* Reserved - must be zero */
;|***    } LBOXINFO;
;|*** 
;|***    typedef LBOXINFO * PLBOXINFO;
;|*** 
;|***    /* Useful macros */
;|*** 
;|***    /***************************************************************************
;|***    * LONG/SHORT WinDeleteLboxItem(HWND hwndLbox, LONG/SHORT index)
;|***    *    deletes item index from the listbox.
;|***    *    returns the number of items left.
;|***    ***************************************************************************/
;|***    #ifdef INCL_32
;|***       #define WinDeleteLboxItem(hwndLbox, index) \
;|***       ((LONG)WinSendMsg(hwndLbox, LM_DELETEITEM, MPFROMLONG(index), \
;|***       (MPARAM)NULL))
;|***    #else
;|***       #define WinDeleteLboxItem(hwndLbox, index) \
;|***       ((SHORT)WinSendMsg(hwndLbox, LM_DELETEITEM, MPFROMSHORT(index), \
;|***       (MPARAM)NULL))
;|***    #endif
;|*** 
;|***    /***************************************************************************
;|***    * LONG/SHORT WinInsertLboxItem(HWND hwndLbox, LONG/SHORT index, PSZ psz)
;|***    *    inserts psz into a listbox at index.  Index may be an LIT_ constant.
;|***    *    returns the actual index where it was inserted.
;|***    ***************************************************************************/
;|***    #ifdef INCL_32
;|***       #define WinInsertLboxItem(hwndLbox, index, psz) \
;|***       ((LONG)WinSendMsg(hwndLbox, LM_INSERTITEM, MPFROMLONG(index), \
;|***       MPFROMP(psz)))
;|***    #else
;|***       #define WinInsertLboxItem(hwndLbox, index, psz) \
;|***       ((SHORT)WinSendMsg(hwndLbox, LM_INSERTITEM, MPFROMSHORT(index), \
;|***       MPFROMP(psz)))
;|***    #endif
;|*** 
;|***    /***************************************************************************
;|***    * LONG/SHORT WinQueryLboxCount(HWND hwndLbox)
;|***    *    returns the number of items in the listbox.
;|***    *
;|***    ***************************************************************************/
;|***    #ifdef INCL_32
;|***       #define WinQueryLboxCount(hwndLbox) \
;|***       ((LONG)WinSendMsg(hwndLbox, LM_QUERYITEMCOUNT, (MPARAM)NULL, \
;|***       (MPARAM)NULL))
;|***    #else
;|***       #define WinQueryLboxCount(hwndLbox) \
;|***       ((SHORT)WinSendMsg(hwndLbox, LM_QUERYITEMCOUNT, (MPARAM)NULL, \
;|***       (MPARAM)NULL))
;|***    #endif
;|*** 
;|***    /***************************************************************************
;|***    * LONG/SHORT WinQueryLboxItemText(HWND hwndLbox, LONG/SHORT index, PSZ psz, SHORT cchMax)
;|***    *    fills psz with the text if item index.
;|***    *    returns the text length copied.
;|***    ***************************************************************************/
;|***    #ifdef INCL_32
;|***       #define WinQueryLboxItemText(hwndLbox, index, psz, cchMax) \
;|***       ((LONG)WinSendMsg(hwndLbox, LM_QUERYITEMTEXT, \
;|***       MPFROM2SHORT((index), (cchMax)), MPFROMP(psz)))
;|***    #else
;|***       #define WinQueryLboxItemText(hwndLbox, index, psz, cchMax) \
;|***       ((SHORT)WinSendMsg(hwndLbox, LM_QUERYITEMTEXT, \
;|***       MPFROM2SHORT((index), (cchMax)), MPFROMP(psz)))
;|***    #endif
;|*** 
;|***    /***************************************************************************
;|***    * LONG/SHORT WinQueryLboxItemTextLength(HWND hwndLbox, LONG/SHORT index)
;|***    *    returns the length of item index.
;|***    *
;|***    ***************************************************************************/
;|***    #ifdef INCL_32
;|***       #define WinQueryLboxItemTextLength(hwndLbox, index)         \
;|***       ((SHORT)WinSendMsg(hwndLbox, LM_QUERYITEMTEXTLENGTH,    \
;|***       MPFROMSHORT(index), (MPARAM)NULL))
;|***    #else
;|***       #define WinQueryLboxItemTextLength(hwndLbox, index)         \
;|***       ((SHORT)WinSendMsg(hwndLbox, LM_QUERYITEMTEXTLENGTH,    \
;|***       MPFROMSHORT(index), (MPARAM)NULL))
;|***    #endif
;|*** 
;|***    /***************************************************************************
;|***    * BOOL WinSetLboxItemText(HWND hwndLbox, LONG/SHORT index, PSZ psz)
;|***    *    sets the text of item index to psz.
;|***    *    returns fSuccess.
;|***    ***************************************************************************/
;|***    #ifdef INCL_32
;|***       #define WinSetLboxItemText(hwndLbox, index, psz) \
;|***       ((BOOL)WinSendMsg(hwndLbox, LM_SETITEMTEXT, \
;|***       MPFROMLONG(index), MPFROMP(psz)))
;|***    #else
;|***       #define WinSetLboxItemText(hwndLbox, index, psz) \
;|***       ((BOOL)WinSendMsg(hwndLbox, LM_SETITEMTEXT, \
;|***       MPFROMSHORT(index), MPFROMP(psz)))
;|***    #endif
;|*** 
;|***    /***************************************************************************
;|***    * LONG/SHORT WinQueryLboxSelectedItem(HWND hwndLbox)
;|***    *    returns the item index selected. (for single selection only)
;|***    *
;|***    ***************************************************************************/
;|***    #ifdef INCL_32
;|***       #define WinQueryLboxSelectedItem(hwndLbox) \
;|***       ((LONG)WinSendMsg(hwndLbox, LM_QUERYSELECTION, MPFROMLONG(LIT_FIRST), \
;|***       (MPARAM)NULL))
;|***    #else
;|***       #define WinQueryLboxSelectedItem(hwndLbox) \
;|***       ((SHORT)WinSendMsg(hwndLbox, LM_QUERYSELECTION, MPFROMSHORT(LIT_FIRST), \
;|***       (MPARAM)NULL))
;|***    #endif
;|*** 
;|*** #endif /* INCL_WINLISTBOXES */
;|*** 
;|*** 
;|*** #ifdef INCL_WINMENUS
;|*** 
;|***    /**** Menu Manager Subsection */
;|*** 
;|***    /* Menu control styles */
;|*** 
;|***    #define MS_ACTIONBAR               0x00000001L
;|***    #define MS_TITLEBUTTON             0x00000002L
;|***    #define MS_VERTICALFLIP            0x00000004L
;|*** 
;|***    #define MS_CONDITIONALCASCADE      0x00000040L
;|*** 
;|***    #ifdef INCL_32
;|***       HWND APIENTRY WinLoadMenu(HWND hwndFrame,
;|***                                 HMODULE hmod,
;|***                                 ULONG idMenu);
;|***    #else
;|***       HWND APIENTRY WinLoadMenu(HWND hwndFrame,
;|***                                 HMODULE hmod,
;|***                                 USHORT idMenu);
;|***    #endif
;|*** 
;|*** 
;|***    /* Menu control messages */
;|*** 
;|***    #define MM_INSERTITEM              0x0180
;|***    #define MM_DELETEITEM              0x0181
;|***    #define MM_QUERYITEM               0x0182
;|***    #define MM_SETITEM                 0x0183
;|***    #define MM_QUERYITEMCOUNT          0x0184
;|***    #define MM_STARTMENUMODE           0x0185
;|***    #define MM_ENDMENUMODE             0x0186
;|***    #define MM_REMOVEITEM              0x0188
;|***    #define MM_SELECTITEM              0x0189
;|***    #define MM_QUERYSELITEMID          0x018a
;|***    #define MM_QUERYITEMTEXT           0x018b
;|***    #define MM_QUERYITEMTEXTLENGTH     0x018c
;|***    #define MM_SETITEMHANDLE           0x018d
;|***    #define MM_SETITEMTEXT             0x018e
;|***    #define MM_ITEMPOSITIONFROMID      0x018f
;|***    #define MM_ITEMIDFROMPOSITION      0x0190
;|***    #define MM_QUERYITEMATTR           0x0191
;|***    #define MM_SETITEMATTR             0x0192
;|***    #define MM_ISITEMVALID             0x0193
;|***    #define MM_QUERYITEMRECT           0x0194
;|*** 
;|***    #define MM_QUERYDEFAULTITEMID      0x0431
;|***    #define MM_SETDEFAULTITEMID        0x0432
;|*** 
;|***    #ifndef MTI_INCLUDED
;|***       #define MTI_INCLUDED
;|*** 
;|***       typedef struct _mti {   /* mti */
;|***          USHORT afStyle;      /* Style Flags      */
;|***          USHORT pad;          /* pad for template */
;|***          USHORT idItem;       /* Item ID          */
;|***          CHAR   c[2];         /*                  */
;|***       } MTI;
;|*** 
;|***       typedef struct _mt {    /* mt */
;|***          ULONG  len;          /* Length of template in bytes */
;|***          USHORT codepage;     /* Codepage                    */
;|***          USHORT reserved;     /* Reserved.                   */
;|***          USHORT cMti;         /* Count of template items.    */
;|***          MTI    rgMti[1];     /* Array of template items.    */
;|***       } MT;
;|***       typedef MT FAR * LPMT;
;|*** 
;|***    #endif
;|*** 
;|***    HWND APIENTRY WinCreateMenu(HWND hwndParent,
;|***                                PVOID lpmt);
;|*** 
;|***    /* Owner Item Structure (Also used for listboxes) */
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #ifdef INCL_32
;|***          typedef struct _OWNERITEM {  /* oi */
;|***             HWND    hwnd;
;|***             HPS     hps;
;|***             ULONG   fsState;
;|***             ULONG   fsAttribute;
;|***             ULONG   fsStateOld;
;|***             ULONG   fsAttributeOld;
;|***             RECTL   rclItem;
;|***             LONG    idItem; /* This field contains idItem for menus, iItem for lb. */
;|***             ULONG   hItem;
;|***          } OWNERITEM;
;|***       #else
;|***          typedef struct _OWNERITEM {  /* oi */
;|***             HWND    hwnd;
;|***             HPS     hps;
;|***             USHORT  fsState;
;|***             USHORT  fsAttribute;
;|***             USHORT  fsStateOld;
;|***             USHORT  fsAttributeOld;
;|***             RECTL   rclItem;
;|***             SHORT   idItem; /* This field contains idItem for menus, iItem for lb. */
;|***             ULONG   hItem;
;|***          } OWNERITEM;
;|***       #endif
;|***       typedef OWNERITEM FAR *POWNERITEM;
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    /* Menu item */
;|*** 
;|***    #pragma pack(2) /* force structure alignment packing */
;|*** 
;|***    /* Binary resources may be bound into application executables or */
;|***    /* passed as a parameter when creating a window or dialog        */
;|***    /* Currently they must be the same for both 16-bit and 32-bit    */
;|***    /* so we pack the structures.                                    */
;|***    typedef struct _MENUITEM {  /* mi */
;|***       SHORT   iPosition;
;|***       USHORT  afStyle;
;|***       USHORT  afAttribute;
;|***       USHORT  id;
;|***       HWND    hwndSubMenu;
;|***       ULONG   hItem;
;|***    } MENUITEM;
;|***    typedef MENUITEM FAR *PMENUITEM;
;|*** 
;|***    #pragma pack()  /* restore packing to default */
;|*** 
;|***    #define MIT_END                    (-1)
;|***    #define MIT_NONE                   (-1)
;|***    #define MIT_MEMERROR               (-1)
;|***    #define MIT_ERROR                  (-1)
;|***    #define MIT_FIRST                  (-2)
;|***    #define MIT_LAST                   (-3)
;|***    #define MID_NONE                   MIT_NONE
;|***    #define MID_ERROR                  (-1)
;|*** 
;|***    /* Menu item styles & attributes */
;|*** 
;|***    #define MIS_TEXT                   0x0001
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #define MIS_BITMAP                 0x0002
;|***    #endif /* !INCL_SAADEFS */
;|***    #define MIS_SEPARATOR              0x0004
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #define MIS_OWNERDRAW              0x0008
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    #define MIS_SUBMENU                0x0010
;|***    #define MIS_MULTMENU               0x0020      /* multiple choice submenu     */
;|***    #define MIS_SYSCOMMAND             0x0040
;|***    #define MIS_HELP                   0x0080
;|***    #define MIS_STATIC                 0x0100
;|***    #define MIS_BUTTONSEPARATOR        0x0200
;|***    #define MIS_BREAK                  0x0400
;|***    #define MIS_BREAKSEPARATOR         0x0800
;|***    #define MIS_GROUP                  0x1000      /* multiple choice group start */
;|***    /* In multiple choice submenus a style of 'single' denotes the item is a
;|***    ** radiobutton.  Absence of this style defaults the item to a checkbox.       */
;|***    #define MIS_SINGLE                 0x2000
;|*** 
;|***    #define MIA_NODISMISS              0x0020
;|***    #define MIA_FRAMED                 0x1000
;|***    #define MIA_CHECKED                0x2000
;|***    #define MIA_DISABLED               0x4000
;|***    #define MIA_HILITED                0x8000
;|*** 
;|*** 
;|***    #ifdef INCL_32
;|***       BOOL APIENTRY WinPopupMenu(HWND hwndParent,
;|***                                  HWND hwndOwner,
;|***                                  HWND hwndMenu,
;|***                                  LONG x,
;|***                                  LONG y,
;|***                                  LONG idItem,
;|***                                  ULONG fs);
;|***    #else
;|***       BOOL APIENTRY WinPopupMenu(HWND hwndParent,
;|***                                  HWND hwndOwner,
;|***                                  HWND hwndMenu,
;|***                                  SHORT x,
;|***                                  SHORT y,
;|***                                  SHORT idItem,
;|***                                  USHORT fs);
;|***    #endif
;|*** 
;|***    /* Values of fs in WinPopupMenu call */
;|*** 
;|***    #define PU_POSITIONONITEM          0x0001 /* Need idItem parameter */
;|*** 
;|***    #define PU_HCONSTRAIN              0x0002 /* Keep menu on left and right edge */
;|***    #define PU_VCONSTRAIN              0x0004 /* Keep menu on top and bottom edge */
;|*** 
;|***    #define PU_NONE                    0x0000 /* If invoked by keyboard */
;|***    #define PU_MOUSEBUTTON1DOWN        0x0008 /* If invoked by button 1 */
;|***    #define PU_MOUSEBUTTON2DOWN        0x0010 /* If invoked by button 2 */
;|***    #define PU_MOUSEBUTTON3DOWN        0x0018 /* If invoked by button 3 */
;|*** 
;|***    #define PU_SELECTITEM              0x0020 /* Set selected item (use with kbd) */
;|*** 
;|***    #define PU_MOUSEBUTTON1            0x0040 /* If button1 use allowed */
;|***    #define PU_MOUSEBUTTON2            0x0080 /* If button2 use allowed */
;|***    #define PU_MOUSEBUTTON3            0x0100 /* If button3 use allowed */
;|***    #define PU_KEYBOARD                0x0200 /* If keyboard use allowed */
;|*** 
;|*** 
;|***    /* Useful macros */
;|*** 
;|***    /***************************************************************************
;|***    * BOOL WinCheckMenuItem(HWND hwndMenu, ULONG/USHORT id, BOOL fcheck)
;|***    *    Sets the check state of menuitem #id to fcheck.
;|***    *    returns fSuccess.
;|***    ***************************************************************************/
;|***    #define WinCheckMenuItem(hwndMenu, id, fcheck) \
;|***    ((BOOL)WinSendMsg(hwndMenu, MM_SETITEMATTR, \
;|***    MPFROM2SHORT(id, TRUE), \
;|***    MPFROM2SHORT(MIA_CHECKED, (USHORT)(fcheck) ? MIA_CHECKED : 0)))
;|*** 
;|***    /***************************************************************************
;|***    * BOOL WinIsMenuItemChecked(HWND hwndMenu, USHORT/ULONG id)
;|***    *    returns the check state of menuitem #id.
;|***    *
;|***    ***************************************************************************/
;|***    #ifdef INCL_32
;|***       #define WinIsMenuItemChecked(hwndMenu, id) \
;|***       ((BOOL)WinSendMsg(hwndMenu, MM_QUERYITEMATTR, \
;|***       MPFROM2SHORT(id, TRUE), \
;|***       MPFROMLONG(MIA_CHECKED)))
;|***    #else
;|***       #define WinIsMenuItemChecked(hwndMenu, id) \
;|***       ((BOOL)WinSendMsg(hwndMenu, MM_QUERYITEMATTR, \
;|***       MPFROM2SHORT(id, TRUE), \
;|***       MPFROMSHORT(MIA_CHECKED)))
;|***    #endif
;|*** 
;|***    /***************************************************************************
;|***    * BOOL WinEnableMenuItem(HWND hwndMenu, ULONG/USHORT id, BOOL fenable)
;|***    *    sets the enable state of menuitem #id to fenable.
;|***    *    returns fSuccess.
;|***    ***************************************************************************/
;|***    #define WinEnableMenuItem(hwndMenu, id, fEnable) \
;|***    ((BOOL)WinSendMsg(hwndMenu, MM_SETITEMATTR, \
;|***    MPFROM2SHORT(id, TRUE), \
;|***    MPFROM2SHORT(MIA_DISABLED, (USHORT)(fEnable) ? 0 : MIA_DISABLED)))
;|*** 
;|***    /***************************************************************************
;|***    * BOOL WinIsMenuItemEnabled(HWND hwndMenu, USHORT/ULONG id)
;|***    *    returns the enable state of menuitem #id.
;|***    *
;|***    ***************************************************************************/
;|***    #ifdef INCL_32
;|***       #define WinIsMenuItemEnabled(hwndMenu, id)  \
;|***       (!(BOOL)WinSendMsg(hwndMenu, MM_QUERYITEMATTR, \
;|***       MPFROM2SHORT(id, TRUE), \
;|***       MPFROMLONG(MIA_DISABLED)))
;|***    #else
;|***       #define WinIsMenuItemEnabled(hwndMenu, id)  \
;|***       (!(BOOL)WinSendMsg(hwndMenu, MM_QUERYITEMATTR, \
;|***       MPFROM2SHORT(id, TRUE), \
;|***       MPFROMSHORT(MIA_DISABLED)))
;|***    #endif
;|*** 
;|***    /***************************************************************************
;|***    * BOOL WinSetMenuItemText(HWND hwndMenu, ULONG/USHORT id, PSZ psz)
;|***    *    sets the text of menuitem #id.
;|***    *    returns fSuccess.
;|***    ***************************************************************************/
;|***    #ifdef INCL_32
;|***       #define WinSetMenuItemText(hwndMenu, id, psz) \
;|***       ((BOOL)WinSendMsg(hwndMenu, MM_SETITEMTEXT, \
;|***       MPFROMLONG(id), MPFROMP(psz)))
;|***    #else
;|***       #define WinSetMenuItemText(hwndMenu, id, psz) \
;|***       ((BOOL)WinSendMsg(hwndMenu, MM_SETITEMTEXT, \
;|***       MPFROMSHORT(id), MPFROMP(psz)))
;|***    #endif
;|*** 
;|***    /***************************************************************************
;|***    * BOOL WinIsMenuItemValid(HWND hwndMenu, ULONG/USHORT id)
;|***    *    Returns TRUE if the specified item is a valid choice.
;|***    ***************************************************************************/
;|***    #ifdef INCL_32
;|***       #define WinIsMenuItemValid(hwndMenu, id) \
;|***       ((BOOL)WinSendMsg(hwndMenu, MM_ISITEMVALID, \
;|***       MPFROM2SHORT(id, TRUE), MPFROMLONG(FALSE)))
;|***    #else
;|***       #define WinIsMenuItemValid(hwndMenu, id) \
;|***       ((BOOL)WinSendMsg(hwndMenu, MM_ISITEMVALID, \
;|***       MPFROM2SHORT(id, TRUE), MPFROMSHORT(FALSE)))
;|***    #endif
;|*** 
;|*** #endif /* INCL_WINMENUS */
;|*** 
;|*** 
;|*** #ifdef INCL_WINSCROLLBARS
;|*** 
;|***    /*** Scroll Bar controls Subsection */
;|*** 
;|***    /* Scroll Bar styles */
;|*** 
;|***    #define SBS_HORZ                   0L
;|***    #define SBS_VERT                   1L
;|***    #define SBS_THUMBSIZE              2L
;|***    #define SBS_AUTOTRACK              4L
;|***    #define SBS_AUTOSIZE        0x2000L
;|*** 
;|*** 
;|*** 
;|***    /* Scroll Bar messages */
;|*** 
;|***    #define SBM_SETSCROLLBAR           0x01a0
;|***    #define SBM_SETPOS                 0x01a1
;|***    #define SBM_QUERYPOS               0x01a2
;|***    #define SBM_QUERYRANGE             0x01a3
;|***    #define SBM_SETTHUMBSIZE           0x01a6
;|*** 
;|***    /* Scroll Bar Commands */
;|*** 
;|***    #define SB_LINEUP                  1
;|***    #define SB_LINEDOWN                2
;|***    #define SB_LINELEFT                1
;|***    #define SB_LINERIGHT               2
;|***    #define SB_PAGEUP                  3
;|***    #define SB_PAGEDOWN                4
;|***    #define SB_PAGELEFT                3
;|***    #define SB_PAGERIGHT               4
;|***    #define SB_SLIDERTRACK             5
;|***    #define SB_SLIDERPOSITION          6
;|***    #define SB_ENDSCROLL               7
;|*** 
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #pragma pack(2) /* force structure alignment packing */
;|*** 
;|***       /* Binary resources may be bound into application executables or */
;|***       /* passed as a parameter when creating a window or dialog        */
;|***       /* Currently they must be the same for both 16-bit and 32-bit    */
;|***       /* so we pack the structures.                                    */
;|***       typedef struct _SBCDATA {  /* sbcd */
;|***          USHORT  cb;
;|***          USHORT  sHilite;      /* reserved, should be set to zero */
;|***          SHORT   posFirst;
;|***          SHORT   posLast;
;|***          SHORT   posThumb;
;|***          SHORT   cVisible;
;|***          SHORT   cTotal;
;|***       } SBCDATA;
;|***       typedef SBCDATA FAR *PSBCDATA;
;|*** 
;|***       #pragma pack()  /* restore packing to default */
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|*** #endif /* INCL_WINSCROLLBARS */
;|*** 
;|*** 
;|*** #if (defined(INCL_WINFRAMEMGR) || !defined(INCL_NOCOMMON))
;|***    /*** Frame Manager Common subsection */
;|*** 
;|***    #pragma pack(2) /* force structure alignment packing */
;|*** 
;|***    /* Binary resources may be bound into application executables or */
;|***    /* passed as a parameter when creating a window or dialog        */
;|***    /* Currently they must be the same for both 16-bit and 32-bit    */
;|***    /* so we pack the structures.                                    */
;|***    typedef struct _FRAMECDATA {  /* fcdata */
;|***       USHORT  cb;
;|***       ULONG   flCreateFlags;
;|***       USHORT  hmodResources;
;|***       USHORT  idResources;
;|***    } FRAMECDATA;
;|***    typedef FRAMECDATA FAR *PFRAMECDATA;
;|*** 
;|***    #pragma pack()  /* restore packing to default */
;|*** 
;|***    /* Frame window styles */
;|***    /* All unused FCF_xxx bits are reserved */
;|***    #define FCF_TITLEBAR               0x00000001L
;|***    #define FCF_SYSMENU                0x00000002L
;|***    #define FCF_MENU                   0x00000004L
;|***    #define FCF_SIZEBORDER             0x00000008L
;|***    #define FCF_MINBUTTON              0x00000010L
;|***    #define FCF_MAXBUTTON              0x00000020L
;|***    #define FCF_MINMAX                 0x00000030L /* minmax means BOTH buttons */
;|***    #define FCF_VERTSCROLL             0x00000040L
;|***    #define FCF_HORZSCROLL             0x00000080L
;|***    #define FCF_DLGBORDER              0x00000100L
;|***    #define FCF_BORDER                 0x00000200L
;|***    #define FCF_SHELLPOSITION          0x00000400L
;|***    #define FCF_TASKLIST               0x00000800L
;|***    #define FCF_NOBYTEALIGN            0x00001000L
;|***    #define FCF_NOMOVEWITHOWNER        0x00002000L
;|***    #define FCF_ICON                   0x00004000L
;|***    #define FCF_ACCELTABLE             0x00008000L
;|***    #define FCF_SYSMODAL               0x00010000L
;|***    #define FCF_SCREENALIGN            0x00020000L
;|***    #define FCF_MOUSEALIGN             0x00040000L
;|***    #define FCF_HIDEBUTTON             0x01000000L
;|***    #define FCF_HIDEMAX                0x01000020L /* hidemax means BOTH buttons */
;|***    #ifdef INCL_16
;|***       /* New values to enable multiple palettes.  Note that if none of the four   */
;|***       /* styles specified below are used then we default to the 'system' palette  */
;|***       #define FCF_PALETTE_NORMAL      0x00080000L /* normal palette            */
;|***       #define FCF_PALETTE_HELP        0x00100000L /* help palette              */
;|***       #define FCF_PALETTE_POPUPODD    0x00200000L /* odd level popup palette   */
;|***       #define FCF_PALETTE_POPUPEVEN   0x00400000L /* even level popup palette  */
;|***    #endif
;|***    #ifdef INCL_NLS
;|***       #define FCF_DBE_APPSTAT         0x80000000L
;|***    #endif /* INCL_NLS */
;|***    #define FCF_AUTOICON               0x40000000L
;|*** 
;|***    #ifdef INCL_32
;|***       /* FCF_TITLEBAR | FCF_SYSMENU | FCF_MENU | FCF_SIZEBORDER | FCF_MINMAX |
;|***       FCF_ICON | FCF_ACCELTABLE | FCF_SHELLPOSITION | FCF_TASKLIST */
;|***       #define FCF_STANDARD            0x0000CC3FL
;|***    #else
;|***       /* FCF_TITLEBAR | FCF_SYSMENU | FCF_MENU | FCF_SIZEBORDER | FCF_MINMAX |
;|***       FCF_ICON | FCF_ACCELTABLE | FCF_SHELLPOSITION | FCF_TASKLIST | FCF_PALETTE_NORMAL */
;|***       #define FCF_STANDARD            0x0008CC3FL
;|***    #endif
;|*** 
;|*** 
;|***    #define FS_ICON                    0x00000001L
;|***    #define FS_ACCELTABLE              0x00000002L
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #define FS_SHELLPOSITION        0x00000004L
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    #define FS_TASKLIST                0x00000008L
;|***    #define FS_NOBYTEALIGN             0x00000010L
;|***    #define FS_NOMOVEWITHOWNER         0x00000020L
;|***    #define FS_SYSMODAL                0x00000040L
;|***    #define FS_DLGBORDER               0x00000080L
;|***    #define FS_BORDER                  0x00000100L
;|***    #define FS_SCREENALIGN             0x00000200L
;|***    #define FS_MOUSEALIGN              0x00000400L
;|***    #define FS_SIZEBORDER              0x00000800L
;|***    #define FS_AUTOICON                0x00001000L
;|***    #ifdef INCL_NLS
;|***       #define FS_DBE_APPSTAT          0x00008000L
;|***    #endif /* INCL_NLS */
;|*** 
;|***    /* FS_ICON | FS_ACCELTABLE | FS_SHELLPOSITION | FS_TASKLIST */
;|***    #define FS_STANDARD                0x0000000FL
;|*** 
;|*** 
;|***    /* Frame Window Flags accessed via WinSet/QueryWindowUShort(QWS_FLAGS) */
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #define FF_FLASHWINDOW             0x0001
;|***       #define FF_ACTIVE                  0x0002
;|***       #define FF_FLASHHILITE             0x0004
;|***       #define FF_OWNERHIDDEN             0x0008
;|***       #define FF_DLGDISMISSED            0x0010
;|***       #define FF_OWNERDISABLED           0x0020
;|***       #define FF_SELECTED                0x0040
;|***       #define FF_NOACTIVATESWP           0x0080
;|***       #define FF_DIALOGBOX               0x0100
;|*** 
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|*** 
;|***    #ifdef INCL_32
;|***       HWND  APIENTRY WinCreateStdWindow(HWND hwndParent,
;|***                                         ULONG flStyle,
;|***                                         PULONG pflCreateFlags,
;|***                                         PSZ pszClientClass,
;|***                                         PSZ pszTitle,
;|***                                         ULONG styleClient,
;|***                                         HMODULE hmod,
;|***                                         ULONG idResources,
;|***                                         PHWND phwndClient);
;|***    #else
;|***       HWND  APIENTRY WinCreateStdWindow(HWND hwndParent,
;|***                                         ULONG flStyle,
;|***                                         PULONG pflCreateFlags,
;|***                                         PSZ pszClientClass,
;|***                                         PSZ pszTitle,
;|***                                         ULONG styleClient,
;|***                                         HMODULE hmod,
;|***                                         USHORT idResources,
;|***                                         PHWND phwndClient);
;|***    #endif
;|*** 
;|*** 
;|*** #endif /* Frame Manager Common subsection */
;|*** 
;|*** 
;|*** #ifdef INCL_WINFRAMEMGR
;|*** 
;|***    BOOL  APIENTRY WinFlashWindow(HWND hwndFrame,
;|***                                  BOOL fFlash);
;|*** 
;|***    /* Frame window related messages */
;|*** 
;|***    #define WM_FLASHWINDOW             0x0040
;|***    #define WM_FORMATFRAME             0x0041
;|***    #define WM_UPDATEFRAME             0x0042
;|***    #define WM_FOCUSCHANGE             0x0043
;|*** 
;|***    #define WM_SETBORDERSIZE           0x0044
;|***    #define WM_TRACKFRAME              0x0045
;|***    #define WM_MINMAXFRAME             0x0046
;|***    #define WM_SETICON                 0x0047
;|***    #define WM_QUERYICON               0x0048
;|***    #define WM_SETACCELTABLE           0x0049
;|***    #define WM_QUERYACCELTABLE         0x004a
;|***    #define WM_TRANSLATEACCEL          0x004b
;|***    #define WM_QUERYTRACKINFO          0x004c
;|***    #define WM_QUERYBORDERSIZE         0x004d
;|***    #define WM_NEXTMENU                0x004e
;|***    #define WM_ERASEBACKGROUND         0x004f
;|***    #define WM_QUERYFRAMEINFO          0x0050
;|***    #define WM_QUERYFOCUSCHAIN         0x0051
;|***    #define WM_OWNERPOSCHANGE          0x0052
;|***    #define WM_CALCFRAMERECT           0x0053
;|***    /* Note 0x0054 is reserved */
;|***    #define WM_WINDOWPOSCHANGED        0x0055
;|***    #define WM_ADJUSTFRAMEPOS          0x0056
;|***    #define WM_QUERYFRAMECTLCOUNT      0x0059
;|***    #ifndef INCL_SAADEFS
;|***       /* Note 0x005A is reserved */
;|***       #define WM_QUERYHELPINFO        0x005B
;|***       #define WM_SETHELPINFO          0x005C
;|***       #define WM_ERROR                0x005D
;|***       #define WM_REALIZEPALETTE       0x005E
;|*** 
;|*** 
;|***       /* WM_QUERYFRAMEINFO constants */
;|*** 
;|***       #define FI_FRAME                0x00000001L
;|***       #define FI_OWNERHIDE            0x00000002L
;|***       #define FI_ACTIVATEOK           0x00000004L
;|***       #define FI_NOMOVEWITHOWNER      0x00000008L
;|*** 
;|*** 
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|*** 
;|***    BOOL  APIENTRY WinCreateFrameControls(HWND hwndFrame,
;|***                                          PFRAMECDATA pfcdata,
;|***                                          PSZ pszTitle);
;|*** 
;|***    BOOL  APIENTRY WinCalcFrameRect(HWND hwndFrame,
;|***                                    PRECTL prcl,
;|***                                    BOOL fClient);
;|*** 
;|***    BOOL  APIENTRY WinGetMinPosition(HWND hwnd,
;|***                                     PSWP pswp,
;|***                                     PPOINTL pptl);
;|***    #ifndef INCL_SAADEFS
;|***       BOOL  APIENTRY WinGetMaxPosition(HWND hwnd,
;|***                                        PSWP pswp);
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    typedef LHANDLE HSAVEWP;      /* hsvwp */
;|*** 
;|***    #ifdef INCL_32
;|***       BOOL APIENTRY WinSaveWindowPos(HSAVEWP hsvwp,
;|***                                      PSWP pswp,
;|***                                      ULONG cswp);
;|***    #else
;|***       BOOL APIENTRY WinSaveWindowPos(HSAVEWP hsvwp,
;|***                                      PSWP pswp,
;|***                                      USHORT cswp);
;|***    #endif
;|*** 
;|***    /* Frame control IDs    */
;|*** 
;|***    #define FID_SYSMENU                0x8002
;|***    #define FID_TITLEBAR               0x8003
;|***    #define FID_MINMAX                 0x8004
;|***    #define FID_MENU                   0x8005
;|***    #define FID_VERTSCROLL             0x8006
;|***    #define FID_HORZSCROLL             0x8007
;|***    #define FID_CLIENT                 0x8008
;|***    /* Note 0x8009 is reserved */
;|*** 
;|***    #define FID_DBE_APPSTAT            0x8010
;|***    #define FID_DBE_KBDSTAT            0x8011
;|***    #define FID_DBE_PECIC              0x8012
;|***    #define FID_DBE_KKPOPUP            0x8013
;|*** 
;|***    /* Standard WM_SYSCOMMAND command values */
;|*** 
;|***    #define SC_SIZE                    0x8000
;|***    #define SC_MOVE                    0x8001
;|***    #define SC_MINIMIZE                0x8002
;|***    #define SC_MAXIMIZE                0x8003
;|***    #define SC_CLOSE                   0x8004
;|***    #define SC_NEXT                    0x8005
;|***    #define SC_APPMENU                 0x8006
;|***    #define SC_SYSMENU                 0x8007
;|***    #define SC_RESTORE                 0x8008
;|***    #define SC_NEXTFRAME               0x8009
;|***    #define SC_NEXTWINDOW              0x8010
;|***    #ifndef INCL_SAADEFS
;|***       #define SC_TASKMANAGER             0x8011
;|***       #define SC_HELPKEYS                0x8012
;|***       #define SC_HELPINDEX               0x8013
;|***       #define SC_HELPEXTENDED            0x8014
;|***       #define SC_SWITCHPANELIDS          0x8015
;|***       #define SC_DBE_FIRST               0x8018
;|***       #define SC_DBE_LAST                0x801F
;|*** 
;|***       #define SC_BEGINDRAG               0x8020
;|***       #define SC_ENDDRAG                 0x8021
;|***       #define SC_SELECT                  0x8022
;|***       #define SC_OPEN                    0x8023
;|***       #define SC_CONTEXTMENU             0x8024
;|***       #define SC_CONTEXTHELP             0x8025
;|***       #define SC_TEXTEDIT                0x8026
;|***       #define SC_BEGINSELECT             0x8027
;|***       #define SC_ENDSELECT               0x8028
;|***       #define SC_WINDOW                  0x8029
;|***       #define SC_HIDE                    0x802a
;|*** 
;|*** 
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|*** #endif /* INCL_WINFRAMEMGR */
;|*** 
;|*** /*** Frame controls */
;|*** 
;|*** #ifdef INCL_WINFRAMECTLS
;|*** 
;|***    /** Title bar controls */
;|*** 
;|*** 
;|***    /* Title bar control messages */
;|*** 
;|***    #define TBM_SETHILITE              0x01e3
;|***    #define TBM_QUERYHILITE            0x01e4
;|*** 
;|***    #ifdef INCL_16
;|***       #define TBM_TRACKMOVE              0x01e5
;|***    #endif /* INCL_16 */
;|*** 
;|*** #endif /* INCL_WINFRAMECTLS */
;|*** 
;|*** #ifdef INCL_WINRECTANGLES
;|***    /*** Rectangle routines */
;|*** 
;|***    BOOL APIENTRY WinCopyRect(HAB hab,
;|***                              PRECTL prclDst,
;|***                              PRECTL prclSrc);
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #ifdef INCL_32
;|***          BOOL APIENTRY WinSetRect(HAB hab,
;|***                                   PRECTL prcl,
;|***                                   LONG xLeft,
;|***                                   LONG yBottom,
;|***                                   LONG xRight,
;|***                                   LONG yTop);
;|***       #else
;|***          BOOL APIENTRY WinSetRect(HAB hab,
;|***                                   PRECTL prcl,
;|***                                   SHORT xLeft,
;|***                                   SHORT yBottom,
;|***                                   SHORT xRight,
;|***                                   SHORT yTop);
;|***       #endif
;|***       BOOL APIENTRY WinIsRectEmpty(HAB hab,
;|***                                    PRECTL prcl);
;|***       BOOL APIENTRY WinEqualRect(HAB hab,
;|***                                  PRECTL prcl1,
;|***                                  PRECTL prcl2);
;|***       BOOL APIENTRY WinSetRectEmpty(HAB hab,
;|***                                     PRECTL prcl);
;|***       #ifdef INCL_32
;|***          BOOL APIENTRY WinOffsetRect(HAB hab,
;|***                                      PRECTL prcl,
;|***                                      LONG cx,
;|***                                      LONG cy);
;|***          BOOL APIENTRY WinInflateRect(HAB hab,
;|***                                       PRECTL prcl,
;|***                                       LONG cx,
;|***                                       LONG cy);
;|***       #else
;|***          BOOL APIENTRY WinOffsetRect(HAB hab,
;|***                                      PRECTL prcl,
;|***                                      SHORT cx,
;|***                                      SHORT cy);
;|***          BOOL APIENTRY WinInflateRect(HAB hab,
;|***                                       PRECTL prcl,
;|***                                       SHORT cx,
;|***                                       SHORT cy);
;|***       #endif
;|***       BOOL APIENTRY WinPtInRect(HAB hab,
;|***                                 PRECTL prcl,
;|***                                 PPOINTL pptl);
;|***       BOOL APIENTRY WinIntersectRect(HAB hab,
;|***                                      PRECTL prclDst,
;|***                                      PRECTL prclSrc1,
;|***                                      PRECTL prclSrc2);
;|***       BOOL APIENTRY WinUnionRect(HAB hab,
;|***                                  PRECTL prclDst,
;|***                                  PRECTL prclSrc1,
;|***                                  PRECTL prclSrc2);
;|***       BOOL APIENTRY WinSubtractRect(HAB hab,
;|***                                     PRECTL prclDst,
;|***                                     PRECTL prclSrc1,
;|***                                     PRECTL prclSrc2);
;|***       #ifdef INCL_32
;|***          BOOL APIENTRY WinMakeRect(HAB hab,
;|***                                    PRECTL pwrc);
;|***          BOOL APIENTRY WinMakePoints(HAB hab,
;|***                                      PPOINTL pwpt,
;|***                                      ULONG cwpt);
;|***       #else
;|***          BOOL APIENTRY WinMakeRect(HAB hab,
;|***                                    PWRECT pwrc);
;|***          BOOL APIENTRY WinMakePoints(HAB hab,
;|***                                      PWPOINT pwpt,
;|***                                      USHORT cwpt);
;|***       #endif
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|*** #endif /* INCL_WINRECTANGLES */
;|*** 
;|*** 
;|*** #ifdef INCL_WINSYS
;|*** 
;|***    /*** System values */
;|*** 
;|***    #ifdef INCL_32
;|***       LONG APIENTRY WinQuerySysValue(HWND hwndDesktop,
;|***                                      LONG iSysValue);
;|***       BOOL  APIENTRY WinSetSysValue(HWND hwndDesktop,
;|***                                     LONG iSysValue,
;|***                                     LONG lValue);
;|***    #else
;|***       LONG APIENTRY WinQuerySysValue(HWND hwndDesktop,
;|***                                      SHORT iSysValue);
;|***       BOOL  APIENTRY WinSetSysValue(HWND hwndDesktop,
;|***                                     SHORT iSysValue,
;|***                                     LONG lValue);
;|***    #endif
;|*** 
;|***    #define SV_SWAPBUTTON              0
;|***    #define SV_DBLCLKTIME              1
;|***    #define SV_CXDBLCLK                2
;|***    #define SV_CYDBLCLK                3
;|***    #define SV_CXSIZEBORDER            4
;|***    #define SV_CYSIZEBORDER            5
;|***    #define SV_ALARM                   6
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #define SV_RESERVEDFIRST1          7
;|***       #define SV_RESERVEDLAST1           8
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    #define SV_CURSORRATE              9
;|***    #define SV_FIRSTSCROLLRATE         10
;|***    #define SV_SCROLLRATE              11
;|***    #define SV_NUMBEREDLISTS           12
;|***    #define SV_WARNINGFREQ             13
;|***    #define SV_NOTEFREQ                14
;|***    #define SV_ERRORFREQ               15
;|***    #define SV_WARNINGDURATION         16
;|***    #define SV_NOTEDURATION            17
;|***    #define SV_ERRORDURATION           18
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #define SV_RESERVEDFIRST           19
;|***       #define SV_RESERVEDLAST            19
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    #define SV_CXSCREEN                20
;|***    #define SV_CYSCREEN                21
;|***    #define SV_CXVSCROLL               22
;|***    #define SV_CYHSCROLL               23
;|***    #define SV_CYVSCROLLARROW          24
;|***    #define SV_CXHSCROLLARROW          25
;|***    #define SV_CXBORDER                26
;|***    #define SV_CYBORDER                27
;|***    #define SV_CXDLGFRAME              28
;|***    #define SV_CYDLGFRAME              29
;|***    #define SV_CYTITLEBAR              30
;|***    #define SV_CYVSLIDER               31
;|***    #define SV_CXHSLIDER               32
;|***    #define SV_CXMINMAXBUTTON          33
;|***    #define SV_CYMINMAXBUTTON          34
;|***    #define SV_CYMENU                  35
;|***    #define SV_CXFULLSCREEN            36
;|***    #define SV_CYFULLSCREEN            37
;|***    #define SV_CXICON                  38
;|***    #define SV_CYICON                  39
;|***    #define SV_CXPOINTER               40
;|***    #define SV_CYPOINTER               41
;|*** 
;|***    #define SV_DEBUG                   42
;|***    #define SV_CMOUSEBUTTONS           43
;|***    #define SV_CPOINTERBUTTONS         43
;|***    #define SV_POINTERLEVEL            44
;|***    #define SV_CURSORLEVEL             45
;|***    #define SV_TRACKRECTLEVEL          46
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #define SV_CTIMERS                 47
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    #define SV_MOUSEPRESENT            48
;|*** 
;|***    #define SV_CXBYTEALIGN             49
;|***    #define SV_CXALIGN                 49
;|***    #define SV_CYBYTEALIGN             50
;|***    #define SV_CYALIGN                 50
;|*** 
;|***    /* The following value enables any greater value to be set by WinSetSysVlaue. */
;|***    /* Values of 51-55 are spare for extra non-settable system values             */
;|***    /* This is to enable the setting of SV_EXTRAKEYBEEP by applications.          */
;|*** 
;|***    #define SV_NOTRESERVED             56
;|***    #define SV_EXTRAKEYBEEP            57
;|*** 
;|***    /* The following system value controls whether PM controls the keyboard      */
;|***    /* lights for light key keystrokes (else applications will)                  */
;|***    #define SV_SETLIGHTS               58
;|***    #define SV_INSERTMODE              59
;|*** 
;|*** 
;|***    #define SV_MENUROLLDOWNDELAY       64
;|***    #define SV_MENUROLLUPDELAY         65
;|***    #define SV_ALTMNEMONIC             66
;|***    #define SV_TASKLISTMOUSEACCESS     67
;|*** 
;|***    #define SV_CXICONTEXTWIDTH         68
;|***    #define SV_CICONTEXTLINES          69
;|*** 
;|***    #define SV_CHORDTIME               70
;|***    #define SV_CXCHORD                 71
;|***    #define SV_CYCHORD                 72
;|***    #define SV_CXMOTIONSTART           73
;|***    #define SV_CYMOTIONSTART           74
;|*** 
;|***    #define SV_BEGINDRAG               75
;|***    #define SV_ENDDRAG                 76
;|***    #define SV_SINGLESELECT            77
;|***    #define SV_OPEN                    78
;|***    #define SV_CONTEXTMENU             79
;|***    #define SV_CONTEXTHELP             80
;|***    #define SV_TEXTEDIT                81
;|***    #define SV_BEGINSELECT             82
;|***    #define SV_ENDSELECT               83
;|*** 
;|***    #define SV_BEGINDRAGKB             84
;|***    #define SV_ENDDRAGKB               85
;|***    #define SV_SELECTKB                86
;|***    #define SV_OPENKB                  87
;|***    #define SV_CONTEXTMENUKB           88
;|***    #define SV_CONTEXTHELPKB           89
;|***    #define SV_TEXTEDITKB              90
;|***    #define SV_BEGINSELECTKB           91
;|***    #define SV_ENDSELECTKB             92
;|*** 
;|***    #define SV_ANIMATION               93
;|***    #define SV_ANIMATIONSPEED          94
;|*** 
;|***    #define SV_MONOICONS               95
;|*** 
;|***    #define SV_KBDALTERED              96
;|*** 
;|***    #define SV_PRINTSCREEN             97
;|*** 
;|***    #define SV_LOCKSTARTINPUT          98
;|*** 
;|***    #define SV_CSYSVALUES              99
;|*** 
;|*** 
;|***    /*
;|***    * Presentation parameter structures.
;|***    */
;|***    typedef struct _PARAM {  /* param */
;|***       ULONG   id;
;|***       ULONG   cb;
;|***       BYTE    ab[1];
;|***    } PARAM;
;|***    typedef PARAM NEAR *NPPARAM;
;|***    typedef PARAM FAR  *PPARAM;
;|*** 
;|***    typedef struct _PRESPARAMS {  /* pres */
;|***       ULONG   cb;
;|***       PARAM   aparam[1];
;|***    } PRESPARAMS;
;|***    typedef PRESPARAMS NEAR *NPPRESPARAMS;
;|***    typedef PRESPARAMS FAR  *PPRESPARAMS;
;|*** 
;|***    /*
;|***    * Presentation parameter APIs
;|***    */
;|***    BOOL  APIENTRY WinSetPresParam(HWND hwnd,
;|***                                   ULONG id,
;|***                                   ULONG cbParam,
;|***                                   PVOID pbParam);
;|***    #ifdef INCL_32
;|***       ULONG APIENTRY WinQueryPresParam(HWND hwnd,
;|***                                        ULONG id1,
;|***                                        ULONG id2,
;|***                                        PULONG pulId,
;|***                                        ULONG cbBuf,
;|***                                        PVOID pbBuf,
;|***                                        ULONG fs);
;|***    #else
;|***       ULONG APIENTRY WinQueryPresParam(HWND hwnd,
;|***                                        ULONG id1,
;|***                                        ULONG id2,
;|***                                        PULONG pulId,
;|***                                        ULONG cbBuf,
;|***                                        PVOID pbBuf,
;|***                                        USHORT fs);
;|***    #endif
;|***    BOOL  APIENTRY WinRemovePresParam(HWND hwnd,
;|***                                      ULONG id);
;|*** 
;|***    /*
;|***    * Presentation parameter types.
;|***    */
;|*** 
;|***    #define PP_FOREGROUNDCOLOR                      1L
;|***    #define PP_FOREGROUNDCOLORINDEX                 2L
;|***    #define PP_BACKGROUNDCOLOR                      3L
;|***    #define PP_BACKGROUNDCOLORINDEX                 4L
;|***    #define PP_HILITEFOREGROUNDCOLOR                5L
;|***    #define PP_HILITEFOREGROUNDCOLORINDEX           6L
;|***    #define PP_HILITEBACKGROUNDCOLOR                7L
;|***    #define PP_HILITEBACKGROUNDCOLORINDEX           8L
;|***    #define PP_DISABLEDFOREGROUNDCOLOR              9L
;|***    #define PP_DISABLEDFOREGROUNDCOLORINDEX         10L
;|***    #define PP_DISABLEDBACKGROUNDCOLOR              11L
;|***    #define PP_DISABLEDBACKGROUNDCOLORINDEX         12L
;|***    #define PP_BORDERCOLOR                          13L
;|***    #define PP_BORDERCOLORINDEX                     14L
;|***    #define PP_FONTNAMESIZE                         15L
;|***    #define PP_FONTHANDLE                           16L
;|***    #define PP_RESERVED                             17L
;|***    #define PP_ACTIVECOLOR                          18L
;|***    #define PP_ACTIVECOLORINDEX                     19L
;|***    #define PP_INACTIVECOLOR                        20L
;|***    #define PP_INACTIVECOLORINDEX                   21L
;|***    #define PP_ACTIVETEXTFGNDCOLOR                  22L
;|***    #define PP_ACTIVETEXTFGNDCOLORINDEX             23L
;|***    #define PP_ACTIVETEXTBGNDCOLOR                  24L
;|***    #define PP_ACTIVETEXTBGNDCOLORINDEX             25L
;|***    #define PP_INACTIVETEXTFGNDCOLOR                26L
;|***    #define PP_INACTIVETEXTFGNDCOLORINDEX           27L
;|***    #define PP_INACTIVETEXTBGNDCOLOR                28L
;|***    #define PP_INACTIVETEXTBGNDCOLORINDEX           29L
;|***    #define PP_SHADOW                               30L
;|***    #define PP_MENUFOREGROUNDCOLOR                  31L
;|***    #define PP_MENUFOREGROUNDCOLORINDEX             32L
;|***    #define PP_MENUBACKGROUNDCOLOR                  33L
;|***    #define PP_MENUBACKGROUNDCOLORINDEX             34L
;|***    #define PP_MENUHILITEFGNDCOLOR                  35L
;|***    #define PP_MENUHILITEFGNDCOLORINDEX             36L
;|***    #define PP_MENUHILITEBGNDCOLOR                  37L
;|***    #define PP_MENUHILITEBGNDCOLORINDEX             38L
;|***    #define PP_MENUDISABLEDFGNDCOLOR                39L
;|***    #define PP_MENUDISABLEDFGNDCOLORINDEX           40L
;|***    #define PP_MENUDISABLEDBGNDCOLOR                41L
;|***    #define PP_MENUDISABLEDBGNDCOLORINDEX           42L
;|***    #define PP_SHADOWTEXTCOLOR                      43L
;|***    #define PP_SHADOWTEXTCOLORINDEX                 44L
;|***    #define PP_SHADOWHILITEFGNDCOLOR                45L
;|***    #define PP_SHADOWHILITEFGNDCOLORINDEX           46L
;|***    #define PP_SHADOWHILITEBGNDCOLOR                47L
;|***    #define PP_SHADOWHILITEBGNDCOLORINDEX           48L
;|***    #define PP_ICONTEXTBACKGROUNDCOLOR              49L
;|***    #define PP_ICONTEXTBACKGROUNDCOLORINDEX         50L
;|*** 
;|***    /* PP_ values 0x100 - 0x012F are reserved*/
;|***    /* for bidirectional language support.   */
;|*** 
;|***    #define PP_BIDI_FIRST                           0x0100L
;|***    #define PP_BIDI_LAST                            0x012FL
;|*** 
;|***    #define PP_USER                                 0x8000L
;|*** 
;|***    /*
;|***    * Flags for WinQueryPresParams()
;|***    */
;|***    #define QPF_NOINHERIT            0x0001 /* Don't inherit                      */
;|***    #define QPF_ID1COLORINDEX        0x0002 /* Convert id1 color index into RGB   */
;|***    #define QPF_ID2COLORINDEX        0x0004 /* Convert id2 color index into RGB   */
;|***    #define QPF_PURERGBCOLOR         0x0008 /* Return pure RGB colors             */
;|***    #define QPF_VALIDFLAGS           0x000F /* Valid WinQueryPresParams() flags.  */
;|*** 
;|***    /*** System color functions */
;|*** 
;|***    LONG APIENTRY WinQuerySysColor(HWND hwndDesktop,
;|***                                   LONG clr,
;|***                                   LONG lReserved);
;|***    BOOL APIENTRY WinSetSysColors(HWND hwndDesktop,
;|***                                  ULONG flOptions,
;|***                                  ULONG flFormat,
;|***                                  LONG clrFirst,
;|***                                  ULONG cclr,
;|***                                  PLONG pclr);
;|*** 
;|***    #define SYSCLR_SHADOWHILITEBGND         (-50L)
;|***    #define SYSCLR_SHADOWHILITEFGND         (-49L)
;|***    #define SYSCLR_SHADOWTEXT               (-48L)
;|***    #define SYSCLR_ENTRYFIELD               (-47L)
;|***    #define SYSCLR_MENUDISABLEDTEXT         (-46L)
;|***    #define SYSCLR_MENUHILITE               (-45L)
;|***    #define SYSCLR_MENUHILITEBGND           (-44L)
;|***    #define SYSCLR_PAGEBACKGROUND           (-43L)
;|***    #define SYSCLR_FIELDBACKGROUND          (-42L)
;|***    #define SYSCLR_BUTTONLIGHT              (-41L)
;|***    #define SYSCLR_BUTTONMIDDLE             (-40L)
;|***    #define SYSCLR_BUTTONDARK               (-39L)
;|***    #define SYSCLR_BUTTONDEFAULT            (-38L)
;|***    #define SYSCLR_TITLEBOTTOM              (-37L)
;|***    #define SYSCLR_SHADOW                   (-36L)
;|***    #define SYSCLR_ICONTEXT                 (-35L)
;|***    #define SYSCLR_DIALOGBACKGROUND         (-34L)
;|***    #define SYSCLR_HILITEFOREGROUND         (-33L)
;|***    #define SYSCLR_HILITEBACKGROUND         (-32L)
;|***    #define SYSCLR_INACTIVETITLETEXTBGND    (-31L)
;|***    #define SYSCLR_ACTIVETITLETEXTBGND      (-30L)
;|***    #define SYSCLR_INACTIVETITLETEXT        (-29L)
;|***    #define SYSCLR_ACTIVETITLETEXT          (-28L)
;|***    #define SYSCLR_OUTPUTTEXT               (-27L)
;|***    #define SYSCLR_WINDOWSTATICTEXT         (-26L)
;|***    #define SYSCLR_SCROLLBAR                (-25L)
;|***    #define SYSCLR_BACKGROUND               (-24L)
;|***    #define SYSCLR_ACTIVETITLE              (-23L)
;|***    #define SYSCLR_INACTIVETITLE            (-22L)
;|***    #define SYSCLR_MENU                     (-21L)
;|***    #define SYSCLR_WINDOW                   (-20L)
;|***    #define SYSCLR_WINDOWFRAME              (-19L)
;|***    #define SYSCLR_MENUTEXT                 (-18L)
;|***    #define SYSCLR_WINDOWTEXT               (-17L)
;|***    #define SYSCLR_TITLETEXT                (-16L)
;|***    #define SYSCLR_ACTIVEBORDER             (-15L)
;|***    #define SYSCLR_INACTIVEBORDER           (-14L)
;|***    #define SYSCLR_APPWORKSPACE             (-13L)
;|***    #define SYSCLR_HELPBACKGROUND           (-12L)
;|***    #define SYSCLR_HELPTEXT                 (-11L)
;|***    #define SYSCLR_HELPHILITE               (-10L)
;|*** 
;|***    #define SYSCLR_CSYSCOLORS               41L
;|*** 
;|*** #endif /* INCL_WINSYS */
;|*** 
;|*** 
;|*** #ifdef INCL_WINTIMER
;|***    /**** Timer manager */
;|*** 
;|***    #ifndef INCL_SAADEFS
;|*** 
;|***       #ifdef INCL_32
;|*** 
;|***          ULONG APIENTRY WinStartTimer(HAB hab,
;|***                                       HWND hwnd,
;|***                                       ULONG idTimer,
;|***                                       ULONG dtTimeout);
;|***          BOOL   APIENTRY WinStopTimer(HAB hab,
;|***                                       HWND hwnd,
;|***                                       ULONG idTimer);
;|*** 
;|***       #else /* not INCL_32 */
;|*** 
;|***          USHORT APIENTRY WinStartTimer(HAB hab,
;|***                                        HWND hwnd,
;|***                                        USHORT idTimer,
;|***                                        USHORT dtTimeout);
;|***          BOOL   APIENTRY WinStopTimer(HAB hab,
;|***                                       HWND hwnd,
;|***                                       USHORT idTimer);
;|*** 
;|***       #endif /* INCL_32 */
;|*** 
;|***       ULONG  APIENTRY WinGetCurrentTime(HAB hab);
;|*** 
;|***       #define TID_CURSOR          0xffff  /* Reserved cursor timer ID              */
;|***       #define TID_SCROLL          0xfffe  /* Reserved scrolling timer ID           */
;|***       #define TID_FLASHWINDOW     0xfffd  /* Reserved for window flashing timer ID */
;|***       #define TID_USERMAX         0x7fff  /* Maximum user timer ID                 */
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|*** #endif /* INCL_WINTIMER */
;|*** 
;|*** typedef LHANDLE HACCEL; /* haccel */
;|*** 
;|*** #ifdef INCL_WINACCELERATORS
;|***    /**** Accelerator functions */
;|*** 
;|***    /* ACCEL fs bits
;|***    *
;|***    * NOTE: the first six AF_ code bits have the same value
;|***    * as their KC_ counterparts
;|***    */
;|***    #ifndef INCL_SAADEFS
;|***       #define AF_CHAR                    0x0001
;|***       #define AF_VIRTUALKEY              0x0002
;|***       #define AF_SCANCODE                0x0004
;|***       #define AF_SHIFT                   0x0008
;|***       #define AF_CONTROL                 0x0010
;|***       #define AF_ALT                     0x0020
;|***       #define AF_LONEKEY                 0x0040
;|***       #define AF_SYSCOMMAND              0x0100
;|***       #define AF_HELP                    0x0200
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    #pragma pack(2) /* force structure alignment packing */
;|*** 
;|***    /* Binary resources may be bound into application executables or */
;|***    /* passed as a parameter when creating a window or dialog        */
;|***    /* Currently they must be the same for both 16-bit and 32-bit    */
;|***    /* so we pack the structures.                                    */
;|***    typedef struct _ACCEL {  /* acc */
;|***       USHORT  fs;
;|***       USHORT  key;
;|***       USHORT  cmd;
;|***    } ACCEL;
;|***    typedef ACCEL FAR *PACCEL;
;|*** 
;|***    /* Binary resources may be bound into application executables or */
;|***    /* passed as a parameter when creating a window or dialog        */
;|***    /* Currently they must be the same for both 16-bit and 32-bit    */
;|***    /* so we pack the structures.                                    */
;|***    typedef struct _ACCELTABLE {  /* acct  */
;|***       USHORT  cAccel;
;|***       USHORT  codepage;
;|***       ACCEL   aaccel[1];
;|***    } ACCELTABLE;
;|***    typedef ACCELTABLE FAR *PACCELTABLE;
;|*** 
;|***    #pragma pack()  /* restore packing to default */
;|*** 
;|***    #ifdef INCL_32
;|***       HACCEL APIENTRY WinLoadAccelTable(HAB hab,
;|***                                         HMODULE hmod,
;|***                                         ULONG idAccelTable);
;|***       ULONG APIENTRY WinCopyAccelTable(HACCEL haccel,
;|***                                        PACCELTABLE pAccelTable,
;|***                                        ULONG cbCopyMax);
;|***    #else
;|***       HACCEL APIENTRY WinLoadAccelTable(HAB hab,
;|***                                         HMODULE hmod,
;|***                                         USHORT idAccelTable);
;|***       USHORT APIENTRY WinCopyAccelTable(HACCEL haccel,
;|***                                         PACCELTABLE pAccelTable,
;|***                                         USHORT cbCopyMax);
;|***    #endif
;|***    HACCEL APIENTRY WinCreateAccelTable(HAB hab,
;|***                                        PACCELTABLE pAccelTable);
;|***    BOOL   APIENTRY WinDestroyAccelTable(HACCEL haccel);
;|***    BOOL   APIENTRY WinTranslateAccel(HAB hab,
;|***                                      HWND hwnd,
;|***                                      HACCEL haccel,
;|***                                      PQMSG pqmsg);
;|***    BOOL   APIENTRY WinSetAccelTable(HAB hab,
;|***                                     HACCEL haccel,
;|***                                     HWND hwndFrame);
;|***    HACCEL APIENTRY WinQueryAccelTable(HAB hab,
;|***                                       HWND hwndFrame);
;|*** 
;|*** #endif /* INCL_WINACCELERATORS */
;|*** 
;|*** /**** Extended Attribute Flags (Association Table) */
;|*** 
;|*** #define EAF_DEFAULTOWNER           0x0001
;|*** #define EAF_UNCHANGEABLE           0x0002
;|*** #define EAF_REUSEICON              0x0004
;|*** 
;|*** /*** WinTrackRect() information */
;|*** 
;|*** #ifdef INCL_WINTRACKRECT
;|*** 
;|***    /* WinTrackRect() tracking information structure */
;|*** 
;|***    #ifdef INCL_32
;|***       typedef struct _TRACKINFO {  /* ti */
;|***          LONG    cxBorder;
;|***          LONG    cyBorder;
;|***          LONG    cxGrid;
;|***          LONG    cyGrid;
;|***          LONG    cxKeyboard;
;|***          LONG    cyKeyboard;
;|***          RECTL   rclTrack;
;|***          RECTL   rclBoundary;
;|***          POINTL  ptlMinTrackSize;
;|***          POINTL  ptlMaxTrackSize;
;|***          ULONG   fs;
;|***       } TRACKINFO;
;|***    #else
;|***       typedef struct _TRACKINFO {  /* ti */
;|***          SHORT   cxBorder;
;|***          SHORT   cyBorder;
;|***          SHORT   cxGrid;
;|***          SHORT   cyGrid;
;|***          SHORT   cxKeyboard;
;|***          SHORT   cyKeyboard;
;|***          RECTL   rclTrack;
;|***          RECTL   rclBoundary;
;|***          POINTL  ptlMinTrackSize;
;|***          POINTL  ptlMaxTrackSize;
;|***          USHORT  fs;
;|***       } TRACKINFO;
;|***    #endif
;|***    typedef TRACKINFO FAR *PTRACKINFO;
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       BOOL APIENTRY WinTrackRect(HWND hwnd,
;|***                                  HPS hps,
;|***                                  PTRACKINFO pti);
;|***       BOOL APIENTRY WinShowTrackRect(HWND hwnd,
;|***                                      BOOL fShow);
;|*** 
;|***       /* WinTrackRect() flags */
;|*** 
;|***       #define TF_LEFT                    0x0001
;|***       #define TF_TOP                     0x0002
;|***       #define TF_RIGHT                   0x0004
;|***       #define TF_BOTTOM                  0x0008
;|***       /* TF_MOVE = TF_LEFT | TF_TOP | TF_RIGHT | TF_BOTTOM */
;|***       #define TF_MOVE                    0x000F
;|*** 
;|***       #define TF_SETPOINTERPOS           0x0010
;|***       #define TF_GRID                    0x0020
;|***       #define TF_STANDARD                0x0040
;|***       #define TF_ALLINBOUNDARY           0x0080
;|***       #define TF_VALIDATETRACKRECT       0x0100
;|***       #define TF_PARTINBOUNDARY          0x0200
;|*** 
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|*** #endif /* INCL_WINTRACKRECT */
;|*** 
;|*** 
;|*** /**** Clipboard Manager */
;|*** 
;|*** #if (defined(INCL_WINCLIPBOARD) || defined(INCL_WINDDE))
;|***    #ifndef INCL_SAADEFS
;|*** 
;|***       /* Clipboard messages */
;|*** 
;|***       #define WM_RENDERFMT               0x0060
;|***       #define WM_RENDERALLFMTS           0x0061
;|***       #define WM_DESTROYCLIPBOARD        0x0062
;|***       #define WM_PAINTCLIPBOARD          0x0063
;|***       #define WM_SIZECLIPBOARD           0x0064
;|***       #define WM_HSCROLLCLIPBOARD        0x0065
;|***       #define WM_VSCROLLCLIPBOARD        0x0066
;|***       #define WM_DRAWCLIPBOARD           0x0067
;|*** 
;|***       /*
;|***       * Standard Clipboard formats
;|***       */
;|***       #define CF_TEXT                    1
;|***       #define CF_BITMAP                  2
;|***       #define CF_DSPTEXT                 3
;|***       #define CF_DSPBITMAP               4
;|***       #define CF_METAFILE                5
;|***       #define CF_DSPMETAFILE             6
;|***       #define CF_PALETTE                 9
;|***       #define CF_MMPMFIRST              10
;|***       #define CF_MMPMLAST               19
;|***       /*
;|***       * standard DDE and clipboard format stings
;|***       */
;|***       #define SZFMT_TEXT                   "#1"
;|***       #define SZFMT_BITMAP                 "#2"
;|***       #define SZFMT_DSPTEXT                "#3"
;|***       #define SZFMT_DSPBITMAP              "#4"
;|***       #define SZFMT_METAFILE               "#5"
;|***       #define SZFMT_DSPMETAFILE            "#6"
;|***       #define SZFMT_PALETTE                "#9"
;|***       #define SZFMT_SYLK                   "Sylk"
;|***       #define SZFMT_DIF                    "Dif"
;|***       #define SZFMT_TIFF                   "Tiff"
;|***       #define SZFMT_OEMTEXT                "OemText"
;|***       #define SZFMT_DIB                    "Dib"
;|***       #define SZFMT_OWNERDISPLAY           "OwnerDisplay"
;|***       #define SZFMT_LINK                   "Link"
;|***       #define SZFMT_METAFILEPICT           "MetaFilePict"
;|***       #define SZFMT_DSPMETAFILEPICT        "DspMetaFilePict"
;|***       #define SZFMT_CPTEXT                 "Codepage Text"
;|***       #define SZDDEFMT_RTF                 "Rich Text Format"
;|***       #define SZDDEFMT_PTRPICT             "Printer_Picture"
;|*** 
;|***       #pragma pack(2) /* force structure alignment packing */
;|*** 
;|***       /* Metafiles are the same no matter whether they are used in     */
;|***       /* 16-bit or 32-bit applications. While not strictly necessary   */
;|***       /* because of inherent alignment we force packing on a 2 byte    */
;|***       /* boundary to avoid any confusion.                              */
;|***       typedef struct _MFP {  /* mfp */
;|***          POINTL sizeBounds;  /* metafile notional grid size      */
;|***          POINTL sizeMM;      /* metafile size high metric units  */
;|***          ULONG  cbLength;    /* length of metafile data          */
;|***          USHORT mapMode;     /* a PM metaflie map mode           */
;|***          USHORT reserved;
;|***          BYTE   abData[1];   /* metafile Data                    */
;|***       } MFP;
;|***       typedef MFP FAR *PMFP;
;|*** 
;|***       /* CPTEXT DDE data are the same no matter whether they are used  */
;|***       /* in 16-bit or 32-bit applications. While not strictly necessary*/
;|***       /* because of inherent alignment we force packing on a 2 byte    */
;|***       /* boundary to avoid any confusion.                              */
;|***       typedef struct _CPTEXT {  /* cptxt */
;|***          USHORT idCountry;
;|***          USHORT usCodepage;
;|***          USHORT usLangID;
;|***          USHORT usSubLangID;
;|***          BYTE   abText[1];   /* text string starts here          */
;|***       } CPTEXT;
;|***       typedef CPTEXT FAR *PCPTEXT;
;|*** 
;|***       #pragma pack()  /* restore packing to default */
;|*** 
;|***    #endif /* not INCL_SAADEFS */
;|*** #endif /* INCL_WINCLIPBOARD | INCL_WINDDE */
;|*** 
;|*** #ifdef INCL_WINCLIPBOARD
;|***    #ifndef INCL_SAADEFS
;|***       BOOL   APIENTRY WinSetClipbrdOwner(HAB hab,
;|***                                          HWND hwnd);
;|***       #ifdef INCL_32
;|***          BOOL   APIENTRY WinSetClipbrdData(HAB hab,
;|***                                            ULONG ulData,
;|***                                            ULONG fmt,
;|***                                            ULONG rgfFmtInfo);
;|***          ULONG  APIENTRY WinQueryClipbrdData(HAB hab,
;|***                                              ULONG fmt);
;|***          BOOL   APIENTRY WinQueryClipbrdFmtInfo(HAB hab,
;|***                                                 ULONG fmt,
;|***                                                 PULONG prgfFmtInfo);
;|***       #else
;|***          BOOL   APIENTRY WinSetClipbrdData(HAB hab,
;|***                                            ULONG ulData,
;|***                                            USHORT fmt,
;|***                                            USHORT rgfFmtInfo);
;|***          ULONG  APIENTRY WinQueryClipbrdData(HAB hab,
;|***                                              USHORT fmt);
;|***          BOOL   APIENTRY WinQueryClipbrdFmtInfo(HAB hab,
;|***                                                 USHORT fmt,
;|***                                                 PUSHORT prgfFmtInfo);
;|***       #endif
;|***       BOOL   APIENTRY WinSetClipbrdViewer(HAB hab,
;|***                                           HWND hwndNewClipViewer);
;|*** 
;|***       /* WinSetClipbrdData() flags */
;|*** 
;|***       #define CFI_OWNERFREE              0x0001
;|***       #define CFI_OWNERDISPLAY           0x0002
;|***       #ifdef INCL_32
;|***          #define CFI_POINTER                0x0400
;|***       #else
;|***          #define CFI_SELECTOR               0x0100
;|***       #endif
;|***       #define CFI_HANDLE                 0x0200
;|*** 
;|***    #endif /* !INCL_SAADEFS */
;|*** 
;|***    #ifdef INCL_32
;|***       ULONG APIENTRY WinEnumClipbrdFmts(HAB hab,
;|***                                         ULONG fmt);
;|***    #else
;|***       USHORT APIENTRY WinEnumClipbrdFmts(HAB hab,
;|***                                          USHORT fmt);
;|***    #endif
;|***    BOOL   APIENTRY WinEmptyClipbrd(HAB hab);
;|***    BOOL   APIENTRY WinOpenClipbrd(HAB hab);
;|***    BOOL   APIENTRY WinCloseClipbrd(HAB hab);
;|*** 
;|***    #ifdef INCL_32
;|***       HWND   APIENTRY WinQueryClipbrdOwner(HAB hab);
;|***       HWND   APIENTRY WinQueryClipbrdViewer(HAB hab);
;|***    #else
;|***       HWND   APIENTRY WinQueryClipbrdOwner(HAB hab,
;|***                                            BOOL fLock);
;|***       HWND   APIENTRY WinQueryClipbrdViewer(HAB hab,
;|***                                             BOOL fLock);
;|***    #endif  /* INCL_32 */
;|*** 
;|*** #endif /* INCL_WINCLIPBOARD */
;|*** 
;|*** 
;|*** #if (defined(INCL_WINCURSORS) || !defined(INCL_NOCOMMON))
;|***    /**** Cursor manager common subsection */
;|*** 
;|***    BOOL APIENTRY WinDestroyCursor(HWND hwnd);
;|***    BOOL APIENTRY WinShowCursor(HWND hwnd,
;|***                                BOOL fShow);
;|***    #ifdef INCL_32
;|***       BOOL APIENTRY WinCreateCursor(HWND hwnd,
;|***                                     LONG x,
;|***                                     LONG y,
;|***                                     LONG cx,
;|***                                     LONG cy,
;|***                                     ULONG fs,
;|***                                     PRECTL prclClip);
;|***    #else
;|***       BOOL APIENTRY WinCreateCursor(HWND hwnd,
;|***                                     SHORT x,
;|***                                     SHORT y,
;|***                                     SHORT cx,
;|***                                     SHORT cy,
;|***                                     USHORT fs,
;|***                                     PRECTL prclClip);
;|***    #endif
;|*** 
;|***    /* WinCreateCursor() flags */
;|*** 
;|***    #define CURSOR_SOLID               0x0000
;|***    #define CURSOR_HALFTONE            0x0001
;|***    #define CURSOR_FRAME               0x0002
;|***    #define CURSOR_FLASH               0x0004
;|***    #define CURSOR_SETPOS              0x8000
;|*** 
;|***    /* Cursor flags 0x0100 and 0x0200 reserved */
;|***    /* for bidirectional language support.     */
;|*** 
;|***    #define CURSOR_BIDI_FIRST          0x0100
;|***    #define CURSOR_BIDI_LAST           0x0200
;|*** 
;|*** 
;|*** #endif /* Cursor manager common subsection */
;|*** 
;|*** #ifdef INCL_WINCURSORS
;|*** 
;|***    #ifdef INCL_32
;|***       typedef struct _CURSORINFO {  /* csri */
;|***          HWND    hwnd;
;|***          LONG    x;
;|***          LONG    y;
;|***          LONG    cx;
;|***          LONG    cy;
;|***          ULONG   fs;
;|***          RECTL   rclClip;
;|***       } CURSORINFO;
;|***    #else
;|***       typedef struct _CURSORINFO {  /* csri */
;|***          HWND    hwnd;
;|***          SHORT   x;
;|***          SHORT   y;
;|***          SHORT   cx;
;|***          SHORT   cy;
;|***          USHORT  fs;
;|***          RECTL   rclClip;
;|***       } CURSORINFO;
;|***    #endif
;|***    typedef CURSORINFO FAR *PCURSORINFO;
;|*** 
;|***    BOOL APIENTRY WinQueryCursorInfo(HWND hwndDesktop,
;|***                                     PCURSORINFO pCursorInfo);
;|*** 
;|*** #endif /* INCL_WINCURSORS */
;|*** 
;|*** 
;|*** #ifdef INCL_WINPOINTERS
;|***    /**** Pointer manager */
;|*** 
;|***    BOOL     APIENTRY WinSetPointer(HWND hwndDesktop,
;|***                                    HPOINTER hptrNew);
;|***    BOOL     APIENTRY WinSetPointerOwner(HPOINTER hptr,
;|***                                         PID pid,
;|***                                         BOOL fDestroy);
;|***    BOOL     APIENTRY WinShowPointer(HWND hwndDesktop,
;|***                                     BOOL fShow);
;|***    #ifdef INCL_32
;|***    BOOL     APIENTRY WinLockPointerUpdate(HWND hwndDesktop,
;|***                                           HPOINTER hptrNew,
;|***                                           ULONG ulTimeInterval);
;|***       HPOINTER APIENTRY WinQuerySysPointer(HWND hwndDesktop,
;|***                                            LONG iptr,
;|***                                            BOOL fLoad);
;|***    #else
;|***    BOOL     APIENTRY WinLockPointerUpdate(HWND hwndDesktop,
;|***                                           HPOINTER hptrNew,
;|***                                           USHORT usTimeInterval);
;|***       HPOINTER APIENTRY WinQuerySysPointer(HWND hwndDesktop,
;|***                                            SHORT iptr,
;|***                                            BOOL fLoad);
;|***    #endif
;|*** 
;|***    #ifdef INCL_32
;|***       BOOL APIENTRY WinQuerySysPointerData(HWND hwndDesktop,
;|***                                            ULONG iptr,
;|***                                            PICONINFO pIconInfo);
;|***       BOOL APIENTRY WinSetSysPointerData(HWND hwndDesktop,
;|***                                          ULONG iptr,
;|***                                          PICONINFO pIconInfo);
;|***    #endif
;|*** 
;|***    /* System pointers (NOTE: these are 1-based) */
;|*** 
;|***    #define SPTR_ARROW                 1
;|***    #define SPTR_TEXT                  2
;|***    #define SPTR_WAIT                  3
;|***    #define SPTR_SIZE                  4
;|***    #define SPTR_MOVE                  5
;|***    #define SPTR_SIZENWSE              6
;|***    #define SPTR_SIZENESW              7
;|***    #define SPTR_SIZEWE                8
;|***    #define SPTR_SIZENS                9
;|***    #define SPTR_APPICON               10
;|*** 
;|***    #define SPTR_ICONINFORMATION       11
;|***    #define SPTR_ICONQUESTION          12
;|***    #define SPTR_ICONERROR             13
;|***    #define SPTR_ICONWARNING           14
;|*** 
;|***    #define SPTR_ILLEGAL               18
;|***    #define SPTR_FILE                  19
;|***    #define SPTR_FOLDER                20
;|***    #define SPTR_MULTFILE              21
;|***    #define SPTR_PROGRAM               22
;|***    #define SPTR_DISPLAY_PTRS          22
;|***    #define SPTR_PENFIRST              23
;|***    #define SPTR_PENLAST               39
;|***    #define SPTR_CPTR                  39  /* total # of system pointers */
;|*** 
;|***    /* backward compatibility */
;|***    #define SPTR_HANDICON         SPTR_ICONERROR
;|***    #define SPTR_QUESICON         SPTR_ICONQUESTION
;|***    #define SPTR_BANGICON         SPTR_ICONWARNING
;|***    #define SPTR_NOTEICON         SPTR_ICONINFORMATION
;|*** 
;|*** 
;|***    #ifdef INCL_32
;|***       HPOINTER APIENTRY WinLoadPointer(HWND hwndDesktop,
;|***                                        HMODULE hmod,
;|***                                        ULONG idres);
;|***       HPOINTER APIENTRY WinCreatePointer(HWND hwndDesktop,
;|***                                          HBITMAP hbmPointer,
;|***                                          BOOL fPointer,
;|***                                          LONG xHotspot,
;|***                                          LONG yHotspot);
;|***       BOOL     APIENTRY WinSetPointerPos(HWND hwndDesktop,
;|***                                          LONG x,
;|***                                          LONG y);
;|***    #else
;|***       HPOINTER APIENTRY WinLoadPointer(HWND hwndDesktop,
;|***                                        HMODULE hmod,
;|***                                        USHORT idres);
;|***       HPOINTER APIENTRY WinCreatePointer(HWND hwndDesktop,
;|***                                          HBITMAP hbmPointer,
;|***                                          BOOL fPointer,
;|***                                          SHORT xHotspot,
;|***                                          SHORT yHotspot);
;|***       BOOL     APIENTRY WinSetPointerPos(HWND hwndDesktop,
;|***                                          SHORT x,
;|***                                          SHORT y);
;|***    #endif
;|***    BOOL     APIENTRY WinDestroyPointer(HPOINTER hptr);
;|*** 
;|***    HPOINTER APIENTRY WinQueryPointer(HWND hwndDesktop);
;|***    BOOL     APIENTRY WinQueryPointerPos(HWND hwndDesktop,
;|***                                         PPOINTL pptl);
;|*** 
;|***    #ifdef INCL_32
;|***       typedef struct _POINTERINFO {  /* ptri */
;|***          ULONG   fPointer;
;|***          LONG    xHotspot;
;|***          LONG    yHotspot;
;|***          HBITMAP hbmPointer;
;|***          HBITMAP hbmColor;
;|***          HBITMAP hbmMiniPointer;
;|***          HBITMAP hbmMiniColor;
;|***       } POINTERINFO;
;|***    #else
;|***       typedef struct _POINTERINFO {  /* ptri */
;|***          USHORT  fPointer;
;|***          SHORT   xHotspot;
;|***          SHORT   yHotspot;
;|***          HBITMAP hbmPointer;
;|***          HBITMAP hbmColor;
;|***       } POINTERINFO;
;|***    #endif
;|***    typedef POINTERINFO FAR *PPOINTERINFO;
;|*** 
;|***    HPOINTER APIENTRY WinCreatePointerIndirect(HWND hwndDesktop,
;|***                                               PPOINTERINFO pptri);
;|***    BOOL     APIENTRY WinQueryPointerInfo(HPOINTER hptr,
;|***                                          PPOINTERINFO pPointerInfo);
;|***    #ifdef INCL_32
;|***       BOOL     APIENTRY WinDrawPointer(HPS hps,
;|***                                        LONG x,
;|***                                        LONG y,
;|***                                        HPOINTER hptr,
;|***                                        ULONG fs);
;|***    #else
;|***       BOOL     APIENTRY WinDrawPointer(HPS hps,
;|***                                        SHORT x,
;|***                                        SHORT y,
;|***                                        HPOINTER hptr,
;|***                                        USHORT fs);
;|***    #endif
;|*** 
;|*** 
;|*** 
;|***    /* WinDrawPointer() constants */
;|*** 
;|***    #define DP_NORMAL                  0x0000
;|***    #define DP_HALFTONED               0x0001
;|***    #define DP_INVERTED                0x0002
;|***    #define DP_MINI                    0x0004  /*   Feature:85493  */
;|*** 
;|*** 
;|***    #ifdef INCL_32
;|***       HBITMAP APIENTRY WinGetSysBitmap(HWND hwndDesktop,
;|***                                        ULONG ibm);
;|***    #else
;|***       HBITMAP APIENTRY WinGetSysBitmap(HWND hwndDesktop,
;|***                                        USHORT ibm);
;|***    #endif
;|*** 
;|***    /* System bitmaps (NOTE: these are 1-based) */
;|*** 
;|***    #define SBMP_OLD_SYSMENU           1
;|***    #define SBMP_OLD_SBUPARROW         2
;|***    #define SBMP_OLD_SBDNARROW         3
;|***    #define SBMP_OLD_SBRGARROW         4
;|***    #define SBMP_OLD_SBLFARROW         5
;|***    #define SBMP_MENUCHECK             6
;|***    #define SBMP_OLD_CHECKBOXES        7
;|***    #define SBMP_BTNCORNERS            8
;|***    #define SBMP_OLD_MINBUTTON         9
;|***    #define SBMP_OLD_MAXBUTTON         10
;|***    #define SBMP_OLD_RESTOREBUTTON     11
;|***    #define SBMP_OLD_CHILDSYSMENU      12
;|***    #define SBMP_DRIVE                 15
;|***    #define SBMP_FILE                  16
;|***    #define SBMP_FOLDER                17
;|***    #define SBMP_TREEPLUS              18
;|***    #define SBMP_TREEMINUS             19
;|***    #define SBMP_PROGRAM               22
;|***    #define SBMP_MENUATTACHED          23
;|***    #define SBMP_SIZEBOX               24
;|*** 
;|***    #define SBMP_SYSMENU               25
;|***    #define SBMP_MINBUTTON             26
;|***    #define SBMP_MAXBUTTON             27
;|***    #define SBMP_RESTOREBUTTON         28
;|***    #define SBMP_CHILDSYSMENU          29
;|***    #define SBMP_SYSMENUDEP            30
;|***    #define SBMP_MINBUTTONDEP          31
;|***    #define SBMP_MAXBUTTONDEP          32
;|***    #define SBMP_RESTOREBUTTONDEP      33
;|***    #define SBMP_CHILDSYSMENUDEP       34
;|***    #define SBMP_SBUPARROW             35
;|***    #define SBMP_SBDNARROW             36
;|***    #define SBMP_SBLFARROW             37
;|***    #define SBMP_SBRGARROW             38
;|***    #define SBMP_SBUPARROWDEP          39
;|***    #define SBMP_SBDNARROWDEP          40
;|***    #define SBMP_SBLFARROWDEP          41
;|***    #define SBMP_SBRGARROWDEP          42
;|***    #define SBMP_SBUPARROWDIS          43
;|***    #define SBMP_SBDNARROWDIS          44
;|***    #define SBMP_SBLFARROWDIS          45
;|***    #define SBMP_SBRGARROWDIS          46
;|***    #define SBMP_COMBODOWN             47
;|***    #define SBMP_CHECKBOXES        48
;|*** 
;|*** #endif /* INCL_WINPOINTERS */
;|*** 
;|*** 
;|*** /**** Hook manager */
;|*** 
;|*** #ifdef INCL_WINHOOKS
;|*** 
;|***    #ifndef INCL_SAADEFS
;|***       #ifdef INCL_32
;|***          BOOL APIENTRY WinSetHook(HAB hab,
;|***                                   HMQ hmq,
;|***                                   LONG iHook,
;|***                                   PFN pfnHook,
;|***                                   HMODULE hmod);
;|***          BOOL APIENTRY WinReleaseHook(HAB hab,
;|***                                       HMQ hmq,
;|***                                       LONG iHook,
;|***                                       PFN pfnHook,
;|***                                       HMODULE hmod);
;|***          BOOL APIENTRY WinCallMsgFilter(HAB hab,
;|***                                         PQMSG pqmsg,
;|***                                         ULONG msgf);
;|***       #else
;|***          BOOL APIENTRY WinSetHook(HAB hab,
;|***                                   HMQ hmq,
;|***                                   SHORT iHook,
;|***                                   PFN pfnHook,
;|***                                   HMODULE hmod);
;|***          BOOL APIENTRY WinReleaseHook(HAB hab,
;|***                                       HMQ hmq,
;|***                                       SHORT iHook,
;|***                                       PFN pfnHook,
;|***                                       HMODULE hmod);
;|***          BOOL APIENTRY WinCallMsgFilter(HAB hab,
;|***                                         PQMSG pqmsg,
;|***                                         USHORT msgf);
;|***       #endif
;|*** 
;|*** 
;|***       /**********************************************************************
;|***       * Hook codes
;|***       *
;|***       * Whether the hook receives a (U)SHORT or (U)LONG parameter depends
;|***       * on the memory model that the hook executes in. 32-bit hook will
;|***       * receive long parameters
;|***       *
;|***       **********************************************************************/
;|*** 
;|***       #define HK_SENDMSG                 0
;|***       /* VOID EXPENTRY SendMsgHook(HAB hab,               ** installer's hab
;|***       *                            PSMHSTRUCT psmh,       ** p send msg struct
;|***       *                            BOOL fInterTask);      ** between threads */
;|*** 
;|***       #define HK_INPUT                   1
;|***       /* BOOL EXPENTRY InputHook(HAB hab,                 ** installer's hab
;|***       *                          PQMSG pQmsg,             ** p qmsg
;|***       *                          ULONG/USHORT fs);        ** remove/noremove */
;|*** 
;|***       #define HK_MSGFILTER               2
;|***       /* BOOL EXPENTRY MsgFilterHook(HAB hab,             ** installer's hab
;|***       *                              PQMSG pQmsg,         ** p qmsg
;|***       *                              ULONG/USHORT msgf);  ** filter flag */
;|*** 
;|***       #define HK_JOURNALRECORD           3
;|***       /* VOID EXPENTRY JournalRecordHook(HAB hab,         ** installer's hab
;|***       *                                  PQMSG pQmsg);    ** p qmsg */
;|*** 
;|***       #define HK_JOURNALPLAYBACK         4
;|***       /* ULONG EXPENTRY JournalPlaybackHook(HAB hab,      **installer's hab
;|***       *                                     BOOL fSkip,   ** skip messages
;|***       *                                     PQMSG pQmsg); ** p qmsg */
;|*** 
;|***       #define HK_HELP                    5
;|***       /* BOOL EXPENTRY HelpHook(HAB hab,                  ** installer's hab
;|***       *                         ULONG/USHORT usMode,      ** mode
;|***       *                         ULONG/USHORT idTopic,     ** main topic
;|***       *                         ULONG/USHORT idSubTopic,  ** sub topic
;|***       *                         PRECTL prcPosition);      ** associated position */
;|*** 
;|***       #define HK_LOADER                  6
;|***       /* BOOL EXPENTRY LoaderHook(HAB hab,                ** installer's hab
;|***       *                           LONG/USHORT idContext,  ** who called hook
;|***       *                           PSZ pszLibname,         ** lib name string
;|***       *                           PHLIB hlib,             ** p to lib handle
;|***       *                           PSZ pszProcname,        ** procedure name
;|***       *                           PFNWP wndProc);         ** window procedure */
;|*** 
;|***       #define HK_REGISTERUSERMSG         7
;|***       /* BOOL EXPENTRY RegisterUserHook(HAB hab,          ** installer's hab
;|***       *                                 ULONG cUshort,    ** entries in arRMP
;|***       *                                 PULONG/PUSHORT arRMP, ** RMP array
;|***       *                                 PBOOL fRegistered); ** msg parms already reg*/
;|*** 
;|***       #define HK_MSGCONTROL              8
;|***       /* BOOL EXPENTRY MsgControlHook(HAB hab,            ** installer's hab
;|***       *                               LONG/SHORT idContext,** who called hook
;|***       *                               HWND hwnd,          ** SEI window handle
;|***       *                               PSZ pszClassname,   ** window class name
;|***       *                               ULONG/USHORT usMsgclass,** interested msg class **
;|***       *                               LONG/SHORT idControl,** SMI_*
;|***       *                               PBOOL fSuccess);    ** mode already set */
;|*** 
;|***       #define HK_PLIST_ENTRY             9
;|***       /* BOOL EXPENTRY ProgramListEntryHook(HAB hab,      ** installer's hab
;|***       *                                     PPRFHOOKPARMS pProfileHookParams,** data
;|***       *                                     PBOOL fNoExecute);  ** cease hook processing*/
;|*** 
;|***       #define HK_PLIST_EXIT              10
;|***       /* BOOL EXPENTRY ProgramListExitHook(HAB hab,       ** installer's hab
;|***       *                                    PPRFHOOKPARMS pProfileHookParams);** data*/
;|*** 
;|***       #define HK_FINDWORD                11
;|***       /* BOOL EXPENTRY FindWordHook(usCodepage,           ** code page to use
;|***       *                             PSZ pszText,          ** text to break
;|***       *                             ULONG cb,             ** maximum text size
;|***       *                             ULONG ich,            ** break 'near' here
;|***       *                             PULONG pichStart,     ** where break began
;|***       *                             PULONG pichEnd,       ** where break ended
;|***       *                             PULONG pichNext);     ** where next word begin*/
;|*** 
;|***       #define HK_CODEPAGECHANGED         12
;|***       /* VOID EXPENTRY CodePageChangedHook(HMQ hmq,       ** msg q handle
;|***       *                                    ULONG/USHORT usOldCodepage, ** old code page
;|***       *                                    ULONG/USHORT usNewCodepage);** new code page*/
;|*** 
;|***       #define HK_WINDOWDC                15
;|***       /* BOOL EXPENTRY WindowDCHook(HAB  hab,             ** installer's hab
;|***       *                             HDC  hdc,             ** current hdc
;|***       *                             HWND hwnd,            ** current hwnd
;|***       *                             BOOL);                ** association flag */
;|*** 
;|***       #define HK_DESTROYWINDOW           16
;|***       /* BOOL EXPENTRY DestroyWindowHook (HAB  hab,       ** installer's hab
;|***       *                                   HWND hwnd,      ** destroyed win hwnd
;|***       *                                   ULONG Reserved);** association flag  */
;|*** 
;|***       #define HK_CHECKMSGFILTER          20
;|***       /* BOOL EXPENTRY CheckMsgFilteHook (HAB  hab,       ** installer's hab
;|***       *                                   PQMSG pQmsg,    ** p qmsg
;|***       *                                   ULONG/USHORT usFirst,  ** first msg
;|***       *                                   ULONG/USHORT usLast,   ** last msg
;|***       *                                   ULONG/USHORT fOptions);** flags  */
;|*** 
;|***       #define HK_MSGINPUT                21
;|***       /* BOOL EXPENTRY MsgInputHook (HAB  hab,          ** installer's hab
;|***       *                              PQMSG pQmsg,       ** p qmsg
;|***       *                              BOOL fSkip,        ** skip msg
;|***       *                              PBOOL pfNoRecord); ** journal record event */
;|*** 
;|***       #define HK_LOCKUP                  23
;|***       /* BOOL EXPENTRY LockupHook (HAB  hab,              ** installer's hab
;|***       *                           HWND hwndLockupFrame); ** hwnd     */
;|*** 
;|***       #define HK_FLUSHBUF                24
;|***       /* BOOL EXPENTRY FlushBufHook (HAB  hab);           ** installer's hab */
;|*** 
;|***       /*** Current message queue constant **********************************/
;|***       #define HMQ_CURRENT          ((HMQ)1)
;|*** 
;|***       /*** WH_MSGFILTER context codes **************************************/
;|***       #define MSGF_DIALOGBOX             1
;|***       #define MSGF_MESSAGEBOX            2
;|***       #define MSGF_TRACK                 8
;|***       #define MSGF_DDEPOSTMSG            3
;|*** 
;|***       /*** HK_HELP Help modes **********************************************/
;|***       #define HLPM_FRAME              (-1)
;|***       #define HLPM_WINDOW             (-2)
;|***       #define HLPM_MENU               (-3)
;|*** 
;|***       /*** HK_SENDMSG structure ********************************************/
;|***       #define PM_MODEL_1X      0
;|***       #define PM_MODEL_2X      1
;|*** 
;|***       #ifdef INCL_32
;|***          typedef struct _SMHSTRUCT {    /* smhs */
;|***             MPARAM mp2;
;|***             MPARAM mp1;
;|***             ULONG  msg;
;|***             HWND   hwnd;
;|***             ULONG  model;
;|***          } SMHSTRUCT;
;|***       #else
;|***          typedef struct _SMHSTRUCT {    /* smhs */
;|***             MPARAM mp2;
;|***             MPARAM mp1;
;|***             USHORT msg;
;|***             HWND   hwnd;
;|***             USHORT model;
;|***          } SMHSTRUCT;
;|***       #endif
;|***       typedef SMHSTRUCT *PSMHSTRUCT;
;|*** 
;|***       /*HK_LOADER context codes */
;|*** 
;|***       #define LHK_DELETEPROC             1
;|***       #define LHK_DELETELIB              2
;|***       #define LHK_LOADPROC               3
;|***       #define LHK_LOADLIB                4
;|*** 
;|***       /*HK_MSGCONTROL context codes */
;|*** 
;|***       #define MCHK_MSGINTEREST           1
;|***       #define MCHK_CLASSMSGINTEREST      2
;|***       #define MCHK_SYNCHRONISATION       3
;|***       #define MCHK_MSGMODE               4
;|*** 
;|***       /*HK_REGISTERUSERMSG conext codes */
;|*** 
;|***       #define RUMHK_DATATYPE             1
;|***       #define RUMHK_MSG                  2
;|*** 
;|***    #endif /* INCL_SAADEFS */
;|*** 
;|*** #endif /* INCL_WINHOOKS */
;|*** 
;|*** 
;|*** #ifdef INCL_WINTHUNKAPI
;|*** 
;|***    BOOL    APIENTRY WinSetClassThunkProc(PSZ pszClassname,
;|***                                          PFN pfnThunkProc);
;|***    PFN     APIENTRY WinQueryClassThunkProc(PSZ pszClassname);
;|***    BOOL    APIENTRY WinSetWindowThunkProc(HWND hwnd,
;|***                                           PFN pfnThunkProc);
;|***    PFN     APIENTRY WinQueryWindowThunkProc(HWND hwnd);
;|***    #ifdef INCL_32
;|***       LONG   APIENTRY WinQueryWindowModel(HWND hwnd);
;|***    #else
;|***       SHORT   APIENTRY WinQueryWindowModel(HWND hwnd);
;|***    #endif
;|*** 
;|*** #endif /* INCL_WINTHUNKAPI */
;|*** 
;|*** /*
;|*** * Include Shell API
;|*** */
;|*** #ifndef INCL_SAADEFS
;|***    #include <pmshl.h>      /* OS/2 Shell definitions */
; Line 4753
;|*** #include <pmgpi.h>        /* OS/2 GPI definitions               */
; Line 96
;|*** #include <pmdev.h>        /* OS/2 Device Context definitions    */
; Line 97
;|*** #ifndef __IBMC__
;|*** /* LATER should include pmwp.h for both IBM and MS, but I don't want */
;|*** /* to break anyone now! David Kerr */
;|*** #else
;|*** #include <pmwp.h>         /* OS/2 Workplace Shell               */
;|*** #endif
;|*** 
;|*** #ifdef INCL_AVIO
;|***    #ifndef __IBMC__
;|***       #ifdef INCL_16
;|***          #include <pmavio.h> /* OS/2 AVIO definitions              */
;|***       #endif
;|***    #else
;|***       #include <pmavio.h>    /* OS/2 AVIO definitions              */
;|***    #endif
;|*** #endif
;|*** 
;|*** #ifdef INCL_SPL
;|***    #include <pmspl.h>     /* OS/2 Spooler definitions           */
;|*** #endif
;|*** 
;|*** #ifdef INCL_PIC
;|***    #include <pmpic.h>     /* OS/2 Picture Utilities definitions */
;|*** #endif
;|*** 
;|*** #ifdef INCL_ORDERS
;|***    #include <pmord.h>     /* OS/2 Graphical Order Formats       */
;|*** #endif
;|*** 
;|*** #ifdef INCL_FONTFILEFORMAT
;|***    #include <pmfont.h>    /* OS/2 Font File Format definition   */
;|*** #endif
;|*** 
;|*** #include <pmstddlg.h>     /* CUA controls and dialogs           */
; Line 131
;|*** //#include <memory.h>
;|*** //#include <stdlib.h>
;|*** //#include <string.h>
;|*** #include "COMDD.H"
; Line 20
;|*** #include "COMDCB.H"
; Line 21
;|*** #include "CUTIL.H"
; Line 22
;|*** #include "RMCALLS.H"
; Line 23
;|*** /**************************************************************************
;|***  *
;|***  * SOURCE FILE NAME =  RMCALLS.H
;|***  *
;|***  * DESCRIPTIVE NAME =  RM function prototypes exported to drivers
;|***  *
;|***  *
;|***  * Copyright : COPYRIGHT IBM CORPORATION, 1994, 1995
;|***  *             LICENSED MATERIAL - PROGRAM PROPERTY OF IBM
;|***  *             REFER TO COPYRIGHT INSTRUCTION FORM#G120-2083
;|***  *             RESTRICTED MATERIALS OF IBM
;|***  *             IBM CONFIDENTIAL
;|***  *
;|***  * VERSION = V1.01
;|***  *
;|***  * DATE
;|***  *
;|***  * DESCRIPTION :
;|***  *
;|***  * Purpose:
;|***  *
;|***  *
;|***  *
;|***  * FUNCTIONS  :
;|***  *
;|***  * NOTES
;|***  *
;|***  *
;|***  * STRUCTURES
;|***  *
;|***  * EXTERNAL REFERENCES
;|***  *
;|***  *
;|***  *
;|***  * EXTERNAL FUNCTIONS
;|***  *
;|***  * CHANGE ACTIVITY =
;|***  *   DATE      FLAG        APAR   CHANGE DESCRIPTION
;|***  *   --------  ----------  -----  --------------------------------------
;|***  *
;|***  ****************************************************************************/
;|*** 
;|*** 
;|*** /****************************************************************************/
;|*** /*                                                                          */
;|*** /* Function Prototypes                                                      */
;|*** /*                                                                          */
;|*** /****************************************************************************/
;|*** 
;|*** 
;|*** 
;|*** #ifndef __RM_CALLS__
;|*** #define __RM_CALLS__
;|*** 
;|*** #include <rmbase.h>
; Line 55
;|*** #include <rmioctl.h>
; Line 56
;|*** 
;|*** #include "message.c"
; Line 25
;|*** 
;|*** #define FP_SEG(fp) (*((unsigned _far *)&(fp)+1))
;|*** #define FP_OFF(fp) (*((unsigned _far *)&(fp)))
;|*** 
;|*** #ifdef use_far
;|*** extern DEVHEAD _far _stDummyHeader;
;|*** extern BYTE _far _abyPath[];
;|*** extern sBOOL _far _bSharedInterrupts;
;|*** extern WORD _far _wIntIDregister;
;|*** extern WORD _far _wOEMjumpEntry;
;|*** extern WORD _far _wOEMjumpExit;
;|*** 
;|*** extern WORD _far _wMaxDeviceCount;
;|*** 
;|*** extern WORD _far _wEndOfData;
;|*** extern DEVDEF _far _stDeviceParms[];
;|*** extern WORD _far_ _wBusType;
;|*** #else
;|*** extern DEVHEAD _stDummyHeader;
;|*** extern BYTE _abyPath[];
;|*** extern sBOOL _bSharedInterrupts;
;|*** extern WORD _wIntIDregister;
;|*** extern WORD _wOEMjumpEntry;
;|*** extern WORD _wOEMjumpExit;
;|*** 
;|*** extern WORD _wMaxDeviceCount;
;|*** 
;|*** extern WORD _wEndOfData;
;|*** extern DEVDEF _stDeviceParms[];
;|*** 
;|*** extern ADDENTRY _stAttachDD;
;|*** extern WORD _wBusType;
;|*** extern WORD bDisableRM;
;|*** extern WORD bPnPcapable;
;|*** extern char _szName[];
;|*** extern BYTE _byAdapterType;
;|*** extern BYTE _byOEMtype;
;|*** //extern BYTE byHardwareType;
;|*** extern BYTE byNextPCIslot;
;|*** 
;|*** #pragma same_seg (_stDummyHeader,_abyPath,_bSharedInterrupts, _wIntIDregister,_wOEMjumpEntry,_wOEMjumpExit,_wMaxDeviceCount,_wEndOfData,_stAttachDD,_szName,_byAdapterType,_wBusType,_byOEMtype)
;|*** 
;|*** #endif
;|*** 
;|*** extern USHORT FAR RMHELP_GetStatusPort(void);
;|*** extern BOOL FAR RMHELP_HasPNPCaps(void);
;|*** extern USHORT FAR RMHELP_GetPorts(DCBHEAD *pComInfo, USHORT usPortNumber);
;|*** extern USHORT FAR RMHELP_StatusPortInitComplete(void);
;|*** extern void RMHELP_CreateDriver(void);
;|*** extern void RMHELP_DestroyDriver(void);
;|*** 
;|*** /*
;|*** ** don't need segment
;|*** */
;|*** extern VOID NEAR *_pCOMscopeStrategy;
;|*** extern VOID NEAR *_pDeviceStrategy;
;|*** 
;|*** extern char chFailedReadIni[];
;|*** extern char chFailedWriteIni[];
;|*** extern char chFailedIniCorrupt_1[];
;|*** extern char chFailedIniCorrupt_2[];
;|*** extern char chFailedIniNotInit_1[];
;|*** extern char chFailedIniNotInit_2[];
;|*** extern char chFailedBadPath[];
;|*** extern char chFailedBadVersion_1[];
;|*** extern char chFailedBadVersion_2[];
;|*** #ifndef NO_PCI
;|*** extern char chPCIMissing[];
;|*** extern char chPCIBadIRQ[];
;|*** extern char chTooManyPCIadapters[];
;|*** extern char chPCI_LoadOrder_1[];
;|*** extern char chPCI_LoadOrder_2[];
;|*** extern PCIADPT stPCIadapterTable[];
;|*** extern PCIADPT stPCIadapterHold[];
;|*** #else
;|*** extern char chPCInotSupported[];
;|*** #endif
;|*** 
;|*** extern COMDCB stConfigParms[];
;|*** extern sBOOL bVerbose;
;|*** extern BYTE abyFileBuffer[];
;|*** extern WORD bPrintLocation;
;|*** 
;|*** extern sBOOL bWaitForCR;
;|*** extern WORD wLoadNumber;
;|*** extern WORD wLoadCount;
;|*** extern WORD wLoadFlags;
;|*** extern BYTE *pbyData;
;|*** extern BYTE abyCOMnumbers[];
;|*** extern BYTE byLoadAdapterType;
;|*** extern sBOOL bABIOSpresent;
;|*** extern sBOOL bIsTheFirst;
;|*** extern LIDTAB LIDtable[];
;|*** extern ULONG ulAvailableBufferSpace;
;|*** extern ULONG ulRequiredBufferSpace;
;|*** extern ULONG ulWriteBufferSpace;
;|*** extern sBOOL bUseDDdataSegment;
;|*** 
;|*** extern WORD _wPCIvendor;
;|*** extern WORD _wPCIdevice;
;|*** extern WORD wPCIcount;
;|*** extern WORD wPCIadapterCount;
;|*** 
;|*** extern WORD wDeviceCount;
;|*** extern WORD wDriverLoadCount;
;|*** extern WORD wDelayCount;
;|*** 
;|*** #ifdef OEM
;|*** extern sBOOL _bOEMpresent;
;|*** extern char chWrongOEM_ss[];
;|*** extern char chCompanyName[];
;|*** extern char chAdapterName[];
;|*** #endif
;|*** 
;|*** extern char szMessage[];
;|*** 
;|*** extern INSTDEF astInstallParms[];
;|*** 
;|*** extern MCAPORT astMCAportTable[];
;|*** 
;|*** #ifdef debug_ini
;|*** extern char szTIF[];
;|*** extern char szDHI[];
;|*** extern char szCHR[];
;|*** extern char szAS[];
;|*** extern char szDHR[];
;|*** extern char szCHW[];
;|*** extern char szCHA[];
;|*** extern char szTLC[];
;|*** #endif
;|*** 
;|*** /*
;|*** **  All variables delcared in this module MUST be initialized in order to force
;|*** **  them into the initialized 'C' data segment.
;|*** */
;|*** CFGINFO stConfigInfo = {0};
;|*** CFGHEAD stConfigHeader = {0};
;|*** DCBHEAD stDCBheader = {0};
;|*** 
;|*** BOOL bPrevErrorMsg = FALSE;
;|*** 
;|*** HFILE hCom = 0;
;|*** HFILE hFile = 0;
;|*** 
;|*** 
;|*** DEVDEF _far *pDeviceParms = 0;
;|*** DEVHEAD _far *pStart = 0;
;|*** DEVHEAD _far *pPrevious = 0;
;|*** WORD wDeviceStrategy = 0;
;|*** extern WORD bSeparateIDreg;
;|*** 
;|*** #ifndef NO_COMscope
;|*** WORD wCOMscopeStrategy = 0;
;|*** VOID MakeCOMscopeName(char _far szString[]);
;|*** #endif
;|*** 
;|*** DEVHEAD stDefaultDevHeader = {0,0};
;|*** 
;|*** WORD bBreakInitialization = FALSE;
;|*** 
;|*** WORD StringLength(BYTE abyString[]);
;|*** 
;|*** WORD awPorts[17] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
;|*** 
;|*** void VerifyABIOSdefinitions(WORD wLoadCount);
;|*** /*
;|*** ** All data MUST be in the data segment of the device driver (RDGROUP)
;|*** ** for the AttachDD function.
;|*** */
;|*** WORD AttachDD(char szName[],ADDENTRY *pstAttachDD);// params assume DS=DGROUP
;|*** 
;|*** void MemCopy(char _far *pDest,char _far *pSource,WORD wCount)
;|***   {
; Line 198
	PUBLIC	_MemCopy
_MemCopy	PROC FAR
	*** 000000	c8 02 00 00 		enter	2,0
	*** 000004	57 			push	di
	*** 000005	56 			push	si
;	wIndex = -2
;	wCount = 14
;	pSource = 10
;	pDest = 6
;|***   WORD wIndex;
;|*** 
;|***   for (wIndex = 0;wIndex < wCount;wIndex++)
; Line 201
	*** 000006	c7 46 fe 00 00 		mov	WORD PTR [bp-2],0	;wIndex
	*** 00000b	e9 03 00 		jmp	$F2479
					$FC2480:
	*** 00000e	ff 46 fe 		inc	WORD PTR [bp-2]	;wIndex
					$F2479:
	*** 000011	8b 46 0e 		mov	ax,WORD PTR [bp+14]	;wCount
	*** 000014	39 46 fe 		cmp	WORD PTR [bp-2],ax	;wIndex
	*** 000017	72 03 			jb	$JCC23
	*** 000019	e9 15 00 		jmp	$FB2481
					$JCC23:
;|***     pDest[wIndex] = pSource[wIndex];
; Line 202
	*** 00001c	c4 5e 0a 		les	bx,DWORD PTR [bp+10]	;pSource
	*** 00001f	8b 76 fe 		mov	si,WORD PTR [bp-2]	;wIndex
	*** 000022	26 8a 00 		mov	al,BYTE PTR es:[bx][si]
	*** 000025	c4 5e 06 		les	bx,DWORD PTR [bp+6]	;pDest
	*** 000028	8b 76 fe 		mov	si,WORD PTR [bp-2]	;wIndex
	*** 00002b	26 88 00 		mov	BYTE PTR es:[bx][si],al
	*** 00002e	e9 dd ff 		jmp	$FC2480
					$FB2481:
;|***   }
; Line 203
					$EX2477:
	*** 000031	5e 			pop	si
	*** 000032	5f 			pop	di
	*** 000033	c9 			leave	
	*** 000034	cb 			ret	

_MemCopy	ENDP
;|*** 
;|*** #ifdef OEM
;|*** void PrintWrongOEM(void)
;|***   {
; Line 207
	PUBLIC	_PrintWrongOEM
_PrintWrongOEM	PROC FAR
	*** 000035	c8 02 00 00 		enter	2,0
	*** 000039	57 			push	di
	*** 00003a	56 			push	si
;	iLen = -2
;|***   int iLen;
;|***   
;|***   iLen = sprintf(szMessage, 0, chWrongOEM_ss,chCompanyName,chAdapterName);
; Line 210
	*** 00003b	68 00 00 		push	SEG _chAdapterName
	*** 00003e	68 00 00 		push	OFFSET _chAdapterName
	*** 000041	68 00 00 		push	SEG _chCompanyName
	*** 000044	68 00 00 		push	OFFSET _chCompanyName
	*** 000047	68 00 00 		push	SEG _chWrongOEM_ss
	*** 00004a	68 00 00 		push	OFFSET _chWrongOEM_ss
	*** 00004d	6a 00 			push	0
	*** 00004f	68 00 00 		push	SEG _szMessage
	*** 000052	68 00 00 		push	OFFSET _szMessage
	*** 000055	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 00005a	83 c4 12 		add	sp,18
	*** 00005d	89 46 fe 		mov	WORD PTR [bp-2],ax	;iLen
;|***   VioWrtTTY(szMessage,iLen,0);
; Line 211
	*** 000060	68 00 00 		push	SEG _szMessage
	*** 000063	68 00 00 		push	OFFSET _szMessage
	*** 000066	ff 76 fe 		push	WORD PTR [bp-2]	;iLen
	*** 000069	6a 00 			push	0
	*** 00006b	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|*** //  VioWrtTTY(chCompanyName,StringLength(chCompanyName),0);
;|*** //  VioWrtTTY(chWrongOEM_2,StringLength(chWrongOEM_2),0);
;|*** //  VioWrtTTY(chAdapterName,StringLength(chAdapterName),0);
;|*** //  VioWrtTTY(chWrongOEM_3,StringLength(chWrongOEM_3),0);
;|***   }
; Line 216
					$EX2483:
	*** 000070	5e 			pop	si
	*** 000071	5f 			pop	di
	*** 000072	c9 			leave	
	*** 000073	cb 			ret	

_PrintWrongOEM	ENDP
;|*** #endif
;|*** 
;|*** void FAR GetIniInfo(void)
;|***   {
; Line 220
	PUBLIC	_GetIniInfo
_GetIniInfo	PROC FAR
	*** 000074	c8 40 00 00 		enter	64,0
	*** 000078	57 			push	di
	*** 000079	56 			push	si
;	byDummy = -22
;	abySaveExt = -40
;	ulFilePosition = -18
;	ulHeaderDummy = -14
;	bPCIadapter = -46
;	wError = -2
;	wPCIerror = -42
;	ulAction = -44
;	ulCount = -30
;	ulFileError = -32
;	iLen = -28
;	rc = -10
;	wDCBindex = -26
;	wIndex = -48
;	lSaveOffset = -6
;	lSaveDCBoffset = -36
;	iPortIndex = -20
;	wSaveExt = -24
;	wDummy = -8
;|***   int iLen;
;|***   WORD rc;
;|***   WORD wDCBindex;
;|***   WORD wIndex;
;|***   LONG lSaveOffset;
;|***   LONG lSaveDCBoffset;
;|***   int iPortIndex;
;|***   WORD wSaveExt;
;|***   WORD wDummy;
;|***   BYTE byDummy;
;|***   char abySaveExt[4];
;|***   //WORD wTemp;
;|***   ULONG ulFilePosition;
;|***   ULONG ulHeaderDummy;
;|***   BOOL bPCIadapter = FALSE;
; Line 235
	*** 00007a	c7 46 d2 00 00 		mov	WORD PTR [bp-46],0	;bPCIadapter
;|***   WORD wError;
;|***   WORD wPCIerror;
;|*** #ifdef _32bitAPI
;|***   ULONG ulAction;
;|***   ULONG ulCount;
;|***   ULONG ulFileError;
;|*** #else
;|***   WORD ulAction;
;|***   WORD ulCount;
;|***   WORD ulFileError;
;|*** #endif
;|*** 
;|***   ulWriteBufferSpace = 0;
; Line 248
_TEXT      ENDS
CONST      SEGMENT
$T20000	DW SEG _ulWriteBufferSpace 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 00007f	8e 06 00 00 		mov	es,WORD PTR $T20000
	*** 000083	2b c0 			sub	ax,ax
	*** 000085	26 a3 02 00 		mov	WORD PTR es:_ulWriteBufferSpace+2,ax
	*** 000089	26 a3 00 00 		mov	WORD PTR es:_ulWriteBufferSpace,ax
;|***   ulRequiredBufferSpace = 0;
; Line 249
_TEXT      ENDS
CONST      SEGMENT
$T20001	DW SEG _ulRequiredBufferSpace 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 00008d	8e 06 02 00 		mov	es,WORD PTR $T20001
	*** 000091	2b c0 			sub	ax,ax
	*** 000093	26 a3 02 00 		mov	WORD PTR es:_ulRequiredBufferSpace+2,ax
	*** 000097	26 a3 00 00 		mov	WORD PTR es:_ulRequiredBufferSpace,ax
;|***   ulFileError = FALSE;
; Line 250
	*** 00009b	c7 46 e0 00 00 		mov	WORD PTR [bp-32],0	;ulFileError
;|***   wLoadNumber = NO_INI_FILE;
; Line 251
_TEXT      ENDS
CONST      SEGMENT
$T20002	DW SEG _wLoadNumber 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 0000a0	8e 06 04 00 		mov	es,WORD PTR $T20002
	*** 0000a4	26 c7 06 00 00 ff ff 	mov	WORD PTR es:_wLoadNumber,-1
;|***   wLoadCount = 0;
; Line 252
_TEXT      ENDS
CONST      SEGMENT
$T20003	DW SEG _wLoadCount 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 0000ab	8e 06 06 00 		mov	es,WORD PTR $T20003
	*** 0000af	26 c7 06 00 00 00 00 	mov	WORD PTR es:_wLoadCount,0
;|***   for (wIndex = 0;wIndex < (CCHMAXPATH - 8);wIndex++)
; Line 253
	*** 0000b6	c7 46 d0 00 00 		mov	WORD PTR [bp-48],0	;wIndex
	*** 0000bb	e9 03 00 		jmp	$F2506
					$FC2507:
	*** 0000be	ff 46 d0 		inc	WORD PTR [bp-48]	;wIndex
					$F2506:
	*** 0000c1	81 7e d0 fc 00 		cmp	WORD PTR [bp-48],252	;wIndex
	*** 0000c6	72 03 			jb	$JCC198
	*** 0000c8	e9 2d 00 		jmp	$FB2508
					$JCC198:
;|***     {
; Line 254
;|***     if (_abyPath[wIndex] == ' ')
; Line 255
_TEXT      ENDS
CONST      SEGMENT
$T20004	DW SEG __abyPath 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 0000cb	8e 06 08 00 		mov	es,WORD PTR $T20004
	*** 0000cf	8b 5e d0 		mov	bx,WORD PTR [bp-48]	;wIndex
	*** 0000d2	26 80 bf 00 00 20 	cmp	BYTE PTR es:__abyPath[bx],32
	*** 0000d8	74 03 			je	$JCC216
	*** 0000da	e9 03 00 		jmp	$I2509
					$JCC216:
;|***       break;
; Line 256
	*** 0000dd	e9 18 00 		jmp	$FB2508
;|***     if (_abyPath[wIndex] == 0)
; Line 257
					$I2509:
	*** 0000e0	8e 06 08 00 		mov	es,WORD PTR $T20004
	*** 0000e4	8b 5e d0 		mov	bx,WORD PTR [bp-48]	;wIndex
	*** 0000e7	26 80 bf 00 00 00 	cmp	BYTE PTR es:__abyPath[bx],0
	*** 0000ed	74 03 			je	$JCC237
	*** 0000ef	e9 03 00 		jmp	$I2510
					$JCC237:
;|***       break;
; Line 258
	*** 0000f2	e9 03 00 		jmp	$FB2508
;|***     }
; Line 259
					$I2510:
	*** 0000f5	e9 c6 ff 		jmp	$FC2507
					$FB2508:
;|***   while (_abyPath[wIndex] != '.')
; Line 260
					$FC2512:
	*** 0000f8	8e 06 08 00 		mov	es,WORD PTR $T20004
	*** 0000fc	8b 5e d0 		mov	bx,WORD PTR [bp-48]	;wIndex
	*** 0000ff	26 80 bf 00 00 2e 	cmp	BYTE PTR es:__abyPath[bx],46
	*** 000105	75 03 			jne	$JCC261
	*** 000107	e9 30 00 		jmp	$FB2513
					$JCC261:
;|***     if (wIndex-- == 0)
; Line 261
	*** 00010a	8b 46 d0 		mov	ax,WORD PTR [bp-48]	;wIndex
	*** 00010d	ff 4e d0 		dec	WORD PTR [bp-48]	;wIndex
	*** 000110	3d 00 00 		cmp	ax,0
	*** 000113	74 03 			je	$JCC275
	*** 000115	e9 1f 00 		jmp	$I2514
					$JCC275:
;|***       {
; Line 262
;|***       VioWrtTTY(chFailedBadPath,StringLength(chFailedBadPath),0);
; Line 263
	*** 000118	68 00 00 		push	SEG _chFailedBadPath
	*** 00011b	68 00 00 		push	OFFSET _chFailedBadPath
	*** 00011e	68 00 00 		push	SEG _chFailedBadPath
	*** 000121	68 00 00 		push	OFFSET _chFailedBadPath
	*** 000124	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 000129	83 c4 04 		add	sp,4
	*** 00012c	50 			push	ax
	*** 00012d	6a 00 			push	0
	*** 00012f	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***       return;
; Line 264
	*** 000134	e9 21 0f 		jmp	$EX2486
;|***       }
; Line 265
;|***   wSaveExt = ++wIndex;
; Line 266
					$I2514:
	*** 000137	e9 be ff 		jmp	$FC2512
					$FB2513:
	*** 00013a	ff 46 d0 		inc	WORD PTR [bp-48]	;wIndex
	*** 00013d	8b 46 d0 		mov	ax,WORD PTR [bp-48]	;wIndex
	*** 000140	89 46 e8 		mov	WORD PTR [bp-24],ax	;wSaveExt
;|***   abySaveExt[0] = _abyPath[wIndex];
; Line 267
	*** 000143	8e 06 08 00 		mov	es,WORD PTR $T20004
	*** 000147	8b 5e d0 		mov	bx,WORD PTR [bp-48]	;wIndex
	*** 00014a	26 8a 87 00 00 		mov	al,BYTE PTR es:__abyPath[bx]
	*** 00014f	88 46 d8 		mov	BYTE PTR [bp-40],al	;abySaveExt
;|***   _abyPath[wIndex] = 'I';
; Line 268
	*** 000152	8b 5e d0 		mov	bx,WORD PTR [bp-48]	;wIndex
	*** 000155	26 c6 87 00 00 49 	mov	BYTE PTR es:__abyPath[bx],73
;|***   abySaveExt[1] = _abyPath[++wIndex];
; Line 269
	*** 00015b	ff 46 d0 		inc	WORD PTR [bp-48]	;wIndex
	*** 00015e	8b 5e d0 		mov	bx,WORD PTR [bp-48]	;wIndex
	*** 000161	26 8a 87 00 00 		mov	al,BYTE PTR es:__abyPath[bx]
	*** 000166	88 46 d9 		mov	BYTE PTR [bp-39],al
;|***   _abyPath[wIndex] = 'N';
; Line 270
	*** 000169	8b 5e d0 		mov	bx,WORD PTR [bp-48]	;wIndex
	*** 00016c	26 c6 87 00 00 4e 	mov	BYTE PTR es:__abyPath[bx],78
;|***   abySaveExt[2] = _abyPath[++wIndex];
; Line 271
	*** 000172	ff 46 d0 		inc	WORD PTR [bp-48]	;wIndex
	*** 000175	8b 5e d0 		mov	bx,WORD PTR [bp-48]	;wIndex
	*** 000178	26 8a 87 00 00 		mov	al,BYTE PTR es:__abyPath[bx]
	*** 00017d	88 46 da 		mov	BYTE PTR [bp-38],al
;|***   _abyPath[wIndex] = 'I';
; Line 272
	*** 000180	8b 5e d0 		mov	bx,WORD PTR [bp-48]	;wIndex
	*** 000183	26 c6 87 00 00 49 	mov	BYTE PTR es:__abyPath[bx],73
;|***   abySaveExt[3] = _abyPath[++wIndex];
; Line 273
	*** 000189	ff 46 d0 		inc	WORD PTR [bp-48]	;wIndex
	*** 00018c	8b 5e d0 		mov	bx,WORD PTR [bp-48]	;wIndex
	*** 00018f	26 8a 87 00 00 		mov	al,BYTE PTR es:__abyPath[bx]
	*** 000194	88 46 db 		mov	BYTE PTR [bp-37],al
;|***   _abyPath[wIndex] = 0;
; Line 274
	*** 000197	8b 5e d0 		mov	bx,WORD PTR [bp-48]	;wIndex
	*** 00019a	26 c6 87 00 00 00 	mov	BYTE PTR es:__abyPath[bx],0
;|*** #ifndef NO_PCI
;|***   #if MAX_PCI_ADAPTERS > 0
;|***   GetAllSerialPCIAdapters();
; Line 277
	*** 0001a0	9a 00 00 00 00 		call	FAR PTR _GetAllSerialPCIAdapters
;|***   if (wPCIadapterCount > 1)
; Line 278
_TEXT      ENDS
CONST      SEGMENT
$T20005	DW SEG _wPCIadapterCount 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 0001a5	8e 06 0a 00 		mov	es,WORD PTR $T20005
	*** 0001a9	26 83 3e 00 00 01 	cmp	WORD PTR es:_wPCIadapterCount,1
	*** 0001af	77 03 			ja	$JCC431
	*** 0001b1	e9 3c 01 		jmp	$I2516
					$JCC431:
;|***     {
; Line 279
;	awIndexList = -64
;	xHighest = -54
;	xLowest = -56
;	xCurrent = -60
;	wListIndex = -58
;	wUsedIndex = -50
;	bSkipIndex = -52
;|***     WORD awIndexList[MAX_PCI_ADAPTERS + 1];
;|***     BYTE xHighest;
;|***     BYTE xLowest;
;|***     BYTE xCurrent;
;|***     WORD wListIndex;
;|***     WORD wUsedIndex;
;|***     BOOL bSkipIndex;
;|***     
;|*** #ifdef OEM
;|***     _bOEMpresent = TRUE;
; Line 289
_TEXT      ENDS
CONST      SEGMENT
$T20006	DW SEG __bOEMpresent 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 0001b4	8e 06 0c 00 		mov	es,WORD PTR $T20006
	*** 0001b8	26 c7 06 00 00 01 00 	mov	WORD PTR es:__bOEMpresent,1
;|*** #endif                               
;|***     for (wIndex = 0; wIndex < MAX_PCI_ADAPTERS; wIndex++)
; Line 291
	*** 0001bf	c7 46 d0 00 00 		mov	WORD PTR [bp-48],0	;wIndex
	*** 0001c4	e9 03 00 		jmp	$F2524
					$FC2525:
	*** 0001c7	ff 46 d0 		inc	WORD PTR [bp-48]	;wIndex
					$F2524:
	*** 0001ca	83 7e d0 01 		cmp	WORD PTR [bp-48],1	;wIndex
	*** 0001ce	72 03 			jb	$JCC462
	*** 0001d0	e9 0d 00 		jmp	$FB2526
					$JCC462:
;|***       awIndexList[wIndex] = -1;
; Line 292
	*** 0001d3	8b 76 d0 		mov	si,WORD PTR [bp-48]	;wIndex
	*** 0001d6	d1 e6 			shl	si,1
	*** 0001d8	c7 42 c0 ff ff 		mov	WORD PTR [bp-64][si],-1
	*** 0001dd	e9 e7 ff 		jmp	$FC2525
					$FB2526:
;|***     for (wListIndex = 0; wListIndex < MAX_PCI_ADAPTERS; wListIndex++)  
; Line 293
	*** 0001e0	c7 46 c6 00 00 		mov	WORD PTR [bp-58],0	;wListIndex
	*** 0001e5	e9 03 00 		jmp	$F2527
					$FC2528:
	*** 0001e8	ff 46 c6 		inc	WORD PTR [bp-58]	;wListIndex
					$F2527:
	*** 0001eb	83 7e c6 01 		cmp	WORD PTR [bp-58],1	;wListIndex
	*** 0001ef	72 03 			jb	$JCC495
	*** 0001f1	e9 91 00 		jmp	$FB2529
					$JCC495:
;|***       {
; Line 294
;|***       xLowest = 0xff;
; Line 295
	*** 0001f4	c6 46 c8 ff 		mov	BYTE PTR [bp-56],255	;xLowest
;|***       for (wIndex = 0; wIndex < MAX_PCI_ADAPTERS; wIndex++)
; Line 296
	*** 0001f8	c7 46 d0 00 00 		mov	WORD PTR [bp-48],0	;wIndex
	*** 0001fd	e9 03 00 		jmp	$F2530
					$FC2531:
	*** 000200	ff 46 d0 		inc	WORD PTR [bp-48]	;wIndex
					$F2530:
	*** 000203	83 7e d0 01 		cmp	WORD PTR [bp-48],1	;wIndex
	*** 000207	72 03 			jb	$JCC519
	*** 000209	e9 76 00 		jmp	$FB2532
					$JCC519:
;|***         {
; Line 297
;|***         if ((xCurrent = stPCIadapterTable[wIndex].xDevFuncNum) == 0)
; Line 298
_TEXT      ENDS
CONST      SEGMENT
$T20007	DW SEG _stPCIadapterTable 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 00020c	8e 06 0e 00 		mov	es,WORD PTR $T20007
	*** 000210	6b 5e d0 18 		imul	bx,WORD PTR [bp-48],24	;wIndex
	*** 000214	26 8a 87 00 00 		mov	al,BYTE PTR es:_stPCIadapterTable[bx]
	*** 000219	88 46 c4 		mov	BYTE PTR [bp-60],al	;xCurrent
	*** 00021c	3c 00 			cmp	al,0
	*** 00021e	74 03 			je	$JCC542
	*** 000220	e9 03 00 		jmp	$I2533
					$JCC542:
;|***           break;
; Line 299
	*** 000223	e9 5c 00 		jmp	$FB2532
;|***         bSkipIndex = FALSE;
; Line 300
					$I2533:
	*** 000226	c7 46 cc 00 00 		mov	WORD PTR [bp-52],0	;bSkipIndex
;|***         for (wUsedIndex = 0; wUsedIndex < MAX_PCI_ADAPTERS; wUsedIndex++)
; Line 301
	*** 00022b	c7 46 ce 00 00 		mov	WORD PTR [bp-50],0	;wUsedIndex
	*** 000230	e9 03 00 		jmp	$F2534
					$FC2535:
	*** 000233	ff 46 ce 		inc	WORD PTR [bp-50]	;wUsedIndex
					$F2534:
	*** 000236	83 7e ce 01 		cmp	WORD PTR [bp-50],1	;wUsedIndex
	*** 00023a	72 03 			jb	$JCC570
	*** 00023c	e9 1b 00 		jmp	$FB2536
					$JCC570:
;|***           if (awIndexList[wUsedIndex] == wIndex)
; Line 302
	*** 00023f	8b 46 d0 		mov	ax,WORD PTR [bp-48]	;wIndex
	*** 000242	8b 76 ce 		mov	si,WORD PTR [bp-50]	;wUsedIndex
	*** 000245	d1 e6 			shl	si,1
	*** 000247	39 42 c0 		cmp	WORD PTR [bp-64][si],ax
	*** 00024a	74 03 			je	$JCC586
	*** 00024c	e9 08 00 		jmp	$I2537
					$JCC586:
;|***             {
; Line 303
;|***             bSkipIndex = TRUE;
; Line 304
	*** 00024f	c7 46 cc 01 00 		mov	WORD PTR [bp-52],1	;bSkipIndex
;|***             break;
; Line 305
	*** 000254	e9 03 00 		jmp	$FB2536
;|***             }
; Line 306
;|***         if (!bSkipIndex)
; Line 307
					$I2537:
	*** 000257	e9 d9 ff 		jmp	$FC2535
					$FB2536:
	*** 00025a	83 7e cc 00 		cmp	WORD PTR [bp-52],0	;bSkipIndex
	*** 00025e	74 03 			je	$JCC606
	*** 000260	e9 1c 00 		jmp	$I2538
					$JCC606:
;|***           if (xCurrent < xLowest)
; Line 308
	*** 000263	8a 46 c8 		mov	al,BYTE PTR [bp-56]	;xLowest
	*** 000266	38 46 c4 		cmp	BYTE PTR [bp-60],al	;xCurrent
	*** 000269	72 03 			jb	$JCC617
	*** 00026b	e9 11 00 		jmp	$I2539
					$JCC617:
;|***             {
; Line 309
;|***             awIndexList[wListIndex] = wIndex;
; Line 310
	*** 00026e	8b 46 d0 		mov	ax,WORD PTR [bp-48]	;wIndex
	*** 000271	8b 76 c6 		mov	si,WORD PTR [bp-58]	;wListIndex
	*** 000274	d1 e6 			shl	si,1
	*** 000276	89 42 c0 		mov	WORD PTR [bp-64][si],ax
;|***             xLowest = xCurrent;
; Line 311
	*** 000279	8a 46 c4 		mov	al,BYTE PTR [bp-60]	;xCurrent
	*** 00027c	88 46 c8 		mov	BYTE PTR [bp-56],al	;xLowest
;|***             }
; Line 312
;|***         }
; Line 313
					$I2539:
					$I2538:
	*** 00027f	e9 7e ff 		jmp	$FC2531
					$FB2532:
;|***       }
; Line 314
	*** 000282	e9 63 ff 		jmp	$FC2528
					$FB2529:
;|***     for (wIndex = 0; wIndex < MAX_PCI_ADAPTERS; wIndex++)
; Line 315
	*** 000285	c7 46 d0 00 00 		mov	WORD PTR [bp-48],0	;wIndex
	*** 00028a	e9 03 00 		jmp	$F2540
					$FC2541:
	*** 00028d	ff 46 d0 		inc	WORD PTR [bp-48]	;wIndex
					$F2540:
	*** 000290	83 7e d0 01 		cmp	WORD PTR [bp-48],1	;wIndex
	*** 000294	72 03 			jb	$JCC660
	*** 000296	e9 41 00 		jmp	$FB2542
					$JCC660:
;|***       if (stPCIadapterTable[wIndex].xDevFuncNum == 0)
; Line 316
	*** 000299	8e 06 0e 00 		mov	es,WORD PTR $T20007
	*** 00029d	6b 5e d0 18 		imul	bx,WORD PTR [bp-48],24	;wIndex
	*** 0002a1	26 80 bf 00 00 00 	cmp	BYTE PTR es:_stPCIadapterTable[bx],0
	*** 0002a7	74 03 			je	$JCC679
	*** 0002a9	e9 06 00 		jmp	$I2543
					$JCC679:
;|***         break;
; Line 317
	*** 0002ac	e9 2b 00 		jmp	$FB2542
;|***       else
; Line 318
	*** 0002af	e9 25 00 		jmp	$I2544
					$I2543:
;|***         MemCopy((char _far *)&stPCIadapterHold[wIndex], (char _far *)&stPCIadapterTable[awIndexList[wIndex]], sizeof (PCIADPT));
; Line 319
	*** 0002b2	6a 18 			push	24
	*** 0002b4	8b 76 d0 		mov	si,WORD PTR [bp-48]	;wIndex
	*** 0002b7	d1 e6 			shl	si,1
	*** 0002b9	6b 42 c0 18 		imul	ax,WORD PTR [bp-64][si],24
	*** 0002bd	05 00 00 		add	ax,OFFSET _stPCIadapterTable
	*** 0002c0	68 00 00 		push	SEG _stPCIadapterTable
	*** 0002c3	50 			push	ax
	*** 0002c4	6b 46 d0 18 		imul	ax,WORD PTR [bp-48],24	;wIndex
	*** 0002c8	05 00 00 		add	ax,OFFSET _stPCIadapterHold
	*** 0002cb	68 00 00 		push	SEG _stPCIadapterHold
	*** 0002ce	50 			push	ax
	*** 0002cf	9a 00 00 00 00 		call	FAR PTR _MemCopy
	*** 0002d4	83 c4 0a 		add	sp,10
					$I2544:
	*** 0002d7	e9 b3 ff 		jmp	$FC2541
					$FB2542:
;|***     MemCopy((char _far *)stPCIadapterTable, (char _far *)stPCIadapterHold, (sizeof (PCIADPT) * MAX_PCI_ADAPTERS));
; Line 320
	*** 0002da	6a 18 			push	24
	*** 0002dc	68 00 00 		push	SEG _stPCIadapterHold
	*** 0002df	68 00 00 		push	OFFSET _stPCIadapterHold
	*** 0002e2	68 00 00 		push	SEG _stPCIadapterTable
	*** 0002e5	68 00 00 		push	OFFSET _stPCIadapterTable
	*** 0002e8	9a 00 00 00 00 		call	FAR PTR _MemCopy
	*** 0002ed	83 c4 0a 		add	sp,10
;|***     }
; Line 321
;|***   #endif
;|*** #endif    
;|***   if (DosOpen(_abyPath,&hFile,&ulAction,0L,0,1,0x1312,0L) == 0)
; Line 324
					$I2516:
	*** 0002f0	68 00 00 		push	SEG __abyPath
	*** 0002f3	68 00 00 		push	OFFSET __abyPath
	*** 0002f6	1e 			push	ds
	*** 0002f7	68 ea 0d 		push	OFFSET DGROUP:_hFile
	*** 0002fa	8d 46 d4 		lea	ax,WORD PTR [bp-44]	;ulAction
	*** 0002fd	16 			push	ss
	*** 0002fe	50 			push	ax
	*** 0002ff	6a 00 			push	0
	*** 000301	6a 00 			push	0
	*** 000303	6a 00 			push	0
	*** 000305	6a 01 			push	1
	*** 000307	68 12 13 		push	4882
	*** 00030a	6a 00 			push	0
	*** 00030c	6a 00 			push	0
	*** 00030e	9a 00 00 00 00 		call	FAR PTR DOS16OPEN
	*** 000313	3d 00 00 		cmp	ax,0
	*** 000316	74 03 			je	$JCC790
	*** 000318	e9 ee 0c 		jmp	$I2545
					$JCC790:
;|***     {
; Line 325
;|***     if ((ulFileError = DosRead(hFile,(PVOID)&stConfigInfo,sizeof(CFGINFO),&ulCount)) != 0)
; Line 326
	*** 00031b	ff 36 ea 0d 		push	WORD PTR _hFile
	*** 00031f	1e 			push	ds
	*** 000320	68 42 0d 		push	OFFSET DGROUP:_stConfigInfo
	*** 000323	6a 2c 			push	44
	*** 000325	8d 46 e2 		lea	ax,WORD PTR [bp-30]	;ulCount
	*** 000328	16 			push	ss
	*** 000329	50 			push	ax
	*** 00032a	9a 00 00 00 00 		call	FAR PTR DOS16READ
	*** 00032f	89 46 e0 		mov	WORD PTR [bp-32],ax	;ulFileError
	*** 000332	3d 00 00 		cmp	ax,0
	*** 000335	75 03 			jne	$JCC821
	*** 000337	e9 24 00 		jmp	$I2546
					$JCC821:
;|***       {
; Line 327
;|***       VioWrtTTY(chFailedReadIni,StringLength(chFailedReadIni),0);
; Line 328
	*** 00033a	68 00 00 		push	SEG _chFailedReadIni
	*** 00033d	68 00 00 		push	OFFSET _chFailedReadIni
	*** 000340	68 00 00 		push	SEG _chFailedReadIni
	*** 000343	68 00 00 		push	OFFSET _chFailedReadIni
	*** 000346	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 00034b	83 c4 04 		add	sp,4
	*** 00034e	50 			push	ax
	*** 00034f	6a 00 			push	0
	*** 000351	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***       ulFileError |= ERR_FILE_READ;
; Line 329
	*** 000356	81 4e e0 00 a0 		or	WORD PTR [bp-32],-24576	;ulFileError
;|***       goto gtEarlyOut;
; Line 330
	*** 00035b	e9 ff 0b 		jmp	$gtEarlyOut2547
;|***       }
; Line 331
;|***     if (stConfigInfo.ulSignature != INI_FILE_SIGNATURE)
; Line 332
					$I2546:
	*** 00035e	81 3e 42 0d 35 18 	cmp	WORD PTR _stConfigInfo,6197
	*** 000364	74 03 			je	$JCC868
	*** 000366	e9 0b 00 		jmp	$L20008
					$JCC868:
	*** 000369	81 3e 44 0d 84 19 	cmp	WORD PTR _stConfigInfo+2,6532
	*** 00036f	75 03 			jne	$JCC879
	*** 000371	e9 5c 00 		jmp	$I2548
					$JCC879:
					$L20008:
;|***       {
; Line 333
;|***       VioWrtTTY(chFailedBadVersion_1,StringLength(chFailedBadVersion_1),0);
; Line 334
	*** 000374	68 00 00 		push	SEG _chFailedBadVersion_1
	*** 000377	68 00 00 		push	OFFSET _chFailedBadVersion_1
	*** 00037a	68 00 00 		push	SEG _chFailedBadVersion_1
	*** 00037d	68 00 00 		push	OFFSET _chFailedBadVersion_1
	*** 000380	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 000385	83 c4 04 		add	sp,4
	*** 000388	50 			push	ax
	*** 000389	6a 00 			push	0
	*** 00038b	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***       VioWrtTTY(_abyPath,StringLength(_abyPath),0);
; Line 335
	*** 000390	68 00 00 		push	SEG __abyPath
	*** 000393	68 00 00 		push	OFFSET __abyPath
	*** 000396	68 00 00 		push	SEG __abyPath
	*** 000399	68 00 00 		push	OFFSET __abyPath
	*** 00039c	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 0003a1	83 c4 04 		add	sp,4
	*** 0003a4	50 			push	ax
	*** 0003a5	6a 00 			push	0
	*** 0003a7	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***       VioWrtTTY(chFailedBadVersion_2,StringLength(chFailedBadVersion_2),0);
; Line 336
	*** 0003ac	68 00 00 		push	SEG _chFailedBadVersion_2
	*** 0003af	68 00 00 		push	OFFSET _chFailedBadVersion_2
	*** 0003b2	68 00 00 		push	SEG _chFailedBadVersion_2
	*** 0003b5	68 00 00 		push	OFFSET _chFailedBadVersion_2
	*** 0003b8	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 0003bd	83 c4 04 		add	sp,4
	*** 0003c0	50 			push	ax
	*** 0003c1	6a 00 			push	0
	*** 0003c3	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***       ulFileError = BAD_INI_SIGNATURE;
; Line 337
	*** 0003c8	c7 46 e0 00 e0 		mov	WORD PTR [bp-32],-8192	;ulFileError
;|***       goto gtEarlyOut;
; Line 338
	*** 0003cd	e9 8d 0b 		jmp	$gtEarlyOut2547
;|***       }
; Line 339
;|***     if (stConfigInfo.wCFGheaderCount == 0)
; Line 340
					$I2548:
	*** 0003d0	83 3e 48 0d 00 		cmp	WORD PTR _stConfigInfo+6,0
	*** 0003d5	74 03 			je	$JCC981
	*** 0003d7	e9 5c 00 		jmp	$I2549
					$JCC981:
;|***       {
; Line 341
;|***       VioWrtTTY(chFailedIniCorrupt_1,StringLength(chFailedIniCorrupt_1),0);
; Line 342
	*** 0003da	68 00 00 		push	SEG _chFailedIniCorrupt_1
	*** 0003dd	68 00 00 		push	OFFSET _chFailedIniCorrupt_1
	*** 0003e0	68 00 00 		push	SEG _chFailedIniCorrupt_1
	*** 0003e3	68 00 00 		push	OFFSET _chFailedIniCorrupt_1
	*** 0003e6	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 0003eb	83 c4 04 		add	sp,4
	*** 0003ee	50 			push	ax
	*** 0003ef	6a 00 			push	0
	*** 0003f1	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***       VioWrtTTY(_abyPath,StringLength(_abyPath),0);
; Line 343
	*** 0003f6	68 00 00 		push	SEG __abyPath
	*** 0003f9	68 00 00 		push	OFFSET __abyPath
	*** 0003fc	68 00 00 		push	SEG __abyPath
	*** 0003ff	68 00 00 		push	OFFSET __abyPath
	*** 000402	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 000407	83 c4 04 		add	sp,4
	*** 00040a	50 			push	ax
	*** 00040b	6a 00 			push	0
	*** 00040d	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***       VioWrtTTY(chFailedIniCorrupt_2,StringLength(chFailedIniCorrupt_2),0);
; Line 344
	*** 000412	68 00 00 		push	SEG _chFailedIniCorrupt_2
	*** 000415	68 00 00 		push	OFFSET _chFailedIniCorrupt_2
	*** 000418	68 00 00 		push	SEG _chFailedIniCorrupt_2
	*** 00041b	68 00 00 		push	OFFSET _chFailedIniCorrupt_2
	*** 00041e	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 000423	83 c4 04 		add	sp,4
	*** 000426	50 			push	ax
	*** 000427	6a 00 			push	0
	*** 000429	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***       ulFileError |= ERR_FILE_CORRUPT;
; Line 345
	*** 00042e	81 4e e0 00 d0 		or	WORD PTR [bp-32],-12288	;ulFileError
;|***       goto gtEarlyOut;
; Line 346
	*** 000433	e9 27 0b 		jmp	$gtEarlyOut2547
;|***       }
; Line 347
;|***     stConfigInfo.byOEMtype = _byOEMtype;
; Line 348
					$I2549:
_TEXT      ENDS
CONST      SEGMENT
$T20009	DW SEG __byOEMtype 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 000436	8e 06 10 00 		mov	es,WORD PTR $T20009
	*** 00043a	26 a0 00 00 		mov	al,BYTE PTR es:__byOEMtype
	*** 00043e	a2 4f 0d 		mov	BYTE PTR _stConfigInfo+13,al
;|***     wDriverLoadCount = stConfigInfo.wCFGheaderCount;
; Line 349
	*** 000441	a1 48 0d 		mov	ax,WORD PTR _stConfigInfo+6
_TEXT      ENDS
CONST      SEGMENT
$T20010	DW SEG _wDriverLoadCount 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 000444	8e 06 12 00 		mov	es,WORD PTR $T20010
	*** 000448	26 a3 00 00 		mov	WORD PTR es:_wDriverLoadCount,ax
;|***     lSaveOffset = stConfigInfo.oFirstCFGheader;
; Line 350
	*** 00044c	a1 4a 0d 		mov	ax,WORD PTR _stConfigInfo+8
	*** 00044f	89 46 fa 		mov	WORD PTR [bp-6],ax	;lSaveOffset
	*** 000452	c7 46 fc 00 00 		mov	WORD PTR [bp-4],0
;|***     DosChgFilePtr(hFile,lSaveOffset,0,&ulFilePosition);
; Line 351
	*** 000457	ff 36 ea 0d 		push	WORD PTR _hFile
	*** 00045b	ff 76 fc 		push	WORD PTR [bp-4]
	*** 00045e	ff 76 fa 		push	WORD PTR [bp-6]	;lSaveOffset
	*** 000461	6a 00 			push	0
	*** 000463	8d 46 ee 		lea	ax,WORD PTR [bp-18]	;ulFilePosition
	*** 000466	16 			push	ss
	*** 000467	50 			push	ax
	*** 000468	9a 00 00 00 00 		call	FAR PTR DOS16CHGFILEPTR
;|***     _byAdapterType = stConfigHeader.byAdapterType;
; Line 352
	*** 00046d	a0 78 0d 		mov	al,BYTE PTR _stConfigHeader+10
_TEXT      ENDS
CONST      SEGMENT
$T20011	DW SEG __byAdapterType 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 000470	8e 06 14 00 		mov	es,WORD PTR $T20011
	*** 000474	26 a2 00 00 		mov	BYTE PTR es:__byAdapterType,al
;|***     byNextPCIslot = stConfigInfo.byNextPCIslot;
; Line 353
	*** 000478	a0 4e 0d 		mov	al,BYTE PTR _stConfigInfo+12
_TEXT      ENDS
CONST      SEGMENT
$T20012	DW SEG _byNextPCIslot 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 00047b	8e 06 16 00 		mov	es,WORD PTR $T20012
	*** 00047f	26 a2 00 00 		mov	BYTE PTR es:_byNextPCIslot,al
;|***     if (bIsTheFirst)
; Line 354
_TEXT      ENDS
CONST      SEGMENT
$T20013	DW SEG _bIsTheFirst 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 000483	8e 06 18 00 		mov	es,WORD PTR $T20013
	*** 000487	26 83 3e 00 00 00 	cmp	WORD PTR es:_bIsTheFirst,0
	*** 00048d	75 03 			jne	$JCC1165
	*** 00048f	e9 30 03 		jmp	$I2550
					$JCC1165:
;|***       {
; Line 355
;|***       byNextPCIslot = 0;
; Line 356
	*** 000492	8e 06 16 00 		mov	es,WORD PTR $T20012
	*** 000496	26 c6 06 00 00 00 	mov	BYTE PTR es:_byNextPCIslot,0
;|***       stConfigInfo.byNextPCIslot = 0;
; Line 357
	*** 00049c	c6 06 4e 0d 00 		mov	BYTE PTR _stConfigInfo+12,0
;|***       /*
;|***       **  Clear HeaderIsAvailable flags for all config headers if this is the
;|***       **  first COMi load.
;|***       */
;|***       DosChgFilePtr(hFile,0,0,&ulFilePosition);
; Line 362
	*** 0004a1	ff 36 ea 0d 		push	WORD PTR _hFile
	*** 0004a5	6a 00 			push	0
	*** 0004a7	6a 00 			push	0
	*** 0004a9	6a 00 			push	0
	*** 0004ab	8d 46 ee 		lea	ax,WORD PTR [bp-18]	;ulFilePosition
	*** 0004ae	16 			push	ss
	*** 0004af	50 			push	ax
	*** 0004b0	9a 00 00 00 00 		call	FAR PTR DOS16CHGFILEPTR
;|***       if ((ulFileError = DosWrite(hFile,(PVOID)&stConfigInfo,sizeof(CFGINFO),&ulCount)) != 0)
; Line 363
	*** 0004b5	ff 36 ea 0d 		push	WORD PTR _hFile
	*** 0004b9	1e 			push	ds
	*** 0004ba	68 42 0d 		push	OFFSET DGROUP:_stConfigInfo
	*** 0004bd	6a 2c 			push	44
	*** 0004bf	8d 46 e2 		lea	ax,WORD PTR [bp-30]	;ulCount
	*** 0004c2	16 			push	ss
	*** 0004c3	50 			push	ax
	*** 0004c4	9a 00 00 00 00 		call	FAR PTR DOS16WRITE
	*** 0004c9	89 46 e0 		mov	WORD PTR [bp-32],ax	;ulFileError
	*** 0004cc	3d 00 00 		cmp	ax,0
	*** 0004cf	75 03 			jne	$JCC1231
	*** 0004d1	e9 24 00 		jmp	$I2551
					$JCC1231:
;|***         {
; Line 364
;|***         VioWrtTTY(chFailedWriteIni,StringLength(chFailedWriteIni),0);
; Line 365
	*** 0004d4	68 00 00 		push	SEG _chFailedWriteIni
	*** 0004d7	68 00 00 		push	OFFSET _chFailedWriteIni
	*** 0004da	68 00 00 		push	SEG _chFailedWriteIni
	*** 0004dd	68 00 00 		push	OFFSET _chFailedWriteIni
	*** 0004e0	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 0004e5	83 c4 04 		add	sp,4
	*** 0004e8	50 			push	ax
	*** 0004e9	6a 00 			push	0
	*** 0004eb	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***         ulFileError |= ERR_FILE_WRITE;
; Line 366
	*** 0004f0	81 4e e0 00 c0 		or	WORD PTR [bp-32],-16384	;ulFileError
;|***         goto gtEarlyOut;
; Line 367
	*** 0004f5	e9 65 0a 		jmp	$gtEarlyOut2547
;|***         }
; Line 368
;|***       for (wIndex = 0;wIndex < stConfigInfo.wCFGheaderCount;wIndex++)
; Line 369
					$I2551:
	*** 0004f8	c7 46 d0 00 00 		mov	WORD PTR [bp-48],0	;wIndex
	*** 0004fd	e9 03 00 		jmp	$F2552
					$FC2553:
	*** 000500	ff 46 d0 		inc	WORD PTR [bp-48]	;wIndex
					$F2552:
	*** 000503	a1 48 0d 		mov	ax,WORD PTR _stConfigInfo+6
	*** 000506	39 46 d0 		cmp	WORD PTR [bp-48],ax	;wIndex
	*** 000509	72 03 			jb	$JCC1289
	*** 00050b	e9 b4 02 		jmp	$FB2554
					$JCC1289:
;|***         {
; Line 370
;|***         if ((ulFileError = DosRead(hFile,(PVOID)&stConfigHeader,sizeof(CFGHEAD),&ulCount)) != 0)
; Line 371
	*** 00050e	ff 36 ea 0d 		push	WORD PTR _hFile
	*** 000512	1e 			push	ds
	*** 000513	68 6e 0d 		push	OFFSET DGROUP:_stConfigHeader
	*** 000516	6a 3e 			push	62
	*** 000518	8d 46 e2 		lea	ax,WORD PTR [bp-30]	;ulCount
	*** 00051b	16 			push	ss
	*** 00051c	50 			push	ax
	*** 00051d	9a 00 00 00 00 		call	FAR PTR DOS16READ
	*** 000522	89 46 e0 		mov	WORD PTR [bp-32],ax	;ulFileError
	*** 000525	3d 00 00 		cmp	ax,0
	*** 000528	75 03 			jne	$JCC1320
	*** 00052a	e9 24 00 		jmp	$I2555
					$JCC1320:
;|***           {
; Line 372
;|***           VioWrtTTY(chFailedReadIni,StringLength(chFailedReadIni),0);
; Line 373
	*** 00052d	68 00 00 		push	SEG _chFailedReadIni
	*** 000530	68 00 00 		push	OFFSET _chFailedReadIni
	*** 000533	68 00 00 		push	SEG _chFailedReadIni
	*** 000536	68 00 00 		push	OFFSET _chFailedReadIni
	*** 000539	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 00053e	83 c4 04 		add	sp,4
	*** 000541	50 			push	ax
	*** 000542	6a 00 			push	0
	*** 000544	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***           ulFileError |= ERR_FILE_READ;
; Line 374
	*** 000549	81 4e e0 00 a0 		or	WORD PTR [bp-32],-24576	;ulFileError
;|***           goto gtEarlyOut;
; Line 375
	*** 00054e	e9 0c 0a 		jmp	$gtEarlyOut2547
;|***           }
; Line 376
;|*** //        byAdapterType = stConfigHeader.byAdapterType;
;|*** #ifdef OEM
;|***         if (wIndex == 0)
; Line 379
					$I2555:
	*** 000551	83 7e d0 00 		cmp	WORD PTR [bp-48],0	;wIndex
	*** 000555	74 03 			je	$JCC1365
	*** 000557	e9 8e 00 		jmp	$I2556
					$JCC1365:
;|***           {
; Line 380
;|***   #ifdef this_junk //NO_PCI
;|***           int iPCIindex;
;|***           for (iPCIindex = 0; iPCIindex < MAX_PCI_ADAPTERS; iPCIindex++)
;|***             {
;|***             if (stPCIadapterTable[iPCIindex].xDevFuncNum == 0)
;|***               break; 
;|***             if (stPCIadapterTable[wIndex].usVendorID == OEM_PCI_VENDOR)
;|***               {
;|***               _bOEMpresent = TRUE;
;|***               break;
;|***               }
;|***             }
;|***   #endif
;|***           if (!_bOEMpresent)
; Line 394
	*** 00055a	8e 06 0c 00 		mov	es,WORD PTR $T20006
	*** 00055e	26 83 3e 00 00 00 	cmp	WORD PTR es:__bOEMpresent,0
	*** 000564	74 03 			je	$JCC1380
	*** 000566	e9 7f 00 		jmp	$I2557
					$JCC1380:
;|***             if ((byLoadAdapterType != HDWTYPE_NONE) && !_bSharedInterrupts)
; Line 395
_TEXT      ENDS
CONST      SEGMENT
$T20014	DW SEG _byLoadAdapterType 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 000569	8e 06 1a 00 		mov	es,WORD PTR $T20014
	*** 00056d	26 80 3e 00 00 00 	cmp	BYTE PTR es:_byLoadAdapterType,0
	*** 000573	75 03 			jne	$JCC1395
	*** 000575	e9 70 00 		jmp	$I2558
					$JCC1395:
_TEXT      ENDS
CONST      SEGMENT
$T20015	DW SEG __bSharedInterrupts 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 000578	8e 06 1c 00 		mov	es,WORD PTR $T20015
	*** 00057c	26 83 3e 00 00 00 	cmp	WORD PTR es:__bSharedInterrupts,0
	*** 000582	74 03 			je	$JCC1410
	*** 000584	e9 61 00 		jmp	$I2558
					$JCC1410:
;|***               {
; Line 396
;|***               if (byLoadAdapterType != stConfigHeader.byAdapterType)
; Line 397
	*** 000587	a0 78 0d 		mov	al,BYTE PTR _stConfigHeader+10
	*** 00058a	8e 06 1a 00 		mov	es,WORD PTR $T20014
	*** 00058e	26 38 06 00 00 		cmp	BYTE PTR es:_byLoadAdapterType,al
	*** 000593	75 03 			jne	$JCC1427
	*** 000595	e9 45 00 		jmp	$I2559
					$JCC1427:
;|***                 {
; Line 398
;|***                 if (byLoadAdapterType == HDWTYPE_DIGIBOARD)
; Line 399
	*** 000598	26 80 3e 00 00 64 	cmp	BYTE PTR es:_byLoadAdapterType,100
	*** 00059e	74 03 			je	$JCC1438
	*** 0005a0	e9 27 00 		jmp	$I2560
					$JCC1438:
;|***                   {
; Line 400
;|***                   if ((stConfigHeader.byAdapterType != HDWTYPE_FIVE) && (stConfigHeader.byAdapterType != HDWTYPE_FOUR))
; Line 401
	*** 0005a3	80 3e 78 0d 05 		cmp	BYTE PTR _stConfigHeader+10,5
	*** 0005a8	75 03 			jne	$JCC1448
	*** 0005aa	e9 1a 00 		jmp	$I2561
					$JCC1448:
	*** 0005ad	80 3e 78 0d 04 		cmp	BYTE PTR _stConfigHeader+10,4
	*** 0005b2	75 03 			jne	$JCC1458
	*** 0005b4	e9 10 00 		jmp	$I2561
					$JCC1458:
;|***                     {
; Line 402
;|***                     PrintWrongOEM();
; Line 403
	*** 0005b7	9a 00 00 00 00 		call	FAR PTR _PrintWrongOEM
;|***                     ulFileError |= ERR_BAD_OEM;
; Line 404
	*** 0005bc	81 4e e0 00 b0 		or	WORD PTR [bp-32],-20480	;ulFileError
;|***                     bBreakInitialization = TRUE;
; Line 405
	*** 0005c1	c7 06 14 0e 01 00 	mov	WORD PTR _bBreakInitialization,1
;|***                     }
; Line 406
;|***                   }
; Line 407
					$I2561:
;|***                 else
; Line 408
	*** 0005c7	e9 10 00 		jmp	$I2562
					$I2560:
;|***                   {
; Line 409
;|***                   PrintWrongOEM();
; Line 410
	*** 0005ca	9a 00 00 00 00 		call	FAR PTR _PrintWrongOEM
;|***                   ulFileError |= ERR_BAD_OEM;
; Line 411
	*** 0005cf	81 4e e0 00 b0 		or	WORD PTR [bp-32],-20480	;ulFileError
;|***                   bBreakInitialization = TRUE;
; Line 412
	*** 0005d4	c7 06 14 0e 01 00 	mov	WORD PTR _bBreakInitialization,1
;|***                   }
; Line 413
					$I2562:
;|***                 }
; Line 414
;|***               else
; Line 415
	*** 0005da	e9 0b 00 		jmp	$I2563
					$I2559:
;|***                 _bOEMpresent = TRUE;
; Line 416
	*** 0005dd	8e 06 0c 00 		mov	es,WORD PTR $T20006
	*** 0005e1	26 c7 06 00 00 01 00 	mov	WORD PTR es:__bOEMpresent,1
					$I2563:
;|***               }
; Line 417
;|***             }
; Line 418
					$I2558:
					$I2557:
;|*** #endif
;|***         DosChgFilePtr(hFile,lSaveOffset,0,&ulFilePosition);
; Line 420
					$I2556:
	*** 0005e8	ff 36 ea 0d 		push	WORD PTR _hFile
	*** 0005ec	ff 76 fc 		push	WORD PTR [bp-4]
	*** 0005ef	ff 76 fa 		push	WORD PTR [bp-6]	;lSaveOffset
	*** 0005f2	6a 00 			push	0
	*** 0005f4	8d 46 ee 		lea	ax,WORD PTR [bp-18]	;ulFilePosition
	*** 0005f7	16 			push	ss
	*** 0005f8	50 			push	ax
	*** 0005f9	9a 00 00 00 00 		call	FAR PTR DOS16CHGFILEPTR
;|***         if (bBreakInitialization)
; Line 421
	*** 0005fe	83 3e 14 0e 00 		cmp	WORD PTR _bBreakInitialization,0
	*** 000603	75 03 			jne	$JCC1539
	*** 000605	e9 09 00 		jmp	$I2564
					$JCC1539:
;|***           stConfigHeader.bHeaderIsAvailable = FALSE;
; Line 422
	*** 000608	c7 06 84 0d 00 00 	mov	WORD PTR _stConfigHeader+22,0
;|***         else
; Line 423
	*** 00060e	e9 06 00 		jmp	$I2565
					$I2564:
;|***           stConfigHeader.bHeaderIsAvailable = TRUE;
; Line 424
	*** 000611	c7 06 84 0d 01 00 	mov	WORD PTR _stConfigHeader+22,1
					$I2565:
;|***         if ((ulFileError = DosWrite(hFile,(PVOID)&stConfigHeader,sizeof(CFGHEAD),&ulCount)) != 0)
; Line 425
	*** 000617	ff 36 ea 0d 		push	WORD PTR _hFile
	*** 00061b	1e 			push	ds
	*** 00061c	68 6e 0d 		push	OFFSET DGROUP:_stConfigHeader
	*** 00061f	6a 3e 			push	62
	*** 000621	8d 46 e2 		lea	ax,WORD PTR [bp-30]	;ulCount
	*** 000624	16 			push	ss
	*** 000625	50 			push	ax
	*** 000626	9a 00 00 00 00 		call	FAR PTR DOS16WRITE
	*** 00062b	89 46 e0 		mov	WORD PTR [bp-32],ax	;ulFileError
	*** 00062e	3d 00 00 		cmp	ax,0
	*** 000631	75 03 			jne	$JCC1585
	*** 000633	e9 24 00 		jmp	$I2566
					$JCC1585:
;|***           {
; Line 426
;|***           VioWrtTTY(chFailedWriteIni,StringLength(chFailedWriteIni),0);
; Line 427
	*** 000636	68 00 00 		push	SEG _chFailedWriteIni
	*** 000639	68 00 00 		push	OFFSET _chFailedWriteIni
	*** 00063c	68 00 00 		push	SEG _chFailedWriteIni
	*** 00063f	68 00 00 		push	OFFSET _chFailedWriteIni
	*** 000642	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 000647	83 c4 04 		add	sp,4
	*** 00064a	50 			push	ax
	*** 00064b	6a 00 			push	0
	*** 00064d	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***           ulFileError |= ERR_FILE_WRITE;
; Line 428
	*** 000652	81 4e e0 00 c0 		or	WORD PTR [bp-32],-16384	;ulFileError
;|***           goto gtEarlyOut;
; Line 429
	*** 000657	e9 03 09 		jmp	$gtEarlyOut2547
;|***           }
; Line 430
;|***         if ((_wMaxDeviceCount != 0) && !bBreakInitialization)
; Line 431
					$I2566:
_TEXT      ENDS
CONST      SEGMENT
$T20016	DW SEG __wMaxDeviceCount 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 00065a	8e 06 1e 00 		mov	es,WORD PTR $T20016
	*** 00065e	26 83 3e 00 00 00 	cmp	WORD PTR es:__wMaxDeviceCount,0
	*** 000664	75 03 			jne	$JCC1636
	*** 000666	e9 35 01 		jmp	$I2567
					$JCC1636:
	*** 000669	83 3e 14 0e 00 		cmp	WORD PTR _bBreakInitialization,0
	*** 00066e	74 03 			je	$JCC1646
	*** 000670	e9 2b 01 		jmp	$I2567
					$JCC1646:
;|***           {
; Line 432
;|***           DosChgFilePtr(hFile,(LONG)stConfigHeader.oFirstDCBheader,0,&ulFilePosition);
; Line 433
	*** 000673	ff 36 ea 0d 		push	WORD PTR _hFile
	*** 000677	6a 00 			push	0
	*** 000679	ff 36 8a 0d 		push	WORD PTR _stConfigHeader+28
	*** 00067d	6a 00 			push	0
	*** 00067f	8d 46 ee 		lea	ax,WORD PTR [bp-18]	;ulFilePosition
	*** 000682	16 			push	ss
	*** 000683	50 			push	ax
	*** 000684	9a 00 00 00 00 		call	FAR PTR DOS16CHGFILEPTR
;|***           for (wDCBindex = 0;wDCBindex < stConfigHeader.wDCBcount;wDCBindex++)
; Line 434
	*** 000689	c7 46 e6 00 00 		mov	WORD PTR [bp-26],0	;wDCBindex
	*** 00068e	e9 03 00 		jmp	$F2568
					$FC2569:
	*** 000691	ff 46 e6 		inc	WORD PTR [bp-26]	;wDCBindex
					$F2568:
	*** 000694	a1 70 0d 		mov	ax,WORD PTR _stConfigHeader+2
	*** 000697	39 46 e6 		cmp	WORD PTR [bp-26],ax	;wDCBindex
	*** 00069a	72 03 			jb	$JCC1690
	*** 00069c	e9 ff 00 		jmp	$FB2570
					$JCC1690:
;|***             {
; Line 435
;|***             lSaveDCBoffset = ulFilePosition;
; Line 436
	*** 00069f	8b 46 ee 		mov	ax,WORD PTR [bp-18]	;ulFilePosition
	*** 0006a2	8b 56 f0 		mov	dx,WORD PTR [bp-16]
	*** 0006a5	89 46 dc 		mov	WORD PTR [bp-36],ax	;lSaveDCBoffset
	*** 0006a8	89 56 de 		mov	WORD PTR [bp-34],dx
;|***             if ((ulFileError = DosRead(hFile,(PVOID)&stDCBheader,sizeof(DCBHEAD),&ulCount)) != 0)
; Line 437
	*** 0006ab	ff 36 ea 0d 		push	WORD PTR _hFile
	*** 0006af	1e 			push	ds
	*** 0006b0	68 ac 0d 		push	OFFSET DGROUP:_stDCBheader
	*** 0006b3	6a 3a 			push	58
	*** 0006b5	8d 46 e2 		lea	ax,WORD PTR [bp-30]	;ulCount
	*** 0006b8	16 			push	ss
	*** 0006b9	50 			push	ax
	*** 0006ba	9a 00 00 00 00 		call	FAR PTR DOS16READ
	*** 0006bf	89 46 e0 		mov	WORD PTR [bp-32],ax	;ulFileError
	*** 0006c2	3d 00 00 		cmp	ax,0
	*** 0006c5	75 03 			jne	$JCC1733
	*** 0006c7	e9 24 00 		jmp	$I2571
					$JCC1733:
;|***               {
; Line 438
;|***               VioWrtTTY(chFailedReadIni,StringLength(chFailedReadIni),0);
; Line 439
	*** 0006ca	68 00 00 		push	SEG _chFailedReadIni
	*** 0006cd	68 00 00 		push	OFFSET _chFailedReadIni
	*** 0006d0	68 00 00 		push	SEG _chFailedReadIni
	*** 0006d3	68 00 00 		push	OFFSET _chFailedReadIni
	*** 0006d6	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 0006db	83 c4 04 		add	sp,4
	*** 0006de	50 			push	ax
	*** 0006df	6a 00 			push	0
	*** 0006e1	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***               ulFileError |= ERR_FILE_READ;
; Line 440
	*** 0006e6	81 4e e0 00 a0 		or	WORD PTR [bp-32],-24576	;ulFileError
;|***               goto gtEarlyOut;
; Line 441
	*** 0006eb	e9 6f 08 		jmp	$gtEarlyOut2547
;|***               }
; Line 442
;|***             if (!bBreakInitialization)
; Line 443
					$I2571:
	*** 0006ee	83 3e 14 0e 00 		cmp	WORD PTR _bBreakInitialization,0
	*** 0006f3	74 03 			je	$JCC1779
	*** 0006f5	e9 2e 00 		jmp	$I2572
					$JCC1779:
;|***               {
; Line 444
;|***               if (stDCBheader.bHeaderIsInitialized)
; Line 445
	*** 0006f8	83 3e b4 0d 00 		cmp	WORD PTR _stDCBheader+8,0
	*** 0006fd	75 03 			jne	$JCC1789
	*** 0006ff	e9 21 00 		jmp	$I2573
					$JCC1789:
;|***                 if (++wDeviceCount == _wMaxDeviceCount)
; Line 446
	*** 000702	8e 06 1e 00 		mov	es,WORD PTR $T20016
	*** 000706	26 a1 00 00 		mov	ax,WORD PTR es:__wMaxDeviceCount
_TEXT      ENDS
CONST      SEGMENT
$T20017	DW SEG _wDeviceCount 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 00070a	8e 06 20 00 		mov	es,WORD PTR $T20017
	*** 00070e	26 ff 06 00 00 		inc	WORD PTR es:_wDeviceCount
	*** 000713	26 39 06 00 00 		cmp	WORD PTR es:_wDeviceCount,ax
	*** 000718	74 03 			je	$JCC1816
	*** 00071a	e9 06 00 		jmp	$I2574
					$JCC1816:
;|***                   bBreakInitialization = TRUE;
; Line 447
	*** 00071d	c7 06 14 0e 01 00 	mov	WORD PTR _bBreakInitialization,1
;|***               }
; Line 448
					$I2574:
					$I2573:
;|***             else
; Line 449
	*** 000723	e9 5f 00 		jmp	$I2575
					$I2572:
;|***               {
; Line 450
;|***               stDCBheader.bHeaderIsInitialized = FALSE;
; Line 451
	*** 000726	c7 06 b4 0d 00 00 	mov	WORD PTR _stDCBheader+8,0
;|***               DosChgFilePtr(hFile,lSaveDCBoffset,0,&ulFilePosition);
; Line 452
	*** 00072c	ff 36 ea 0d 		push	WORD PTR _hFile
	*** 000730	ff 76 de 		push	WORD PTR [bp-34]
	*** 000733	ff 76 dc 		push	WORD PTR [bp-36]	;lSaveDCBoffset
	*** 000736	6a 00 			push	0
	*** 000738	8d 46 ee 		lea	ax,WORD PTR [bp-18]	;ulFilePosition
	*** 00073b	16 			push	ss
	*** 00073c	50 			push	ax
	*** 00073d	9a 00 00 00 00 		call	FAR PTR DOS16CHGFILEPTR
;|***               if ((ulFileError = DosWrite(hFile,(PVOID)&stDCBheader,sizeof(DCBHEAD),&ulCount)) != 0)
; Line 453
	*** 000742	ff 36 ea 0d 		push	WORD PTR _hFile
	*** 000746	1e 			push	ds
	*** 000747	68 ac 0d 		push	OFFSET DGROUP:_stDCBheader
	*** 00074a	6a 3a 			push	58
	*** 00074c	8d 46 e2 		lea	ax,WORD PTR [bp-30]	;ulCount
	*** 00074f	16 			push	ss
	*** 000750	50 			push	ax
	*** 000751	9a 00 00 00 00 		call	FAR PTR DOS16WRITE
	*** 000756	89 46 e0 		mov	WORD PTR [bp-32],ax	;ulFileError
	*** 000759	3d 00 00 		cmp	ax,0
	*** 00075c	75 03 			jne	$JCC1884
	*** 00075e	e9 24 00 		jmp	$I2576
					$JCC1884:
;|***                 {
; Line 454
;|***                 VioWrtTTY(chFailedWriteIni,StringLength(chFailedWriteIni),0);
; Line 455
	*** 000761	68 00 00 		push	SEG _chFailedWriteIni
	*** 000764	68 00 00 		push	OFFSET _chFailedWriteIni
	*** 000767	68 00 00 		push	SEG _chFailedWriteIni
	*** 00076a	68 00 00 		push	OFFSET _chFailedWriteIni
	*** 00076d	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 000772	83 c4 04 		add	sp,4
	*** 000775	50 			push	ax
	*** 000776	6a 00 			push	0
	*** 000778	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***                 ulFileError |= ERR_FILE_WRITE;
; Line 456
	*** 00077d	81 4e e0 00 c0 		or	WORD PTR [bp-32],-16384	;ulFileError
;|***                 goto gtEarlyOut;
; Line 457
	*** 000782	e9 d8 07 		jmp	$gtEarlyOut2547
;|***                 }
; Line 458
;|***               }
; Line 459
					$I2576:
					$I2575:
;|***             DosChgFilePtr(hFile,(LONG)stDCBheader.oNextDCBheader,0,&ulFilePosition);
; Line 460
	*** 000785	ff 36 ea 0d 		push	WORD PTR _hFile
	*** 000789	6a 00 			push	0
	*** 00078b	ff 36 b6 0d 		push	WORD PTR _stDCBheader+10
	*** 00078f	6a 00 			push	0
	*** 000791	8d 46 ee 		lea	ax,WORD PTR [bp-18]	;ulFilePosition
	*** 000794	16 			push	ss
	*** 000795	50 			push	ax
	*** 000796	9a 00 00 00 00 		call	FAR PTR DOS16CHGFILEPTR
;|***             }
; Line 461
	*** 00079b	e9 f3 fe 		jmp	$FC2569
					$FB2570:
;|***           }
; Line 462
;|***         DosChgFilePtr(hFile,(LONG)stConfigHeader.oNextCFGheader,0,&ulFilePosition);
; Line 463
					$I2567:
	*** 00079e	ff 36 ea 0d 		push	WORD PTR _hFile
	*** 0007a2	6a 00 			push	0
	*** 0007a4	ff 36 88 0d 		push	WORD PTR _stConfigHeader+26
	*** 0007a8	6a 00 			push	0
	*** 0007aa	8d 46 ee 		lea	ax,WORD PTR [bp-18]	;ulFilePosition
	*** 0007ad	16 			push	ss
	*** 0007ae	50 			push	ax
	*** 0007af	9a 00 00 00 00 		call	FAR PTR DOS16CHGFILEPTR
;|***         lSaveOffset = stConfigHeader.oNextCFGheader;
; Line 464
	*** 0007b4	a1 88 0d 		mov	ax,WORD PTR _stConfigHeader+26
	*** 0007b7	89 46 fa 		mov	WORD PTR [bp-6],ax	;lSaveOffset
	*** 0007ba	c7 46 fc 00 00 		mov	WORD PTR [bp-4],0
;|***         }
; Line 465
	*** 0007bf	e9 3e fd 		jmp	$FC2553
					$FB2554:
;|***       }
; Line 466
;|*** #ifndef NO_RESOURCE_MGR
;|***     if (!bDisableRM)
; Line 468
					$I2550:
_TEXT      ENDS
CONST      SEGMENT
$T20018	DW SEG _bDisableRM 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 0007c2	8e 06 22 00 		mov	es,WORD PTR $T20018
	*** 0007c6	26 83 3e 00 00 00 	cmp	WORD PTR es:_bDisableRM,0
	*** 0007cc	74 03 			je	$JCC1996
	*** 0007ce	e9 12 00 		jmp	$I2577
					$JCC1996:
;|***       {
; Line 469
;|***       bPnPcapable = RMHELP_HasPNPCaps();
; Line 470
	*** 0007d1	9a 00 00 00 00 		call	FAR PTR _RMHELP_HasPNPCaps
_TEXT      ENDS
CONST      SEGMENT
$T20019	DW SEG _bPnPcapable 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 0007d6	8e 06 24 00 		mov	es,WORD PTR $T20019
	*** 0007da	26 a3 00 00 		mov	WORD PTR es:_bPnPcapable,ax
;|***       RMHELP_CreateDriver();
; Line 471
	*** 0007de	9a 00 00 00 00 		call	FAR PTR _RMHELP_CreateDriver
;|***       }
; Line 472
;|*** #endif
;|***     DosChgFilePtr(hFile,(LONG)stConfigInfo.oFirstCFGheader,0,&ulFilePosition);
; Line 474
					$I2577:
	*** 0007e3	ff 36 ea 0d 		push	WORD PTR _hFile
	*** 0007e7	6a 00 			push	0
	*** 0007e9	ff 36 4a 0d 		push	WORD PTR _stConfigInfo+8
	*** 0007ed	6a 00 			push	0
	*** 0007ef	8d 46 ee 		lea	ax,WORD PTR [bp-18]	;ulFilePosition
	*** 0007f2	16 			push	ss
	*** 0007f3	50 			push	ax
	*** 0007f4	9a 00 00 00 00 		call	FAR PTR DOS16CHGFILEPTR
;|***     for (wIndex = 0;wIndex < stConfigInfo.wCFGheaderCount;wIndex++)
; Line 475
	*** 0007f9	c7 46 d0 00 00 		mov	WORD PTR [bp-48],0	;wIndex
	*** 0007fe	e9 03 00 		jmp	$F2578
					$FC2579:
	*** 000801	ff 46 d0 		inc	WORD PTR [bp-48]	;wIndex
					$F2578:
	*** 000804	a1 48 0d 		mov	ax,WORD PTR _stConfigInfo+6
	*** 000807	39 46 d0 		cmp	WORD PTR [bp-48],ax	;wIndex
	*** 00080a	72 03 			jb	$JCC2058
	*** 00080c	e9 4e 07 		jmp	$FB2580
					$JCC2058:
;|***       {
; Line 476
;|***       if ((ulFileError = DosRead(hFile,(PVOID)&stConfigHeader,sizeof(CFGHEAD),&ulCount)) != 0)
; Line 477
	*** 00080f	ff 36 ea 0d 		push	WORD PTR _hFile
	*** 000813	1e 			push	ds
	*** 000814	68 6e 0d 		push	OFFSET DGROUP:_stConfigHeader
	*** 000817	6a 3e 			push	62
	*** 000819	8d 46 e2 		lea	ax,WORD PTR [bp-30]	;ulCount
	*** 00081c	16 			push	ss
	*** 00081d	50 			push	ax
	*** 00081e	9a 00 00 00 00 		call	FAR PTR DOS16READ
	*** 000823	89 46 e0 		mov	WORD PTR [bp-32],ax	;ulFileError
	*** 000826	3d 00 00 		cmp	ax,0
	*** 000829	75 03 			jne	$JCC2089
	*** 00082b	e9 24 00 		jmp	$I2581
					$JCC2089:
;|***         {
; Line 478
;|***         VioWrtTTY(chFailedReadIni,StringLength(chFailedReadIni),0);
; Line 479
	*** 00082e	68 00 00 		push	SEG _chFailedReadIni
	*** 000831	68 00 00 		push	OFFSET _chFailedReadIni
	*** 000834	68 00 00 		push	SEG _chFailedReadIni
	*** 000837	68 00 00 		push	OFFSET _chFailedReadIni
	*** 00083a	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 00083f	83 c4 04 		add	sp,4
	*** 000842	50 			push	ax
	*** 000843	6a 00 			push	0
	*** 000845	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***         ulFileError |= ERR_FILE_READ;
; Line 480
	*** 00084a	81 4e e0 00 a0 		or	WORD PTR [bp-32],-24576	;ulFileError
;|***         goto gtEarlyOut;
; Line 481
	*** 00084f	e9 0b 07 		jmp	$gtEarlyOut2547
;|***         }
; Line 482
;|***       if (stConfigHeader.bHeaderIsAvailable && (stConfigHeader.wDCBcount != 0))
; Line 483
					$I2581:
	*** 000852	83 3e 84 0d 00 		cmp	WORD PTR _stConfigHeader+22,0
	*** 000857	75 03 			jne	$JCC2135
	*** 000859	e9 e8 06 		jmp	$I2582
					$JCC2135:
	*** 00085c	83 3e 70 0d 00 		cmp	WORD PTR _stConfigHeader+2,0
	*** 000861	75 03 			jne	$JCC2145
	*** 000863	e9 de 06 		jmp	$I2582
					$JCC2145:
;|***         {
; Line 484
;|***         if (stConfigInfo.wCFGheaderCount > 1)
; Line 485
	*** 000866	83 3e 48 0d 01 		cmp	WORD PTR _stConfigInfo+6,1
	*** 00086b	77 03 			ja	$JCC2155
	*** 00086d	e9 2c 00 		jmp	$I2583
					$JCC2155:
;|***           {
; Line 486
;|***           iLen = sprintf(szMessage,0,"Load Number %u\r\n",(wIndex + 1));
; Line 487
	*** 000870	8b 46 d0 		mov	ax,WORD PTR [bp-48]	;wIndex
	*** 000873	40 			inc	ax
	*** 000874	50 			push	ax
	*** 000875	1e 			push	ds
	*** 000876	68 38 0e 		push	OFFSET DGROUP:$SG2584
	*** 000879	6a 00 			push	0
	*** 00087b	68 00 00 		push	SEG _szMessage
	*** 00087e	68 00 00 		push	OFFSET _szMessage
	*** 000881	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 000886	83 c4 0c 		add	sp,12
	*** 000889	89 46 e4 		mov	WORD PTR [bp-28],ax	;iLen
;|***           VioWrtTTY(szMessage,iLen,0);
; Line 488
	*** 00088c	68 00 00 		push	SEG _szMessage
	*** 00088f	68 00 00 		push	OFFSET _szMessage
	*** 000892	ff 76 e4 		push	WORD PTR [bp-28]	;iLen
	*** 000895	6a 00 			push	0
	*** 000897	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***           }
; Line 489
;|***         if ((wDelayCount = stConfigHeader.wDelayCount) != 0)
; Line 490
					$I2583:
	*** 00089c	a1 72 0d 		mov	ax,WORD PTR _stConfigHeader+4
_TEXT      ENDS
CONST      SEGMENT
$T20020	DW SEG _wDelayCount 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 00089f	8e 06 26 00 		mov	es,WORD PTR $T20020
	*** 0008a3	26 a3 00 00 		mov	WORD PTR es:_wDelayCount,ax
	*** 0008a7	3d 00 00 		cmp	ax,0
	*** 0008aa	75 03 			jne	$JCC2218
	*** 0008ac	e9 0b 00 		jmp	$I2585
					$JCC2218:
;|***           bWaitForCR = TRUE;
; Line 491
_TEXT      ENDS
CONST      SEGMENT
$T20021	DW SEG _bWaitForCR 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 0008af	8e 06 28 00 		mov	es,WORD PTR $T20021
	*** 0008b3	26 c7 06 00 00 01 00 	mov	WORD PTR es:_bWaitForCR,1
;|***         wLoadFlags = stConfigHeader.wLoadFlags;
; Line 492
					$I2585:
	*** 0008ba	a1 80 0d 		mov	ax,WORD PTR _stConfigHeader+18
_TEXT      ENDS
CONST      SEGMENT
$T20022	DW SEG _wLoadFlags 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 0008bd	8e 06 2a 00 		mov	es,WORD PTR $T20022
	*** 0008c1	26 a3 00 00 		mov	WORD PTR es:_wLoadFlags,ax
;|***         if (wLoadFlags & LOAD_FLAG1_VERBOSE)
; Line 493
	*** 0008c5	26 f6 06 01 00 40 	test	BYTE PTR es:_wLoadFlags+1,64
	*** 0008cb	75 03 			jne	$JCC2251
	*** 0008cd	e9 0b 00 		jmp	$I2586
					$JCC2251:
;|***           bVerbose = TRUE;
; Line 494
_TEXT      ENDS
CONST      SEGMENT
$T20023	DW SEG _bVerbose 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 0008d0	8e 06 2c 00 		mov	es,WORD PTR $T20023
	*** 0008d4	26 c7 06 00 00 01 00 	mov	WORD PTR es:_bVerbose,1
;|***         if (wLoadFlags & LOAD_FLAG1_PRINT_LOCAL)
; Line 495
					$I2586:
	*** 0008db	8e 06 2a 00 		mov	es,WORD PTR $T20022
	*** 0008df	26 f6 06 01 00 20 	test	BYTE PTR es:_wLoadFlags+1,32
	*** 0008e5	75 03 			jne	$JCC2277
	*** 0008e7	e9 0b 00 		jmp	$I2587
					$JCC2277:
;|***           bPrintLocation = TRUE;
; Line 496
_TEXT      ENDS
CONST      SEGMENT
$T20024	DW SEG _bPrintLocation 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 0008ea	8e 06 2e 00 		mov	es,WORD PTR $T20024
	*** 0008ee	26 c7 06 00 00 01 00 	mov	WORD PTR es:_bPrintLocation,1
;|***         bSeparateIDreg = TRUE;
; Line 497
					$I2587:
_TEXT      ENDS
CONST      SEGMENT
$T20025	DW SEG _bSeparateIDreg 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 0008f5	8e 06 30 00 		mov	es,WORD PTR $T20025
	*** 0008f9	26 c7 06 00 00 01 00 	mov	WORD PTR es:_bSeparateIDreg,1
;|***         if (stConfigHeader.byAdapterType != HDWTYPE_PCI)
; Line 498
	*** 000900	80 3e 78 0d 09 		cmp	BYTE PTR _stConfigHeader+10,9
	*** 000905	75 03 			jne	$JCC2309
	*** 000907	e9 55 00 		jmp	$I2588
					$JCC2309:
;|***           {
; Line 499
;|***           _wIntIDregister = stConfigHeader.wIntIDregister;
; Line 500
	*** 00090a	a1 82 0d 		mov	ax,WORD PTR _stConfigHeader+20
_TEXT      ENDS
CONST      SEGMENT
$T20026	DW SEG __wIntIDregister 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 00090d	8e 06 32 00 		mov	es,WORD PTR $T20026
	*** 000911	26 a3 00 00 		mov	WORD PTR es:__wIntIDregister,ax
;|***           /*
;|***           ** if device is DigiBoard (<=8 port) and interrupt level is even then
;|***           ** increment ID register address
;|***           */
;|***           if (wLoadFlags & LOAD_FLAG1_DIGIBOARD08_INT_ID)
; Line 505
	*** 000915	8e 06 2a 00 		mov	es,WORD PTR $T20022
	*** 000919	26 f6 06 00 00 02 	test	BYTE PTR es:_wLoadFlags,2
	*** 00091f	75 03 			jne	$JCC2335
	*** 000921	e9 13 00 		jmp	$I2589
					$JCC2335:
;|***             if ((stConfigHeader.byInterruptLevel & 0x01) == 0)
; Line 506
	*** 000924	f6 06 79 0d 01 		test	BYTE PTR _stConfigHeader+11,1
	*** 000929	74 03 			je	$JCC2345
	*** 00092b	e9 09 00 		jmp	$I2590
					$JCC2345:
;|***               _wIntIDregister++;
; Line 507
	*** 00092e	8e 06 32 00 		mov	es,WORD PTR $T20026
	*** 000932	26 ff 06 00 00 		inc	WORD PTR es:__wIntIDregister
;|***           if (_wIntIDregister != 0)
; Line 508
					$I2590:
					$I2589:
	*** 000937	8e 06 32 00 		mov	es,WORD PTR $T20026
	*** 00093b	26 83 3e 00 00 00 	cmp	WORD PTR es:__wIntIDregister,0
	*** 000941	75 03 			jne	$JCC2369
	*** 000943	e9 16 00 		jmp	$I2591
					$JCC2369:
;|***             {
; Line 509
;|***             _wOEMjumpEntry = stConfigHeader.wOEMentryVector;
; Line 510
	*** 000946	a1 7a 0d 		mov	ax,WORD PTR _stConfigHeader+12
_TEXT      ENDS
CONST      SEGMENT
$T20027	DW SEG __wOEMjumpEntry 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 000949	8e 06 34 00 		mov	es,WORD PTR $T20027
	*** 00094d	26 a3 00 00 		mov	WORD PTR es:__wOEMjumpEntry,ax
;|***             _wOEMjumpExit = stConfigHeader.wOEMexitVector;
; Line 511
	*** 000951	a1 7c 0d 		mov	ax,WORD PTR _stConfigHeader+14
_TEXT      ENDS
CONST      SEGMENT
$T20028	DW SEG __wOEMjumpExit 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 000954	8e 06 36 00 		mov	es,WORD PTR $T20028
	*** 000958	26 a3 00 00 		mov	WORD PTR es:__wOEMjumpExit,ax
;|***             }
; Line 512
;|***           }
; Line 513
					$I2591:
;|***         else
; Line 514
	*** 00095c	e9 50 01 		jmp	$I2592
					$I2588:
;|***           {
; Line 515
;	bForceInterrupt = -64
;|*** #ifndef NO_PCI
;|***           BOOL bForceInterrupt = FALSE;
; Line 517
	*** 00095f	c7 46 c0 00 00 		mov	WORD PTR [bp-64],0	;awIndexList
;|***           
;|***           if ((wPCIerror = LoadPCIAdapter(wIndex,&stConfigHeader.byInterruptLevel,awPorts)) != NO_ERROR)
; Line 519
	*** 000964	1e 			push	ds
	*** 000965	68 16 0e 		push	OFFSET DGROUP:_awPorts
	*** 000968	1e 			push	ds
	*** 000969	68 79 0d 		push	OFFSET DGROUP:_stConfigHeader+11
	*** 00096c	ff 76 d0 		push	WORD PTR [bp-48]	;wIndex
	*** 00096f	9a 00 00 00 00 		call	FAR PTR _LoadPCIAdapter
	*** 000974	83 c4 0a 		add	sp,10
	*** 000977	89 46 d6 		mov	WORD PTR [bp-42],ax	;wPCIerror
	*** 00097a	3d 00 00 		cmp	ax,0
	*** 00097d	75 03 			jne	$JCC2429
	*** 00097f	e9 75 00 		jmp	$I2595
					$JCC2429:
;|***             {
; Line 520
;|***             if (wPCIerror == 0xfffe)
; Line 521
	*** 000982	83 7e d6 fe 		cmp	WORD PTR [bp-42],-2	;wPCIerror
	*** 000986	74 03 			je	$JCC2438
	*** 000988	e9 1f 00 		jmp	$I2596
					$JCC2438:
;|***               VioWrtTTY(chPCIBadIRQ,StringLength(chPCIBadIRQ),0);
; Line 522
	*** 00098b	68 00 00 		push	SEG _chPCIBadIRQ
	*** 00098e	68 00 00 		push	OFFSET _chPCIBadIRQ
	*** 000991	68 00 00 		push	SEG _chPCIBadIRQ
	*** 000994	68 00 00 		push	OFFSET _chPCIBadIRQ
	*** 000997	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 00099c	83 c4 04 		add	sp,4
	*** 00099f	50 			push	ax
	*** 0009a0	6a 00 			push	0
	*** 0009a2	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***             else
; Line 523
	*** 0009a7	e9 44 00 		jmp	$I2597
					$I2596:
;|***               if (wPCIerror == 0xfffd)
; Line 524
	*** 0009aa	83 7e d6 fd 		cmp	WORD PTR [bp-42],-3	;wPCIerror
	*** 0009ae	74 03 			je	$JCC2478
	*** 0009b0	e9 1f 00 		jmp	$I2598
					$JCC2478:
;|***                 VioWrtTTY(chTooManyPCIadapters,StringLength(chTooManyPCIadapters),0);
; Line 525
	*** 0009b3	68 00 00 		push	SEG _chTooManyPCIadapters
	*** 0009b6	68 00 00 		push	OFFSET _chTooManyPCIadapters
	*** 0009b9	68 00 00 		push	SEG _chTooManyPCIadapters
	*** 0009bc	68 00 00 		push	OFFSET _chTooManyPCIadapters
	*** 0009bf	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 0009c4	83 c4 04 		add	sp,4
	*** 0009c7	50 			push	ax
	*** 0009c8	6a 00 			push	0
	*** 0009ca	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***               else
; Line 526
	*** 0009cf	e9 1c 00 		jmp	$I2599
					$I2598:
;|***                 VioWrtTTY(chPCIMissing,StringLength(chPCIMissing),0);
; Line 527
	*** 0009d2	68 00 00 		push	SEG _chPCIMissing
	*** 0009d5	68 00 00 		push	OFFSET _chPCIMissing
	*** 0009d8	68 00 00 		push	SEG _chPCIMissing
	*** 0009db	68 00 00 		push	OFFSET _chPCIMissing
	*** 0009de	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 0009e3	83 c4 04 		add	sp,4
	*** 0009e6	50 			push	ax
	*** 0009e7	6a 00 			push	0
	*** 0009e9	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
					$I2599:
					$I2597:
;|***             bPrevErrorMsg = TRUE;
; Line 528
	*** 0009ee	c7 06 e6 0d 01 00 	mov	WORD PTR _bPrevErrorMsg,1
;|***             goto gtEarlyOut;
; Line 529
	*** 0009f4	e9 66 05 		jmp	$gtEarlyOut2547
;|***             }
; Line 530
;|***           bPCIadapter = TRUE;
; Line 531
					$I2595:
	*** 0009f7	c7 46 d2 01 00 		mov	WORD PTR [bp-46],1	;bPCIadapter
;|***           _wBusType = BUSTYPE_PCI;
; Line 532
_TEXT      ENDS
CONST      SEGMENT
$T20029	DW SEG __wBusType 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 0009fc	8e 06 38 00 		mov	es,WORD PTR $T20029
	*** 000a00	26 c7 06 00 00 05 00 	mov	WORD PTR es:__wBusType,5
;|***           byNextPCIslot++;
; Line 533
	*** 000a07	8e 06 16 00 		mov	es,WORD PTR $T20012
	*** 000a0b	26 fe 06 00 00 		inc	BYTE PTR es:_byNextPCIslot
;|***           stConfigHeader.byPCIslot = byNextPCIslot;
; Line 534
	*** 000a10	26 a0 00 00 		mov	al,BYTE PTR es:_byNextPCIslot
	*** 000a14	a2 90 0d 		mov	BYTE PTR _stConfigHeader+34,al
;|***           stConfigHeader.wPCIvendor = stPCIadapterTable[wIndex].usVendorID;
; Line 535
	*** 000a17	8e 06 0e 00 		mov	es,WORD PTR $T20007
	*** 000a1b	6b 5e d0 18 		imul	bx,WORD PTR [bp-48],24	;wIndex
	*** 000a1f	26 8b 87 04 00 		mov	ax,WORD PTR es:_stPCIadapterTable[bx+4]
	*** 000a24	a3 8c 0d 		mov	WORD PTR _stConfigHeader+30,ax
;|***           _wPCIvendor = stConfigHeader.wPCIvendor;
; Line 536
	*** 000a27	a1 8c 0d 		mov	ax,WORD PTR _stConfigHeader+30
_TEXT      ENDS
CONST      SEGMENT
$T20030	DW SEG __wPCIvendor 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 000a2a	8e 06 3a 00 		mov	es,WORD PTR $T20030
	*** 000a2e	26 a3 00 00 		mov	WORD PTR es:__wPCIvendor,ax
;|***           stConfigHeader.wPCIdevice = stPCIadapterTable[wIndex].usDeviceID;
; Line 537
	*** 000a32	8e 06 0e 00 		mov	es,WORD PTR $T20007
	*** 000a36	6b 5e d0 18 		imul	bx,WORD PTR [bp-48],24	;wIndex
	*** 000a3a	26 8b 87 06 00 		mov	ax,WORD PTR es:_stPCIadapterTable[bx+6]
	*** 000a3f	a3 8e 0d 		mov	WORD PTR _stConfigHeader+32,ax
;|***           _wPCIdevice = stConfigHeader.wPCIdevice;
; Line 538
	*** 000a42	a1 8e 0d 		mov	ax,WORD PTR _stConfigHeader+32
_TEXT      ENDS
CONST      SEGMENT
$T20031	DW SEG __wPCIdevice 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 000a45	8e 06 3c 00 		mov	es,WORD PTR $T20031
	*** 000a49	26 a3 00 00 		mov	WORD PTR es:__wPCIdevice,ax
;|***           stConfigInfo.byNextPCIslot = byNextPCIslot;
; Line 539
	*** 000a4d	8e 06 16 00 		mov	es,WORD PTR $T20012
	*** 000a51	26 a0 00 00 		mov	al,BYTE PTR es:_byNextPCIslot
	*** 000a55	a2 4e 0d 		mov	BYTE PTR _stConfigInfo+12,al
;|***           DosChgFilePtr(hFile,0,0,&ulHeaderDummy);
; Line 540
	*** 000a58	ff 36 ea 0d 		push	WORD PTR _hFile
	*** 000a5c	6a 00 			push	0
	*** 000a5e	6a 00 			push	0
	*** 000a60	6a 00 			push	0
	*** 000a62	8d 46 f2 		lea	ax,WORD PTR [bp-14]	;ulHeaderDummy
	*** 000a65	16 			push	ss
	*** 000a66	50 			push	ax
	*** 000a67	9a 00 00 00 00 		call	FAR PTR DOS16CHGFILEPTR
;|***           if ((ulFileError = DosWrite(hFile,(PVOID)&stConfigInfo,sizeof(CFGINFO),&ulCount)) != 0)
; Line 541
	*** 000a6c	ff 36 ea 0d 		push	WORD PTR _hFile
	*** 000a70	1e 			push	ds
	*** 000a71	68 42 0d 		push	OFFSET DGROUP:_stConfigInfo
	*** 000a74	6a 2c 			push	44
	*** 000a76	8d 46 e2 		lea	ax,WORD PTR [bp-30]	;ulCount
	*** 000a79	16 			push	ss
	*** 000a7a	50 			push	ax
	*** 000a7b	9a 00 00 00 00 		call	FAR PTR DOS16WRITE
	*** 000a80	89 46 e0 		mov	WORD PTR [bp-32],ax	;ulFileError
	*** 000a83	3d 00 00 		cmp	ax,0
	*** 000a86	75 03 			jne	$JCC2694
	*** 000a88	e9 24 00 		jmp	$I2600
					$JCC2694:
;|***             {
; Line 542
;|***             VioWrtTTY(chFailedWriteIni,StringLength(chFailedWriteIni),0);
; Line 543
	*** 000a8b	68 00 00 		push	SEG _chFailedWriteIni
	*** 000a8e	68 00 00 		push	OFFSET _chFailedWriteIni
	*** 000a91	68 00 00 		push	SEG _chFailedWriteIni
	*** 000a94	68 00 00 		push	OFFSET _chFailedWriteIni
	*** 000a97	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 000a9c	83 c4 04 		add	sp,4
	*** 000a9f	50 			push	ax
	*** 000aa0	6a 00 			push	0
	*** 000aa2	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***             ulFileError |= ERR_FILE_WRITE;
; Line 544
	*** 000aa7	81 4e e0 00 c0 		or	WORD PTR [bp-32],-16384	;ulFileError
;|***             goto gtEarlyOut;
; Line 545
	*** 000aac	e9 ae 04 		jmp	$gtEarlyOut2547
;|***             }
; Line 546
;|*** #else
;|***           // PCI not allowed in this version
;|***           VioWrtTTY(chPCInotSupported,StringLength(chPCInotSupported),0);
;|***           bPrevErrorMsg = TRUE;
;|***           goto gtEarlyOut;
;|*** #endif
;|***           }
; Line 553
					$I2600:
					$I2592:
;|***         stConfigHeader.bHeaderIsAvailable = FALSE;
; Line 554
	*** 000aaf	c7 06 84 0d 00 00 	mov	WORD PTR _stConfigHeader+22,0
;|***         DosChgFilePtr(hFile,ulFilePosition,0,&ulFilePosition);
; Line 555
	*** 000ab5	ff 36 ea 0d 		push	WORD PTR _hFile
	*** 000ab9	ff 76 f0 		push	WORD PTR [bp-16]
	*** 000abc	ff 76 ee 		push	WORD PTR [bp-18]	;ulFilePosition
	*** 000abf	6a 00 			push	0
	*** 000ac1	8d 46 ee 		lea	ax,WORD PTR [bp-18]	;ulFilePosition
	*** 000ac4	16 			push	ss
	*** 000ac5	50 			push	ax
	*** 000ac6	9a 00 00 00 00 		call	FAR PTR DOS16CHGFILEPTR
;|***         if ((ulFileError = DosWrite(hFile,(PVOID)&stConfigHeader,sizeof(CFGHEAD),&ulCount)) != 0)
; Line 556
	*** 000acb	ff 36 ea 0d 		push	WORD PTR _hFile
	*** 000acf	1e 			push	ds
	*** 000ad0	68 6e 0d 		push	OFFSET DGROUP:_stConfigHeader
	*** 000ad3	6a 3e 			push	62
	*** 000ad5	8d 46 e2 		lea	ax,WORD PTR [bp-30]	;ulCount
	*** 000ad8	16 			push	ss
	*** 000ad9	50 			push	ax
	*** 000ada	9a 00 00 00 00 		call	FAR PTR DOS16WRITE
	*** 000adf	89 46 e0 		mov	WORD PTR [bp-32],ax	;ulFileError
	*** 000ae2	3d 00 00 		cmp	ax,0
	*** 000ae5	75 03 			jne	$JCC2789
	*** 000ae7	e9 24 00 		jmp	$I2601
					$JCC2789:
;|***           {
; Line 557
;|***           VioWrtTTY(chFailedWriteIni,StringLength(chFailedWriteIni),0);
; Line 558
	*** 000aea	68 00 00 		push	SEG _chFailedWriteIni
	*** 000aed	68 00 00 		push	OFFSET _chFailedWriteIni
	*** 000af0	68 00 00 		push	SEG _chFailedWriteIni
	*** 000af3	68 00 00 		push	OFFSET _chFailedWriteIni
	*** 000af6	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 000afb	83 c4 04 		add	sp,4
	*** 000afe	50 			push	ax
	*** 000aff	6a 00 			push	0
	*** 000b01	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***           ulFileError |= ERR_FILE_WRITE;
; Line 559
	*** 000b06	81 4e e0 00 c0 		or	WORD PTR [bp-32],-16384	;ulFileError
;|***           goto gtEarlyOut;
; Line 560
	*** 000b0b	e9 4f 04 		jmp	$gtEarlyOut2547
;|***           }
; Line 561
;|***         DosChgFilePtr(hFile,(LONG)stConfigHeader.oFirstDCBheader,0,&ulFilePosition);
; Line 562
					$I2601:
	*** 000b0e	ff 36 ea 0d 		push	WORD PTR _hFile
	*** 000b12	6a 00 			push	0
	*** 000b14	ff 36 8a 0d 		push	WORD PTR _stConfigHeader+28
	*** 000b18	6a 00 			push	0
	*** 000b1a	8d 46 ee 		lea	ax,WORD PTR [bp-18]	;ulFilePosition
	*** 000b1d	16 			push	ss
	*** 000b1e	50 			push	ax
	*** 000b1f	9a 00 00 00 00 		call	FAR PTR DOS16CHGFILEPTR
;|***         if (stConfigHeader.wDCBcount > MAX_DEVICE)
; Line 563
	*** 000b24	83 3e 70 0d 08 		cmp	WORD PTR _stConfigHeader+2,8
	*** 000b29	77 03 			ja	$JCC2857
	*** 000b2b	e9 06 00 		jmp	$I2602
					$JCC2857:
;|***           stConfigHeader.wDCBcount = MAX_DEVICE;
; Line 564
	*** 000b2e	c7 06 70 0d 08 00 	mov	WORD PTR _stConfigHeader+2,8
;|***         pDeviceParms = (DEVDEF _far *)_stDeviceParms;
; Line 565
					$I2602:
	*** 000b34	c7 06 ec 0d 00 00 	mov	WORD PTR _pDeviceParms,OFFSET __stDeviceParms
	*** 000b3a	c7 06 ee 0d 00 00 	mov	WORD PTR _pDeviceParms+2,SEG __stDeviceParms
;|*** #ifndef NO_COMscope
;|***         wCOMscopeStrategy = (WORD)&_pCOMscopeStrategy;
;|*** #endif
;|***         wDeviceStrategy = (WORD)&_pDeviceStrategy;
; Line 569
	*** 000b40	c7 06 f8 0d 00 00 	mov	WORD PTR _wDeviceStrategy,OFFSET __pDeviceStrategy
;|***         pPrevious = NULL;
; Line 570
	*** 000b46	2b c0 			sub	ax,ax
	*** 000b48	a3 f6 0d 		mov	WORD PTR _pPrevious+2,ax
	*** 000b4b	a3 f4 0d 		mov	WORD PTR _pPrevious,ax
;|*** //        wEndOfData = ((WORD)DeviceParms + (stConfigHeader.wDCBcount * sizeof(DEVDEF)));
;|***         for (wDCBindex = 0;wDCBindex < stConfigHeader.wDCBcount;wDCBindex++)
; Line 572
	*** 000b4e	c7 46 e6 00 00 		mov	WORD PTR [bp-26],0	;wDCBindex
	*** 000b53	e9 03 00 		jmp	$F2603
					$FC2604:
	*** 000b56	ff 46 e6 		inc	WORD PTR [bp-26]	;wDCBindex
					$F2603:
	*** 000b59	a1 70 0d 		mov	ax,WORD PTR _stConfigHeader+2
	*** 000b5c	39 46 e6 		cmp	WORD PTR [bp-26],ax	;wDCBindex
	*** 000b5f	72 03 			jb	$JCC2911
	*** 000b61	e9 c4 02 		jmp	$FB2605
					$JCC2911:
;|***           {
; Line 573
;|***           if ((ulFileError = DosRead(hFile,(PVOID)&stDCBheader,sizeof(DCBHEAD),&ulCount)) != 0)
; Line 574
	*** 000b64	ff 36 ea 0d 		push	WORD PTR _hFile
	*** 000b68	1e 			push	ds
	*** 000b69	68 ac 0d 		push	OFFSET DGROUP:_stDCBheader
	*** 000b6c	6a 3a 			push	58
	*** 000b6e	8d 46 e2 		lea	ax,WORD PTR [bp-30]	;ulCount
	*** 000b71	16 			push	ss
	*** 000b72	50 			push	ax
	*** 000b73	9a 00 00 00 00 		call	FAR PTR DOS16READ
	*** 000b78	89 46 e0 		mov	WORD PTR [bp-32],ax	;ulFileError
	*** 000b7b	3d 00 00 		cmp	ax,0
	*** 000b7e	75 03 			jne	$JCC2942
	*** 000b80	e9 24 00 		jmp	$I2606
					$JCC2942:
;|***             {
; Line 575
;|***             VioWrtTTY(chFailedReadIni,StringLength(chFailedReadIni),0);
; Line 576
	*** 000b83	68 00 00 		push	SEG _chFailedReadIni
	*** 000b86	68 00 00 		push	OFFSET _chFailedReadIni
	*** 000b89	68 00 00 		push	SEG _chFailedReadIni
	*** 000b8c	68 00 00 		push	OFFSET _chFailedReadIni
	*** 000b8f	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 000b94	83 c4 04 		add	sp,4
	*** 000b97	50 			push	ax
	*** 000b98	6a 00 			push	0
	*** 000b9a	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***             ulFileError |= ERR_FILE_READ;
; Line 577
	*** 000b9f	81 4e e0 00 a0 		or	WORD PTR [bp-32],-24576	;ulFileError
;|***             goto gtEarlyOut;
; Line 578
	*** 000ba4	e9 b6 03 		jmp	$gtEarlyOut2547
;|***             }
; Line 579
;|***           if (stDCBheader.bHeaderIsInitialized)
; Line 580
					$I2606:
	*** 000ba7	83 3e b4 0d 00 		cmp	WORD PTR _stDCBheader+8,0
	*** 000bac	75 03 			jne	$JCC2988
	*** 000bae	e9 fc 01 		jmp	$I2607
					$JCC2988:
;|***             {
; Line 581
;|***             /*
;|***             ** if global IRQ is defined then make device IRQ equal to
;|***             ** global IRQ
;|***             */
;|***             if (stConfigHeader.byInterruptLevel != 0)
; Line 586
	*** 000bb1	80 3e 79 0d 00 		cmp	BYTE PTR _stConfigHeader+11,0
	*** 000bb6	75 03 			jne	$JCC2998
	*** 000bb8	e9 06 00 		jmp	$I2608
					$JCC2998:
;|***               stDCBheader.stComDCB.byInterruptLevel = stConfigHeader.byInterruptLevel;
; Line 587
	*** 000bbb	a0 79 0d 		mov	al,BYTE PTR _stConfigHeader+11
	*** 000bbe	a2 dc 0d 		mov	BYTE PTR _stDCBheader+48,al
;|*** 
;|***             if (bPCIadapter)
; Line 589
					$I2608:
	*** 000bc1	83 7e d2 00 		cmp	WORD PTR [bp-46],0	;bPCIadapter
	*** 000bc5	75 03 			jne	$JCC3013
	*** 000bc7	e9 0f 00 		jmp	$I2609
					$JCC3013:
;|***               stDCBheader.stComDCB.wIObaseAddress = awPorts[wDCBindex];
; Line 590
	*** 000bca	8b 5e e6 		mov	bx,WORD PTR [bp-26]	;wDCBindex
	*** 000bcd	d1 e3 			shl	bx,1
	*** 000bcf	8b 87 16 0e 		mov	ax,WORD PTR _awPorts[bx]
	*** 000bd3	a3 c2 0d 		mov	WORD PTR _stDCBheader+22,ax
;|***             else
; Line 591
	*** 000bd6	e9 0f 00 		jmp	$I2610
					$I2609:
;|***               {
; Line 592
;|***               /*
;|***               **  Transfer load flag interrupt status/ID bits to device flags
;|***               */
;|***               stDCBheader.stComDCB.wConfigFlags1 |= (wLoadFlags & LOAD_FLAG1_INT_ID_LOAD_MASK);
; Line 596
	*** 000bd9	8e 06 2a 00 		mov	es,WORD PTR $T20022
	*** 000bdd	26 a1 00 00 		mov	ax,WORD PTR es:_wLoadFlags
	*** 000be1	25 0f 80 		and	ax,-32753
	*** 000be4	09 06 bc 0d 		or	WORD PTR _stDCBheader+16,ax
;|***               }
; Line 597
					$I2610:
;|*** #ifndef NO_RESOURCE_MGR
;|***             if (!bDisableRM)
; Line 599
	*** 000be8	8e 06 22 00 		mov	es,WORD PTR $T20018
	*** 000bec	26 83 3e 00 00 00 	cmp	WORD PTR es:_bDisableRM,0
	*** 000bf2	74 03 			je	$JCC3058
	*** 000bf4	e9 69 00 		jmp	$I2611
					$JCC3058:
;|***               {
; Line 600
;|***               /*
;|***               ** Test if interrupt status register is inside UART address space
;|***               */
;|***               if ((_wIntIDregister == 0) ||
;|***                   (_wIntIDregister >= stDCBheader.stComDCB.wIObaseAddress) &&
;|***                   (_wIntIDregister <= (stDCBheader.stComDCB.wIObaseAddress + 7)))
; Line 606
	*** 000bf7	8e 06 32 00 		mov	es,WORD PTR $T20026
	*** 000bfb	26 83 3e 00 00 00 	cmp	WORD PTR es:__wIntIDregister,0
	*** 000c01	75 03 			jne	$JCC3073
	*** 000c03	e9 1d 00 		jmp	$I2613
					$JCC3073:
	*** 000c06	a1 c2 0d 		mov	ax,WORD PTR _stDCBheader+22
	*** 000c09	26 39 06 00 00 		cmp	WORD PTR es:__wIntIDregister,ax
	*** 000c0e	73 03 			jae	$JCC3086
	*** 000c10	e9 1b 00 		jmp	$I2612
					$JCC3086:
	*** 000c13	a1 c2 0d 		mov	ax,WORD PTR _stDCBheader+22
	*** 000c16	05 07 00 		add	ax,7
	*** 000c19	26 39 06 00 00 		cmp	WORD PTR es:__wIntIDregister,ax
	*** 000c1e	76 03 			jbe	$JCC3102
	*** 000c20	e9 0b 00 		jmp	$I2612
					$JCC3102:
					$I2613:
;|***                   bSeparateIDreg = FALSE;
; Line 607
	*** 000c23	8e 06 30 00 		mov	es,WORD PTR $T20025
	*** 000c27	26 c7 06 00 00 00 00 	mov	WORD PTR es:_bSeparateIDreg,0
;|*** //  _asm int 3
;|***               if ((rc = RMHELP_GetPorts(&stDCBheader,wLoadCount)) != 0)
; Line 609
					$I2612:
	*** 000c2e	8e 06 06 00 		mov	es,WORD PTR $T20003
	*** 000c32	26 ff 36 00 00 		push	WORD PTR es:_wLoadCount
	*** 000c37	1e 			push	ds
	*** 000c38	68 ac 0d 		push	OFFSET DGROUP:_stDCBheader
	*** 000c3b	9a 00 00 00 00 		call	FAR PTR _RMHELP_GetPorts
	*** 000c40	83 c4 06 		add	sp,6
	*** 000c43	89 46 f6 		mov	WORD PTR [bp-10],ax	;rc
	*** 000c46	3d 00 00 		cmp	ax,0
	*** 000c49	75 03 			jne	$JCC3145
	*** 000c4b	e9 12 00 		jmp	$I2614
					$JCC3145:
;|***                 {
; Line 610
;|***                 if (rc != 0xffff)
; Line 611
	*** 000c4e	83 7e f6 ff 		cmp	WORD PTR [bp-10],-1	;rc
	*** 000c52	75 03 			jne	$JCC3154
	*** 000c54	e9 09 00 		jmp	$I2615
					$JCC3154:
;|***                   {
; Line 612
;|***                   bPrevErrorMsg = TRUE;
; Line 613
	*** 000c57	c7 06 e6 0d 01 00 	mov	WORD PTR _bPrevErrorMsg,1
;|***                   goto gtNextDCBheader;
; Line 614
	*** 000c5d	e9 4d 01 		jmp	$gtNextDCBheader2616
;|***                   }
; Line 615
;|***                 }
; Line 616
					$I2615:
;|***               }
; Line 617
					$I2614:
;|*** #endif
;|***             /*
;|***             ** if starting header address is not defined then define it
;|***             ** and set dummy header to point to it
;|***             */
;|***             if (pStart == NULL)
; Line 623
					$I2611:
	*** 000c60	a1 f2 0d 		mov	ax,WORD PTR _pStart+2
	*** 000c63	0b 06 f0 0d 		or	ax,WORD PTR _pStart
	*** 000c67	74 03 			je	$JCC3175
	*** 000c69	e9 11 00 		jmp	$I2617
					$JCC3175:
;|***               pStart = &pDeviceParms->stDeviceHeader;
; Line 624
	*** 000c6c	a1 ec 0d 		mov	ax,WORD PTR _pDeviceParms
	*** 000c6f	8b 16 ee 0d 		mov	dx,WORD PTR _pDeviceParms+2
	*** 000c73	05 a4 00 		add	ax,164
	*** 000c76	a3 f0 0d 		mov	WORD PTR _pStart,ax
	*** 000c79	89 16 f2 0d 		mov	WORD PTR _pStart+2,dx
;|***             /*
;|***             ** Initialized device headers
;|***             */
;|***             MemCopy((BYTE _far *)&pDeviceParms->stDeviceHeader.abyDeviceName,(BYTE *)(stDCBheader.abyPortName),8);
; Line 628
					$I2617:
	*** 000c7d	6a 08 			push	8
	*** 000c7f	1e 			push	ds
	*** 000c80	68 ac 0d 		push	OFFSET DGROUP:_stDCBheader
	*** 000c83	a1 ec 0d 		mov	ax,WORD PTR _pDeviceParms
	*** 000c86	8b 16 ee 0d 		mov	dx,WORD PTR _pDeviceParms+2
	*** 000c8a	05 ae 00 		add	ax,174
	*** 000c8d	52 			push	dx
	*** 000c8e	50 			push	ax
	*** 000c8f	9a 00 00 00 00 		call	FAR PTR _MemCopy
	*** 000c94	83 c4 0a 		add	sp,10
;|***             pDeviceParms->stDeviceHeader.StrategyOffset = wDeviceStrategy;
; Line 629
	*** 000c97	a1 f8 0d 		mov	ax,WORD PTR _wDeviceStrategy
	*** 000c9a	c4 1e ec 0d 		les	bx,DWORD PTR _pDeviceParms
	*** 000c9e	26 89 87 aa 00 		mov	WORD PTR es:[bx+170],ax
;|***             abyCOMnumbers[wLoadCount] = (BYTE)atoi(&stDCBheader.abyPortName[3]);
; Line 630
	*** 000ca3	1e 			push	ds
	*** 000ca4	68 af 0d 		push	OFFSET DGROUP:_stDCBheader+3
	*** 000ca7	9a 00 00 00 00 		call	FAR PTR _atoi
	*** 000cac	83 c4 04 		add	sp,4
	*** 000caf	8e 06 06 00 		mov	es,WORD PTR $T20003
	*** 000cb3	26 8b 1e 00 00 		mov	bx,WORD PTR es:_wLoadCount
_TEXT      ENDS
CONST      SEGMENT
$T20032	DW SEG _abyCOMnumbers 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 000cb8	8e 06 3e 00 		mov	es,WORD PTR $T20032
	*** 000cbc	26 88 87 00 00 		mov	BYTE PTR es:_abyCOMnumbers[bx],al
;|***             if (pPrevious != NULL)
; Line 631
	*** 000cc1	a1 f6 0d 		mov	ax,WORD PTR _pPrevious+2
	*** 000cc4	0b 06 f4 0d 		or	ax,WORD PTR _pPrevious
	*** 000cc8	75 03 			jne	$JCC3272
	*** 000cca	e9 15 00 		jmp	$I2619
					$JCC3272:
;|***               pPrevious->pNextHeader = &pDeviceParms->stDeviceHeader;
; Line 632
	*** 000ccd	a1 ec 0d 		mov	ax,WORD PTR _pDeviceParms
	*** 000cd0	8b 16 ee 0d 		mov	dx,WORD PTR _pDeviceParms+2
	*** 000cd4	05 a4 00 		add	ax,164
	*** 000cd7	c4 1e f4 0d 		les	bx,DWORD PTR _pPrevious
	*** 000cdb	26 89 07 		mov	WORD PTR es:[bx],ax
	*** 000cde	26 89 57 02 		mov	WORD PTR es:[bx+2],dx
;|*** #ifndef NO_COMscope
;|***             if (stDCBheader.stComDCB.wConfigFlags1 & CFG_FLAG1_COMSCOPE)
;|***               {
;|***               if (stDCBheader.stComDCB.wCOMscopeBuffLen != 0)
;|***                 ulRequiredBufferSpace += stDCBheader.stComDCB.wCOMscopeBuffLen;
;|***               else
;|***                 ulRequiredBufferSpace += DEF_COMscope_BUFF_LEN;
;|***               MemCopy((BYTE _far *)&pDeviceParms->stCOMscopeHeader.abyDeviceName,(BYTE *)(stDCBheader.abyPortName),8);
;|***               pDeviceParms->stCOMscopeHeader.StrategyOffset = wCOMscopeStrategy;
;|***               MakeCOMscopeName(pDeviceParms->stCOMscopeHeader.abyDeviceName);
;|***               pDeviceParms->stDeviceHeader.pNextHeader = &pDeviceParms->stCOMscopeHeader;
;|***               pPrevious = &pDeviceParms->stCOMscopeHeader;
;|***               pPrevious->pNextHeader = (VOID *)-1;
;|***               }
;|***             else
;|*** #endif
;|***               {
; Line 649
					$I2619:
;|***               pPrevious = &pDeviceParms->stDeviceHeader;
; Line 650
	*** 000ce2	a1 ec 0d 		mov	ax,WORD PTR _pDeviceParms
	*** 000ce5	8b 16 ee 0d 		mov	dx,WORD PTR _pDeviceParms+2
	*** 000ce9	05 a4 00 		add	ax,164
	*** 000cec	a3 f4 0d 		mov	WORD PTR _pPrevious,ax
	*** 000cef	89 16 f6 0d 		mov	WORD PTR _pPrevious+2,dx
;|***               pPrevious->pNextHeader = (VOID *)-1;
; Line 651
	*** 000cf3	c4 1e f4 0d 		les	bx,DWORD PTR _pPrevious
	*** 000cf7	26 c7 07 ff ff 		mov	WORD PTR es:[bx],-1
	*** 000cfc	26 c7 47 02 ff ff 	mov	WORD PTR es:[bx+2],-1
;|***               }
; Line 652
;|***             if (stDCBheader.stComDCB.wReadBufferLength != 0)
; Line 653
	*** 000d02	83 3e c4 0d 00 		cmp	WORD PTR _stDCBheader+24,0
	*** 000d07	75 03 			jne	$JCC3335
	*** 000d09	e9 2c 00 		jmp	$I2620
					$JCC3335:
;|***               {
; Line 654
;|***               ulRequiredBufferSpace += stDCBheader.stComDCB.wReadBufferLength;
; Line 655
	*** 000d0c	a1 c4 0d 		mov	ax,WORD PTR _stDCBheader+24
	*** 000d0f	2b d2 			sub	dx,dx
	*** 000d11	8e 06 02 00 		mov	es,WORD PTR $T20001
	*** 000d15	26 01 06 00 00 		add	WORD PTR es:_ulRequiredBufferSpace,ax
	*** 000d1a	26 11 16 02 00 		adc	WORD PTR es:_ulRequiredBufferSpace+2,dx
;|***               if (stDCBheader.stComDCB.wReadBufferLength == 0xffff)
; Line 656
	*** 000d1f	83 3e c4 0d ff 		cmp	WORD PTR _stDCBheader+24,-1
	*** 000d24	74 03 			je	$JCC3364
	*** 000d26	e9 0c 00 		jmp	$I2621
					$JCC3364:
;|***                 ulRequiredBufferSpace++;
; Line 657
	*** 000d29	26 83 06 00 00 01 	add	WORD PTR es:_ulRequiredBufferSpace,1
	*** 000d2f	26 83 16 02 00 00 	adc	WORD PTR es:_ulRequiredBufferSpace+2,0
;|***               }
; Line 658
					$I2621:
;|***             else
; Line 659
	*** 000d35	e9 11 00 		jmp	$I2622
					$I2620:
;|***               ulRequiredBufferSpace += DEF_READ_BUFF_LEN;
; Line 660
	*** 000d38	8e 06 02 00 		mov	es,WORD PTR $T20001
	*** 000d3c	26 81 06 00 00 00 10 	add	WORD PTR es:_ulRequiredBufferSpace,4096
	*** 000d43	26 83 16 02 00 00 	adc	WORD PTR es:_ulRequiredBufferSpace+2,0
					$I2622:
;|***             if (stDCBheader.stComDCB.wWrtBufferLength != 0)
; Line 661
	*** 000d49	83 3e c6 0d 00 		cmp	WORD PTR _stDCBheader+26,0
	*** 000d4e	75 03 			jne	$JCC3406
	*** 000d50	e9 16 00 		jmp	$I2623
					$JCC3406:
;|***               ulWriteBufferSpace += stDCBheader.stComDCB.wWrtBufferLength;
; Line 662
	*** 000d53	a1 c6 0d 		mov	ax,WORD PTR _stDCBheader+26
	*** 000d56	2b d2 			sub	dx,dx
	*** 000d58	8e 06 00 00 		mov	es,WORD PTR $T20000
	*** 000d5c	26 01 06 00 00 		add	WORD PTR es:_ulWriteBufferSpace,ax
	*** 000d61	26 11 16 02 00 		adc	WORD PTR es:_ulWriteBufferSpace+2,dx
;|***             else
; Line 663
	*** 000d66	e9 11 00 		jmp	$I2624
					$I2623:
;|***               ulWriteBufferSpace += DEF_WRITE_BUFF_LEN;
; Line 664
	*** 000d69	8e 06 00 00 		mov	es,WORD PTR $T20000
	*** 000d6d	26 81 06 00 00 00 01 	add	WORD PTR es:_ulWriteBufferSpace,256
	*** 000d74	26 83 16 02 00 00 	adc	WORD PTR es:_ulWriteBufferSpace+2,0
					$I2624:
;|***             MemCopy((BYTE *)(&stConfigParms[wLoadCount]),(BYTE *)(&stDCBheader.stComDCB),sizeof(COMDCB));
; Line 665
	*** 000d7a	6a 2a 			push	42
	*** 000d7c	1e 			push	ds
	*** 000d7d	68 bc 0d 		push	OFFSET DGROUP:_stDCBheader+16
	*** 000d80	8e 06 06 00 		mov	es,WORD PTR $T20003
	*** 000d84	26 6b 06 00 00 2a 	imul	ax,WORD PTR es:_wLoadCount,42
	*** 000d8a	05 00 00 		add	ax,OFFSET _stConfigParms
	*** 000d8d	68 00 00 		push	SEG _stConfigParms
	*** 000d90	50 			push	ax
	*** 000d91	9a 00 00 00 00 		call	FAR PTR _MemCopy
	*** 000d96	83 c4 0a 		add	sp,10
;|***             pDeviceParms++;
; Line 666
	*** 000d99	81 06 ec 0d be 00 	add	WORD PTR _pDeviceParms,190
;|*** #ifndef NO_COMscope
;|***             wCOMscopeStrategy += 6;
;|*** #endif
;|***             wDeviceStrategy += 6;
; Line 670
	*** 000d9f	83 06 f8 0d 06 		add	WORD PTR _wDeviceStrategy,6
;|***             wLoadCount++;
; Line 671
	*** 000da4	8e 06 06 00 		mov	es,WORD PTR $T20003
	*** 000da8	26 ff 06 00 00 		inc	WORD PTR es:_wLoadCount
;|***             }
; Line 672
;|*** gtNextDCBheader:
; Line 673
					$I2607:
					$gtNextDCBheader2616:
;|***           if (bPCIadapter)
; Line 674
	*** 000dad	83 7e d2 00 		cmp	WORD PTR [bp-46],0	;bPCIadapter
	*** 000db1	75 03 			jne	$JCC3505
	*** 000db3	e9 59 00 		jmp	$I2625
					$JCC3505:
;|***             {
; Line 675
;|***             // write back I/O addresses
;|***             DosChgFilePtr(hFile,ulFilePosition,0,&ulFilePosition);
; Line 677
	*** 000db6	ff 36 ea 0d 		push	WORD PTR _hFile
	*** 000dba	ff 76 f0 		push	WORD PTR [bp-16]
	*** 000dbd	ff 76 ee 		push	WORD PTR [bp-18]	;ulFilePosition
	*** 000dc0	6a 00 			push	0
	*** 000dc2	8d 46 ee 		lea	ax,WORD PTR [bp-18]	;ulFilePosition
	*** 000dc5	16 			push	ss
	*** 000dc6	50 			push	ax
	*** 000dc7	9a 00 00 00 00 		call	FAR PTR DOS16CHGFILEPTR
;|***             if ((ulFileError = DosWrite(hFile,(PVOID)&stDCBheader,sizeof(DCBHEAD),&ulCount)) != 0)
; Line 678
	*** 000dcc	ff 36 ea 0d 		push	WORD PTR _hFile
	*** 000dd0	1e 			push	ds
	*** 000dd1	68 ac 0d 		push	OFFSET DGROUP:_stDCBheader
	*** 000dd4	6a 3a 			push	58
	*** 000dd6	8d 46 e2 		lea	ax,WORD PTR [bp-30]	;ulCount
	*** 000dd9	16 			push	ss
	*** 000dda	50 			push	ax
	*** 000ddb	9a 00 00 00 00 		call	FAR PTR DOS16WRITE
	*** 000de0	89 46 e0 		mov	WORD PTR [bp-32],ax	;ulFileError
	*** 000de3	3d 00 00 		cmp	ax,0
	*** 000de6	75 03 			jne	$JCC3558
	*** 000de8	e9 24 00 		jmp	$I2626
					$JCC3558:
;|***               {
; Line 679
;|***               VioWrtTTY(chFailedWriteIni,StringLength(chFailedWriteIni),0);
; Line 680
	*** 000deb	68 00 00 		push	SEG _chFailedWriteIni
	*** 000dee	68 00 00 		push	OFFSET _chFailedWriteIni
	*** 000df1	68 00 00 		push	SEG _chFailedWriteIni
	*** 000df4	68 00 00 		push	OFFSET _chFailedWriteIni
	*** 000df7	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 000dfc	83 c4 04 		add	sp,4
	*** 000dff	50 			push	ax
	*** 000e00	6a 00 			push	0
	*** 000e02	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***               ulFileError |= ERR_FILE_WRITE;
; Line 681
	*** 000e07	81 4e e0 00 c0 		or	WORD PTR [bp-32],-16384	;ulFileError
;|***               goto gtEarlyOut;
; Line 682
	*** 000e0c	e9 4e 01 		jmp	$gtEarlyOut2547
;|***               }
; Line 683
;|***             }
; Line 684
					$I2626:
;|***           DosChgFilePtr(hFile,(LONG)stDCBheader.oNextDCBheader,0,&ulFilePosition);
; Line 685
					$I2625:
	*** 000e0f	ff 36 ea 0d 		push	WORD PTR _hFile
	*** 000e13	6a 00 			push	0
	*** 000e15	ff 36 b6 0d 		push	WORD PTR _stDCBheader+10
	*** 000e19	6a 00 			push	0
	*** 000e1b	8d 46 ee 		lea	ax,WORD PTR [bp-18]	;ulFilePosition
	*** 000e1e	16 			push	ss
	*** 000e1f	50 			push	ax
	*** 000e20	9a 00 00 00 00 		call	FAR PTR DOS16CHGFILEPTR
;|***           }
; Line 686
	*** 000e25	e9 2e fd 		jmp	$FC2604
					$FB2605:
;|***         if (wLoadCount > 0)
; Line 687
	*** 000e28	8e 06 06 00 		mov	es,WORD PTR $T20003
	*** 000e2c	26 83 3e 00 00 00 	cmp	WORD PTR es:_wLoadCount,0
	*** 000e32	77 03 			ja	$JCC3634
	*** 000e34	e9 0a 01 		jmp	$I2627
					$JCC3634:
;|***           {
; Line 688
;|***           _wEndOfData = ((WORD)_stDeviceParms + (wLoadCount * sizeof(DEVDEF)));
; Line 689
	*** 000e37	26 69 06 00 00 be 00 	imul	ax,WORD PTR es:_wLoadCount,190
	*** 000e3e	05 00 00 		add	ax,OFFSET __stDeviceParms
_TEXT      ENDS
CONST      SEGMENT
$T20033	DW SEG __wEndOfData 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 000e41	8e 06 40 00 		mov	es,WORD PTR $T20033
	*** 000e45	26 a3 00 00 		mov	WORD PTR es:__wEndOfData,ax
;|***           ulAvailableBufferSpace = (0x10000 - (ulWriteBufferSpace + (ULONG)_wEndOfData));
; Line 690
	*** 000e49	b8 00 00 		mov	ax,0
	*** 000e4c	ba 01 00 		mov	dx,1
	*** 000e4f	8e 06 00 00 		mov	es,WORD PTR $T20000
	*** 000e53	26 2b 06 00 00 		sub	ax,WORD PTR es:_ulWriteBufferSpace
	*** 000e58	26 1b 16 02 00 		sbb	dx,WORD PTR es:_ulWriteBufferSpace+2
	*** 000e5d	8e 06 40 00 		mov	es,WORD PTR $T20033
	*** 000e61	26 2b 06 00 00 		sub	ax,WORD PTR es:__wEndOfData
	*** 000e66	83 da 00 		sbb	dx,0
_TEXT      ENDS
CONST      SEGMENT
$T20034	DW SEG _ulAvailableBufferSpace 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 000e69	8e 06 42 00 		mov	es,WORD PTR $T20034
	*** 000e6d	26 a3 00 00 		mov	WORD PTR es:_ulAvailableBufferSpace,ax
	*** 000e71	26 89 16 02 00 		mov	WORD PTR es:_ulAvailableBufferSpace+2,dx
;|***           if (ulRequiredBufferSpace >= ulAvailableBufferSpace)
; Line 691
	*** 000e76	8e 06 02 00 		mov	es,WORD PTR $T20001
	*** 000e7a	26 a1 00 00 		mov	ax,WORD PTR es:_ulRequiredBufferSpace
	*** 000e7e	26 8b 16 02 00 		mov	dx,WORD PTR es:_ulRequiredBufferSpace+2
	*** 000e83	8e 06 42 00 		mov	es,WORD PTR $T20034
	*** 000e87	26 39 16 02 00 		cmp	WORD PTR es:_ulAvailableBufferSpace+2,dx
	*** 000e8c	76 03 			jbe	$JCC3724
	*** 000e8e	e9 1a 00 		jmp	$I2628
					$JCC3724:
	*** 000e91	73 03 			jae	$JCC3729
	*** 000e93	e9 0a 00 		jmp	$L20036
					$JCC3729:
	*** 000e96	26 39 06 00 00 		cmp	WORD PTR es:_ulAvailableBufferSpace,ax
	*** 000e9b	76 03 			jbe	$JCC3739
	*** 000e9d	e9 0b 00 		jmp	$I2628
					$JCC3739:
					$L20036:
;|***             bUseDDdataSegment = FALSE;
; Line 692
_TEXT      ENDS
CONST      SEGMENT
$T20037	DW SEG _bUseDDdataSegment 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 000ea0	8e 06 44 00 		mov	es,WORD PTR $T20037
	*** 000ea4	26 c7 06 00 00 00 00 	mov	WORD PTR es:_bUseDDdataSegment,0
;|***           pDeviceParms--;
; Line 693
					$I2628:
	*** 000eab	81 2e ec 0d be 00 	sub	WORD PTR _pDeviceParms,190
;|***           _stDummyHeader.pNextHeader = pStart;
; Line 694
	*** 000eb1	a1 f0 0d 		mov	ax,WORD PTR _pStart
	*** 000eb4	8b 16 f2 0d 		mov	dx,WORD PTR _pStart+2
_TEXT      ENDS
CONST      SEGMENT
$T20038	DW SEG __stDummyHeader 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 000eb8	8e 06 46 00 		mov	es,WORD PTR $T20038
	*** 000ebc	26 a3 00 00 		mov	WORD PTR es:__stDummyHeader,ax
	*** 000ec0	26 89 16 02 00 		mov	WORD PTR es:__stDummyHeader+2,dx
;|*** #ifdef this_junk
;|***           _stDummyHeader.sCodeSegment = pDeviceParms->stDeviceHeader.sCodeSegment;
;|***  #ifndef NO_COMscope
;|***           if (pDeviceParms->stDeviceHeader.pNextHeader != 0xffff)
;|***             pDeviceParms->stCOMscopeHeader.sCodeSegment = 0xffff;
;|***           else
;|***  #endif
;|***             pDeviceParms->stDeviceHeader.sCodeSegment = 0xffff;
;|*** #endif
;|***           wLoadNumber = (wIndex + 1);
; Line 704
	*** 000ec5	8b 46 d0 		mov	ax,WORD PTR [bp-48]	;wIndex
	*** 000ec8	40 			inc	ax
	*** 000ec9	8e 06 04 00 		mov	es,WORD PTR $T20002
	*** 000ecd	26 a3 00 00 		mov	WORD PTR es:_wLoadNumber,ax
;|*** #ifndef NO_RESOURCE_MGR
;|***           if (!bDisableRM)
; Line 706
	*** 000ed1	8e 06 22 00 		mov	es,WORD PTR $T20018
	*** 000ed5	26 83 3e 00 00 00 	cmp	WORD PTR es:_bDisableRM,0
	*** 000edb	74 03 			je	$JCC3803
	*** 000edd	e9 2f 00 		jmp	$I2629
					$JCC3803:
;|***             {
; Line 707
;|***             if (bSeparateIDreg)
; Line 708
	*** 000ee0	8e 06 30 00 		mov	es,WORD PTR $T20025
	*** 000ee4	26 83 3e 00 00 00 	cmp	WORD PTR es:_bSeparateIDreg,0
	*** 000eea	75 03 			jne	$JCC3818
	*** 000eec	e9 20 00 		jmp	$I2630
					$JCC3818:
;|***               {
; Line 709
;|*** //              RMHELP_CreateStatusPort();
;|***               if (RMHELP_GetStatusPort() != 0)
; Line 711
	*** 000eef	9a 00 00 00 00 		call	FAR PTR _RMHELP_GetStatusPort
	*** 000ef4	3d 00 00 		cmp	ax,0
	*** 000ef7	75 03 			jne	$JCC3831
	*** 000ef9	e9 0e 00 		jmp	$I2631
					$JCC3831:
;|***                 {
; Line 712
;|***                 wLoadCount = 0;
; Line 713
	*** 000efc	8e 06 06 00 		mov	es,WORD PTR $T20003
	*** 000f00	26 c7 06 00 00 00 00 	mov	WORD PTR es:_wLoadCount,0
;|***                 goto gtEarlyOut;
; Line 714
	*** 000f07	e9 53 00 		jmp	$gtEarlyOut2547
;|***                 }
; Line 715
;|***               RMHELP_StatusPortInitComplete();
; Line 716
					$I2631:
	*** 000f0a	9a 00 00 00 00 		call	FAR PTR _RMHELP_StatusPortInitComplete
;|***               }
; Line 717
;|***             }
; Line 718
					$I2630:
;|*** #endif
;|***           if (bABIOSpresent && bIsTheFirst)
; Line 720
					$I2629:
_TEXT      ENDS
CONST      SEGMENT
$T20039	DW SEG _bABIOSpresent 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 000f0f	8e 06 48 00 		mov	es,WORD PTR $T20039
	*** 000f13	26 83 3e 00 00 00 	cmp	WORD PTR es:_bABIOSpresent,0
	*** 000f19	75 03 			jne	$JCC3865
	*** 000f1b	e9 20 00 		jmp	$I2632
					$JCC3865:
	*** 000f1e	8e 06 18 00 		mov	es,WORD PTR $T20013
	*** 000f22	26 83 3e 00 00 00 	cmp	WORD PTR es:_bIsTheFirst,0
	*** 000f28	75 03 			jne	$JCC3880
	*** 000f2a	e9 11 00 		jmp	$I2632
					$JCC3880:
;|***             VerifyABIOSdefinitions(wLoadCount);
; Line 721
	*** 000f2d	8e 06 06 00 		mov	es,WORD PTR $T20003
	*** 000f31	26 ff 36 00 00 		push	WORD PTR es:_wLoadCount
	*** 000f36	9a 00 00 00 00 		call	FAR PTR _VerifyABIOSdefinitions
	*** 000f3b	83 c4 02 		add	sp,2
;|***           break;
; Line 722
					$I2632:
	*** 000f3e	e9 1c 00 		jmp	$FB2580
;|***           }
; Line 723
;|***         }
; Line 724
					$I2627:
;|***       else
; Line 725
	*** 000f41	e9 16 00 		jmp	$I2633
					$I2582:
;|***         DosChgFilePtr(hFile,(LONG)stConfigHeader.oNextCFGheader,0,&ulFilePosition);
; Line 726
	*** 000f44	ff 36 ea 0d 		push	WORD PTR _hFile
	*** 000f48	6a 00 			push	0
	*** 000f4a	ff 36 88 0d 		push	WORD PTR _stConfigHeader+26
	*** 000f4e	6a 00 			push	0
	*** 000f50	8d 46 ee 		lea	ax,WORD PTR [bp-18]	;ulFilePosition
	*** 000f53	16 			push	ss
	*** 000f54	50 			push	ax
	*** 000f55	9a 00 00 00 00 		call	FAR PTR DOS16CHGFILEPTR
					$I2633:
;|***       }
; Line 727
	*** 000f5a	e9 a4 f8 		jmp	$FC2579
					$FB2580:
;|*** gtEarlyOut:
; Line 728
					$gtEarlyOut2547:
;|***     if (wLoadCount == 0)
; Line 729
	*** 000f5d	8e 06 06 00 		mov	es,WORD PTR $T20003
	*** 000f61	26 83 3e 00 00 00 	cmp	WORD PTR es:_wLoadCount,0
	*** 000f67	74 03 			je	$JCC3943
	*** 000f69	e9 94 00 		jmp	$I2634
					$JCC3943:
;|***       {
; Line 730
;|*** #ifndef NO_RESOURCE_MGR
;|***       if (!bDisableRM)
; Line 732
	*** 000f6c	8e 06 22 00 		mov	es,WORD PTR $T20018
	*** 000f70	26 83 3e 00 00 00 	cmp	WORD PTR es:_bDisableRM,0
	*** 000f76	74 03 			je	$JCC3958
	*** 000f78	e9 05 00 		jmp	$I2635
					$JCC3958:
;|***         RMHELP_DestroyDriver();
; Line 733
	*** 000f7b	9a 00 00 00 00 		call	FAR PTR _RMHELP_DestroyDriver
;|*** #endif
;|*** //#ifdef OEM
;|***       if (ulFileError == 0)
; Line 736
					$I2635:
	*** 000f80	83 7e e0 00 		cmp	WORD PTR [bp-32],0	;ulFileError
	*** 000f84	74 03 			je	$JCC3972
	*** 000f86	e9 6c 00 		jmp	$I2636
					$JCC3972:
;|***         {
; Line 737
;|*** //#endif
;|***         if (!bPrevErrorMsg)
; Line 739
	*** 000f89	83 3e e6 0d 00 		cmp	WORD PTR _bPrevErrorMsg,0
	*** 000f8e	74 03 			je	$JCC3982
	*** 000f90	e9 54 00 		jmp	$I2637
					$JCC3982:
;|***           {
; Line 740
;|***           VioWrtTTY(chFailedIniNotInit_1,StringLength(chFailedIniNotInit_1),0);
; Line 741
	*** 000f93	68 00 00 		push	SEG _chFailedIniNotInit_1
	*** 000f96	68 00 00 		push	OFFSET _chFailedIniNotInit_1
	*** 000f99	68 00 00 		push	SEG _chFailedIniNotInit_1
	*** 000f9c	68 00 00 		push	OFFSET _chFailedIniNotInit_1
	*** 000f9f	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 000fa4	83 c4 04 		add	sp,4
	*** 000fa7	50 			push	ax
	*** 000fa8	6a 00 			push	0
	*** 000faa	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***           VioWrtTTY(_abyPath,StringLength(_abyPath),0);
; Line 742
	*** 000faf	68 00 00 		push	SEG __abyPath
	*** 000fb2	68 00 00 		push	OFFSET __abyPath
	*** 000fb5	68 00 00 		push	SEG __abyPath
	*** 000fb8	68 00 00 		push	OFFSET __abyPath
	*** 000fbb	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 000fc0	83 c4 04 		add	sp,4
	*** 000fc3	50 			push	ax
	*** 000fc4	6a 00 			push	0
	*** 000fc6	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***           VioWrtTTY(chFailedIniNotInit_2,StringLength(chFailedIniNotInit_2),0);
; Line 743
	*** 000fcb	68 00 00 		push	SEG _chFailedIniNotInit_2
	*** 000fce	68 00 00 		push	OFFSET _chFailedIniNotInit_2
	*** 000fd1	68 00 00 		push	SEG _chFailedIniNotInit_2
	*** 000fd4	68 00 00 		push	OFFSET _chFailedIniNotInit_2
	*** 000fd7	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 000fdc	83 c4 04 		add	sp,4
	*** 000fdf	50 			push	ax
	*** 000fe0	6a 00 			push	0
	*** 000fe2	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***           }
; Line 744
;|***         wLoadNumber = NO_DEFINED_DEVICES;
; Line 745
					$I2637:
	*** 000fe7	8e 06 04 00 		mov	es,WORD PTR $T20002
	*** 000feb	26 c7 06 00 00 00 80 	mov	WORD PTR es:_wLoadNumber,-32768
;|*** //#ifdef OEM
;|***         }
; Line 747
;|***       else
; Line 748
	*** 000ff2	e9 0b 00 		jmp	$I2638
					$I2636:
;|***         wLoadNumber = FILE_ACCESS_ERROR;
; Line 749
	*** 000ff5	8e 06 04 00 		mov	es,WORD PTR $T20002
	*** 000ff9	26 c7 06 00 00 00 c0 	mov	WORD PTR es:_wLoadNumber,-16384
					$I2638:
;|*** //#endif
;|***       }
; Line 751
;|***     DosClose(hFile);
; Line 752
					$I2634:
	*** 001000	ff 36 ea 0d 		push	WORD PTR _hFile
	*** 001004	9a 00 00 00 00 		call	FAR PTR DOS16CLOSE
;|***     }
; Line 753
;|***   _abyPath[wSaveExt++] = abySaveExt[0];
; Line 754
					$I2545:
	*** 001009	8a 46 d8 		mov	al,BYTE PTR [bp-40]	;abySaveExt
	*** 00100c	8e 06 08 00 		mov	es,WORD PTR $T20004
	*** 001010	8b 5e e8 		mov	bx,WORD PTR [bp-24]	;wSaveExt
	*** 001013	26 88 87 00 00 		mov	BYTE PTR es:__abyPath[bx],al
	*** 001018	ff 46 e8 		inc	WORD PTR [bp-24]	;wSaveExt
;|***   _abyPath[wSaveExt++] = abySaveExt[1];
; Line 755
	*** 00101b	8a 46 d9 		mov	al,BYTE PTR [bp-39]
	*** 00101e	8b 5e e8 		mov	bx,WORD PTR [bp-24]	;wSaveExt
	*** 001021	26 88 87 00 00 		mov	BYTE PTR es:__abyPath[bx],al
	*** 001026	ff 46 e8 		inc	WORD PTR [bp-24]	;wSaveExt
;|***   _abyPath[wSaveExt++] = abySaveExt[2];
; Line 756
	*** 001029	8a 46 da 		mov	al,BYTE PTR [bp-38]
	*** 00102c	8b 5e e8 		mov	bx,WORD PTR [bp-24]	;wSaveExt
	*** 00102f	26 88 87 00 00 		mov	BYTE PTR es:__abyPath[bx],al
	*** 001034	ff 46 e8 		inc	WORD PTR [bp-24]	;wSaveExt
;|***   _abyPath[wSaveExt] = abySaveExt[3];
; Line 757
	*** 001037	8a 46 db 		mov	al,BYTE PTR [bp-37]
	*** 00103a	8b 5e e8 		mov	bx,WORD PTR [bp-24]	;wSaveExt
	*** 00103d	26 88 87 00 00 		mov	BYTE PTR es:__abyPath[bx],al
;|***   if (ulFileError != 0)
; Line 758
	*** 001042	83 7e e0 00 		cmp	WORD PTR [bp-32],0	;ulFileError
	*** 001046	75 03 			jne	$JCC4166
	*** 001048	e9 0a 00 		jmp	$I2639
					$JCC4166:
;|***     DosSleep(1000);
; Line 759
	*** 00104b	6a 00 			push	0
	*** 00104d	68 e8 03 		push	1000
	*** 001050	9a 00 00 00 00 		call	FAR PTR DOS16SLEEP
;|***   return;
; Line 760
					$I2639:
	*** 001055	e9 00 00 		jmp	$EX2486
;|***   }
; Line 761
					$EX2486:
	*** 001058	5e 			pop	si
	*** 001059	5f 			pop	di
	*** 00105a	c9 			leave	
	*** 00105b	cb 			ret	

_GetIniInfo	ENDP
;|*** 
;|*** void VerifyABIOSdefinitions(WORD wLoadCount)
;|***   {
; Line 764
	PUBLIC	_VerifyABIOSdefinitions
_VerifyABIOSdefinitions	PROC FAR
	*** 00105c	c8 06 00 00 		enter	6,0
	*** 001060	57 			push	di
	*** 001061	56 			push	si
;	wDCBindex = -2
;	wIndex = -6
;	wTemp = -4
;	wLoadCount = 6
;|***   WORD wDCBindex;
;|***   WORD wIndex;
;|***   WORD wTemp;
;|*** 
;|***   for (wDCBindex = 0;wDCBindex < wLoadCount;wDCBindex++)
; Line 769
	*** 001062	c7 46 fe 00 00 		mov	WORD PTR [bp-2],0	;wDCBindex
	*** 001067	e9 03 00 		jmp	$F2645
					$FC2646:
	*** 00106a	ff 46 fe 		inc	WORD PTR [bp-2]	;wDCBindex
					$F2645:
	*** 00106d	8b 46 06 		mov	ax,WORD PTR [bp+6]	;wLoadCount
	*** 001070	39 46 fe 		cmp	WORD PTR [bp-2],ax	;wDCBindex
	*** 001073	72 03 			jb	$JCC4211
	*** 001075	e9 d0 01 		jmp	$FB2647
					$JCC4211:
;|***     {
; Line 770
;|***     if (LIDtable[wDCBindex].fFlags & LID_ALREADY_OWNED)
; Line 771
_TEXT      ENDS
CONST      SEGMENT
$T20040	DW SEG _LIDtable 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 001078	8e 06 4a 00 		mov	es,WORD PTR $T20040
	*** 00107c	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;wDCBindex
	*** 00107f	c1 e3 04 		shl	bx,4
	*** 001082	26 f6 87 0c 00 01 	test	BYTE PTR es:_LIDtable[bx+12],1
	*** 001088	75 03 			jne	$JCC4232
	*** 00108a	e9 4b 00 		jmp	$I2648
					$JCC4232:
;|***       {
; Line 772
;|***       wTemp = LIDtable[wDCBindex].wBaseAddress;
; Line 773
	*** 00108d	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;wDCBindex
	*** 001090	c1 e3 04 		shl	bx,4
	*** 001093	26 8b 87 06 00 		mov	ax,WORD PTR es:_LIDtable[bx+6]
	*** 001098	89 46 fc 		mov	WORD PTR [bp-4],ax	;wTemp
;|***       for (wIndex = 0;wIndex < 8;wIndex++)
; Line 774
	*** 00109b	c7 46 fa 00 00 		mov	WORD PTR [bp-6],0	;wIndex
	*** 0010a0	e9 03 00 		jmp	$F2649
					$FC2650:
	*** 0010a3	ff 46 fa 		inc	WORD PTR [bp-6]	;wIndex
					$F2649:
	*** 0010a6	83 7e fa 08 		cmp	WORD PTR [bp-6],8	;wIndex
	*** 0010aa	72 03 			jb	$JCC4266
	*** 0010ac	e9 26 00 		jmp	$FB2651
					$JCC4266:
;|***       if (stConfigParms[wIndex].wIObaseAddress == wTemp)
; Line 775
	*** 0010af	8b 46 fc 		mov	ax,WORD PTR [bp-4]	;wTemp
_TEXT      ENDS
CONST      SEGMENT
$T20041	DW SEG _stConfigParms 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 0010b2	8e 06 4c 00 		mov	es,WORD PTR $T20041
	*** 0010b6	6b 5e fa 2a 		imul	bx,WORD PTR [bp-6],42	;wIndex
	*** 0010ba	26 39 87 06 00 		cmp	WORD PTR es:_stConfigParms[bx+6],ax
	*** 0010bf	74 03 			je	$JCC4287
	*** 0010c1	e9 0e 00 		jmp	$I2652
					$JCC4287:
;|***         {
; Line 776
;|***         stConfigParms[wIndex].wIObaseAddress = PORT_LID_ALREADY_OWNED;
; Line 777
	*** 0010c4	6b 5e fa 2a 		imul	bx,WORD PTR [bp-6],42	;wIndex
	*** 0010c8	26 c7 87 06 00 fe ff 	mov	WORD PTR es:_stConfigParms[bx+6],-2
;|***         break;
; Line 778
	*** 0010cf	e9 03 00 		jmp	$FB2651
;|***         }
; Line 779
;|***       }
; Line 780
					$I2652:
	*** 0010d2	e9 ce ff 		jmp	$FC2650
					$FB2651:
;|***     else
; Line 781
	*** 0010d5	e9 6d 01 		jmp	$I2653
					$I2648:
;|***       {
; Line 782
;|***       if (stConfigParms[wDCBindex].wIObaseAddress != PORT_USER_DISABLED)
; Line 783
	*** 0010d8	8e 06 4c 00 		mov	es,WORD PTR $T20041
	*** 0010dc	6b 5e fe 2a 		imul	bx,WORD PTR [bp-2],42	;wDCBindex
	*** 0010e0	26 83 bf 06 00 ff 	cmp	WORD PTR es:_stConfigParms[bx+6],-1
	*** 0010e6	75 03 			jne	$JCC4326
	*** 0010e8	e9 5a 01 		jmp	$I2654
					$JCC4326:
;|***         {
; Line 784
;|***         wTemp = stConfigParms[wDCBindex].wIObaseAddress;
; Line 785
	*** 0010eb	6b 5e fe 2a 		imul	bx,WORD PTR [bp-2],42	;wDCBindex
	*** 0010ef	26 8b 87 06 00 		mov	ax,WORD PTR es:_stConfigParms[bx+6]
	*** 0010f4	89 46 fc 		mov	WORD PTR [bp-4],ax	;wTemp
;|***         for (wIndex = 0;wIndex < 8;wIndex++)
; Line 786
	*** 0010f7	c7 46 fa 00 00 		mov	WORD PTR [bp-6],0	;wIndex
	*** 0010fc	e9 03 00 		jmp	$F2655
					$FC2656:
	*** 0010ff	ff 46 fa 		inc	WORD PTR [bp-6]	;wIndex
					$F2655:
	*** 001102	83 7e fa 08 		cmp	WORD PTR [bp-6],8	;wIndex
	*** 001106	72 03 			jb	$JCC4358
	*** 001108	e9 20 00 		jmp	$FB2657
					$JCC4358:
;|***           if (astMCAportTable[wIndex].wAddress == wTemp)
; Line 787
	*** 00110b	8b 46 fc 		mov	ax,WORD PTR [bp-4]	;wTemp
_TEXT      ENDS
CONST      SEGMENT
$T20042	DW SEG _astMCAportTable 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 00110e	8e 06 4e 00 		mov	es,WORD PTR $T20042
	*** 001112	8b 5e fa 		mov	bx,WORD PTR [bp-6]	;wIndex
	*** 001115	8b cb 			mov	cx,bx
	*** 001117	d1 e3 			shl	bx,1
	*** 001119	03 d9 			add	bx,cx
	*** 00111b	26 39 87 00 00 		cmp	WORD PTR es:_astMCAportTable[bx],ax
	*** 001120	74 03 			je	$JCC4384
	*** 001122	e9 03 00 		jmp	$I2658
					$JCC4384:
;|***             break;
; Line 788
	*** 001125	e9 03 00 		jmp	$FB2657
;|***         if (wIndex < 8)
; Line 789
					$I2658:
	*** 001128	e9 d4 ff 		jmp	$FC2656
					$FB2657:
	*** 00112b	83 7e fa 08 		cmp	WORD PTR [bp-6],8	;wIndex
	*** 00112f	72 03 			jb	$JCC4399
	*** 001131	e9 11 01 		jmp	$I2659
					$JCC4399:
;|***           {
; Line 790
;|***           for (wIndex = 0;wIndex < 8;wIndex++)
; Line 791
	*** 001134	c7 46 fa 00 00 		mov	WORD PTR [bp-6],0	;wIndex
	*** 001139	e9 03 00 		jmp	$F2660
					$FC2661:
	*** 00113c	ff 46 fa 		inc	WORD PTR [bp-6]	;wIndex
					$F2660:
	*** 00113f	83 7e fa 08 		cmp	WORD PTR [bp-6],8	;wIndex
	*** 001143	72 03 			jb	$JCC4419
	*** 001145	e9 1d 00 		jmp	$FB2662
					$JCC4419:
;|***             if (LIDtable[wIndex].wBaseAddress == wTemp)
; Line 792
	*** 001148	8b 46 fc 		mov	ax,WORD PTR [bp-4]	;wTemp
	*** 00114b	8e 06 4a 00 		mov	es,WORD PTR $T20040
	*** 00114f	8b 5e fa 		mov	bx,WORD PTR [bp-6]	;wIndex
	*** 001152	c1 e3 04 		shl	bx,4
	*** 001155	26 39 87 06 00 		cmp	WORD PTR es:_LIDtable[bx+6],ax
	*** 00115a	74 03 			je	$JCC4442
	*** 00115c	e9 03 00 		jmp	$I2663
					$JCC4442:
;|***               break;
; Line 793
	*** 00115f	e9 03 00 		jmp	$FB2662
;|***           if (wIndex >= 8)
; Line 794
					$I2663:
	*** 001162	e9 d7 ff 		jmp	$FC2661
					$FB2662:
	*** 001165	83 7e fa 08 		cmp	WORD PTR [bp-6],8	;wIndex
	*** 001169	73 03 			jae	$JCC4457
	*** 00116b	e9 12 00 		jmp	$I2664
					$JCC4457:
;|***             stConfigParms[wDCBindex].wIObaseAddress = PORT_ADDRESS_INVALID;
; Line 795
	*** 00116e	8e 06 4c 00 		mov	es,WORD PTR $T20041
	*** 001172	6b 5e fe 2a 		imul	bx,WORD PTR [bp-2],42	;wDCBindex
	*** 001176	26 c7 87 06 00 fc ff 	mov	WORD PTR es:_stConfigParms[bx+6],-4
;|***           else
; Line 796
	*** 00117d	e9 c5 00 		jmp	$I2665
					$I2664:
;|***             {
; Line 797
;|***             MemCopy(_szName,_stDeviceParms[wDCBindex].stDeviceHeader.abyDeviceName,8);
; Line 798
	*** 001180	6a 08 			push	8
	*** 001182	69 46 fe be 00 		imul	ax,WORD PTR [bp-2],190	;wDCBindex
	*** 001187	05 ae 00 		add	ax,OFFSET __stDeviceParms+174
	*** 00118a	68 00 00 		push	SEG __stDeviceParms
	*** 00118d	50 			push	ax
	*** 00118e	68 00 00 		push	SEG __szName
	*** 001191	68 00 00 		push	OFFSET __szName
	*** 001194	9a 00 00 00 00 		call	FAR PTR _MemCopy
	*** 001199	83 c4 0a 		add	sp,10
;|***             _szName[8] = 0;
; Line 799
_TEXT      ENDS
CONST      SEGMENT
$T20043	DW SEG __szName 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 00119c	8e 06 50 00 		mov	es,WORD PTR $T20043
	*** 0011a0	26 c6 06 08 00 00 	mov	BYTE PTR es:__szName+8,0
;|***             if (AttachDD(_szName,&_stAttachDD) == DRIVER_ATTACHED)
; Line 800
	*** 0011a6	68 00 00 		push	SEG __stAttachDD
	*** 0011a9	68 00 00 		push	OFFSET __stAttachDD
	*** 0011ac	06 			push	es
	*** 0011ad	68 00 00 		push	OFFSET __szName
	*** 0011b0	9a 00 00 00 00 		call	FAR PTR _AttachDD
	*** 0011b5	83 c4 08 		add	sp,8
	*** 0011b8	3d 00 00 		cmp	ax,0
	*** 0011bb	74 03 			je	$JCC4539
	*** 0011bd	e9 34 00 		jmp	$I2666
					$JCC4539:
;|***               {
; Line 801
;|***               if (LIDtable[abyCOMnumbers[wDCBindex] - 1].wBaseAddress != wTemp)
; Line 802
	*** 0011c0	8b 46 fc 		mov	ax,WORD PTR [bp-4]	;wTemp
	*** 0011c3	8e 06 3e 00 		mov	es,WORD PTR $T20032
	*** 0011c7	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;wDCBindex
	*** 0011ca	26 8a 9f 00 00 		mov	bl,BYTE PTR es:_abyCOMnumbers[bx]
	*** 0011cf	2a ff 			sub	bh,bh
	*** 0011d1	c1 e3 04 		shl	bx,4
	*** 0011d4	8e 06 4a 00 		mov	es,WORD PTR $T20040
	*** 0011d8	26 39 87 f6 ff 		cmp	WORD PTR es:_LIDtable[bx-10],ax
	*** 0011dd	75 03 			jne	$JCC4573
	*** 0011df	e9 0f 00 		jmp	$I2667
					$JCC4573:
;|***                 stConfigParms[wDCBindex].wIObaseAddress = PORT_ADDRESS_TAKEN;
; Line 803
	*** 0011e2	8e 06 4c 00 		mov	es,WORD PTR $T20041
	*** 0011e6	6b 5e fe 2a 		imul	bx,WORD PTR [bp-2],42	;wDCBindex
	*** 0011ea	26 c7 87 06 00 fb ff 	mov	WORD PTR es:_stConfigParms[bx+6],-5
;|***               }
; Line 804
					$I2667:
;|***             else
; Line 805
	*** 0011f1	e9 51 00 		jmp	$I2668
					$I2666:
;|***               {
; Line 806
;|***               for (wIndex = 0;wIndex < 8;wIndex++)
; Line 807
	*** 0011f4	c7 46 fa 00 00 		mov	WORD PTR [bp-6],0	;wIndex
	*** 0011f9	e9 03 00 		jmp	$F2669
					$FC2670:
	*** 0011fc	ff 46 fa 		inc	WORD PTR [bp-6]	;wIndex
					$F2669:
	*** 0011ff	83 7e fa 08 		cmp	WORD PTR [bp-6],8	;wIndex
	*** 001203	72 03 			jb	$JCC4611
	*** 001205	e9 3d 00 		jmp	$FB2671
					$JCC4611:
;|***                 if (LIDtable[wIndex].wBaseAddress == wTemp)
; Line 808
	*** 001208	8b 46 fc 		mov	ax,WORD PTR [bp-4]	;wTemp
	*** 00120b	8e 06 4a 00 		mov	es,WORD PTR $T20040
	*** 00120f	8b 5e fa 		mov	bx,WORD PTR [bp-6]	;wIndex
	*** 001212	c1 e3 04 		shl	bx,4
	*** 001215	26 39 87 06 00 		cmp	WORD PTR es:_LIDtable[bx+6],ax
	*** 00121a	74 03 			je	$JCC4634
	*** 00121c	e9 23 00 		jmp	$I2672
					$JCC4634:
;|***                   {
; Line 809
;|***                   if (LIDtable[wIndex].bNameTaken)
; Line 810
	*** 00121f	8b 5e fa 		mov	bx,WORD PTR [bp-6]	;wIndex
	*** 001222	c1 e3 04 		shl	bx,4
	*** 001225	26 83 bf 0a 00 00 	cmp	WORD PTR es:_LIDtable[bx+10],0
	*** 00122b	75 03 			jne	$JCC4651
	*** 00122d	e9 0f 00 		jmp	$I2673
					$JCC4651:
;|***                     stConfigParms[wDCBindex].wIObaseAddress = PORT_ADDRESS_TAKEN;
; Line 811
	*** 001230	8e 06 4c 00 		mov	es,WORD PTR $T20041
	*** 001234	6b 5e fe 2a 		imul	bx,WORD PTR [bp-2],42	;wDCBindex
	*** 001238	26 c7 87 06 00 fb ff 	mov	WORD PTR es:_stConfigParms[bx+6],-5
;|***                   break;
; Line 812
					$I2673:
	*** 00123f	e9 03 00 		jmp	$FB2671
;|***                   }
; Line 813
;|***               }
; Line 814
					$I2672:
	*** 001242	e9 b7 ff 		jmp	$FC2670
					$FB2671:
					$I2668:
;|***             }
; Line 815
					$I2665:
;|***           }
; Line 816
;|***         }
; Line 817
					$I2659:
;|***       }
; Line 818
					$I2654:
					$I2653:
;|***     }
; Line 819
	*** 001245	e9 22 fe 		jmp	$FC2646
					$FB2647:
;|***   }
; Line 820
					$EX2641:
	*** 001248	5e 			pop	si
	*** 001249	5f 			pop	di
	*** 00124a	c9 			leave	
	*** 00124b	cb 			ret	

_VerifyABIOSdefinitions	ENDP
;|*** 
;|*** #ifndef x16_BIT
;|*** #ifndef RTEST
;|*** BYTE GetDeviceInterrupt(WORD wLID);
;|*** WORD GetDeviceBlockOffset(WORD wLID);
;|*** WORD GetDeviceBlockLen(WORD wLID);
;|*** WORD GetKernalData(WORD wLID,WORD wSrcOffset,BYTE *pDest,ULONG ulCount );
;|*** WORD GetDeviceAddress(WORD wLID);
;|*** WORD _far GetLIDentry(WORD *pwLID);
;|*** void FreeLIDentry(WORD wLID);
;|*** 
;|*** int iLIDcount = 0;
;|*** 
;|*** void _far BuildLIDtable(void)
;|***   {
; Line 835
	PUBLIC	_BuildLIDtable
_BuildLIDtable	PROC FAR
	*** 00124c	c8 2a 00 00 		enter	42,0
	*** 001250	57 			push	di
	*** 001251	56 			push	si
;	iIndex = -12
;	wError = -10
;	pstDevBlock = -8
;	wBlockLen = -4
;	wOffset = -36
;	bDone = -22
;	iLastAvailable = -34
;	iFirstAvailable = -14
;	bDeviceOwned = -40
;	bDeviceAvailable = -16
;	pWord = -32
;	wMaxCount = -18
;	wSaveExt = -20
;	abySaveExt = -28
;	wLID = -2
;	ulAction = -38
;	ulCount = -24
;|***   int iIndex;
;|***   WORD wError;
;|***   DEVBLK *pstDevBlock;
;|***   WORD wBlockLen;
;|***   WORD wOffset;
;|***   BOOL bDone;
;|***   int iLastAvailable = -1;
; Line 842
	*** 001252	c7 46 de ff ff 		mov	WORD PTR [bp-34],-1	;iLastAvailable
;|***   int iFirstAvailable = -1;
; Line 843
	*** 001257	c7 46 f2 ff ff 		mov	WORD PTR [bp-14],-1	;iFirstAvailable
;|***   BOOL bDeviceOwned = FALSE;
; Line 844
	*** 00125c	c7 46 d8 00 00 		mov	WORD PTR [bp-40],0	;bDeviceOwned
;|***   BOOL bDeviceAvailable = FALSE;
; Line 845
	*** 001261	c7 46 f0 00 00 		mov	WORD PTR [bp-16],0	;bDeviceAvailable
;|***   WORD *pWord = (WORD *)abyFileBuffer;
; Line 846
	*** 001266	c7 46 e0 00 00 		mov	WORD PTR [bp-32],OFFSET _abyFileBuffer	;pWord
	*** 00126b	c7 46 e2 00 00 		mov	WORD PTR [bp-30],SEG _abyFileBuffer
;|***   WORD wMaxCount;
;|***   WORD wSaveExt;
;|***   char abySaveExt[4];
;|***   WORD wLID;
;|*** #ifdef _32bitAPI
;|***   ULONG ulAction;
;|***   ULONG ulCount;
;|*** #else
;|***   WORD ulAction;
;|***   WORD ulCount;
;|*** #endif
;|*** 
;|***   for (iIndex = 0;iIndex < 8;iIndex++)
; Line 859
	*** 001270	c7 46 f4 00 00 		mov	WORD PTR [bp-12],0	;iIndex
	*** 001275	e9 03 00 		jmp	$F2711
					$FC2712:
	*** 001278	ff 46 f4 		inc	WORD PTR [bp-12]	;iIndex
					$F2711:
	*** 00127b	83 7e f4 08 		cmp	WORD PTR [bp-12],8	;iIndex
	*** 00127f	7c 03 			jl	$JCC4735
	*** 001281	e9 03 01 		jmp	$FB2713
					$JCC4735:
;|***     {
; Line 860
;|***     iLIDcount++;
; Line 861
	*** 001284	ff 06 54 0e 		inc	WORD PTR _iLIDcount
;|***     wLID = iIndex + 1;
; Line 862
	*** 001288	8b 46 f4 		mov	ax,WORD PTR [bp-12]	;iIndex
	*** 00128b	40 			inc	ax
	*** 00128c	89 46 fe 		mov	WORD PTR [bp-2],ax	;wLID
;|***     if ((wError = GetLIDentry(&wLID)) == NO_ERROR)
; Line 863
	*** 00128f	8d 46 fe 		lea	ax,WORD PTR [bp-2]	;wLID
	*** 001292	16 			push	ss
	*** 001293	50 			push	ax
	*** 001294	9a 00 00 00 00 		call	FAR PTR _GetLIDentry
	*** 001299	83 c4 04 		add	sp,4
	*** 00129c	89 46 f6 		mov	WORD PTR [bp-10],ax	;wError
	*** 00129f	3d 00 00 		cmp	ax,0
	*** 0012a2	74 03 			je	$JCC4770
	*** 0012a4	e9 9d 00 		jmp	$I2714
					$JCC4770:
;|***       {
; Line 864
;|***       bDeviceAvailable = TRUE;
; Line 865
	*** 0012a7	c7 46 f0 01 00 		mov	WORD PTR [bp-16],1	;bDeviceAvailable
;|***       LIDtable[iIndex].wDeviceNumber = (iIndex + 1);
; Line 866
	*** 0012ac	8b 46 f4 		mov	ax,WORD PTR [bp-12]	;iIndex
	*** 0012af	40 			inc	ax
	*** 0012b0	8e 06 4a 00 		mov	es,WORD PTR $T20040
	*** 0012b4	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 0012b7	c1 e3 04 		shl	bx,4
	*** 0012ba	26 89 87 08 00 		mov	WORD PTR es:_LIDtable[bx+8],ax
;|***       LIDtable[iIndex].wLID = wLID;
; Line 867
	*** 0012bf	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;wLID
	*** 0012c2	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 0012c5	c1 e3 04 		shl	bx,4
	*** 0012c8	26 89 87 04 00 		mov	WORD PTR es:_LIDtable[bx+4],ax
;|***       LIDtable[iIndex].fFlags = LID_AVAILABLE;
; Line 868
	*** 0012cd	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 0012d0	c1 e3 04 		shl	bx,4
	*** 0012d3	26 c6 87 0c 00 08 	mov	BYTE PTR es:_LIDtable[bx+12],8
;|***       LIDtable[iIndex].wBaseAddress = GetDeviceAddress(wLID);
; Line 869
	*** 0012d9	ff 76 fe 		push	WORD PTR [bp-2]	;wLID
	*** 0012dc	9a 00 00 00 00 		call	FAR PTR _GetDeviceAddress
	*** 0012e1	83 c4 02 		add	sp,2
	*** 0012e4	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 0012e7	c1 e3 04 		shl	bx,4
	*** 0012ea	8e 06 4a 00 		mov	es,WORD PTR $T20040
	*** 0012ee	26 89 87 06 00 		mov	WORD PTR es:_LIDtable[bx+6],ax
;|***       LIDtable[iIndex].wBlockLen = GetDeviceBlockLen(wLID);
; Line 870
	*** 0012f3	ff 76 fe 		push	WORD PTR [bp-2]	;wLID
	*** 0012f6	9a 00 00 00 00 		call	FAR PTR _GetDeviceBlockLen
	*** 0012fb	83 c4 02 		add	sp,2
	*** 0012fe	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 001301	c1 e3 04 		shl	bx,4
	*** 001304	8e 06 4a 00 		mov	es,WORD PTR $T20040
	*** 001308	26 89 87 02 00 		mov	WORD PTR es:_LIDtable[bx+2],ax
;|***       LIDtable[iIndex].wDevBlkOffset = GetDeviceBlockOffset(wLID);
; Line 871
	*** 00130d	ff 76 fe 		push	WORD PTR [bp-2]	;wLID
	*** 001310	9a 00 00 00 00 		call	FAR PTR _GetDeviceBlockOffset
	*** 001315	83 c4 02 		add	sp,2
	*** 001318	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 00131b	c1 e3 04 		shl	bx,4
	*** 00131e	8e 06 4a 00 		mov	es,WORD PTR $T20040
	*** 001322	26 89 87 00 00 		mov	WORD PTR es:_LIDtable[bx],ax
;|***       LIDtable[iIndex].byInterruptLevel = GetDeviceInterrupt(wLID);
; Line 872
	*** 001327	ff 76 fe 		push	WORD PTR [bp-2]	;wLID
	*** 00132a	9a 00 00 00 00 		call	FAR PTR _GetDeviceInterrupt
	*** 00132f	83 c4 02 		add	sp,2
	*** 001332	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 001335	c1 e3 04 		shl	bx,4
	*** 001338	8e 06 4a 00 		mov	es,WORD PTR $T20040
	*** 00133c	26 88 87 0d 00 		mov	BYTE PTR es:_LIDtable[bx+13],al
;|***       }
; Line 873
;|***     else
; Line 874
	*** 001341	e9 40 00 		jmp	$I2715
					$I2714:
;|***       if (wError == ERROR_LID_ALREADY_OWNED)
; Line 875
	*** 001344	83 7e f6 01 		cmp	WORD PTR [bp-10],1	;wError
	*** 001348	74 03 			je	$JCC4936
	*** 00134a	e9 27 00 		jmp	$I2716
					$JCC4936:
;|***         {
; Line 876
;|***         bDeviceOwned = TRUE;
; Line 877
	*** 00134d	c7 46 d8 01 00 		mov	WORD PTR [bp-40],1	;bDeviceOwned
;|***         LIDtable[iIndex].wDeviceNumber = (iIndex + 1);
; Line 878
	*** 001352	8b 46 f4 		mov	ax,WORD PTR [bp-12]	;iIndex
	*** 001355	40 			inc	ax
	*** 001356	8e 06 4a 00 		mov	es,WORD PTR $T20040
	*** 00135a	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 00135d	c1 e3 04 		shl	bx,4
	*** 001360	26 89 87 08 00 		mov	WORD PTR es:_LIDtable[bx+8],ax
;|***         LIDtable[iIndex].fFlags |= LID_ALREADY_OWNED;
; Line 879
	*** 001365	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 001368	c1 e3 04 		shl	bx,4
	*** 00136b	26 80 8f 0c 00 01 	or	BYTE PTR es:_LIDtable[bx+12],1
;|***         }
; Line 880
;|***       else
; Line 881
	*** 001371	e9 10 00 		jmp	$I2717
					$I2716:
;|***         if (wError == ERROR_LID_DOES_NOT_EXIST)
; Line 882
	*** 001374	83 7e f6 02 		cmp	WORD PTR [bp-10],2	;wError
	*** 001378	74 03 			je	$JCC4984
	*** 00137a	e9 07 00 		jmp	$I2718
					$JCC4984:
;|***           {
; Line 883
;|***           iLIDcount--;
; Line 884
	*** 00137d	ff 0e 54 0e 		dec	WORD PTR _iLIDcount
;|***           break;
; Line 885
	*** 001381	e9 03 00 		jmp	$FB2713
;|***           }
; Line 886
;|***     }
; Line 887
					$I2718:
					$I2717:
					$I2715:
	*** 001384	e9 f1 fe 		jmp	$FC2712
					$FB2713:
;|***   for (;iIndex < 8;iIndex++)
; Line 888
	*** 001387	e9 03 00 		jmp	$F2719
					$FC2720:
	*** 00138a	ff 46 f4 		inc	WORD PTR [bp-12]	;iIndex
					$F2719:
	*** 00138d	83 7e f4 08 		cmp	WORD PTR [bp-12],8	;iIndex
	*** 001391	7c 03 			jl	$JCC5009
	*** 001393	e9 13 00 		jmp	$FB2721
					$JCC5009:
;|***     LIDtable[iIndex].fFlags |= LID_DOES_NOT_EXIST;
; Line 889
	*** 001396	8e 06 4a 00 		mov	es,WORD PTR $T20040
	*** 00139a	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 00139d	c1 e3 04 		shl	bx,4
	*** 0013a0	26 80 8f 0c 00 02 	or	BYTE PTR es:_LIDtable[bx+12],2
	*** 0013a6	e9 e1 ff 		jmp	$FC2720
					$FB2721:
;|*** 
;|***   if (bDeviceOwned && bDeviceAvailable)
; Line 891
	*** 0013a9	83 7e d8 00 		cmp	WORD PTR [bp-40],0	;bDeviceOwned
	*** 0013ad	75 03 			jne	$JCC5037
	*** 0013af	e9 49 02 		jmp	$I2722
					$JCC5037:
	*** 0013b2	83 7e f0 00 		cmp	WORD PTR [bp-16],0	;bDeviceAvailable
	*** 0013b6	75 03 			jne	$JCC5046
	*** 0013b8	e9 40 02 		jmp	$I2722
					$JCC5046:
;|***     {
; Line 892
;|***     for (iIndex = 0;iIndex < iLIDcount;iIndex++)
; Line 893
	*** 0013bb	c7 46 f4 00 00 		mov	WORD PTR [bp-12],0	;iIndex
	*** 0013c0	e9 03 00 		jmp	$F2723
					$FC2724:
	*** 0013c3	ff 46 f4 		inc	WORD PTR [bp-12]	;iIndex
					$F2723:
	*** 0013c6	a1 54 0e 		mov	ax,WORD PTR _iLIDcount
	*** 0013c9	39 46 f4 		cmp	WORD PTR [bp-12],ax	;iIndex
	*** 0013cc	7c 03 			jl	$JCC5068
	*** 0013ce	e9 0a 01 		jmp	$FB2725
					$JCC5068:
;|***       {
; Line 894
;|***       if (LIDtable[iIndex].fFlags & LID_ALREADY_OWNED)
; Line 895
	*** 0013d1	8e 06 4a 00 		mov	es,WORD PTR $T20040
	*** 0013d5	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 0013d8	c1 e3 04 		shl	bx,4
	*** 0013db	26 f6 87 0c 00 01 	test	BYTE PTR es:_LIDtable[bx+12],1
	*** 0013e1	75 03 			jne	$JCC5089
	*** 0013e3	e9 dd 00 		jmp	$I2726
					$JCC5089:
;|***         {
; Line 896
;|***         if (iLastAvailable != -1)
; Line 897
	*** 0013e6	83 7e de ff 		cmp	WORD PTR [bp-34],-1	;iLastAvailable
	*** 0013ea	75 03 			jne	$JCC5098
	*** 0013ec	e9 d1 00 		jmp	$I2727
					$JCC5098:
;|***           {
; Line 898
;|***           wLID = LIDtable[iLastAvailable].wLID;
; Line 899
	*** 0013ef	8b 5e de 		mov	bx,WORD PTR [bp-34]	;iLastAvailable
	*** 0013f2	c1 e3 04 		shl	bx,4
	*** 0013f5	26 8b 87 04 00 		mov	ax,WORD PTR es:_LIDtable[bx+4]
	*** 0013fa	89 46 fe 		mov	WORD PTR [bp-2],ax	;wLID
;|***           wBlockLen = LIDtable[iLastAvailable].wBlockLen;
; Line 900
	*** 0013fd	8b 5e de 		mov	bx,WORD PTR [bp-34]	;iLastAvailable
	*** 001400	c1 e3 04 		shl	bx,4
	*** 001403	26 8b 87 02 00 		mov	ax,WORD PTR es:_LIDtable[bx+2]
	*** 001408	89 46 fc 		mov	WORD PTR [bp-4],ax	;wBlockLen
;|***           wOffset = (wBlockLen + LIDtable[iLastAvailable].wDevBlkOffset);
; Line 901
	*** 00140b	8b 5e de 		mov	bx,WORD PTR [bp-34]	;iLastAvailable
	*** 00140e	c1 e3 04 		shl	bx,4
	*** 001411	26 8b 87 00 00 		mov	ax,WORD PTR es:_LIDtable[bx]
	*** 001416	03 46 fc 		add	ax,WORD PTR [bp-4]	;wBlockLen
	*** 001419	89 46 dc 		mov	WORD PTR [bp-36],ax	;wOffset
;|***           GetKernalData(wLID,wOffset,abyFileBuffer,(wBlockLen * (iIndex - iLastAvailable)));
; Line 902
	*** 00141c	8b 46 f4 		mov	ax,WORD PTR [bp-12]	;iIndex
	*** 00141f	2b 46 de 		sub	ax,WORD PTR [bp-34]	;iLastAvailable
	*** 001422	f7 66 fc 		mul	WORD PTR [bp-4]	;wBlockLen
	*** 001425	6a 00 			push	0
	*** 001427	50 			push	ax
	*** 001428	68 00 00 		push	SEG _abyFileBuffer
	*** 00142b	68 00 00 		push	OFFSET _abyFileBuffer
	*** 00142e	ff 76 dc 		push	WORD PTR [bp-36]	;wOffset
	*** 001431	ff 76 fe 		push	WORD PTR [bp-2]	;wLID
	*** 001434	9a 00 00 00 00 		call	FAR PTR _GetKernalData
	*** 001439	83 c4 0c 		add	sp,12
;|***           bDone = FALSE;
; Line 903
	*** 00143c	c7 46 ea 00 00 		mov	WORD PTR [bp-22],0	;bDone
;|***           pWord = (WORD *)&abyFileBuffer[wBlockLen * (iIndex - iLastAvailable - 1)];
; Line 904
	*** 001441	8b 46 f4 		mov	ax,WORD PTR [bp-12]	;iIndex
	*** 001444	2b 46 de 		sub	ax,WORD PTR [bp-34]	;iLastAvailable
	*** 001447	48 			dec	ax
	*** 001448	f7 66 fc 		mul	WORD PTR [bp-4]	;wBlockLen
	*** 00144b	05 00 00 		add	ax,OFFSET _abyFileBuffer
	*** 00144e	89 46 e0 		mov	WORD PTR [bp-32],ax	;pWord
	*** 001451	c7 46 e2 00 00 		mov	WORD PTR [bp-30],SEG _abyFileBuffer
;|***           while (!bDone)
; Line 905
					$FC2729:
	*** 001456	83 7e ea 00 		cmp	WORD PTR [bp-22],0	;bDone
	*** 00145a	74 03 			je	$JCC5210
	*** 00145c	e9 4b 00 		jmp	$FB2730
					$JCC5210:
;|***             {
; Line 906
;|***             wMaxCount = wBlockLen;
; Line 907
	*** 00145f	8b 46 fc 		mov	ax,WORD PTR [bp-4]	;wBlockLen
	*** 001462	89 46 ee 		mov	WORD PTR [bp-18],ax	;wMaxCount
;|***             while (*pWord != wBlockLen)
; Line 908
					$FC2732:
	*** 001465	8b 46 fc 		mov	ax,WORD PTR [bp-4]	;wBlockLen
	*** 001468	c4 5e e0 		les	bx,DWORD PTR [bp-32]	;pWord
	*** 00146b	26 39 07 		cmp	WORD PTR es:[bx],ax
	*** 00146e	75 03 			jne	$JCC5230
	*** 001470	e9 16 00 		jmp	$FB2733
					$JCC5230:
;|***               {
; Line 909
;|***               if (--wMaxCount == 0)
; Line 910
	*** 001473	ff 4e ee 		dec	WORD PTR [bp-18]	;wMaxCount
	*** 001476	83 7e ee 00 		cmp	WORD PTR [bp-18],0	;wMaxCount
	*** 00147a	74 03 			je	$JCC5242
	*** 00147c	e9 03 00 		jmp	$I2734
					$JCC5242:
;|***                 return;
; Line 911
	*** 00147f	e9 90 03 		jmp	$EX2693
;|***               pWord++;
; Line 912
					$I2734:
	*** 001482	83 46 e0 02 		add	WORD PTR [bp-32],2	;pWord
;|***               }
; Line 913
	*** 001486	e9 dc ff 		jmp	$FC2732
					$FB2733:
;|***             pstDevBlock = (DEVBLK *)pWord;
; Line 914
	*** 001489	8b 46 e0 		mov	ax,WORD PTR [bp-32]	;pWord
	*** 00148c	8b 56 e2 		mov	dx,WORD PTR [bp-30]
	*** 00148f	89 46 f8 		mov	WORD PTR [bp-8],ax	;pstDevBlock
	*** 001492	89 56 fa 		mov	WORD PTR [bp-6],dx
;|***             if (pstDevBlock->wDeviceID == ASYNC_DEVICE_ID)
; Line 915
	*** 001495	c4 5e f8 		les	bx,DWORD PTR [bp-8]	;pstDevBlock
	*** 001498	26 83 7f 06 06 		cmp	WORD PTR es:[bx+6],6
	*** 00149d	74 03 			je	$JCC5277
	*** 00149f	e9 05 00 		jmp	$I2735
					$JCC5277:
;|***               bDone = TRUE;
; Line 916
	*** 0014a2	c7 46 ea 01 00 		mov	WORD PTR [bp-22],1	;bDone
;|***             }
; Line 917
					$I2735:
	*** 0014a7	e9 ac ff 		jmp	$FC2729
					$FB2730:
;|***           LIDtable[iIndex].wBaseAddress = pstDevBlock->wDataArea;
; Line 918
	*** 0014aa	c4 5e f8 		les	bx,DWORD PTR [bp-8]	;pstDevBlock
	*** 0014ad	26 8b 47 0c 		mov	ax,WORD PTR es:[bx+12]
	*** 0014b1	8e 06 4a 00 		mov	es,WORD PTR $T20040
	*** 0014b5	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 0014b8	c1 e3 04 		shl	bx,4
	*** 0014bb	26 89 87 06 00 		mov	WORD PTR es:_LIDtable[bx+6],ax
;|***           }
; Line 919
;|***         }
; Line 920
					$I2727:
;|***       else
; Line 921
	*** 0014c0	e9 15 00 		jmp	$I2736
					$I2726:
;|***         {
; Line 922
;|***         if (iFirstAvailable == -1)
; Line 923
	*** 0014c3	83 7e f2 ff 		cmp	WORD PTR [bp-14],-1	;iFirstAvailable
	*** 0014c7	74 03 			je	$JCC5319
	*** 0014c9	e9 06 00 		jmp	$I2737
					$JCC5319:
;|***           iFirstAvailable = iIndex;
; Line 924
	*** 0014cc	8b 46 f4 		mov	ax,WORD PTR [bp-12]	;iIndex
	*** 0014cf	89 46 f2 		mov	WORD PTR [bp-14],ax	;iFirstAvailable
;|***         iLastAvailable = iIndex;
; Line 925
					$I2737:
	*** 0014d2	8b 46 f4 		mov	ax,WORD PTR [bp-12]	;iIndex
	*** 0014d5	89 46 de 		mov	WORD PTR [bp-34],ax	;iLastAvailable
;|***         }
; Line 926
					$I2736:
;|***       }
; Line 927
	*** 0014d8	e9 e8 fe 		jmp	$FC2724
					$FB2725:
;|***     if (iFirstAvailable > 0)
; Line 928
	*** 0014db	83 7e f2 00 		cmp	WORD PTR [bp-14],0	;iFirstAvailable
	*** 0014df	7f 03 			jg	$JCC5343
	*** 0014e1	e9 17 01 		jmp	$I2738
					$JCC5343:
;|***       {
; Line 929
;|***       wLID = LIDtable[iFirstAvailable].wLID;
; Line 930
	*** 0014e4	8e 06 4a 00 		mov	es,WORD PTR $T20040
	*** 0014e8	8b 5e f2 		mov	bx,WORD PTR [bp-14]	;iFirstAvailable
	*** 0014eb	c1 e3 04 		shl	bx,4
	*** 0014ee	26 8b 87 04 00 		mov	ax,WORD PTR es:_LIDtable[bx+4]
	*** 0014f3	89 46 fe 		mov	WORD PTR [bp-2],ax	;wLID
;|***       wBlockLen = LIDtable[iFirstAvailable].wBlockLen;
; Line 931
	*** 0014f6	8b 5e f2 		mov	bx,WORD PTR [bp-14]	;iFirstAvailable
	*** 0014f9	c1 e3 04 		shl	bx,4
	*** 0014fc	26 8b 87 02 00 		mov	ax,WORD PTR es:_LIDtable[bx+2]
	*** 001501	89 46 fc 		mov	WORD PTR [bp-4],ax	;wBlockLen
;|***       wOffset = LIDtable[iFirstAvailable].wDevBlkOffset;
; Line 932
	*** 001504	8b 5e f2 		mov	bx,WORD PTR [bp-14]	;iFirstAvailable
	*** 001507	c1 e3 04 		shl	bx,4
	*** 00150a	26 8b 87 00 00 		mov	ax,WORD PTR es:_LIDtable[bx]
	*** 00150f	89 46 dc 		mov	WORD PTR [bp-36],ax	;wOffset
;|***       wOffset -= ((wBlockLen * (iFirstAvailable + 1)) - 8);
; Line 933
	*** 001512	b8 ff ff 		mov	ax,-1
	*** 001515	2b 46 f2 		sub	ax,WORD PTR [bp-14]	;iFirstAvailable
	*** 001518	f7 66 fc 		mul	WORD PTR [bp-4]	;wBlockLen
	*** 00151b	05 08 00 		add	ax,8
	*** 00151e	01 46 dc 		add	WORD PTR [bp-36],ax	;wOffset
;|***       GetKernalData(wLID,wOffset,abyFileBuffer,(wBlockLen * (iFirstAvailable + 2)));
; Line 934
	*** 001521	8b 46 f2 		mov	ax,WORD PTR [bp-14]	;iFirstAvailable
	*** 001524	05 02 00 		add	ax,2
	*** 001527	f7 66 fc 		mul	WORD PTR [bp-4]	;wBlockLen
	*** 00152a	6a 00 			push	0
	*** 00152c	50 			push	ax
	*** 00152d	68 00 00 		push	SEG _abyFileBuffer
	*** 001530	68 00 00 		push	OFFSET _abyFileBuffer
	*** 001533	ff 76 dc 		push	WORD PTR [bp-36]	;wOffset
	*** 001536	ff 76 fe 		push	WORD PTR [bp-2]	;wLID
	*** 001539	9a 00 00 00 00 		call	FAR PTR _GetKernalData
	*** 00153e	83 c4 0c 		add	sp,12
;|***       pWord = (WORD *)abyFileBuffer;
; Line 935
	*** 001541	c7 46 e0 00 00 		mov	WORD PTR [bp-32],OFFSET _abyFileBuffer	;pWord
	*** 001546	c7 46 e2 00 00 		mov	WORD PTR [bp-30],SEG _abyFileBuffer
;|***       pWord--;
; Line 936
	*** 00154b	83 6e e0 02 		sub	WORD PTR [bp-32],2	;pWord
;|***       wMaxCount = (wBlockLen * 3);
; Line 937
	*** 00154f	8b 46 fc 		mov	ax,WORD PTR [bp-4]	;wBlockLen
	*** 001552	8b c8 			mov	cx,ax
	*** 001554	d1 e0 			shl	ax,1
	*** 001556	03 c1 			add	ax,cx
	*** 001558	89 46 ee 		mov	WORD PTR [bp-18],ax	;wMaxCount
;|***       for (iIndex = iFirstAvailable;iIndex > 0;iIndex--)
; Line 938
	*** 00155b	8b 46 f2 		mov	ax,WORD PTR [bp-14]	;iFirstAvailable
	*** 00155e	89 46 f4 		mov	WORD PTR [bp-12],ax	;iIndex
	*** 001561	e9 03 00 		jmp	$F2739
					$FC2740:
	*** 001564	ff 4e f4 		dec	WORD PTR [bp-12]	;iIndex
					$F2739:
	*** 001567	83 7e f4 00 		cmp	WORD PTR [bp-12],0	;iIndex
	*** 00156b	7f 03 			jg	$JCC5483
	*** 00156d	e9 8b 00 		jmp	$FB2741
					$JCC5483:
;|***         {
; Line 939
;|***         pWord++;
; Line 940
	*** 001570	83 46 e0 02 		add	WORD PTR [bp-32],2	;pWord
;|***         bDone = FALSE;
; Line 941
	*** 001574	c7 46 ea 00 00 		mov	WORD PTR [bp-22],0	;bDone
;|***         while (!bDone)
; Line 942
					$FC2743:
	*** 001579	83 7e ea 00 		cmp	WORD PTR [bp-22],0	;bDone
	*** 00157d	74 03 			je	$JCC5501
	*** 00157f	e9 57 00 		jmp	$FB2744
					$JCC5501:
;|***           {
; Line 943
;|***           while (*pWord != wBlockLen)
; Line 944
					$FC2746:
	*** 001582	8b 46 fc 		mov	ax,WORD PTR [bp-4]	;wBlockLen
	*** 001585	c4 5e e0 		les	bx,DWORD PTR [bp-32]	;pWord
	*** 001588	26 39 07 		cmp	WORD PTR es:[bx],ax
	*** 00158b	75 03 			jne	$JCC5515
	*** 00158d	e9 16 00 		jmp	$FB2747
					$JCC5515:
;|***             {
; Line 945
;|***             if (--wMaxCount == 0)
; Line 946
	*** 001590	ff 4e ee 		dec	WORD PTR [bp-18]	;wMaxCount
	*** 001593	83 7e ee 00 		cmp	WORD PTR [bp-18],0	;wMaxCount
	*** 001597	74 03 			je	$JCC5527
	*** 001599	e9 03 00 		jmp	$I2748
					$JCC5527:
;|***               return;
; Line 947
	*** 00159c	e9 73 02 		jmp	$EX2693
;|***             pWord++;
; Line 948
					$I2748:
	*** 00159f	83 46 e0 02 		add	WORD PTR [bp-32],2	;pWord
;|***             }
; Line 949
	*** 0015a3	e9 dc ff 		jmp	$FC2746
					$FB2747:
;|***           pstDevBlock = (DEVBLK *)pWord;
; Line 950
	*** 0015a6	8b 46 e0 		mov	ax,WORD PTR [bp-32]	;pWord
	*** 0015a9	8b 56 e2 		mov	dx,WORD PTR [bp-30]
	*** 0015ac	89 46 f8 		mov	WORD PTR [bp-8],ax	;pstDevBlock
	*** 0015af	89 56 fa 		mov	WORD PTR [bp-6],dx
;|***           if ((pstDevBlock->wDeviceID == ASYNC_DEVICE_ID) &&
;|***               (pstDevBlock->wLogicalID == (wLID - iIndex)))
; Line 952
	*** 0015b2	c4 5e f8 		les	bx,DWORD PTR [bp-8]	;pstDevBlock
	*** 0015b5	26 83 7f 06 06 		cmp	WORD PTR es:[bx+6],6
	*** 0015ba	74 03 			je	$JCC5562
	*** 0015bc	e9 17 00 		jmp	$I2749
					$JCC5562:
	*** 0015bf	c4 5e f8 		les	bx,DWORD PTR [bp-8]	;pstDevBlock
	*** 0015c2	26 8b 47 04 		mov	ax,WORD PTR es:[bx+4]
	*** 0015c6	03 46 f4 		add	ax,WORD PTR [bp-12]	;iIndex
	*** 0015c9	3b 46 fe 		cmp	ax,WORD PTR [bp-2]	;wLID
	*** 0015cc	74 03 			je	$JCC5580
	*** 0015ce	e9 05 00 		jmp	$I2749
					$JCC5580:
;|***             bDone = TRUE;
; Line 953
	*** 0015d1	c7 46 ea 01 00 		mov	WORD PTR [bp-22],1	;bDone
;|***           }
; Line 954
					$I2749:
	*** 0015d6	e9 a0 ff 		jmp	$FC2743
					$FB2744:
;|***         wMaxCount = wBlockLen;
; Line 955
	*** 0015d9	8b 46 fc 		mov	ax,WORD PTR [bp-4]	;wBlockLen
	*** 0015dc	89 46 ee 		mov	WORD PTR [bp-18],ax	;wMaxCount
;|***         LIDtable[iFirstAvailable - iIndex].wBaseAddress = pstDevBlock->wDataArea;
; Line 956
	*** 0015df	c4 5e f8 		les	bx,DWORD PTR [bp-8]	;pstDevBlock
	*** 0015e2	26 8b 47 0c 		mov	ax,WORD PTR es:[bx+12]
	*** 0015e6	8e 06 4a 00 		mov	es,WORD PTR $T20040
	*** 0015ea	8b 5e f2 		mov	bx,WORD PTR [bp-14]	;iFirstAvailable
	*** 0015ed	2b 5e f4 		sub	bx,WORD PTR [bp-12]	;iIndex
	*** 0015f0	c1 e3 04 		shl	bx,4
	*** 0015f3	26 89 87 06 00 		mov	WORD PTR es:_LIDtable[bx+6],ax
;|***         }
; Line 957
	*** 0015f8	e9 69 ff 		jmp	$FC2740
					$FB2741:
;|***       }
; Line 958
;|***     }
; Line 959
					$I2738:
;|***   for (iIndex = 0;iIndex < 8;iIndex++)
; Line 960
					$I2722:
	*** 0015fb	c7 46 f4 00 00 		mov	WORD PTR [bp-12],0	;iIndex
	*** 001600	e9 03 00 		jmp	$F2750
					$FC2751:
	*** 001603	ff 46 f4 		inc	WORD PTR [bp-12]	;iIndex
					$F2750:
	*** 001606	83 7e f4 08 		cmp	WORD PTR [bp-12],8	;iIndex
	*** 00160a	7c 03 			jl	$JCC5642
	*** 00160c	e9 31 00 		jmp	$FB2752
					$JCC5642:
;|***     {
; Line 961
;|***     if (LIDtable[iIndex].fFlags & LID_AVAILABLE)
; Line 962
	*** 00160f	8e 06 4a 00 		mov	es,WORD PTR $T20040
	*** 001613	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 001616	c1 e3 04 		shl	bx,4
	*** 001619	26 f6 87 0c 00 08 	test	BYTE PTR es:_LIDtable[bx+12],8
	*** 00161f	75 03 			jne	$JCC5663
	*** 001621	e9 19 00 		jmp	$I2753
					$JCC5663:
;|***       {
; Line 963
;|***       wLID = LIDtable[iIndex].wLID;
; Line 964
	*** 001624	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 001627	c1 e3 04 		shl	bx,4
	*** 00162a	26 8b 87 04 00 		mov	ax,WORD PTR es:_LIDtable[bx+4]
	*** 00162f	89 46 fe 		mov	WORD PTR [bp-2],ax	;wLID
;|***       FreeLIDentry(wLID);
; Line 965
	*** 001632	ff 76 fe 		push	WORD PTR [bp-2]	;wLID
	*** 001635	9a 00 00 00 00 		call	FAR PTR _FreeLIDentry
	*** 00163a	83 c4 02 		add	sp,2
;|***       }
; Line 966
;|***     }
; Line 967
					$I2753:
	*** 00163d	e9 c3 ff 		jmp	$FC2751
					$FB2752:
;|***   if (iLIDcount > 0)
; Line 968
	*** 001640	83 3e 54 0e 00 		cmp	WORD PTR _iLIDcount,0
	*** 001645	7f 03 			jg	$JCC5701
	*** 001647	e9 c8 01 		jmp	$I2754
					$JCC5701:
;|***     {
; Line 969
;|*** //_asm INT 3
;|***     for (iIndex = 0;iIndex < iLIDcount;iIndex++)
; Line 971
	*** 00164a	c7 46 f4 00 00 		mov	WORD PTR [bp-12],0	;iIndex
	*** 00164f	e9 03 00 		jmp	$F2755
					$FC2756:
	*** 001652	ff 46 f4 		inc	WORD PTR [bp-12]	;iIndex
					$F2755:
	*** 001655	a1 54 0e 		mov	ax,WORD PTR _iLIDcount
	*** 001658	39 46 f4 		cmp	WORD PTR [bp-12],ax	;iIndex
	*** 00165b	7c 03 			jl	$JCC5723
	*** 00165d	e9 49 00 		jmp	$FB2757
					$JCC5723:
;|***       {
; Line 972
;|***       sprintf(_szName,0,"COM%d    ",(iIndex + 1));
; Line 973
	*** 001660	8b 46 f4 		mov	ax,WORD PTR [bp-12]	;iIndex
	*** 001663	40 			inc	ax
	*** 001664	50 			push	ax
	*** 001665	1e 			push	ds
	*** 001666	68 49 0e 		push	OFFSET DGROUP:$SG2758
	*** 001669	6a 00 			push	0
	*** 00166b	68 00 00 		push	SEG __szName
	*** 00166e	68 00 00 		push	OFFSET __szName
	*** 001671	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 001676	83 c4 0c 		add	sp,12
;|***       if (AttachDD(_szName,&_stAttachDD) == DRIVER_ATTACHED)
; Line 974
	*** 001679	68 00 00 		push	SEG __stAttachDD
	*** 00167c	68 00 00 		push	OFFSET __stAttachDD
	*** 00167f	68 00 00 		push	SEG __szName
	*** 001682	68 00 00 		push	OFFSET __szName
	*** 001685	9a 00 00 00 00 		call	FAR PTR _AttachDD
	*** 00168a	83 c4 08 		add	sp,8
	*** 00168d	3d 00 00 		cmp	ax,0
	*** 001690	74 03 			je	$JCC5776
	*** 001692	e9 11 00 		jmp	$I2759
					$JCC5776:
;|***         LIDtable[iIndex].bNameTaken = TRUE;
; Line 975
	*** 001695	8e 06 4a 00 		mov	es,WORD PTR $T20040
	*** 001699	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 00169c	c1 e3 04 		shl	bx,4
	*** 00169f	26 c7 87 0a 00 01 00 	mov	WORD PTR es:_LIDtable[bx+10],1
;|***       }
; Line 976
					$I2759:
	*** 0016a6	e9 a9 ff 		jmp	$FC2756
					$FB2757:
;|***     iIndex = 0;
; Line 977
	*** 0016a9	c7 46 f4 00 00 		mov	WORD PTR [bp-12],0	;iIndex
;|***     while (iIndex < (CCHMAXPATH - 8))
; Line 978
					$FC2761:
	*** 0016ae	81 7e f4 fc 00 		cmp	WORD PTR [bp-12],252	;iIndex
	*** 0016b3	7c 03 			jl	$JCC5811
	*** 0016b5	e9 30 00 		jmp	$FB2762
					$JCC5811:
;|***       {
; Line 979
;|***       if (_abyPath[iIndex] == ' ')
; Line 980
	*** 0016b8	8e 06 08 00 		mov	es,WORD PTR $T20004
	*** 0016bc	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 0016bf	26 80 bf 00 00 20 	cmp	BYTE PTR es:__abyPath[bx],32
	*** 0016c5	74 03 			je	$JCC5829
	*** 0016c7	e9 03 00 		jmp	$I2763
					$JCC5829:
;|***         break;
; Line 981
	*** 0016ca	e9 1b 00 		jmp	$FB2762
;|***       if (_abyPath[iIndex] == 0)
; Line 982
					$I2763:
	*** 0016cd	8e 06 08 00 		mov	es,WORD PTR $T20004
	*** 0016d1	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 0016d4	26 80 bf 00 00 00 	cmp	BYTE PTR es:__abyPath[bx],0
	*** 0016da	74 03 			je	$JCC5850
	*** 0016dc	e9 03 00 		jmp	$I2764
					$JCC5850:
;|***         break;
; Line 983
	*** 0016df	e9 06 00 		jmp	$FB2762
;|***       iIndex++;
; Line 984
					$I2764:
	*** 0016e2	ff 46 f4 		inc	WORD PTR [bp-12]	;iIndex
;|***       }
; Line 985
	*** 0016e5	e9 c6 ff 		jmp	$FC2761
					$FB2762:
;|***     while (_abyPath[iIndex] != '.')
; Line 986
					$FC2766:
	*** 0016e8	8e 06 08 00 		mov	es,WORD PTR $T20004
	*** 0016ec	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 0016ef	26 80 bf 00 00 2e 	cmp	BYTE PTR es:__abyPath[bx],46
	*** 0016f5	75 03 			jne	$JCC5877
	*** 0016f7	e9 30 00 		jmp	$FB2767
					$JCC5877:
;|***       if (iIndex-- == 0)
; Line 987
	*** 0016fa	8b 46 f4 		mov	ax,WORD PTR [bp-12]	;iIndex
	*** 0016fd	ff 4e f4 		dec	WORD PTR [bp-12]	;iIndex
	*** 001700	3d 00 00 		cmp	ax,0
	*** 001703	74 03 			je	$JCC5891
	*** 001705	e9 1f 00 		jmp	$I2768
					$JCC5891:
;|***         {
; Line 988
;|***         VioWrtTTY(chFailedBadPath,StringLength(chFailedBadPath),0);
; Line 989
	*** 001708	68 00 00 		push	SEG _chFailedBadPath
	*** 00170b	68 00 00 		push	OFFSET _chFailedBadPath
	*** 00170e	68 00 00 		push	SEG _chFailedBadPath
	*** 001711	68 00 00 		push	OFFSET _chFailedBadPath
	*** 001714	9a 00 00 00 00 		call	FAR PTR _StringLength
	*** 001719	83 c4 04 		add	sp,4
	*** 00171c	50 			push	ax
	*** 00171d	6a 00 			push	0
	*** 00171f	9a 00 00 00 00 		call	FAR PTR VIO16WRTTTY
;|***         return;
; Line 990
	*** 001724	e9 eb 00 		jmp	$EX2693
;|***         }
; Line 991
;|***     wSaveExt = ++iIndex;
; Line 992
					$I2768:
	*** 001727	e9 be ff 		jmp	$FC2766
					$FB2767:
	*** 00172a	ff 46 f4 		inc	WORD PTR [bp-12]	;iIndex
	*** 00172d	8b 46 f4 		mov	ax,WORD PTR [bp-12]	;iIndex
	*** 001730	89 46 ec 		mov	WORD PTR [bp-20],ax	;wSaveExt
;|***     abySaveExt[0] = _abyPath[iIndex];
; Line 993
	*** 001733	8e 06 08 00 		mov	es,WORD PTR $T20004
	*** 001737	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 00173a	26 8a 87 00 00 		mov	al,BYTE PTR es:__abyPath[bx]
	*** 00173f	88 46 e4 		mov	BYTE PTR [bp-28],al	;abySaveExt
;|***     _abyPath[iIndex] = 'M';
; Line 994
	*** 001742	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 001745	26 c6 87 00 00 4d 	mov	BYTE PTR es:__abyPath[bx],77
;|***     abySaveExt[1] = _abyPath[++iIndex];
; Line 995
	*** 00174b	ff 46 f4 		inc	WORD PTR [bp-12]	;iIndex
	*** 00174e	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 001751	26 8a 87 00 00 		mov	al,BYTE PTR es:__abyPath[bx]
	*** 001756	88 46 e5 		mov	BYTE PTR [bp-27],al
;|***     _abyPath[iIndex] = 'A';
; Line 996
	*** 001759	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 00175c	26 c6 87 00 00 41 	mov	BYTE PTR es:__abyPath[bx],65
;|***     abySaveExt[2] = _abyPath[++iIndex];
; Line 997
	*** 001762	ff 46 f4 		inc	WORD PTR [bp-12]	;iIndex
	*** 001765	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 001768	26 8a 87 00 00 		mov	al,BYTE PTR es:__abyPath[bx]
	*** 00176d	88 46 e6 		mov	BYTE PTR [bp-26],al
;|***     _abyPath[iIndex] = 'P';
; Line 998
	*** 001770	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 001773	26 c6 87 00 00 50 	mov	BYTE PTR es:__abyPath[bx],80
;|***     abySaveExt[3] = _abyPath[++iIndex];
; Line 999
	*** 001779	ff 46 f4 		inc	WORD PTR [bp-12]	;iIndex
	*** 00177c	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 00177f	26 8a 87 00 00 		mov	al,BYTE PTR es:__abyPath[bx]
	*** 001784	88 46 e7 		mov	BYTE PTR [bp-25],al
;|***     _abyPath[iIndex] = 0;
; Line 1000
	*** 001787	8b 5e f4 		mov	bx,WORD PTR [bp-12]	;iIndex
	*** 00178a	26 c6 87 00 00 00 	mov	BYTE PTR es:__abyPath[bx],0
;|***     if (DosOpen(_abyPath,&hFile,&ulAction,0L,0,0x0012,0x1012,0L) == 0)
; Line 1001
	*** 001790	06 			push	es
	*** 001791	68 00 00 		push	OFFSET __abyPath
	*** 001794	1e 			push	ds
	*** 001795	68 ea 0d 		push	OFFSET DGROUP:_hFile
	*** 001798	8d 46 da 		lea	ax,WORD PTR [bp-38]	;ulAction
	*** 00179b	16 			push	ss
	*** 00179c	50 			push	ax
	*** 00179d	6a 00 			push	0
	*** 00179f	6a 00 			push	0
	*** 0017a1	6a 00 			push	0
	*** 0017a3	6a 12 			push	18
	*** 0017a5	68 12 10 		push	4114
	*** 0017a8	6a 00 			push	0
	*** 0017aa	6a 00 			push	0
	*** 0017ac	9a 00 00 00 00 		call	FAR PTR DOS16OPEN
	*** 0017b1	3d 00 00 		cmp	ax,0
	*** 0017b4	74 03 			je	$JCC6068
	*** 0017b6	e9 20 00 		jmp	$I2769
					$JCC6068:
;|***       {
; Line 1002
;|***       DosWrite(hFile,&LIDtable,(sizeof(LIDTAB) * 8),&ulCount);
; Line 1003
	*** 0017b9	ff 36 ea 0d 		push	WORD PTR _hFile
	*** 0017bd	68 00 00 		push	SEG _LIDtable
	*** 0017c0	68 00 00 		push	OFFSET _LIDtable
	*** 0017c3	68 80 00 		push	128
	*** 0017c6	8d 46 e8 		lea	ax,WORD PTR [bp-24]	;ulCount
	*** 0017c9	16 			push	ss
	*** 0017ca	50 			push	ax
	*** 0017cb	9a 00 00 00 00 		call	FAR PTR DOS16WRITE
;|***       DosClose(hFile);
; Line 1004
	*** 0017d0	ff 36 ea 0d 		push	WORD PTR _hFile
	*** 0017d4	9a 00 00 00 00 		call	FAR PTR DOS16CLOSE
;|***       }
; Line 1005
;|***     _abyPath[wSaveExt++] = abySaveExt[0];
; Line 1006
					$I2769:
	*** 0017d9	8a 46 e4 		mov	al,BYTE PTR [bp-28]	;abySaveExt
	*** 0017dc	8e 06 08 00 		mov	es,WORD PTR $T20004
	*** 0017e0	8b 5e ec 		mov	bx,WORD PTR [bp-20]	;wSaveExt
	*** 0017e3	26 88 87 00 00 		mov	BYTE PTR es:__abyPath[bx],al
	*** 0017e8	ff 46 ec 		inc	WORD PTR [bp-20]	;wSaveExt
;|***     _abyPath[wSaveExt++] = abySaveExt[1];
; Line 1007
	*** 0017eb	8a 46 e5 		mov	al,BYTE PTR [bp-27]
	*** 0017ee	8b 5e ec 		mov	bx,WORD PTR [bp-20]	;wSaveExt
	*** 0017f1	26 88 87 00 00 		mov	BYTE PTR es:__abyPath[bx],al
	*** 0017f6	ff 46 ec 		inc	WORD PTR [bp-20]	;wSaveExt
;|***     _abyPath[wSaveExt++] = abySaveExt[2];
; Line 1008
	*** 0017f9	8a 46 e6 		mov	al,BYTE PTR [bp-26]
	*** 0017fc	8b 5e ec 		mov	bx,WORD PTR [bp-20]	;wSaveExt
	*** 0017ff	26 88 87 00 00 		mov	BYTE PTR es:__abyPath[bx],al
	*** 001804	ff 46 ec 		inc	WORD PTR [bp-20]	;wSaveExt
;|***     _abyPath[wSaveExt] = abySaveExt[3];
; Line 1009
	*** 001807	8a 46 e7 		mov	al,BYTE PTR [bp-25]
	*** 00180a	8b 5e ec 		mov	bx,WORD PTR [bp-20]	;wSaveExt
	*** 00180d	26 88 87 00 00 		mov	BYTE PTR es:__abyPath[bx],al
;|***     }
; Line 1010
;|***   }
; Line 1011
					$I2754:
					$EX2693:
	*** 001812	5e 			pop	si
	*** 001813	5f 			pop	di
	*** 001814	c9 			leave	
	*** 001815	cb 			ret	

_BuildLIDtable	ENDP
;|*** 
;|*** void _far LoadHeadersFromABIOStable(void)
;|***   {
; Line 1014
	PUBLIC	_LoadHeadersFromABIOStable
_LoadHeadersFromABIOStable	PROC FAR
	*** 001816	c8 04 00 00 		enter	4,0
	*** 00181a	57 			push	di
	*** 00181b	56 			push	si
;	iIndex = -2
;	wMaxDevice = -4
;|***   int iIndex;
;|***   WORD wMaxDevice;
;|*** 
;|***   if (_wMaxDeviceCount == 0)
; Line 1018
	*** 00181c	8e 06 1e 00 		mov	es,WORD PTR $T20016
	*** 001820	26 83 3e 00 00 00 	cmp	WORD PTR es:__wMaxDeviceCount,0
	*** 001826	74 03 			je	$JCC6182
	*** 001828	e9 08 00 		jmp	$I2774
					$JCC6182:
;|***     wMaxDevice = 8;
; Line 1019
	*** 00182b	c7 46 fc 08 00 		mov	WORD PTR [bp-4],8	;wMaxDevice
;|***   else
; Line 1020
	*** 001830	e9 0b 00 		jmp	$I2775
					$I2774:
;|***     wMaxDevice = _wMaxDeviceCount;
; Line 1021
	*** 001833	8e 06 1e 00 		mov	es,WORD PTR $T20016
	*** 001837	26 a1 00 00 		mov	ax,WORD PTR es:__wMaxDeviceCount
	*** 00183b	89 46 fc 		mov	WORD PTR [bp-4],ax	;wMaxDevice
					$I2775:
;|***   pDeviceParms = (DEVDEF _far *)_stDeviceParms;
; Line 1022
	*** 00183e	c7 06 ec 0d 00 00 	mov	WORD PTR _pDeviceParms,OFFSET __stDeviceParms
	*** 001844	c7 06 ee 0d 00 00 	mov	WORD PTR _pDeviceParms+2,SEG __stDeviceParms
;|***   wDeviceStrategy = (WORD)&_pDeviceStrategy;
; Line 1023
	*** 00184a	c7 06 f8 0d 00 00 	mov	WORD PTR _wDeviceStrategy,OFFSET __pDeviceStrategy
;|***   pStart = &pDeviceParms->stDeviceHeader;
; Line 1024
	*** 001850	a1 ec 0d 		mov	ax,WORD PTR _pDeviceParms
	*** 001853	8b 16 ee 0d 		mov	dx,WORD PTR _pDeviceParms+2
	*** 001857	05 a4 00 		add	ax,164
	*** 00185a	a3 f0 0d 		mov	WORD PTR _pStart,ax
	*** 00185d	89 16 f2 0d 		mov	WORD PTR _pStart+2,dx
;|***   pPrevious = &_stDummyHeader;
; Line 1025
	*** 001861	c7 06 f4 0d 00 00 	mov	WORD PTR _pPrevious,OFFSET __stDummyHeader
	*** 001867	c7 06 f6 0d 00 00 	mov	WORD PTR _pPrevious+2,SEG __stDummyHeader
;|***   for (iIndex = 0;iIndex < iLIDcount;iIndex++)
; Line 1026
	*** 00186d	c7 46 fe 00 00 		mov	WORD PTR [bp-2],0	;iIndex
	*** 001872	e9 03 00 		jmp	$F2776
					$FC2777:
	*** 001875	ff 46 fe 		inc	WORD PTR [bp-2]	;iIndex
					$F2776:
	*** 001878	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;iIndex
	*** 00187b	39 06 54 0e 		cmp	WORD PTR _iLIDcount,ax
	*** 00187f	7f 03 			jg	$JCC6271
	*** 001881	e9 5d 01 		jmp	$FB2778
					$JCC6271:
;|***     {
; Line 1027
;|***     if (LIDtable[iIndex].fFlags & LID_DOES_NOT_EXIST)
; Line 1028
	*** 001884	8e 06 4a 00 		mov	es,WORD PTR $T20040
	*** 001888	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;iIndex
	*** 00188b	c1 e3 04 		shl	bx,4
	*** 00188e	26 f6 87 0c 00 02 	test	BYTE PTR es:_LIDtable[bx+12],2
	*** 001894	75 03 			jne	$JCC6292
	*** 001896	e9 03 00 		jmp	$I2779
					$JCC6292:
;|***       break;
; Line 1029
	*** 001899	e9 45 01 		jmp	$FB2778
;|***     if ((LIDtable[iIndex].fFlags & LID_ALREADY_OWNED) == 0)
; Line 1030
					$I2779:
	*** 00189c	8e 06 4a 00 		mov	es,WORD PTR $T20040
	*** 0018a0	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;iIndex
	*** 0018a3	c1 e3 04 		shl	bx,4
	*** 0018a6	26 f6 87 0c 00 01 	test	BYTE PTR es:_LIDtable[bx+12],1
	*** 0018ac	74 03 			je	$JCC6316
	*** 0018ae	e9 2d 01 		jmp	$I2780
					$JCC6316:
;|***       {
; Line 1031
;|***       sprintf(_szName,0,"COM%u    ",(iIndex + 1));
; Line 1032
	*** 0018b1	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;iIndex
	*** 0018b4	40 			inc	ax
	*** 0018b5	50 			push	ax
	*** 0018b6	1e 			push	ds
	*** 0018b7	68 56 0e 		push	OFFSET DGROUP:$SG2781
	*** 0018ba	6a 00 			push	0
	*** 0018bc	68 00 00 		push	SEG __szName
	*** 0018bf	68 00 00 		push	OFFSET __szName
	*** 0018c2	9a 00 00 00 00 		call	FAR PTR _sprintf
	*** 0018c7	83 c4 0c 		add	sp,12
;|***       MemCopy(pDeviceParms->stDeviceHeader.abyDeviceName,_szName,8);
; Line 1033
	*** 0018ca	6a 08 			push	8
	*** 0018cc	68 00 00 		push	SEG __szName
	*** 0018cf	68 00 00 		push	OFFSET __szName
	*** 0018d2	a1 ec 0d 		mov	ax,WORD PTR _pDeviceParms
	*** 0018d5	8b 16 ee 0d 		mov	dx,WORD PTR _pDeviceParms+2
	*** 0018d9	05 ae 00 		add	ax,174
	*** 0018dc	52 			push	dx
	*** 0018dd	50 			push	ax
	*** 0018de	9a 00 00 00 00 		call	FAR PTR _MemCopy
	*** 0018e3	83 c4 0a 		add	sp,10
;|***       if (!LIDtable[iIndex].bNameTaken)
; Line 1034
	*** 0018e6	8e 06 4a 00 		mov	es,WORD PTR $T20040
	*** 0018ea	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;iIndex
	*** 0018ed	c1 e3 04 		shl	bx,4
	*** 0018f0	26 83 bf 0a 00 00 	cmp	WORD PTR es:_LIDtable[bx+10],0
	*** 0018f6	74 03 			je	$JCC6390
	*** 0018f8	e9 e3 00 		jmp	$I2782
					$JCC6390:
;|***         {
; Line 1035
;|***         abyCOMnumbers[wLoadCount] = (BYTE)(iIndex + 1);
; Line 1036
	*** 0018fb	8a 46 fe 		mov	al,BYTE PTR [bp-2]	;iIndex
	*** 0018fe	fe c0 			inc	al
	*** 001900	8e 06 06 00 		mov	es,WORD PTR $T20003
	*** 001904	26 8b 1e 00 00 		mov	bx,WORD PTR es:_wLoadCount
	*** 001909	8e 06 3e 00 		mov	es,WORD PTR $T20032
	*** 00190d	26 88 87 00 00 		mov	BYTE PTR es:_abyCOMnumbers[bx],al
;|***         stConfigParms[wLoadCount].wIObaseAddress = LIDtable[iIndex].wBaseAddress;
; Line 1037
	*** 001912	8e 06 4a 00 		mov	es,WORD PTR $T20040
	*** 001916	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;iIndex
	*** 001919	c1 e3 04 		shl	bx,4
	*** 00191c	26 8b 87 06 00 		mov	ax,WORD PTR es:_LIDtable[bx+6]
	*** 001921	8e 06 06 00 		mov	es,WORD PTR $T20003
	*** 001925	26 6b 1e 00 00 2a 	imul	bx,WORD PTR es:_wLoadCount,42
	*** 00192b	8e 06 4c 00 		mov	es,WORD PTR $T20041
	*** 00192f	26 89 87 06 00 		mov	WORD PTR es:_stConfigParms[bx+6],ax
;|***         stConfigParms[wLoadCount].byInterruptLevel = LIDtable[iIndex].byInterruptLevel;
; Line 1038
	*** 001934	8e 06 4a 00 		mov	es,WORD PTR $T20040
	*** 001938	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;iIndex
	*** 00193b	c1 e3 04 		shl	bx,4
	*** 00193e	26 8a 87 0d 00 		mov	al,BYTE PTR es:_LIDtable[bx+13]
	*** 001943	8e 06 06 00 		mov	es,WORD PTR $T20003
	*** 001947	26 6b 1e 00 00 2a 	imul	bx,WORD PTR es:_wLoadCount,42
	*** 00194d	8e 06 4c 00 		mov	es,WORD PTR $T20041
	*** 001951	26 88 87 20 00 		mov	BYTE PTR es:_stConfigParms[bx+32],al
;|***         astInstallParms[wLoadCount].wLID = LIDtable[iIndex].wDeviceNumber;
; Line 1039
	*** 001956	8e 06 4a 00 		mov	es,WORD PTR $T20040
	*** 00195a	8b 5e fe 		mov	bx,WORD PTR [bp-2]	;iIndex
	*** 00195d	c1 e3 04 		shl	bx,4
	*** 001960	26 8b 87 08 00 		mov	ax,WORD PTR es:_LIDtable[bx+8]
	*** 001965	8e 06 06 00 		mov	es,WORD PTR $T20003
	*** 001969	26 8b 1e 00 00 		mov	bx,WORD PTR es:_wLoadCount
	*** 00196e	d1 e3 			shl	bx,1
_TEXT      ENDS
CONST      SEGMENT
$T20044	DW SEG _astInstallParms 
CONST      ENDS
_TEXT      SEGMENT
	ASSUME	CS: _TEXT
	*** 001970	8e 06 52 00 		mov	es,WORD PTR $T20044
	*** 001974	26 89 87 00 00 		mov	WORD PTR es:_astInstallParms[bx],ax
;|***         pDeviceParms->stDeviceHeader.StrategyOffset = wDeviceStrategy;
; Line 1040
	*** 001979	a1 f8 0d 		mov	ax,WORD PTR _wDeviceStrategy
	*** 00197c	c4 1e ec 0d 		les	bx,DWORD PTR _pDeviceParms
	*** 001980	26 89 87 aa 00 		mov	WORD PTR es:[bx+170],ax
;|***         pPrevious->pNextHeader = &pDeviceParms->stDeviceHeader;
; Line 1041
	*** 001985	a1 ec 0d 		mov	ax,WORD PTR _pDeviceParms
	*** 001988	8b 16 ee 0d 		mov	dx,WORD PTR _pDeviceParms+2
	*** 00198c	05 a4 00 		add	ax,164
	*** 00198f	c4 1e f4 0d 		les	bx,DWORD PTR _pPrevious
	*** 001993	26 89 07 		mov	WORD PTR es:[bx],ax
	*** 001996	26 89 57 02 		mov	WORD PTR es:[bx+2],dx
;|***         pPrevious = &pDeviceParms->stDeviceHeader;
; Line 1042
	*** 00199a	a1 ec 0d 		mov	ax,WORD PTR _pDeviceParms
	*** 00199d	8b 16 ee 0d 		mov	dx,WORD PTR _pDeviceParms+2
	*** 0019a1	05 a4 00 		add	ax,164
	*** 0019a4	a3 f4 0d 		mov	WORD PTR _pPrevious,ax
	*** 0019a7	89 16 f6 0d 		mov	WORD PTR _pPrevious+2,dx
;|***         pPrevious->pNextHeader = (VOID *)-1;
; Line 1043
	*** 0019ab	c4 1e f4 0d 		les	bx,DWORD PTR _pPrevious
	*** 0019af	26 c7 07 ff ff 		mov	WORD PTR es:[bx],-1
	*** 0019b4	26 c7 47 02 ff ff 	mov	WORD PTR es:[bx+2],-1
;|***         pDeviceParms++;
; Line 1044
	*** 0019ba	81 06 ec 0d be 00 	add	WORD PTR _pDeviceParms,190
;|***         wDeviceStrategy += 6;
; Line 1045
	*** 0019c0	83 06 f8 0d 06 		add	WORD PTR _wDeviceStrategy,6
;|***         if (++wLoadCount >= wMaxDevice)
; Line 1046
	*** 0019c5	8b 46 fc 		mov	ax,WORD PTR [bp-4]	;wMaxDevice
	*** 0019c8	8e 06 06 00 		mov	es,WORD PTR $T20003
	*** 0019cc	26 ff 06 00 00 		inc	WORD PTR es:_wLoadCount
	*** 0019d1	26 39 06 00 00 		cmp	WORD PTR es:_wLoadCount,ax
	*** 0019d6	73 03 			jae	$JCC6614
	*** 0019d8	e9 03 00 		jmp	$I2783
					$JCC6614:
;|***           break;
; Line 1047
	*** 0019db	e9 03 00 		jmp	$FB2778
;|***         }
; Line 1048
					$I2783:
;|***       }
; Line 1049
					$I2782:
;|***     }
; Line 1050
					$I2780:
	*** 0019de	e9 94 fe 		jmp	$FC2777
					$FB2778:
;|***   if (wLoadCount > 0)
; Line 1051
	*** 0019e1	8e 06 06 00 		mov	es,WORD PTR $T20003
	*** 0019e5	26 83 3e 00 00 00 	cmp	WORD PTR es:_wLoadCount,0
	*** 0019eb	77 03 			ja	$JCC6635
	*** 0019ed	e9 1a 00 		jmp	$I2784
					$JCC6635:
;|***     {
; Line 1052
;|***     pDeviceParms--;
; Line 1053
	*** 0019f0	81 2e ec 0d be 00 	sub	WORD PTR _pDeviceParms,190
;|*** //    pDeviceParms->stDeviceHeader.sCodeSegment = 0xffff;
;|***     _stDummyHeader.pNextHeader = pStart;
; Line 1055
	*** 0019f6	a1 f0 0d 		mov	ax,WORD PTR _pStart
	*** 0019f9	8b 16 f2 0d 		mov	dx,WORD PTR _pStart+2
	*** 0019fd	8e 06 46 00 		mov	es,WORD PTR $T20038
	*** 001a01	26 a3 00 00 		mov	WORD PTR es:__stDummyHeader,ax
	*** 001a05	26 89 16 02 00 		mov	WORD PTR es:__stDummyHeader+2,dx
;|***     }
; Line 1056
;|*** //  else
;|*** //    _stDummyHeader.sCodeSegment = -1;
;|***   _wEndOfData = ((WORD)_stDeviceParms + (wLoadCount * sizeof(DEVDEF)));
; Line 1059
					$I2784:
	*** 001a0a	8e 06 06 00 		mov	es,WORD PTR $T20003
	*** 001a0e	26 69 06 00 00 be 00 	imul	ax,WORD PTR es:_wLoadCount,190
	*** 001a15	05 00 00 		add	ax,OFFSET __stDeviceParms
	*** 001a18	8e 06 40 00 		mov	es,WORD PTR $T20033
	*** 001a1c	26 a3 00 00 		mov	WORD PTR es:__wEndOfData,ax
;|***   }
; Line 1060
					$EX2771:
	*** 001a20	5e 			pop	si
	*** 001a21	5f 			pop	di
	*** 001a22	c9 			leave	
	*** 001a23	cb 			ret	

_LoadHeadersFromABIOStable	ENDP
_TEXT	ENDS
END
;|*** 
;|*** #ifdef this_junk
;|*** WORD CopyDeviceBlocks(WORD *pwBlockLen)
;|***   {
;|***   int iIndex;
;|***   int iFirstIndex;
;|***   WORD wBlockLen = 0;
;|***   WORD wStartOffset;
;|***   WORD wOffset = 0;
;|***   WORD wFirstLID;
;|***   WORD wError;
;|***   WORD wLIDcount = 0;
;|***   WORD wTableSize = 0;
;|***   WORD wByteIndex;
;|***   int iLastIndex;
;|*** 
;|***   for (iIndex = 0;iIndex < wMaxDevice;iIndex++)
;|***     {
;|***     wLIDcount++;
;|***     wLID = iIndex + 1;
;|***     if ((wError = GetLIDentry(&wLID)) == NO_ERROR)
;|***       {
;|***       wBlockLen = GetDeviceBlockLen(wLID);
;|***       wStartOffset = GetDeviceBlockOffset(wLID);
;|***       break;
;|***       }
;|***     else
;|***       if (wError == ERROR_LID_DOES_NOT_EXIST)
;|***         {
;|***         wLIDcount--;
;|***         break;
;|***         }
;|***     }
;|***   if (wStartOffset != 0)
;|***     {
;|***     wFirstLID = wLID;
;|***     iFirstIndex = iIndex++;
;|***     for (;iIndex < 8;iIndex++)
;|***       {
;|***       wLID = iIndex + 1;
;|***       wLIDcount++;
;|***       if ((wError = GetLIDentry(&wLID)) == NO_ERROR)
;|***         {
;|***         wOffset = GetDeviceBlockOffset(wLID);
;|***         FreeLIDentry(wLID);
;|***         break;
;|***         }
;|***       else
;|***         if (wError == ERROR_LID_DOES_NOT_EXIST)
;|***           {
;|***           wLIDcount--;
;|***           break;
;|***           }
;|***       }
;|***     if (wOffset != 0)
;|***       {
;|***       wBlockLen = ((wOffset - wStartOffset) / (iIndex - iFirstIndex));
;|***       wOffset = (wStartOffset - (iFirstIndex * wBlockLen));
;|***       GetKernalData(wFirstLID,wOffset,abyFileBuffer,(wBlockLen * 8));
;|***       FreeLIDentry(wFirstLID);
;|***       }
;|***     else
;|***       {
;|***       iLastIndex = iIndex;
;|***       wTableSize = GetKernalData(wFirstLID,0,abyFileBuffer,0xffff);
;|***       if (wFirstIndex == 0)
;|***         {
;|***         if (wLIDcount == 1)
;|***           wBlockLen = GetDeviceBlockLen(wFirstLID);
;|***         else
;|***           {
;|***           wCurrentAddress = GetDeviceAddress(wFirstLID);
;|***           for (iIndex = 0;iIndex < 8;iIndex++)
;|***             if (wCurrentAddress == astMCAportTable[iIndex]
;|***               {
;|***               iIndex++;
;|***               break;
;|***               }
;|***           if ((wBlockSize * 9) < wTableSize)
;|***             wTableSize = (wBlockSize * 9);
;|***           for (;iIndex < 8;iIndex++)
;|***             {
;|***             wSearchAddress = astMCAportTable[iIndex]
;|***             for (wByteIndex = wStartOffset;wByteIndex < wTableSize;wByteIndex++)
;|***               {
;|***               if ((abyFileBuffer[wByteIndex] == wSearchAddress) &&
;|***                   (abyFileBuffer[wByteIndex - 0x000c] == wBlockLen) &&
;|***                   (abyFileBuffer[wByteIndex - 0x0008] == ASYNC_DEVICE_ID))
;|***                 {
;|***                 wBlockLen = (wByteIndex - 0x000c - wStartOffset);
;|***                 GetKernalData(wFirstLID,wStartOffset,abyFileBuffer,(wBlockLen * 8));
;|***                 FreeLIDentry(wFirstLID);
;|***                 break;
;|***                 }
;|***               }
;|***             }
;|***           }
;|***         }
;|***       else
;|***         {
;|***         }
;|***       }
;|***     }
;|***   *pwBlockLen = wBlockLen;
;|***   return(wLIDcount);
;|***   }
;|*** #endif
;|*** #endif /* RTEST */
;|*** #endif /* x16_BIT */
