Microsoft (R) Macro Assembler Version 6.00     		    08/24/02 23:27:14
INIT.asm						     Page 1 - 1


				;************************************************************************
				;
				; $Revision:   1.1  $
				;
				; $Log:   P:/archive/comi/INIT.ASv  $
				;
				;     Rev 1.1   28 Mar 1996 00:19:18   EMMETT
				;  Added resource manager.  Began work on VDD support.
				;
				;     Rev 1.0   19 Feb 1996 11:03:06   EMMETT
				;
				;
				;     Rev 1.8   18 Feb 1996 14:18:04   EMMETT
				;  Added many features.  Notably:
				;  Tracing application DosDevIOCtl function calls and packets.
				;  Support for 16650 and 16750 UARTs.
				;  Streamlined interrupt routine.
				;
				;     Rev 1.7   25 Apr 1995 22:16:36   EMMETT
				;  Added Support for DigiBoard PC/16.  Changed interrupt Routine for better adapter independence.
				;  Changed interrupt routine to allow user to select interrupting device selection algorithim.  Fixed
				;  ABIOS interaction for better "non.INI" initialization in MCA machines.  Fixed various initialization
				;  message strings.  COMscope and receive buffer are now allocated from system memory, allowing
				;  a 32k (word) COMscope buffer and a 64k (byte) receive buffer.
				;
				;     Rev 1.6   03 Dec 1994 15:07:28   EMMETT
				;  Changed segment names.  Streamlined ABIOS machine initialization.
				;  Removed most of old "parse" init code.
				;
				;     Rev 1.5   28 Jun 1994 09:09:30   EMMETT
				;  Added "clear all interrupts" to handle interrupt ID register problems when one or more ports
				;  on an adapter were in an interrupt state at system reset time.
				;
				;     Rev 1.4   11 Jun 1994 10:37:40   EMMETT
				;  Changed all references to "Mirror" to "COMscope".
				;
				;     Rev 1.3   07 Jun 1994 00:19:08   EMMETT
				;  Added support for DigiBoard.
				;  Added initialization support for OEM specific loads.
				;  Fixed bug in StartWriteStream and ProcessModemSignals that caused handshaking problems.
				;  Fixed hardware tests to set baud rate before testing interrupts.
				;  Fixed hardware tests off switch to work only for retail version.
				;
				;     Rev 1.2   27 Apr 1994 22:56:22   EMMETT
				;  FIxed ABIOS stuff to work better than before.
				;
				;     Rev 1.1   18 Apr 1994 23:18:06   EMMETT
				;  Changed ABIOS processing and added ability to disallow a port to initialize.
				;
				;     Rev 1.0   16 Apr 1994 08:35:14   EMMETT
				;  Initial version control archive.
				;
				;************************************************************************

				  IFNDEF x16_BIT
				.386P
				  ELSE
				  ENDIF
				.NOLISTMACRO                   ;suppress macro expansion in listing

				.XLIST
				.LIST

 0000				RES_DATA SEGMENT

				  IFDEF DEMO
				  ENDIF
				    EXTRN wLastDeviceParmsOffset        :WORD
				    EXTRN wClockRate                    :WORD
				    EXTRN wClockRate2                   :WORD
				    EXTRN device_hlp                    :DWORD
				    EXTRN stDeviceParms                 :s_stDeviceParms
				    EXTRN wMaxDeviceCount               :WORD
				    EXTRN wSystemDebug                  :WORD
				    EXTRN wLastEndOfData                :WORD
				    EXTRN wDeviceCount                  :WORD
				    EXTRN wDeviceOffsetTable            :WORD
				    EXTRN abyPath                       :BYTE
				    EXTRN wEndOfData                    :WORD
				    EXTRN wBusType                      :WORD
				    EXTRN byOEMtype                     :BYTE

				  IFNDEF x16_BIT
				    EXTRN IDCaccess                     :WORD
				    EXTRN IDCaccessPM                   :DWORD
				    EXTRN IDCaccessPDS                  :WORD
				    EXTRN IDCdata                       :WORD
				    EXTRN IDCdeviceName                 :BYTE
				  ENDIF
				    EXTRN wInitTimerCount               :WORD

				    EXTRN bSharedInterrupts             :WORD
				    EXTRN wIntIDregister                :WORD
				    EXTRN ComAux                        :WORD
				    EXTRN xComAux                       :WORD
				    EXTRN wCOMiLoadNumber               :WORD

				 IFDEF OEM
				 ENDIF

 0000				RES_DATA ENDS

 0000				_DATA SEGMENT

				.XLIST
				.LIST
				    EXTRN _szMessage                     :BYTE

				    EXTRN _bUseDDdataSegment            :WORD
				    EXTRN _astInstallParms              :WORD
				    EXTRN _wLoadNumber                  :WORD
				    EXTRN _wLoadCount                   :WORD
				    EXTRN _ulRequiredBufferSpace        :DWORD
				    EXTRN _ulAvailableBufferSpace       :DWORD
				    EXTRN _wSelectorCount               :WORD
				    EXTRN _bABIOSpresent                :WORD
				    EXTRN _bPCI_BIOSpresent             :WORD

				    EXTRN _abyCOMnumbers                :BYTE

				    EXTRN _wDriverLoadCount             :WORD
				    EXTRN _bTimerAvailable              :WORD

				    EXTRN _StackPointer                 :WORD
				    EXTRN _wLoadFlags                   :WORD
				  IFNDEF x16_BIT
				   IFDEF VDD_support
				   ENDIF
				  ENDIF
				    EXTRN _bBadLoad                     :WORD
				    EXTRN _bDebugDelay                  :WORD

				    EXTRN _byLoadAdapterType            :BYTE
				    EXTRN _abyString                    :BYTE
				    EXTRN _wEndOfInitData               :WORD

				    EXTRN _bDisableRM                   :WORD

				  IFDEF COPY_PROTECT
				  ENDIF

				    EXTRN _wCurrentDevice               :WORD
				    EXTRN _wDelayCount                  :WORD

				    EXTRN _stConfigParms                :s_stConfigParms

				    EXTRN _wInitTestPort                :WORD
				    EXTRN _wInstallTryCount             :WORD
				    EXTRN _bWaitForCR                   :WORD
				    EXTRN _bWaitingKey                  :WORD

				    EXTRN _bVerbose                     :WORD
				    EXTRN _bDelay                       :WORD
				    EXTRN _bPrintLocation               :WORD

				    EXTRN _bPrimaryInit                 :WORD
				    EXTRN _byIntIDregisterPreset        :BYTE

				    EXTRN _ADFtable                     :WORD

				  IFDEF VDD_support
				  ENDIF

				  IFDEF COPY_PROTECT
				  ENDIF
				    EXTRN _bIsTheFirst                  :WORD
				    EXTRN _bContinueParse               :WORD

				  IFDEF OEM
				  ENDIF

 0000				_DATA ENDS

 0000				_TEXT SEGMENT

				  IFNDEF NO_RESOURCE_MGR
				;    EXTRN _RMHELP_CreateDriver          :FAR
				    EXTRN _RMHELP_SetDevHelp            :FAR
				;    EXTRN _RMHELP_GetPorts              :FAR
				    EXTRN _RMHELP_PortDidntInstall      :FAR
				    EXTRN _RMHELP_PortInitComplete      :FAR
				  ENDIF
				    EXTRN _GetIniInfo                   :FAR
				    EXTRN _LoadHeadersFromABIOStable    :FAR
				    EXTRN _BuildLIDtable                :FAR
				  IFDEF OEM
				  ENDIF


 0000				_TEXT ENDS

 0000				RES_CODE SEGMENT
				    ASSUME CS:RCGROUP, ES:nothing, SS:nothing, DS:RDGROUP, GS:DGROUP

 0000 = 0000			BEGIN_INIT_CODE  EQU $
				;-------------------------------------------------------------------------------
				; Initialization procedurs are placed after BEGIN_INIT_CODE so they can go
				; away once initialization has completed.
				;-------------------------------------------------------------------------------
				    EXTRN _GetLIDentry                  :FAR
				  IFDEF VDD_support
				  ENDIF
				    EXTRN TestValidHDW                  :NEAR
				    EXTRN TestMCA                       :NEAR
				    EXTRN CalcBaudRate                  :NEAR

				 IFDEF OEM
				 ENDIF

				  IFDEF x16_BIT
				  ENDIF

				    EXTRN PrintString                   :NEAR
				    EXTRN DelayFunction                 :NEAR
				    EXTRN InitTimer                     :NEAR
				    EXTRN CalcDelay                     :NEAR
				    EXTRN OutputProgress                :NEAR
				    EXTRN binac_10                      :NEAR
				    EXTRN GetCOMnumber                  :NEAR
				    EXTRN binac                         :NEAR
				    EXTRN ParseArguments                :NEAR
				    EXTRN StorePath                     :NEAR

				  IFNDEF x16_BIT
				   IFDEF VDD_support
				   ENDIF
				    EXTRN SetRing0Access                :NEAR
				    EXTRN _MemorySetup                  :NEAR
				  ENDIF

				  IFDEF COPY_PROTECT
				  ENDIF

 0000				Location PROC NEAR

 0000  65: 83 3E 0000 E		        cmp     GS:_bPrintLocation,TRUE
       01
 0006  75 38			        jne     exit

 0008  BB 0000 R		        lea     bx,BEGIN_INIT_CODE
				  IFDEF VDD_support
				  ENDIF
				        INVOKE sprintf,ADDR _szMessage,0,ADDR _szCodeLocation_xxxxxxx,
				               cs,bx,300,ds,wEndOfData,GS:_wEndOfInitData,wLastEndOfData
 000B  FF 36 0000 E	   *	    push   wLastEndOfData
 000F  65: FF 36 0000 E	   *	    push   gs:_wEndOfInitData
 0014  FF 36 0000 E	   *	    push   wEndOfData
 0018  1E		   *	    push   ds
 0019  68 012C		   *	    push   +0012Ch
 001C  53		   *	    push   bx
 001D  0E		   *	    push   cs
 001E  0F A8		   *	    push   gs
 0020  68 0000 E	   *	    push   OFFSET DGROUP: _szCodeLocation_xxxxxxx
 0023  6A 00		   *	    push   +00000h
 0025  0F A8		   *	    push   gs
 0027  68 0000 E	   *	    push   OFFSET DGROUP: _szMessage
 002A  9A ---- 0000 E	   *	    call   sprintf
 002F  83 C4 18		   *	    add    sp, 00018h
				        INVOKE PrintMessage,ADDR _szMessage,ax
 0032  50		   *	    push   ax
 0033  0F A8		   *	    push   gs
 0035  68 0000 E	   *	    push   OFFSET DGROUP: _szMessage
 0038  9A ---- 0000 E	   *	    call   PrintMessage
 003D  83 C4 06		   *	    add    sp, 00006h
 0040				exit:
 0040  C3			        ret

 0041				Location ENDP

				; AX contains strategy target upon entry

 0041				Init PROC NEAR C USES ES GS DI, oErrorCode:WORD

				;        LOCAL bAutoConfig:WORD
				        LOCAL pPacket:DWORD
				;  int 3
 0041  55		   *	    push   bp
 0042  8B EC		   *	    mov    bp, sp
 0044  83 C4 FC		   *	    add    sp, 0FFFCh
 0047  06		   *	    push   es
 0048  0F A8		   *	    push   gs
 004A  57		   *	    push   di
 004B  89 7E FC			        mov     WORD PTR pPacket,di
 004E  8C C7			        mov     di,es
 0050  89 7E FE			        mov     WORD PTR pPacket + 2,di
 0053  C4 7E FC			        les     di,pPacket
 0056  26: 8B 5D 0E		        mov     bx,ES:[di].s_stPacket.InitParamPacket.DevHlpOffset
 005A  89 1E 0000 E		        mov     word ptr device_hlp,bx
 005E  26: 8B 5D 10		        mov     bx,ES:[di].s_stPacket.InitParamPacket.DevHlpOffset + 2
 0062  89 1E 0002 E		        mov     word ptr device_hlp + 2,bx

				;  int 3
				    SetGS     DGROUP

 006B  83 F8 FF			        cmp     ax,SPECIAL_STRATEGY
 006E  75 09			        jne     @f
 0070  65: C7 06 0000 E		        mov     GS:_bPrimaryInit,TRUE
       0001
 0077  EB 26			        jmp     main_init
 0079				@@:
 0079  83 F8 FE			        cmp     ax,DUMMY_STRATEGY
 007C  0F 85 0275		        jne     begin_device_init
 0080  65: 83 3E 0000 E		        cmp     GS:_bPrimaryInit,TRUE
       01
 0086  75 17			        jne     main_init

 0088  65: A1 0000 E		        mov     ax,GS:_wEndOfInitData
 008C  C4 7E FC			        les     di,pPacket
 008F  26: 89 45 10		        mov     ES:[di].s_stPacket.InitDataPacket.DataEndOffset,ax
				        StoreError oErrorCode,ERROR_I24_GEN_FAILURE
 009C  E9 0A30			        jmp     set_end_of_code

				;------------------------------------------------------------
				; First entry into this COMi load.
				;------------------------------------------------------------
 009F				main_init:
				;  int  3
 009F  65: C7 06 0000 E		        mov     GS:_bIsTheFirst,TRUE  ; initialize variable
       0001

				  IFNDEF x16_BIT
 00A6  BB 0000 E		        lea     bx,OFFSET IDCdeviceName
 00A9  BF 0000 E		        lea     di,OFFSET IDCaccess
 00AC  BA 002A			        mov     dx,DevHlp_AttachDD
 00AF  FF 1E 0000 E		        call    device_hlp
 00B3  72 07			        jc      @f
 00B5  65: C7 06 0000 E		        mov     GS:_bIsTheFirst,FALSE ; this in NOT the first COMi load
       0000
 00BC				@@:
				  ENDIF

 00BC  C7 06 0000 E 0004	        mov     wBusType,BUSTYPE_ISA  ; initialize bus type to ISA

				; Try to initialize timer to be used by init process
 00C2  B8 0000 E		        mov     ax,OFFSET InitTimer
 00C5  B2 1D			        mov     dl,DevHlp_SetTimer
 00C7  FF 1E 0000 E		        call    device_hlp
 00CB  72 07			        jc      @f
 00CD  65: C7 06 0000 E		        mov     GS:_bTimerAvailable,TRUE ; timer is initialized
       0001
 00D4				@@:
				; Process command line parameters and store driver path
 00D4  C4 7E FC			        les     di,pPacket
 00D7  26: C4 5D 12		        les     bx,ES:[di].s_stPacket.InitParamPacket.ArgumentPointer
 00DB  E8 0000 E		        call    StorePath

				  IFDEF x16_BIT
				  ENDIF

 00DE  E8 0000 E		        call    ParseArguments
 00E1  E8 FF1C			        call    Location
				  IFDEF x16_BIT
				  ENDIF

				; RM environment must be set before any calls to RM functions
				; and after command line is parsed so that we can know if we want to
				; disable resource manager.

				   IFNDEF NO_RESOURCE_MGR
 00E4  65: 83 3E 0000 E		        cmp     GS:_bDisableRM,TRUE
       01
 00EA  74 18			        je      @f
 00EC  FF 36 0002 E		        push    WORD PTR [device_hlp + 2]
 00F0  FF 36 0000 E		        push    WORD PTR [device_hlp]
				     SetDS    DGROUP                            ;push-pop
 00F8  9A ---- 0000 E		        call    _RMHELP_SetDevHelp
 00FD  83 C4 04			        add     sp,4
				     SetDS    RDGROUP
 0104				@@:
				   ENDIF
				;  int 3
				; If EXT-INITDELAY is a command line parameter then wait for
				; kernal debugger break (^C from debug terminal).
 0104  B8 001E			        mov     ax,30
 0107  65: 83 3E 0000 E		        cmp     GS:_bDebugDelay,TRUE
       01
 010D  75 16			        jne     AfterDebugDelay
				;        jne     @f
 010F  B8 0000 E		        mov     ax,OFFSET _szDebugMessage
 0112  E8 0000 E		        call    PrintString
 0115  B8 001E			        mov     ax,30
				;@@:
 0118  E8 0000 E		        call    CalcDelay
				        Delay   ax

 0125				AfterDebugDelay::
 0125  B8 0000 E		        mov     ax,OFFSET _szCRonly
 0128  E8 0000 E		        call    PrintString
				  IFNDEF x16_BIT
 012B  65: 83 3E 0000 E		        cmp     GS:_bIsTheFirst,TRUE
       01
				   IFDEF OEM
				   ELSE
 0131  75 37			        jne     test_MCA
				   ENDIF
				   IFDEF VDD_support
				   ENDIF ;VDD_support
 0133  65: 83 3E 0000 E		        cmp     GS:_bDebugDelay,TRUE
       01
 0139  74 06			        je      @f
 013B  B8 0000 E		        mov     ax,OFFSET _szCR
 013E  E8 0000 E		        call    PrintString
 0141				@@:
				        INVOKE sprintf,ADDR _szMessage,0,ADDR _szLogoMessage_s,OFFSET _szSubLogo,GS
 0141  0F A8		   *	    push   gs
 0143  68 0000 E	   *	    push   word  ptr OFFSET _szSubLogo
 0146  0F A8		   *	    push   gs
 0148  68 0000 E	   *	    push   OFFSET DGROUP: _szLogoMessage_s
 014B  6A 00		   *	    push   +00000h
 014D  0F A8		   *	    push   gs
 014F  68 0000 E	   *	    push   OFFSET DGROUP: _szMessage
 0152  9A ---- 0000 E	   *	    call   sprintf
 0157  83 C4 0E		   *	    add    sp, 0000Eh
				        INVOKE PrintMessage,ADDR _szMessage,ax
 015A  50		   *	    push   ax
 015B  0F A8		   *	    push   gs
 015D  68 0000 E	   *	    push   OFFSET DGROUP: _szMessage
 0160  9A ---- 0000 E	   *	    call   PrintMessage
 0165  83 C4 06		   *	    add    sp, 00006h
 0168  EB 00			        jmp     test_MCA

				   IFDEF OEM
				   ENDIF

 016A				test_MCA:
				  ENDIF ;NOT x16_BIT
 016A  E8 0000 E		        call    TestMCA
				  IFNDEF x16_BIT
 016D  65: 83 3E 0000 E		        cmp     GS:_bABIOSpresent,TRUE
       01
 0173  74 02			        je      MCA_build_LID_table

				   IFDEF NoISAsupport
				   ELSE
 0175  EB 20			        jmp     get_configuration
				   ENDIF
 0177				MCA_build_LID_table:
				;-------------------------------------------------------------------
				; If this is the first COMi load then setup ring zero access and
				; build LID table.  LID table is only built if machine is Micro Channel.
				;-------------------------------------------------------------------
 0177  65: 83 3E 0000 E		        cmp     GS:_bIsTheFirst,TRUE
       01
				;        jne     test_PCI
 017D  75 18			        jne     get_configuration
 017F  E8 0000 E		        call    SetRing0Access
				;        jc      test_PCI
 0182  72 13			        jc      get_configuration
				    SetDS     DGROUP
 0188  9A ---- 0000 E		        call    _BuildLIDtable
				    SetDS     RDGROUP

 0191  C7 06 0000 E 0002	        mov     wBusType,BUSTYPE_MCA
				;        jmp     get_configuration

				;test_PCI::
				;        call    TestPCI
				;        cmp     GS:_bPCI_BIOSpresent,TRUE
				;        jne     get_configuration

 0197				get_configuration::
				  IFDEF OEM
				  ENDIF

 0197				ReadConfigFile::
				;--------------------------------------------------------------
				; Read INI file
				;--------------------------------------------------------------
				   SetDS      DGROUP
 019B  60			        pusha
 019C  0F A8			        push    gs
 019E  1E			        push    ds
 019F  89 26 0000 E		        mov     _StackPointer,sp
 01A3  9A ---- 0000 E		        call    _GetIniInfo
 01A8  1F			        pop     ds
 01A9  0F A9			        pop     gs
 01AB  61			        popa
				   SetDS      RDGROUP
				;---------------------------------------------------------------
				; Test INI file results
				;---------------------------------------------------------------
 01B0  65: A1 0000 E		        mov     ax,GS:_wLoadNumber
 01B4  A3 0000 E		        mov     wCOMiLoadNumber,ax

				; Was valid INI file found?
 01B7  83 F8 FF			        cmp     ax,NO_INI_FILE
 01BA  75 35			        jne     test_INI_access
 01BC  65: 83 3E 0000 E		        cmp     GS:_bABIOSpresent,TRUE
       01
 01C2  75 3F			        jne     bad_INI_file
 01C4  65: C7 06 0000 E		        mov     GS:_bVerbose,TRUE
       0001

				; Since no INI file was found, attempt to load configuration from ABIOS
				   SetDS      DGROUP
 01CF  9A ---- 0000 E		        call    _LoadHeadersFromABIOStable
				   SetDS      RDGROUP
 01D8  65: A1 0000 E		        mov     ax,GS:_wLoadCount
 01DC  0B C0			        or      ax,ax
 01DE  74 09			        jz      @f
 01E0  65: C7 06 0000 E		        mov     GS:_wDriverLoadCount,1
       0001
 01E7  EB 2B			        jmp     continue_initialization
 01E9				@@:
				; No INI file and no ABIOS ports found so abort load
 01E9  B8 0000 E		        mov     ax,OFFSET _szNoPortAvailable
 01EC  E8 0000 E		        call    PrintString
 01EF  EB 12			        jmp     bad_INI_file

 01F1				test_INI_access:
				; Error messages for the following error conditions were displayed from
				; within PRELOAD.C.

				; Were any serial devices defined in INI file?
 01F1  65: 81 3E 0000 E		        cmp     GS:_wLoadNumber,NO_DEFINED_DEVICES
       8000
 01F8  74 09			        je      bad_INI_file

				; Test if INI file was invalid or corrupted
 01FA  65: 81 3E 0000 E		        cmp     GS:_wLoadNumber,FILE_ACCESS_ERROR
       C000
 0201  75 11			        jne     continue_initialization

 0203				bad_INI_file:
				; An error was found in INI file so cause pause to extend display of
				; error messages then abort load
				;        mov     ax,OFFSET _szWaitKeyMessage
				;        call    PrintString
 0203  65: C7 06 0000 E		        mov     GS:_bWaitingKey,TRUE
       0001
 020A  65: C7 06 0000 E		        mov     GS:_wDelayCount,1000
       03E8
				;        Delay   GS:_wDelayCount
				;        lea     ax,_szCR
				;        call    PrintString
 0211  E9 00B6			        jmp     abort_COMi_load_exit

 0214				continue_initialization::
				; serial device were defined in INI file or by ABIOS
				  ENDIF ;NOT x16_BIT
				  IFDEF OEM
				  ENDIF
				  IFDEF DEMO
				  ENDIF
				   IFNDEF x16_BIT
				; Test if there is enough memory available in device driver data segment
				; to accomodate all required buffers.  This variable is set in PRELOAD.C
				; (GetIniInfo).
 0214  65: 83 3E 0000 E		        cmp     GS:_bUseDDdataSegment,TRUE
       01
 021A  74 77			        je      calculate_delay_count

				; There is not enough memory in device driver data segment, so allocate
				; selectors and buffers
 021C  65: FF 36 0000 E		        push    GS:_wLoadCount
 0221  E8 0000 E		        call    _MemorySetup
 0224  58			        pop     ax
 0225  73 2E			        jnc     tell_resources

				; There was an error allocating memory for COMi buffers, so print error message
				; and abort load.
 0227  B8 0000 E		        mov     ax,OFFSET _szAllocError
 022A  E8 0000 E		        call    PrintString
 022D  B8 0000 E		        mov     ax,OFFSET _szWaitKeyMessage
 0230  E8 0000 E		        call    PrintString
 0233  65: C7 06 0000 E		        mov     GS:_bWaitingKey,TRUE
       0001
 023A  65: C7 06 0000 E		        mov     GS:_wDelayCount,0ffffh
       FFFF
				        Delay   GS:_wDelayCount
 024D  B8 0000 E		        lea     ax,_szCR
 0250  E8 0000 E		        call    PrintString
 0253  EB 75			        jmp     abort_COMi_load_exit

 0255				tell_resources:
				; Display allocated resources used
 0255  66| 65: 8B 1E 0000 E	        mov     ebx,GS:_ulRequiredBufferSpace;
 025B  65: 8B 0E 0000 E		        mov     cx,GS:_wSelectorCount

				        INVOKE sprintf,ADDR _szMessage,0,ADDR _szAllocBuffers_ululu,
				                                           GS:_wSelectorCount,
				                                           GS:_ulRequiredBufferSpace,
				                                           GS:_ulAvailableBufferSpace
 0260  66| 65: FF 36 0000 E *	    push   gs:_ulAvailableBufferSpace
 0266  66| 65: FF 36 0000 E *	    push   gs:_ulRequiredBufferSpace
 026C  65: FF 36 0000 E	   *	    push   gs:_wSelectorCount
 0271  0F A8		   *	    push   gs
 0273  68 0000 E	   *	    push   OFFSET DGROUP: _szAllocBuffers_ululu
 0276  6A 00		   *	    push   +00000h
 0278  0F A8		   *	    push   gs
 027A  68 0000 E	   *	    push   OFFSET DGROUP: _szMessage
 027D  9A ---- 0000 E	   *	    call   sprintf
 0282  83 C4 14		   *	    add    sp, 00014h
				        INVOKE PrintMessage,ADDR _szMessage,ax
 0285  50		   *	    push   ax
 0286  0F A8		   *	    push   gs
 0288  68 0000 E	   *	    push   OFFSET DGROUP: _szMessage
 028B  9A ---- 0000 E	   *	    call   PrintMessage
 0290  83 C4 06		   *	    add    sp, 00006h

 0293				calculate_delay_count::
				   ENDIF  ;x16_BIT
				; Convert delay count seconds to timer ticks
 0293  65: A1 0000 E		        mov     ax,GS:_wDelayCount
 0297  E8 0000 E		        call    CalcDelay
 029A  65: A3 0000 E		        mov     GS:_wDelayCount,ax
				  IFDEF DEMO
				  ENDIF
				; Set up exit variables
 029E  65: A1 0000 E		        mov     ax,GS:_wEndOfInitData
 02A2  C4 7E FC			        les     di,pPacket
 02A5  26: 89 45 10		        mov     ES:[di].s_stPacket.InitDataPacket.DataEndOffset,ax

				; If this is NOT the first COMi load then the "sloot$OS" device name was
				; used to initialize this load.  In that case, we must cause that device name
				; to be available for any subsequent load.
 02A9  65: 83 3E 0000 E		        cmp     GS:_bIsTheFirst,TRUE
       01
 02AF  74 09			        je      @f

				; Cause "sloot$SO" device to not be loaded
				        StoreError oErrorCode,ERROR_I24_GEN_FAILURE
 02BA				@@:
				; If there are no devices to initialize then kill the timer and exit,
				; otherwise just exit.
 02BA  65: A1 0000 E		        mov     ax,GS:_wLoadCount
 02BE  65: 3B 06 0000 E		        cmp     ax,GS:_wInstallTryCount
 02C3  0F 84 07F0		        je      kill_timer
 02C7  E9 0805			        jmp     set_end_of_code

 02CA				abort_COMi_load_exit:
				; Cause this COMi load to NOT be loaded
 02CA  BB 0000 E		        lea     bx,xComAux
 02CD  C7 07 FFFF		        mov     WORD PTR [bx],0ffffh
 02D1  C7 47 02 FFFF		        mov     WORD PTR [bx + 2],0ffffh
 02D6  65: A1 0000 E		        mov     ax,GS:_wEndOfInitData
 02DA  C4 7E FC			        les     di,pPacket
 02DD  26: 89 45 10		        mov     ES:[di].s_stPacket.InitDataPacket.DataEndOffset,ax
 02E1  65: 83 3E 0000 E		        cmp     GS:_bIsTheFirst,TRUE
       01
 02E7  74 09			        je      @f
				        StoreError oErrorCode,ERROR_I24_GEN_FAILURE
 02F2				@@:
 02F2  E9 078C			        jmp     test_final_delay

				;------------------------------------------------------------
				; Entry for each device in this COMi load
				;------------------------------------------------------------
 02F5				begin_device_init::
 02F5  A9 FF00			        test    ax,0ff00h  ; test if device is for COMscope access
 02F8  74 24			        jz      device_init
 02FA  8B D8			        mov     bx,ax
 02FC  83 E3 0F			        and     bx,000fh
 02FF  D1 E3			        shl     bx,1
 0301  83 BF 0000 E 00		        cmp     wDeviceOffsetTable[bx],ZERO
 0306  75 09			        jne     @f
				        StoreError oErrorCode,ERROR_I24_GEN_FAILURE
 0311				@@:
 0311  A1 0000 E		        mov     ax,wLastEndOfData
 0314  C4 7E FC			        les     di,pPacket
 0317  26: 89 45 10		        mov     ES:[di].s_stPacket.InitDataPacket.DataEndOffset,ax
 031B  E9 07B1			        jmp     set_end_of_code

 031E				device_init:
				; We are initializing the clock variable here so that we won't advertise
				; a modified clock rate unless there are devices to initialize.
 031E  65: A3 0000 E		        mov     GS:_wCurrentDevice,ax
 0322  83 F8 00			        cmp     ax,0
 0325  77 3E			        ja      start

				; Initialize end of data and other variables
 0327  A1 0000 E		        mov     ax,wEndOfData
 032A  A3 0000 E		        mov     wLastEndOfData,ax
 032D  65: C7 06 0000 E		        mov     GS:_bBadLoad,FALSE
       0000

				; We are initializing the clock variable here so that we don't advertise
				; a modified clock rate unless there are devices defined.
 0334  83 3E 0000 E 20		        cmp     wClockRate,DEFAULT_CLOCK_RATE
 0339  74 2A			        je      start
 033B  8B 1E 0000 E		        mov     bx,wClockRate
				        INVOKE sprintf,ADDR _szMessage,0,ADDR _szClockRate_u,bx
 033F  53		   *	    push   bx
 0340  0F A8		   *	    push   gs
 0342  68 0000 E	   *	    push   OFFSET DGROUP: _szClockRate_u
 0345  6A 00		   *	    push   +00000h
 0347  0F A8		   *	    push   gs
 0349  68 0000 E	   *	    push   OFFSET DGROUP: _szMessage
 034C  9A ---- 0000 E	   *	    call   sprintf
 0351  83 C4 0C		   *	    add    sp, 0000Ch
				        INVOKE PrintMessage,ADDR _szMessage,ax
 0354  50		   *	    push   ax
 0355  0F A8		   *	    push   gs
 0357  68 0000 E	   *	    push   OFFSET DGROUP: _szMessage
 035A  9A ---- 0000 E	   *	    call   PrintMessage
 035F  83 C4 06		   *	    add    sp, 00006h
 0362  E8 0000 E		        call    PrintString

 0365				start:
 0365  65: FF 06 0000 E		        inc     GS:_wInstallTryCount
 036A  BE 00F0			        mov     si,TYPE s_stDeviceParms
 036D  A1 0000 E		        mov     ax,wDeviceCount
 0370  F7 E6			        mul     si
 0372  8B F0			        mov     si,ax
 0374  81 C6 0000 E		        add     si,OFFSET stDeviceParms
 0378  BF 002A			        mov     di,TYPE s_stConfigParms
 037B  65: A1 0000 E		        mov     ax,GS:_wCurrentDevice
 037F  F7 E7			        mul     di
 0381  8B F8			        mov     di,ax
 0383  81 C7 0000 E		        add     di,OFFSET _stConfigParms  ; assume in DGROUP - GS = DGROUP

 0387  65: 83 3E 0000 E		        cmp     GS:_bABIOSpresent,TRUE
       01
 038D  0F 85 00D2		        jne     test_user_disable
				;------------------------------------------------
				; Test for ABIOS access Logical Device override.

				; Possible only when INI file present.
				;------------------------------------------------
 0391  65: 83 7D 06 FC		        cmp     GS:[di].s_stConfigParms.cwIObaseAddress,PORT_ADDRESS_INVALID
 0396  75 29			        jne     @f
 0398  E8 0000 E		        call    GetCOMnumber
				        INVOKE sprintf,ADDR _szMessage,0,ADDR _szABIOSaddrInvalid_u,bx
 039B  53		   *	    push   bx
 039C  0F A8		   *	    push   gs
 039E  68 0000 E	   *	    push   OFFSET DGROUP: _szABIOSaddrInvalid_u
 03A1  6A 00		   *	    push   +00000h
 03A3  0F A8		   *	    push   gs
 03A5  68 0000 E	   *	    push   OFFSET DGROUP: _szMessage
 03A8  9A ---- 0000 E	   *	    call   sprintf
 03AD  83 C4 0C		   *	    add    sp, 0000Ch
				        INVOKE PrintMessage,ADDR _szMessage,ax
 03B0  50		   *	    push   ax
 03B1  0F A8		   *	    push   gs
 03B3  68 0000 E	   *	    push   OFFSET DGROUP: _szMessage
 03B6  9A ---- 0000 E	   *	    call   PrintMessage
 03BB  83 C4 06		   *	    add    sp, 00006h
 03BE  E9 00DB			        jmp     bad_device
 03C1				@@:
 03C1  65: 83 7D 06 FB		        cmp     GS:[di].s_stConfigParms.cwIObaseAddress,PORT_ADDRESS_TAKEN
 03C6  75 29			        jne     @f
 03C8  E8 0000 E		        call    GetCOMnumber
				        INVOKE sprintf,ADDR _szMessage,0,ADDR _szABIOSaddrTaken_u,bx
 03CB  53		   *	    push   bx
 03CC  0F A8		   *	    push   gs
 03CE  68 0000 E	   *	    push   OFFSET DGROUP: _szABIOSaddrTaken_u
 03D1  6A 00		   *	    push   +00000h
 03D3  0F A8		   *	    push   gs
 03D5  68 0000 E	   *	    push   OFFSET DGROUP: _szMessage
 03D8  9A ---- 0000 E	   *	    call   sprintf
 03DD  83 C4 0C		   *	    add    sp, 0000Ch
				        INVOKE PrintMessage,ADDR _szMessage,ax
 03E0  50		   *	    push   ax
 03E1  0F A8		   *	    push   gs
 03E3  68 0000 E	   *	    push   OFFSET DGROUP: _szMessage
 03E6  9A ---- 0000 E	   *	    call   PrintMessage
 03EB  83 C4 06		   *	    add    sp, 00006h
 03EE  E9 00AB			        jmp     bad_device
 03F1				@@:
				;------------------------------------------------
				; Possible only without INI file.
				;------------------------------------------------
 03F1  65: 83 7D 06 FD		        cmp     GS:[di].s_stConfigParms.cwIObaseAddress,PORT_OWNED_BY_OTHER_DD
 03F6  75 32			        jne     @f
 03F8  65: 83 3E 0000 E		        cmp     GS:_wLoadNumber,NO_INI_FILE
       FF
 03FE  0F 84 00CF		        je      non_device
 0402  E8 0000 E		        call    GetCOMnumber
				        INVOKE sprintf,ADDR _szMessage,0,ADDR _szABIOSname_u,bx
 0405  53		   *	    push   bx
 0406  0F A8		   *	    push   gs
 0408  68 0000 E	   *	    push   OFFSET DGROUP: _szABIOSname_u
 040B  6A 00		   *	    push   +00000h
 040D  0F A8		   *	    push   gs
 040F  68 0000 E	   *	    push   OFFSET DGROUP: _szMessage
 0412  9A ---- 0000 E	   *	    call   sprintf
 0417  83 C4 0C		   *	    add    sp, 0000Ch
				        INVOKE PrintMessage,ADDR _szMessage,ax
 041A  50		   *	    push   ax
 041B  0F A8		   *	    push   gs
 041D  68 0000 E	   *	    push   OFFSET DGROUP: _szMessage
 0420  9A ---- 0000 E	   *	    call   PrintMessage
 0425  83 C4 06		   *	    add    sp, 00006h
 0428  EB 72			        jmp     bad_device
 042A				@@:
				;------------------------------------------------
				; Possible with or without INI file.
				;------------------------------------------------
 042A  65: 83 7D 06 FE		        cmp     GS:[di].s_stConfigParms.cwIObaseAddress,PORT_LID_ALREADY_OWNED
 042F  75 32			        jne     test_user_disable
 0431  65: 83 3E 0000 E		        cmp     GS:_wLoadNumber,NO_INI_FILE
       FF
 0437  0F 84 0096		        je      non_device
 043B  E8 0000 E		        call    GetCOMnumber
				        INVOKE sprintf,ADDR _szMessage,0,ADDR _szABIOSowned_u,bx
 043E  53		   *	    push   bx
 043F  0F A8		   *	    push   gs
 0441  68 0000 E	   *	    push   OFFSET DGROUP: _szABIOSowned_u
 0444  6A 00		   *	    push   +00000h
 0446  0F A8		   *	    push   gs
 0448  68 0000 E	   *	    push   OFFSET DGROUP: _szMessage
 044B  9A ---- 0000 E	   *	    call   sprintf
 0450  83 C4 0C		   *	    add    sp, 0000Ch
				        INVOKE PrintMessage,ADDR _szMessage,ax
 0453  50		   *	    push   ax
 0454  0F A8		   *	    push   gs
 0456  68 0000 E	   *	    push   OFFSET DGROUP: _szMessage
 0459  9A ---- 0000 E	   *	    call   PrintMessage
 045E  83 C4 06		   *	    add    sp, 00006h
 0461  EB 39			        jmp     bad_device

 0463				test_user_disable:
				;------------------------------------------------
				; Possible only when user set port address to 0xffff, to disable port access.
				;------------------------------------------------
 0463  65: 83 7D 06 FF		        cmp     GS:[di].s_stConfigParms.cwIObaseAddress,PORT_USER_DISABLED
 0468  0F 85 0081		        jne     attempt_access
 046C  65: 83 3E 0000 E		        cmp     GS:_bVerbose,TRUE
       01
 0472  75 5D			        jne     non_device
 0474  E8 0000 E		        call    GetCOMnumber
				        INVOKE sprintf,ADDR _szMessage,0,ADDR _szSkippedPort_u,bx
 0477  53		   *	    push   bx
 0478  0F A8		   *	    push   gs
 047A  68 0000 E	   *	    push   OFFSET DGROUP: _szSkippedPort_u
 047D  6A 00		   *	    push   +00000h
 047F  0F A8		   *	    push   gs
 0481  68 0000 E	   *	    push   OFFSET DGROUP: _szMessage
 0484  9A ---- 0000 E	   *	    call   sprintf
 0489  83 C4 0C		   *	    add    sp, 0000Ch
				        INVOKE PrintMessage,ADDR _szMessage,ax
 048C  50		   *	    push   ax
 048D  0F A8		   *	    push   gs
 048F  68 0000 E	   *	    push   OFFSET DGROUP: _szMessage
 0492  9A ---- 0000 E	   *	    call   PrintMessage
 0497  83 C4 06		   *	    add    sp, 00006h
 049A  EB 35			        jmp     non_device

 049C				bad_device:
				  IFNDEF NO_RESOURCE_MGR
				; Device is bad so remove it from Resource Manager lists.
 049C  65: 83 3E 0000 E		        cmp     GS:_bDisableRM,TRUE
       01
 04A2  74 18			        je      @f
 04A4  65: 8B 1E 0000 E		        mov     bx,GS:_wInstallTryCount
 04A9  4B			        dec     bx
 04AA  53			        push    bx
 04AB  50			        push    ax
				   SetDS      DGROUP
 04B0  9A ---- 0000 E		        call    _RMHELP_PortDidntInstall
				   SetDS      RDGROUP
 04B9  83 C4 04			        add     sp,4
 04BC				@@:
				  ENDIF
 04BC  65: C7 06 0000 E		        mov     GS:_bWaitForCR,TRUE
       0001
 04C3  65: C7 06 0000 E		        mov     GS:_wDelayCount,1000
       03E8
 04CA  65: C7 06 0000 E		        mov     GS:_bBadLoad,TRUE
       0001

 04D1				non_device::
 04D1  BB 0000 E		        mov     bx,OFFSET _astInstallParms
 04D4  65: 8B 07		        mov     ax,GS:[bx].s_stInstallParms.wLID
 04D7  0B C0			        or      ax,ax
 04D9  74 06			        jz      error_exit
 04DB  B2 35			        mov     dl,DevHlp_FreeLIDEntry
 04DD  FF 1E 0000 E		        call    device_hlp

 04E1				error_exit:
				        StoreError oErrorCode,ERROR_I24_GEN_FAILURE
 04EA  E9 04DD			        jmp     init_exit
				;---------------------------------------------------------------------
				; Setup minimum device data and test if device is valid
				;---------------------------------------------------------------------
 04ED				attempt_access::
				; Has an I/O base address been specified?
 04ED  65: 83 7D 06 00		        cmp     GS:[di].s_stConfigParms.cwIObaseAddress,ZERO
 04F2  74 06			        je      @f
 04F4  65: 8B 55 06		        mov     dx,GS:[di].s_stConfigParms.cwIObaseAddress
 04F8  EB 59			        jmp     set_IO_base_address
 04FA				@@:
 04FA  83 3E 0000 E 05		        cmp     wBusType, BUSTYPE_PCI
 04FF  75 29			        jne     @f
 0501  E8 0000 E		        call    GetCOMnumber
				        INVOKE sprintf,ADDR _szMessage,0,ADDR _szPCIerror_u,bx
 0504  53		   *	    push   bx
 0505  0F A8		   *	    push   gs
 0507  68 0000 E	   *	    push   OFFSET DGROUP: _szPCIerror_u
 050A  6A 00		   *	    push   +00000h
 050C  0F A8		   *	    push   gs
 050E  68 0000 E	   *	    push   OFFSET DGROUP: _szMessage
 0511  9A ---- 0000 E	   *	    call   sprintf
 0516  83 C4 0C		   *	    add    sp, 0000Ch
				        INVOKE PrintMessage,ADDR _szMessage,ax
 0519  50		   *	    push   ax
 051A  0F A8		   *	    push   gs
 051C  68 0000 E	   *	    push   OFFSET DGROUP: _szMessage
 051F  9A ---- 0000 E	   *	    call   PrintMessage
 0524  83 C4 06		   *	    add    sp, 00006h
 0527  E9 FF72			        jmp     bad_device
 052A				@@:
 052A  E8 0000 E		        call    GetCOMnumber
				        INVOKE sprintf,ADDR _szMessage,0,ADDR _szBaseAddrError_u,bx
 052D  53		   *	    push   bx
 052E  0F A8		   *	    push   gs
 0530  68 0000 E	   *	    push   OFFSET DGROUP: _szBaseAddrError_u
 0533  6A 00		   *	    push   +00000h
 0535  0F A8		   *	    push   gs
 0537  68 0000 E	   *	    push   OFFSET DGROUP: _szMessage
 053A  9A ---- 0000 E	   *	    call   sprintf
 053F  83 C4 0C		   *	    add    sp, 0000Ch
				        INVOKE PrintMessage,ADDR _szMessage,ax
 0542  50		   *	    push   ax
 0543  0F A8		   *	    push   gs
 0545  68 0000 E	   *	    push   OFFSET DGROUP: _szMessage
 0548  9A ---- 0000 E	   *	    call   PrintMessage
 054D  83 C4 06		   *	    add    sp, 00006h
 0550  E9 FF49			        jmp     bad_device

 0553				set_IO_base_address:
 0553  89 54 3A			        mov     [si].s_stDeviceParms.wIObaseAddress,dx

				; Has an interrupt level been specified?
 0556  65: 80 7D 20 00		        cmp     GS:[di].s_stConfigParms.cbyInterruptLevel,ZERO
 055B  74 06			        je      @f
 055D  65: 8A 45 20		        mov     al,GS:[di].s_stConfigParms.cbyInterruptLevel
 0561  EB 29			        jmp     set_interrupt_level
 0563				@@:
 0563  E8 0000 E		        call    GetCOMnumber
				        INVOKE sprintf,ADDR _szMessage,0,ADDR _szInterruptLevelError_u,bx
 0566  53		   *	    push   bx
 0567  0F A8		   *	    push   gs
 0569  68 0000 E	   *	    push   OFFSET DGROUP: _szInterruptLevelError_u
 056C  6A 00		   *	    push   +00000h
 056E  0F A8		   *	    push   gs
 0570  68 0000 E	   *	    push   OFFSET DGROUP: _szMessage
 0573  9A ---- 0000 E	   *	    call   sprintf
 0578  83 C4 0C		   *	    add    sp, 0000Ch
				        INVOKE PrintMessage,ADDR _szMessage,ax
 057B  50		   *	    push   ax
 057C  0F A8		   *	    push   gs
 057E  68 0000 E	   *	    push   OFFSET DGROUP: _szMessage
 0581  9A ---- 0000 E	   *	    call   PrintMessage
 0586  83 C4 06		   *	    add    sp, 00006h
 0589  E9 FF10			        jmp     bad_device

 058C				set_interrupt_level:
 058C  88 44 3E			        mov     [si].s_stDeviceParms.byInterruptLevel,al

 058F  65: 8B 05		        mov     ax,GS:[di].s_stConfigParms.cwDeviceFlags1
 0592  89 44 08			        mov     [si].s_stDeviceParms.wConfigFlags1,ax
 0595  65: 8B 45 02		        mov     ax,GS:[di].s_stConfigParms.cwDeviceFlags2
 0599  89 44 0A			        mov     [si].s_stDeviceParms.wConfigFlags2,ax

 059C  F7 44 08 0001		        test    [si].s_stDeviceParms.wConfigFlags1,CFG_FLAG1_FORCE_4X_TEST
 05A1  74 06			        jz      @f
 05A3  65: 83 0E 0000 E		        or    GS:_wLoadFlags,LOAD_FLAG1_FORCE_4X_TEST
       10
				;        or      [si].s_stDeviceParms.wDeviceFlag2,DEV_FLAG2_FORCE_4X_TEST
 05A9				@@:
				; Is special interrupt processing required because TI 16550B UART is present.
 05A9  F7 44 08 0008		        test    [si].s_stDeviceParms.wConfigFlags1,CFG_FLAG1_TIB_UART
 05AE  74 0B			        jz      @f

				; Do not do special processing for other TI UARTs.  This is tested here in case ;;3.83i
				; a type two adapter was selected during configuration and we find some other
				; TI UART is actually being used.
				; This won't prevent an explicit selection of this "feature" or the selection
				; of a type two adapter type when no TI UART is present

 05B0  F7 44 04 000A		        test    [si].s_stDeviceParms.wDeviceFlag2,(DEV_FLAG2_16750_UART OR DEV_FLAG2_TI16550C_UART)
 05B5  75 04			        jnz     @f
 05B7  83 4C 04 10		        or      [si].s_stDeviceParms.wDeviceFlag2,DEV_FLAG2_TIB_UART
 05BB				@@:
				; Set status register preload value
 05BB  65: C6 06 0000 E		        mov     GS:_byIntIDregisterPreset,0
       00
				    IFNDEF OEM
				;        cmp     GS:byOEMtype,OEM_BOCA
				;        je      @f
 05C1  65: 80 3E 0000 E		        cmp     GS:_byLoadAdapterType,HDWTYPE_DIGIBOARD
       64
 05C7  75 06			        jne     not_DigiBoard
				;@@:
 05C9  65: C6 06 0000 E		        mov     GS:_byIntIDregisterPreset,0ffh
       FF

 05CF				not_DigiBoard:
				    ELSEIFDEF DigiBoard
				    ENDIF
				; Test if valid hardware is available.
 05CF  E8 0000 E		        call    TestValidHDW
 05D2  0F 82 FEC6		        jc      bad_device

 05D6				set_packet_size:
				; Test read/write packet queue count request.
 05D6  B0 06			        mov     al,DEFAULT_WRITE_PKT_QUEUE
 05D8  65: 80 7D 1E 00		        cmp     GS:[di].s_stConfigParms.cbyMaxWritePktCount,ZERO
 05DD  74 04			        je      @f
 05DF  65: 8A 45 1E		        mov     al,GS:[di].s_stConfigParms.cbyMaxWritePktCount
 05E3				@@:
 05E3  88 44 2A			        mov     [si].s_stDeviceParms.byMaxWritePktCount,al

 05E6  B0 06			        mov     al,DEFAULT_READ_PKT_QUEUE
 05E8  65: 80 7D 1F 00		        cmp     GS:[di].s_stConfigParms.cbyMaxReadPktCount,ZERO
 05ED  74 04			        je      @f
 05EF  65: 8A 45 1F		        mov     al,GS:[di].s_stConfigParms.cbyMaxReadPktCount
 05F3				@@:
 05F3  88 44 2B			        mov     [si].s_stDeviceParms.byMaxReadPktCount,al

				; Transmit buffer space is always allocated in device driver's data segment
				; so we must determine if there is enough space available
 05F6  66| 33 C0		        xor     eax,eax
 05F9  B8 0100			        mov     ax,DEF_WRITE_BUFF_LEN
 05FC  65: 83 7D 0A 00		        cmp     GS:[di].s_stConfigParms.cwWrtBufferLength,ZERO
 0601  74 0C			        je      @f
 0603  65: 8B 45 0A		        mov     ax,GS:[di].s_stConfigParms.cwWrtBufferLength
 0607  3D 0080			        cmp     ax,MIN_WRITE_BUFF_LEN
 060A  73 03			        jae     @f
 060C  B8 0080			        mov     ax,MIN_WRITE_BUFF_LEN
 060F				@@:
 060F  89 44 0C			        mov     [si].s_stDeviceParms.wWrtBufferLength,ax


 0612  03 06 0000 E		        add     ax,wLastEndOfData
 0616  72 70			        jc      segment_overflow
 0618  83 F8 FE			        cmp     ax,0fffeh

 061B  77 6B			        ja      segment_overflow
				  IFNDEF x16_BIT
 061D  65: 83 3E 0000 E		        cmp     GS:_bUseDDdataSegment,TRUE
       01
 0623  0F 84 008A		        je      set_thresholds

				  ENDIF
				; Test buffer length request if allocating memory for receive and/or COMscope
				; buffers in the device driver's data segment.  If we aren't allocating memory
				; in the device driver's data segment then we have already calculated
				; required buffer space and compared to available buffer space.

 0627  66| BB 00001000		        mov     ebx,DEF_READ_BUFF_LEN      ; also zeros upper word of EBX
 062D  65: 83 7D 08 00		        cmp     GS:[di].s_stConfigParms.cwReadBufferLength,ZERO
 0632  74 13			        je      @f
 0634  65: 8B 5D 08		        mov     bx,GS:[di].s_stConfigParms.cwReadBufferLength
 0638  66| 81 FB 00000400	        cmp     ebx,MIN_READ_BUFF_LEN
 063F  73 06			        jae     @f
 0641  66| BB 00000400		        mov     ebx,MIN_READ_BUFF_LEN
 0647				@@:
 0647  66| 89 5C 10		        mov     [si].s_stDeviceParms.dwReadBufferLength,ebx

 064B  03 C3			        add     ax,bx
 064D  72 39			        jc      segment_overflow
 064F  83 F8 FE			        cmp     ax,0fffeh
 0652  77 34			        ja      segment_overflow

				  IFNDEF NO_COMscope
 0654  65: F7 05 0040		        test    GS:[di].s_stConfigParms.cwDeviceFlags1,CFG_FLAG1_COMSCOPE
 0659  74 56			        jz      set_thresholds

 065B  66| BB 00002000		        mov     ebx,DEF_COMscope_BUFF_LEN  ; also zeros upper word of EBX
 0661  65: 83 7D 04 00		        cmp     GS:[di].s_stConfigParms.cwCOMscopeBuffLen,ZERO
 0666  74 13			        je      @f
 0668  65: 8B 5D 04		        mov     bx,GS:[di].s_stConfigParms.cwCOMscopeBuffLen
 066C  66| 81 FB 00000400	        cmp     ebx,MIN_COMscope_BUFF_LEN
 0673  73 06			        jae     @f
 0675  66| BB 00000400		        mov     ebx,MIN_COMscope_BUFF_LEN
 067B				@@:
 067B  66| 89 5C 18		        mov     [si].s_stDeviceParms.dwCOMscopeBuffLen,ebx

 067F  03 C3			        add     ax,bx
 0681  72 05			        jc      segment_overflow
 0683  83 F8 FE			        cmp     ax,0fffeh
 0686  76 29			        jbe     set_thresholds

				  ENDIF

 0688				segment_overflow:
 0688  E8 0000 E		        call    GetCOMnumber
				        INVOKE sprintf,ADDR _szMessage,0,ADDR _szMemoryError_u,bx
 068B  53		   *	    push   bx
 068C  0F A8		   *	    push   gs
 068E  68 0000 E	   *	    push   OFFSET DGROUP: _szMemoryError_u
 0691  6A 00		   *	    push   +00000h
 0693  0F A8		   *	    push   gs
 0695  68 0000 E	   *	    push   OFFSET DGROUP: _szMessage
 0698  9A ---- 0000 E	   *	    call   sprintf
 069D  83 C4 0C		   *	    add    sp, 0000Ch
				        INVOKE PrintMessage,ADDR _szMessage,ax
 06A0  50		   *	    push   ax
 06A1  0F A8		   *	    push   gs
 06A3  68 0000 E	   *	    push   OFFSET DGROUP: _szMessage
 06A6  9A ---- 0000 E	   *	    call   PrintMessage
 06AB  83 C4 06		   *	    add    sp, 00006h
 06AE  E9 FDEB			        jmp     bad_device

 06B1				set_thresholds::
				;  Set handshaking thresholds
 06B1  B8 0020			        mov     ax,20h
 06B4  65: 83 7D 28 00		        cmp     GS:[di].s_stConfigParms.cwXoffThreshold,0
 06B9  74 07			        je      @f
 06BB  65: 8B 45 28		        mov     ax,GS:[di].s_stConfigParms.cwXoffThreshold
 06BF  89 44 48			        mov     [si].s_stDeviceParms.wDefXoffThreshold,ax
 06C2				@@:
 06C2  89 44 36			        mov     [si].s_stDeviceParms.wXoffThreshold,ax

 06C5  66| 8B 44 10		        mov     eax,[si].s_stDeviceParms.dwReadBufferLength
 06C9  66| D1 E8		        shr     eax,1
 06CC  65: 83 7D 26 00		        cmp     GS:[di].s_stConfigParms.cwXonHysteresis,0
 06D1  74 0E			        je      @f
 06D3  66| 8B 44 10		        mov     eax,[si].s_stDeviceParms.dwReadBufferLength
 06D7  65: 2B 45 26		        sub     ax,GS:[di].s_stConfigParms.cwXonHysteresis
 06DB  2B 44 36			        sub     ax,[si].s_stDeviceParms.wXoffThreshold
 06DE  89 44 4A			        mov     [si].s_stDeviceParms.wDefXonThreshold,ax
 06E1				@@:
 06E1  89 44 34			        mov     [si].s_stDeviceParms.wXonThreshold,ax

				  IFDEF this_junk ; these were tested and set in valid hardware tests
				  ENDIF
				; Setup defaults for DCB
 06E4  65: 83 7D 16 00		        cmp     GS:[di].s_stConfigParms.cwRdTimeout,ZERO
 06E9  74 07			        je      @f
 06EB  65: 8B 45 16		        mov     ax,GS:[di].s_stConfigParms.cwRdTimeout
 06EF  89 44 42			        mov     [si].s_stDeviceParms.wDefRdTimeout,ax
 06F2				@@:
 06F2  65: 83 7D 14 00		        cmp     GS:[di].s_stConfigParms.cwWrtTimeout,ZERO
 06F7  74 07			        je      @f
 06F9  65: 8B 45 14		        mov     ax,GS:[di].s_stConfigParms.cwWrtTimeout
 06FD  89 44 40			        mov     [si].s_stDeviceParms. wDefWrtTimeout,ax
 0700				@@:
 0700  8B 54 3A			        mov     dx,[si].s_stDeviceParms.wIObaseAddress
 0703  83 C2 03			        add     dx,LINE_CTL_REG_OFFSET
 0706  B0 03			        mov     al,DEFAULT_LINE_CHARACTERISTICS

 0708  65: 80 7D 21 00		        cmp     GS:[di].s_stConfigParms.cbyLineCharacteristics,ZERO
 070D  74 06			        je      @f
 070F  65: 8A 45 21		        mov     al,GS:[di].s_stConfigParms.cbyLineCharacteristics
 0713  24 3F			        and     al,3fh
 0715				@@:
				        OutByteDel bx
 071C  24 07			        and     al,LINE_CTL_WORD_LEN_MASK
 071E  3C 00			        cmp     al,LINE_CTL_WL5
 0720  75 06			        jne     @f
 0722  C6 44 3F 1F		        mov     [si].s_stDeviceParms.byDataLengthMask,01fh
 0726  EB 18			        jmp     do_def_baud
 0728				@@:
 0728  3C 01			        cmp     al,LINE_CTL_WL6
 072A  75 06			        jne     @f
 072C  C6 44 3F 3F		        mov     [si].s_stDeviceParms.byDataLengthMask,03fh
 0730  EB 0E			        jmp     do_def_baud
 0732				@@:
 0732  3C 02			        cmp     al,LINE_CTL_WL7
 0734  75 06			        jne     @f
 0736  C6 44 3F 7F		        mov     [si].s_stDeviceParms.byDataLengthMask,07fh
 073A  EB 04			        jmp     do_def_baud
 073C				@@:
 073C  C6 44 3F FF		        mov     [si].s_stDeviceParms.byDataLengthMask,0ffh

 0740				do_def_baud:
				  IFNDEF x16_BIT
 0740  66| 65: 83 7D 18		        cmp     GS:[di].s_stConfigParms.cdwBaudRate,ZERO
       00
 0746  74 41			        je      do_def_DCB_flags
				  ELSE
				  ENDIF
				  IFNDEF x16_BIT
 0748  66| 65: 8B 45 18		        mov     eax,GS:[di].s_stConfigParms.cdwBaudRate
				  ELSE
				  ENDIF
 074D  8B C8			        mov     cx,ax
 074F  81 E1 7FFF		        and     cx,7fffh      ; limit minimum baud rate
 0753  F7 45 08 0080		        test    [di].s_stDeviceParms.wConfigFlags1,CFG_FLAG1_EXPLICIT_BAUD_DIVISOR
 0758  75 28			        jnz     store_baud
				  IFNDEF x16_BIT
 075A  F7 44 08 0010		        test    [si].s_stDeviceParms.wConfigFlags1,CFG_FLAG1_NORMALIZE_BAUD
 075F  74 1C			        jz      @f
				IFDEF this_junk
				ELSE
 0761  80 BC 009E 01		        cmp     [si].s_stDeviceParms.xBaudMultiplier,1
 0766  76 15			        jbe     @f
 0768  66| 33 DB		        xor     ebx,ebx
 076B  8A 9C 009E		        mov     bl,[si].s_stDeviceParms.xBaudMultiplier
 076F  66| F7 E3		        mul     ebx
 0772  66| 83 FA 00		        cmp     edx,0    ; test for overflow
 0776  74 05			        je      @f
 0778  66| 65: 8B 45 18		        mov     eax,GS:[di].s_stConfigParms.cdwBaudRate   ; messed up don't multiply (safety net)
				ENDIF
 077D				@@:
				  ENDIF
 077D  E8 0000 E		        call    CalcBaudRate
 0780  72 07			        jc      do_def_DCB_flags

 0782				store_baud:
				  IFNDEF x16_BIT
 0782  66| 89 44 26		        mov     [si].s_stDeviceParms.dwBaudRate,eax
				  ELSE
				  ENDIF
 0786  89 4C 24			        mov     [si].s_stDeviceParms.wBaudRateDivisor,cx

 0789				do_def_DCB_flags:
 0789  65: 83 7D 0E 00		        cmp     GS:[di].s_stConfigParms.cwFlags1,ZERO
 078E  74 07			        je      do_def_flags2
 0790  65: 8A 45 0E		        mov     al,BYTE PTR GS:[di].s_stConfigParms.cwFlags1
 0794  88 44 2C			        mov     [si].s_stDeviceParms.byFlag1,al

 0797				do_def_flags2:
 0797  C6 84 00A3 FF		        mov     [si].s_stDeviceParms.byFlag2Mask,0ffh
 079C  80 A4 00A3 E3		        and     [si].s_stDeviceParms.byFlag2Mask,NOT (F2_ENABLE_BREAK_REPL OR \
				                                                     F2_ENABLE_ERROR_REPL OR \
				                                                     F2_ENABLE_NULL_STRIP)
 07A1  65: 83 7D 10 00		        cmp     GS:[di].s_stConfigParms.cwFlags2,ZERO
 07A6  74 2E			        je      do_def_flags3
 07A8  65: 8A 45 10		        mov     al,BYTE PTR GS:[di].s_stConfigParms.cwFlags2
 07AC  88 44 2D			        mov     [si].s_stDeviceParms.byFlag2,al
 07AF  65: F7 45 10 0010	        test    GS:[di].s_stConfigParms.cwFlags2,F2_ENABLE_BREAK_REPL
 07B5  74 05			        jz      @f
 07B7  80 8C 00A3 10		        or      [si].s_stDeviceParms.byFlag2Mask,F2_ENABLE_BREAK_REPL
 07BC				@@:
 07BC  65: F7 45 10 0004	        test    GS:[di].s_stConfigParms.cwFlags2,F2_ENABLE_ERROR_REPL
 07C2  74 05			        jz      @f
 07C4  80 8C 00A3 04		        or      [si].s_stDeviceParms.byFlag2Mask,F2_ENABLE_ERROR_REPL
 07C9				@@:
 07C9  65: F7 45 10 0008	        test    GS:[di].s_stConfigParms.cwFlags2,F2_ENABLE_NULL_STRIP
 07CF  74 05			        jz      do_def_flags3
 07D1  80 8C 00A3 08		        or      [si].s_stDeviceParms.byFlag2Mask,F2_ENABLE_NULL_STRIP

 07D6				do_def_flags3:
 07D6  65: 83 7D 12 00		        cmp     GS:[di].s_stConfigParms.cwFlags3,ZERO
 07DB  74 0B			        je      do_def_characters
 07DD  65: 8A 45 12		        mov     al,BYTE PTR GS:[di].s_stConfigParms.cwFlags3
 07E1  88 84 00A4		        mov     [si].s_stDeviceParms.byDefFlag3,al
 07E5  88 44 2E			        mov     [si].s_stDeviceParms.byFlag3,al

 07E8				do_def_characters:
 07E8  65: 80 7D 22 00		        cmp     GS:[di].s_stConfigParms.cbyErrorChar,ZERO
 07ED  74 07			        je      @f
 07EF  65: 8A 45 22		        mov     al,BYTE PTR GS:[di].s_stConfigParms.cbyErrorChar
 07F3  88 44 46			        mov     [si].s_stDeviceParms.byDefErrorChar,al
 07F6				@@:
 07F6  65: 80 7D 23 00		        cmp     GS:[di].s_stConfigParms.cbyBreakChar,ZERO
 07FB  74 07			        je      @f
 07FD  65: 8A 45 23		        mov     al,BYTE PTR GS:[di].s_stConfigParms.cbyBreakChar
 0801  88 44 47			        mov     [si].s_stDeviceParms.byDefBreakChar,al
 0804				@@:
 0804  65: 80 7D 25 00		        cmp     GS:[di].s_stConfigParms.cbyXoffChar,ZERO
 0809  74 07			        je      @f
 080B  65: 8A 45 25		        mov     al,BYTE PTR GS:[di].s_stConfigParms.cbyXoffChar
 080F  88 44 45			        mov     [si].s_stDeviceParms.byDefXoffChar,al
 0812				@@:
 0812  65: 80 7D 24 00		        cmp     GS:[di].s_stConfigParms.cbyXonChar,ZERO
 0817  74 07			        je      do_def_FIFO_depth
 0819  65: 8A 45 24		        mov     al,BYTE PTR GS:[di].s_stConfigParms.cbyXonChar
 081D  88 44 44			        mov     [si].s_stDeviceParms.byDefXonChar,al

 0820				do_def_FIFO_depth::
 0820  B8 0001			        mov     ax,1
 0823  F7 44 04 2000		        test    [si].s_stDeviceParms.wDeviceFlag2,DEV_FLAG2_FIFO_AVAILABLE
 0828  0F 84 00C5		        jz      set_FIFO_depth
				  IFNDEF x16_BIT
 082C  65: 83 7D 0C 00		        cmp     GS:[di].s_stConfigParms.cwTxFIFOdepth,ZERO
 0831  75 2C			        jne     set_user_FIFO_depth
				  ENDIF
 0833  B8 0010			        mov     ax,MAX_16550_TX_DEPTH
				        test_DeviceFlag2 DEV_FLAG2_16650_UART
 083B  74 06			        jz      try_16654
 083D  B8 0020			        mov     ax,MAX_16650_TX_DEPTH
 0840  E9 00AE			        jmp     set_FIFO_depth

 0843				try_16654:
				        test_DeviceFlag2 DEV_FLAG2_16654_UART
 0848  74 06			        jz      try_16750
 084A  B8 0040			        mov     ax,MAX_16654_TX_DEPTH
 084D  E9 00A1			        jmp     set_FIFO_depth

 0850				try_16750:
				        test_DeviceFlag2 DEV_FLAG2_16750_UART
 0855  0F 84 0098		        jz      set_FIFO_depth
 0859  B8 0040			        mov     ax,MAX_16750_TX_DEPTH
 085C  E9 0092			        jmp     set_FIFO_depth

				  IFNDEF x16_BIT
 085F				set_user_FIFO_depth:
 085F  65: 8B 45 0C		        mov     ax,GS:[di].s_stConfigParms.cwTxFIFOdepth
 0863  F7 44 0A 4000		        test    [si].s_stDeviceParms.wConfigFlags2,CFG_FLAG2_EXPLICIT_TX_LOAD
 0868  75 4C			        jnz     set_explicit_TX_load
 086A  83 F8 01			        cmp     ax,1
 086D  0F 84 0080		        je      set_FIFO_depth
				        test_DeviceFlag2 DEV_FLAG2_16650_UART
 0876  74 19			        jz      test_16554

 0878  83 F8 02			        cmp     ax,2
 087B  75 05			        jne     test_16650_L3
 087D  B8 0010			        mov     ax,16
 0880  EB 6F			        jmp     set_FIFO_depth
 0882				test_16650_L3:
 0882  83 F8 03			        cmp     ax,3
 0885  75 05			        jne     test_16650_L4
 0887  B8 0018			        mov     ax,24
 088A  EB 65			        jmp     set_FIFO_depth

 088C				test_16650_L4:
 088C  B8 0020			        mov     ax,32
 088F  EB 60			        jmp     set_FIFO_depth

 0891				test_16554:
				        test_DeviceFlag2 (DEV_FLAG2_16654_UART OR DEV_FLAG2_16750_UART)
 0896  74 19			        jz      set_16550

 0898  83 F8 02			        cmp     ax,2
 089B  75 05			        jne     test_64byteFIFO_L3
 089D  B8 0020			        mov     ax,32
 08A0  EB 4F			        jmp     set_FIFO_depth
 08A2				test_64byteFIFO_L3:
 08A2  83 F8 03			        cmp     ax,3
 08A5  75 05			        jne     test_64byteFIFO_L4
 08A7  B8 0030			        mov     ax,48
 08AA  EB 45			        jmp     set_FIFO_depth

 08AC				test_64byteFIFO_L4:
 08AC  B8 0040			        mov     ax,64
 08AF  EB 40			        jmp     set_FIFO_depth

 08B1				set_16550:
 08B1  B8 0010			        mov     ax,16
 08B4  EB 3B			        jmp     set_FIFO_depth

 08B6				set_explicit_TX_load:
				        test_DeviceFlag2 DEV_FLAG2_16650_UART
 08BB  74 0A			        jz      test_exp_16654
 08BD  83 F8 20			        cmp     ax,MAX_16650_TX_DEPTH
 08C0  76 2F			        jna     set_FIFO_depth
 08C2  B8 0020			        mov     ax,MAX_16650_TX_DEPTH
 08C5  EB 2A			        jmp     set_FIFO_depth

 08C7				test_exp_16654:
				        test_DeviceFlag2 DEV_FLAG2_16654_UART
 08CC  74 0A			        jz      test_exp_16750
 08CE  83 F8 40			        cmp     ax,MAX_16654_TX_DEPTH
 08D1  76 1E			        jna     set_FIFO_depth
 08D3  B8 0040			        mov     ax,MAX_16654_TX_DEPTH
 08D6  EB 19			        jmp     set_FIFO_depth

 08D8				test_exp_16750:
				        test_DeviceFlag2 DEV_FLAG2_16750_UART
 08DD  74 0A			        jz      set_exp_16550
 08DF  83 F8 40			        cmp     ax,MAX_16750_TX_DEPTH
 08E2  76 0D			        jna     set_FIFO_depth
 08E4  B8 0040			        mov     ax,MAX_16750_TX_DEPTH
 08E7  EB 08			        jmp     set_FIFO_depth

 08E9				set_exp_16550:
 08E9  83 F8 10			        cmp     ax,MAX_16550_TX_DEPTH
 08EC  76 03			        jna     set_FIFO_depth
 08EE  B8 0010			        mov     ax,MAX_16550_TX_DEPTH
				  ENDIF

 08F1				set_FIFO_depth:
 08F1  89 44 7A			        mov     [si].s_stDeviceParms.wUserTxFIFOdepth,ax

 08F4				lock_LID::
 08F4  65: 83 3E 0000 E		        cmp     GS:_bIsTheFirst,TRUE
       01
 08FA  75 24			        jne     clear_BIOS_data
 08FC  65: 83 3E 0000 E		        cmp     GS:_bABIOSpresent,TRUE
       01
 0902  75 1C			        jne     clear_BIOS_data
 0904  BB 0000 E		        mov     bx,OFFSET _astInstallParms
 0907  65: 8B 07		        mov     ax,GS:[bx].s_stInstallParms.wLID;
 090A  0B C0			        or      ax,ax
 090C  74 12			        jz      clear_BIOS_data
				    SetDS     DGROUP            ; GetLIDentry get called from 'C' init code
 0912  1E			        push    ds
 0913  53			        push    bx
 0914  9A ---- 0000 E		        call    _GetLIDentry
 0919  83 C4 04			        add     sp,4
				    SetDS     RDGROUP

 0920				clear_BIOS_data:

				IFDEF this_junk
				ENDIF

 0920				write_installed_message::
 0920  E8 0000 E		        call    OutputProgress

				; If COMscpope and receive buffers are to be allocated in device driver's data
				; segment then calculate end of data segment and read/write/COMscope buffer offsets

				; since the buffer lengths are adjustable at initialization time, it is more
				; efficient to adjust the read buffer length variable to fit the queue handling
				; algorithims at initialization time, rather than at run time

				; Memory requirements were calculated above when the device driver segment is to be used.

 0923  66| 33 C0		        xor     eax,eax
 0926  A1 0000 E		        mov     ax,wLastEndOfData

 0929  89 44 62			        mov     [si].s_stDeviceParms.oWriteBuffer,ax
 092C  03 44 0C			        add     ax,[si].s_stDeviceParms.wWrtBufferLength
 092F  89 44 0E			        mov     [si].s_stDeviceParms.wWrtBufferExtent,ax
 0932  FF 4C 0E			        dec     [si].s_stDeviceParms.wWrtBufferExtent        ;adj for zero base

				; If it was determined in PRELOAD.C that there wasn't enough space available
				; in the device driver's data segment then skip this, as the COMscope and receive
				; buffers were defined in UTIL.ASM (MemorySetup).

 0935  65: 83 3E 0000 E		        cmp     GS:_bUseDDdataSegment,TRUE
       01
 093B  75 4D			        jne     adjust_last_end_of_data

				        OR_DeviceFlag2 DEV_FLAG2_USE_DD_DATA_SEGMENT

 0942  66| 89 84 0088		        mov     [si].s_stDeviceParms.oReadBuffer,eax
 0947  66| 89 84 0080		        mov     [si].s_stDeviceParms.dwReceiveQueueWritePointer,eax
 094C  66| 89 84 0084		        mov     [si].s_stDeviceParms.dwReceiveQueueReadPointer,eax
 0951  66| 03 44 10		        add     eax,[si].s_stDeviceParms.dwReadBufferLength
 0955  66| 89 44 14		        mov     [si].s_stDeviceParms.dwReadBufferExtent,eax
 0959  66| FF 4C 14		        dec     [si].s_stDeviceParms.dwReadBufferExtent       ;adj for zero base
 095D  C7 44 5C 0000		        mov     [si].s_stDeviceParms.wRdBuffSelector,RDGROUP

				   IFNDEF NO_COMscope
 0962  65: F7 05 0040		        test    GS:[di].s_stConfigParms.cwDeviceFlags1,CFG_FLAG1_COMSCOPE
 0967  74 21			        jz      adjust_last_end_of_data

 0969  66| 89 84 0094		        mov     [si].s_stDeviceParms.oCOMscopeBuff,eax
 096E  66| 89 84 008C		        mov     [si].s_stDeviceParms.dwCOMscopeQWrtPtr,eax
 0973  66| 89 84 0090		        mov     [si].s_stDeviceParms.dwCOMscopeQRdPtr,eax
 0978  66| 03 44 18		        add     eax,[si].s_stDeviceParms.dwCOMscopeBuffLen
 097C  66| 89 44 1C		        mov     [si].s_stDeviceParms.dwCOMscopeBuffExtent,eax
 0980  66| 83 6C 1C 02		        sub     [si].s_stDeviceParms.dwCOMscopeBuffExtent,2   ;adj for zero base
 0985  C7 44 5A 0000		        mov     [si].s_stDeviceParms.wCOMscopeSelector,RDGROUP

				   ENDIF
 098A				adjust_last_end_of_data::
 098A  A3 0000 E		        mov     wLastEndOfData,ax
 098D  89 36 0000 E		        mov     wLastDeviceParmsOffset,si

 0991				set_end_of_data_segment::
 0991  C4 7E FC			        les     di,pPacket
 0994  26: 89 45 10		        mov     ES:[di].s_stPacket.InitDataPacket.DataEndOffset,ax

 0998  FF 06 0000 E		        inc     wDeviceCount
 099C  65: 8B 1E 0000 E		        mov     bx,GS:_wCurrentDevice
 09A1  D1 E3			        shl     bx,1
 09A3  89 B7 0000 E		        mov     wDeviceOffsetTable[bx],si

				  IFNDEF NO_RESOURCE_MGR
 09A7  65: 83 3E 0000 E		        cmp     GS:_bDisableRM,TRUE
       01
 09AD  74 1B			        je      @f
 09AF  8B 1E 0000 E		        mov     bx,wBusType
 09B3  53			        push    bx
 09B4  65: A1 0000 E		        mov     ax,GS:_wInstallTryCount
 09B8  48			        dec     ax
 09B9  50			        push    ax
				     SetDS    DGROUP
 09BE  9A ---- 0000 E		        call    _RMHELP_PortInitComplete
 09C3  83 C4 04			        add     sp,4
				     SetDS    RDGROUP
 09CA				@@:
				  ENDIF
 09CA				init_exit::
 09CA  65: A1 0000 E		        mov     ax,GS:_wLoadCount
 09CE  0B C0			        or      ax,ax
 09D0  74 11			        jz      say_bad_load
 09D2  65: 3B 06 0000 E		        cmp     ax,GS:_wInstallTryCount
 09D7  0F 85 00F4		        jne     set_end_of_code

 09DB				display_finals::
 09DB  65: 83 3E 0000 E		        cmp     GS:_bBadLoad,TRUE
       01
 09E1  75 1B			        jne     @f

 09E3				say_bad_load:
 09E3  65: C7 06 0000 E		        mov     GS:_bWaitForCR,TRUE
       0001
 09EA  65: C7 06 0000 E		        mov     GS:_bDelay,TRUE
       0001
 09F1  65: C7 06 0000 E		        mov     GS:_wDelayCount,60
       003C
 09F8  B8 0000 E		        mov     ax,OFFSET _szFinalError
 09FB  E8 0000 E		        call    PrintString
 09FE				@@:
 09FE  65: 83 3E 0000 E		        cmp     GS:_bWaitForCR,TRUE
       01
 0A04  74 14			        je      test_copyright
 0A06  65: 83 3E 0000 E		        cmp     GS:_bDelay,TRUE
       01
 0A0C  75 0C			        jne     test_copyright
				        Delay   GS:_wDelayCount

 0A1A				test_copyright:
 0A1A  65: 83 3E 0000 E		        cmp     GS:_wLoadNumber,NO_INI_FILE
       FF
 0A20  74 1C			        je      play_copyright
 0A22  65: A1 0000 E		        mov     ax,GS:_wLoadCount
 0A26  83 3E 0000 E 00		        cmp     wMaxDeviceCount,0
 0A2B  74 06			        je      test_last_load
 0A2D  3B 06 0000 E		        cmp     ax,wMaxDeviceCount
 0A31  73 0B			        jae     play_copyright

 0A33				test_last_load:
 0A33  65: A1 0000 E		        mov     ax,GS:_wLoadNumber
 0A37  65: 39 06 0000 E		        cmp     GS:_wDriverLoadCount,ax
 0A3C  75 43			        jne     test_final_delay

 0A3E				play_copyright:
 0A3E  B8 0000 E		        mov     ax,OFFSET _szCopyright
 0A41  E8 0000 E		        call    PrintString
 0A44  BB 0000 E		        mov     bx,OFFSET _szVersion

				        INVOKE sprintf,ADDR _szMessage,0,ADDR _szVersionString_ss,bx,gs,OFFSET _szVerMod,gs
 0A47  0F A8		   *	    push   gs
 0A49  68 0000 E	   *	    push   word  ptr OFFSET _szVerMod
 0A4C  0F A8		   *	    push   gs
 0A4E  53		   *	    push   bx
 0A4F  0F A8		   *	    push   gs
 0A51  68 0000 E	   *	    push   OFFSET DGROUP: _szVersionString_ss
 0A54  6A 00		   *	    push   +00000h
 0A56  0F A8		   *	    push   gs
 0A58  68 0000 E	   *	    push   OFFSET DGROUP: _szMessage
 0A5B  9A ---- 0000 E	   *	    call   sprintf
 0A60  83 C4 12		   *	    add    sp, 00012h
				        INVOKE PrintMessage,ADDR _szMessage,ax
 0A63  50		   *	    push   ax
 0A64  0F A8		   *	    push   gs
 0A66  68 0000 E	   *	    push   OFFSET DGROUP: _szMessage
 0A69  9A ---- 0000 E	   *	    call   PrintMessage
 0A6E  83 C4 06		   *	    add    sp, 00006h
 0A71  B8 001E			        mov     ax,30
 0A74  E8 0000 E		        call    CalcDelay
				        Delay   ax

 0A81				test_final_delay:
 0A81  65: 83 3E 0000 E		        cmp     GS:_bWaitForCR,TRUE
       01
 0A87  75 2E			        jne     kill_timer

 0A89  83 3E 0000 E 00		        cmp     wDeviceCount,0
 0A8E  75 08			        jne     @f
 0A90  65: 83 3E 0000 E		        cmp     GS:_bIsTheFirst,TRUE
       01
 0A96  75 1F			        jne     kill_timer
 0A98				@@:
 0A98  B8 0000 E		        mov     ax,OFFSET _szWaitKeyMessage
 0A9B  E8 0000 E		        call    PrintString
 0A9E  65: C7 06 0000 E		        mov     GS:_bWaitingKey,TRUE
       0001
				        Delay   GS:_wDelayCount
 0AB1  B8 0000 E		        mov     ax,OFFSET _szCR
 0AB4  E8 0000 E		        call    PrintString

 0AB7				kill_timer:
 0AB7  65: 83 3E 0000 E		        cmp     GS:_bTimerAvailable,TRUE
       01
 0ABD  75 10			        jne     set_end_of_code
 0ABF  65: C7 06 0000 E		        mov     GS:_bTimerAvailable,FALSE
       0000
 0AC6  B8 0000 E		        mov     ax,OFFSET InitTimer
 0AC9  B2 1E			        mov     dl,DevHlp_ResetTimer
 0ACB  FF 1E 0000 E		        call    device_hlp

 0ACF				set_end_of_code:
 0ACF  B8 0000 R		        lea     ax,BEGIN_INIT_CODE
				   IFDEF VDD_support
				   ENDIF
 0AD2  C4 7E FC			        les     di,pPacket
 0AD5  26: 89 45 0E		        mov     word ptr ES:[di].s_stPacket.InitDataPacket.CodeEndOffset,ax

				; clear other return parameters (as required by OS/2)

 0AD9  33 C0			        xor     ax,ax
 0ADB  26: 88 45 0D		        mov     ES:[di].s_stPacket.InitDataPacket.DeviceCount,al
 0ADF  26: 89 45 12		        mov     WORD PTR ES:[di].s_stPacket.InitDataPacket.BPBoffset,ax
 0AE3  26: 89 45 14		        mov     WORD PTR ES:[di].s_stPacket.InitDataPacket.BPBoffset + 2,ax
				        ret
 0AE7  5F		   *	    pop    di
 0AE8  0F A9		   *	    pop    gs
 0AEA  07		   *	    pop    es
 0AEB  8B E5		   *	    mov    sp, bp
 0AED  5D		   *	    pop    bp
 0AEE  C3		   *	    ret    00000h

 0AEF				Init ENDP

 0AEF = 0AEF			INIT_CODE_END EQU $

 0AEF				RES_CODE ENDS

				     END

